/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/linmath -Ipanda/src/linmath -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3linmath_igate.cxx -od built/pandac/input/libp3linmath.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/linmath -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3linmath aa_luse.h compose_matrix.h configVariableColor.h config_linmath.h coordinateSystem.h dbl2fltnames.h dblnames.h deg_2_rad.h flt2dblnames.h fltnames.h intnames.h lcast_to.h lmatrix.h lmatrix_ext.h lorientation.h lpoint2.h lpoint2_ext.h lpoint3.h lpoint3_ext.h lpoint4.h lpoint4_ext.h lquaternion.h lrotation.h lsimpleMatrix.h luse.h lvec2_ops.h lvec3_ops.h lvec4_ops.h lvecBase2.h lvecBase2_ext.h lvecBase3.h lvecBase3_ext.h lvecBase4.h lvecBase4_ext.h lvector2.h lvector2_ext.h lvector3.h lvector3_ext.h lvector4.h lvector4_ext.h mathNumbers.h p3linmath_composite1.cxx p3linmath_composite2.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3linmath
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "aa_luse.h"
#include "compose_matrix.h"
#include "configVariable.h"
#include "configVariableColor.h"
#include "config_linmath.h"
#include "config_prc.h"
#include "coordinateSystem.h"
#include "dbl2fltnames.h"
#include "dblnames.h"
#include "deg_2_rad.h"
#include "dtoolbase.h"
#include "extension.h"
#include "flt2dblnames.h"
#include "fltnames.h"
#include "intnames.h"
#include "lmat_ops.h"
#include "lmatrix.h"
#include "lmatrix_ext.h"
#include "lorientation.h"
#include "lpoint2.h"
#include "lpoint2_ext.h"
#include "lpoint3.h"
#include "lpoint3_ext.h"
#include "lpoint4.h"
#include "lpoint4_ext.h"
#include "lquaternion.h"
#include "lrotation.h"
#include "lsimpleMatrix.h"
#include "luse.h"
#include "lvec2_ops.h"
#include "lvec3_ops.h"
#include "lvec4_ops.h"
#include "lvecBase2.h"
#include "lvecBase2_ext.h"
#include "lvecBase3.h"
#include "lvecBase3_ext.h"
#include "lvecBase4.h"
#include "lvecBase4_ext.h"
#include "lvector2.h"
#include "lvector2_ext.h"
#include "lvector3.h"
#include "lvector3_ext.h"
#include "lvector4.h"
#include "lvector4_ext.h"
#include "mathNumbers.h"
#include "pandabase.h"
#include "stl_compares.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class MathNumbers
 */
typedef MathNumbers MathNumbers_localtype;
Define_Module_Class(panda3d.core, MathNumbers, MathNumbers_localtype, MathNumbers);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MathNumbers = &Dtool_MathNumbers;
static void Dtool_PyModuleClassInit_MathNumbers(PyObject *module);

/**
 * Forward declarations for top-level class LVecBase2f
 */
typedef LVecBase2f LVecBase2f_localtype;
Define_Module_Class(panda3d.core, LVecBase2f, LVecBase2f_localtype, LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
static void Dtool_PyModuleClassInit_LVecBase2f(PyObject *module);
LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);

/**
 * Forward declarations for top-level class LVecBase2d
 */
typedef LVecBase2d LVecBase2d_localtype;
Define_Module_Class(panda3d.core, LVecBase2d, LVecBase2d_localtype, LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
static void Dtool_PyModuleClassInit_LVecBase2d(PyObject *module);
LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);

/**
 * Forward declarations for top-level class LVecBase2i
 */
typedef LVecBase2i LVecBase2i_localtype;
Define_Module_Class(panda3d.core, LVecBase2i, LVecBase2i_localtype, LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
static void Dtool_PyModuleClassInit_LVecBase2i(PyObject *module);
LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);

/**
 * Forward declarations for top-level class LVector2f
 */
typedef LVector2f LVector2f_localtype;
Define_Module_Class(panda3d.core, LVector2f, LVector2f_localtype, LVector2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
static void Dtool_PyModuleClassInit_LVector2f(PyObject *module);
LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);

/**
 * Forward declarations for top-level class LVector2d
 */
typedef LVector2d LVector2d_localtype;
Define_Module_Class(panda3d.core, LVector2d, LVector2d_localtype, LVector2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2d = &Dtool_LVector2d;
static void Dtool_PyModuleClassInit_LVector2d(PyObject *module);
LVector2d *Dtool_Coerce_LVector2d(PyObject *args, LVector2d &coerced);

/**
 * Forward declarations for top-level class LVector2i
 */
typedef LVector2i LVector2i_localtype;
Define_Module_Class(panda3d.core, LVector2i, LVector2i_localtype, LVector2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2i = &Dtool_LVector2i;
static void Dtool_PyModuleClassInit_LVector2i(PyObject *module);
LVector2i *Dtool_Coerce_LVector2i(PyObject *args, LVector2i &coerced);

/**
 * Forward declarations for top-level class LPoint2f
 */
typedef LPoint2f LPoint2f_localtype;
Define_Module_Class(panda3d.core, LPoint2f, LPoint2f_localtype, LPoint2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
static void Dtool_PyModuleClassInit_LPoint2f(PyObject *module);
LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);

/**
 * Forward declarations for top-level class LPoint2d
 */
typedef LPoint2d LPoint2d_localtype;
Define_Module_Class(panda3d.core, LPoint2d, LPoint2d_localtype, LPoint2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2d = &Dtool_LPoint2d;
static void Dtool_PyModuleClassInit_LPoint2d(PyObject *module);
LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced);

/**
 * Forward declarations for top-level class LPoint2i
 */
typedef LPoint2i LPoint2i_localtype;
Define_Module_Class(panda3d.core, LPoint2i, LPoint2i_localtype, LPoint2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2i = &Dtool_LPoint2i;
static void Dtool_PyModuleClassInit_LPoint2i(PyObject *module);
LPoint2i *Dtool_Coerce_LPoint2i(PyObject *args, LPoint2i &coerced);

/**
 * Forward declarations for top-level class LVecBase3f
 */
typedef LVecBase3f LVecBase3f_localtype;
Define_Module_Class(panda3d.core, LVecBase3f, LVecBase3f_localtype, LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
static void Dtool_PyModuleClassInit_LVecBase3f(PyObject *module);
LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);

/**
 * Forward declarations for top-level class LVecBase3d
 */
typedef LVecBase3d LVecBase3d_localtype;
Define_Module_Class(panda3d.core, LVecBase3d, LVecBase3d_localtype, LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
static void Dtool_PyModuleClassInit_LVecBase3d(PyObject *module);
LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);

/**
 * Forward declarations for top-level class LVecBase3i
 */
typedef LVecBase3i LVecBase3i_localtype;
Define_Module_Class(panda3d.core, LVecBase3i, LVecBase3i_localtype, LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
static void Dtool_PyModuleClassInit_LVecBase3i(PyObject *module);
LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);

/**
 * Forward declarations for top-level class LVector3f
 */
typedef LVector3f LVector3f_localtype;
Define_Module_Class(panda3d.core, LVector3f, LVector3f_localtype, LVector3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
static void Dtool_PyModuleClassInit_LVector3f(PyObject *module);
LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);

/**
 * Forward declarations for top-level class LVector3d
 */
typedef LVector3d LVector3d_localtype;
Define_Module_Class(panda3d.core, LVector3d, LVector3d_localtype, LVector3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3d = &Dtool_LVector3d;
static void Dtool_PyModuleClassInit_LVector3d(PyObject *module);
LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced);

/**
 * Forward declarations for top-level class LVector3i
 */
typedef LVector3i LVector3i_localtype;
Define_Module_Class(panda3d.core, LVector3i, LVector3i_localtype, LVector3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3i = &Dtool_LVector3i;
static void Dtool_PyModuleClassInit_LVector3i(PyObject *module);
LVector3i *Dtool_Coerce_LVector3i(PyObject *args, LVector3i &coerced);

/**
 * Forward declarations for top-level class LPoint3f
 */
typedef LPoint3f LPoint3f_localtype;
Define_Module_Class(panda3d.core, LPoint3f, LPoint3f_localtype, LPoint3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
static void Dtool_PyModuleClassInit_LPoint3f(PyObject *module);
LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);

/**
 * Forward declarations for top-level class LPoint3d
 */
typedef LPoint3d LPoint3d_localtype;
Define_Module_Class(panda3d.core, LPoint3d, LPoint3d_localtype, LPoint3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3d = &Dtool_LPoint3d;
static void Dtool_PyModuleClassInit_LPoint3d(PyObject *module);
LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced);

/**
 * Forward declarations for top-level class LPoint3i
 */
typedef LPoint3i LPoint3i_localtype;
Define_Module_Class(panda3d.core, LPoint3i, LPoint3i_localtype, LPoint3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3i = &Dtool_LPoint3i;
static void Dtool_PyModuleClassInit_LPoint3i(PyObject *module);
LPoint3i *Dtool_Coerce_LPoint3i(PyObject *args, LPoint3i &coerced);

/**
 * Forward declarations for top-level class LVecBase4f
 */
typedef LVecBase4f LVecBase4f_localtype;
Define_Module_Class(panda3d.core, LVecBase4f, LVecBase4f_localtype, LVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
static void Dtool_PyModuleClassInit_LVecBase4f(PyObject *module);
LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);

/**
 * Forward declarations for top-level class UnalignedLVecBase4f
 */
typedef UnalignedLVecBase4f UnalignedLVecBase4f_localtype;
Define_Module_Class(panda3d.core, UnalignedLVecBase4f, UnalignedLVecBase4f_localtype, UnalignedLVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4f = &Dtool_UnalignedLVecBase4f;
static void Dtool_PyModuleClassInit_UnalignedLVecBase4f(PyObject *module);
UnalignedLVecBase4f *Dtool_Coerce_UnalignedLVecBase4f(PyObject *args, UnalignedLVecBase4f &coerced);

/**
 * Forward declarations for top-level class LVecBase4d
 */
typedef LVecBase4d LVecBase4d_localtype;
Define_Module_Class(panda3d.core, LVecBase4d, LVecBase4d_localtype, LVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
static void Dtool_PyModuleClassInit_LVecBase4d(PyObject *module);
LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);

/**
 * Forward declarations for top-level class UnalignedLVecBase4d
 */
typedef UnalignedLVecBase4d UnalignedLVecBase4d_localtype;
Define_Module_Class(panda3d.core, UnalignedLVecBase4d, UnalignedLVecBase4d_localtype, UnalignedLVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4d = &Dtool_UnalignedLVecBase4d;
static void Dtool_PyModuleClassInit_UnalignedLVecBase4d(PyObject *module);
UnalignedLVecBase4d *Dtool_Coerce_UnalignedLVecBase4d(PyObject *args, UnalignedLVecBase4d &coerced);

/**
 * Forward declarations for top-level class LVecBase4i
 */
typedef LVecBase4i LVecBase4i_localtype;
Define_Module_Class(panda3d.core, LVecBase4i, LVecBase4i_localtype, LVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4i = &Dtool_LVecBase4i;
static void Dtool_PyModuleClassInit_LVecBase4i(PyObject *module);
LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced);

/**
 * Forward declarations for top-level class UnalignedLVecBase4i
 */
typedef UnalignedLVecBase4i UnalignedLVecBase4i_localtype;
Define_Module_Class(panda3d.core, UnalignedLVecBase4i, UnalignedLVecBase4i_localtype, UnalignedLVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLVecBase4i = &Dtool_UnalignedLVecBase4i;
static void Dtool_PyModuleClassInit_UnalignedLVecBase4i(PyObject *module);
UnalignedLVecBase4i *Dtool_Coerce_UnalignedLVecBase4i(PyObject *args, UnalignedLVecBase4i &coerced);

/**
 * Forward declarations for top-level class LVector4f
 */
typedef LVector4f LVector4f_localtype;
Define_Module_Class(panda3d.core, LVector4f, LVector4f_localtype, LVector4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector4f = &Dtool_LVector4f;
static void Dtool_PyModuleClassInit_LVector4f(PyObject *module);
LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced);

/**
 * Forward declarations for top-level class LVector4d
 */
typedef LVector4d LVector4d_localtype;
Define_Module_Class(panda3d.core, LVector4d, LVector4d_localtype, LVector4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector4d = &Dtool_LVector4d;
static void Dtool_PyModuleClassInit_LVector4d(PyObject *module);
LVector4d *Dtool_Coerce_LVector4d(PyObject *args, LVector4d &coerced);

/**
 * Forward declarations for top-level class LVector4i
 */
typedef LVector4i LVector4i_localtype;
Define_Module_Class(panda3d.core, LVector4i, LVector4i_localtype, LVector4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector4i = &Dtool_LVector4i;
static void Dtool_PyModuleClassInit_LVector4i(PyObject *module);
LVector4i *Dtool_Coerce_LVector4i(PyObject *args, LVector4i &coerced);

/**
 * Forward declarations for top-level class LPoint4f
 */
typedef LPoint4f LPoint4f_localtype;
Define_Module_Class(panda3d.core, LPoint4f, LPoint4f_localtype, LPoint4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4f = &Dtool_LPoint4f;
static void Dtool_PyModuleClassInit_LPoint4f(PyObject *module);
LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced);

/**
 * Forward declarations for top-level class LPoint4d
 */
typedef LPoint4d LPoint4d_localtype;
Define_Module_Class(panda3d.core, LPoint4d, LPoint4d_localtype, LPoint4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4d = &Dtool_LPoint4d;
static void Dtool_PyModuleClassInit_LPoint4d(PyObject *module);
LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced);

/**
 * Forward declarations for top-level class LPoint4i
 */
typedef LPoint4i LPoint4i_localtype;
Define_Module_Class(panda3d.core, LPoint4i, LPoint4i_localtype, LPoint4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint4i = &Dtool_LPoint4i;
static void Dtool_PyModuleClassInit_LPoint4i(PyObject *module);
LPoint4i *Dtool_Coerce_LPoint4i(PyObject *args, LPoint4i &coerced);

/**
 * Forward declarations for top-level class LMatrix3f
 */
typedef LMatrix3f LMatrix3f_localtype;
Define_Module_Class(panda3d.core, LMatrix3f, LMatrix3f_localtype, LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
static void Dtool_PyModuleClassInit_LMatrix3f(PyObject *module);
LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);

/**
 * Forward declarations for top-level class LMatrix3f_Row
 */
typedef LMatrix3f::Row LMatrix3f_Row_localtype;
Define_Module_Class(panda3d.core, LMatrix3f_Row, LMatrix3f_Row_localtype, Row);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f_Row = &Dtool_LMatrix3f_Row;
static void Dtool_PyModuleClassInit_LMatrix3f_Row(PyObject *module);

/**
 * Forward declarations for top-level class LMatrix3f_CRow
 */
typedef LMatrix3f::CRow LMatrix3f_CRow_localtype;
Define_Module_Class(panda3d.core, LMatrix3f_CRow, LMatrix3f_CRow_localtype, CRow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f_CRow = &Dtool_LMatrix3f_CRow;
static void Dtool_PyModuleClassInit_LMatrix3f_CRow(PyObject *module);

/**
 * Forward declarations for top-level class LMatrix4f
 */
typedef LMatrix4f LMatrix4f_localtype;
Define_Module_Class(panda3d.core, LMatrix4f, LMatrix4f_localtype, LMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
static void Dtool_PyModuleClassInit_LMatrix4f(PyObject *module);
LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);

/**
 * Forward declarations for top-level class LMatrix4f_Row
 */
typedef LMatrix4f::Row LMatrix4f_Row_localtype;
Define_Module_Class(panda3d.core, LMatrix4f_Row, LMatrix4f_Row_localtype, Row);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f_Row = &Dtool_LMatrix4f_Row;
static void Dtool_PyModuleClassInit_LMatrix4f_Row(PyObject *module);

/**
 * Forward declarations for top-level class LMatrix4f_CRow
 */
typedef LMatrix4f::CRow LMatrix4f_CRow_localtype;
Define_Module_Class(panda3d.core, LMatrix4f_CRow, LMatrix4f_CRow_localtype, CRow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f_CRow = &Dtool_LMatrix4f_CRow;
static void Dtool_PyModuleClassInit_LMatrix4f_CRow(PyObject *module);

/**
 * Forward declarations for top-level class UnalignedLMatrix4f
 */
typedef UnalignedLMatrix4f UnalignedLMatrix4f_localtype;
Define_Module_Class(panda3d.core, UnalignedLMatrix4f, UnalignedLMatrix4f_localtype, UnalignedLMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLMatrix4f = &Dtool_UnalignedLMatrix4f;
static void Dtool_PyModuleClassInit_UnalignedLMatrix4f(PyObject *module);
UnalignedLMatrix4f *Dtool_Coerce_UnalignedLMatrix4f(PyObject *args, UnalignedLMatrix4f &coerced);

/**
 * Forward declarations for top-level class LMatrix3d
 */
typedef LMatrix3d LMatrix3d_localtype;
Define_Module_Class(panda3d.core, LMatrix3d, LMatrix3d_localtype, LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
static void Dtool_PyModuleClassInit_LMatrix3d(PyObject *module);
LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);

/**
 * Forward declarations for top-level class LMatrix3d_Row
 */
typedef LMatrix3d::Row LMatrix3d_Row_localtype;
Define_Module_Class(panda3d.core, LMatrix3d_Row, LMatrix3d_Row_localtype, Row);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d_Row = &Dtool_LMatrix3d_Row;
static void Dtool_PyModuleClassInit_LMatrix3d_Row(PyObject *module);

/**
 * Forward declarations for top-level class LMatrix3d_CRow
 */
typedef LMatrix3d::CRow LMatrix3d_CRow_localtype;
Define_Module_Class(panda3d.core, LMatrix3d_CRow, LMatrix3d_CRow_localtype, CRow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d_CRow = &Dtool_LMatrix3d_CRow;
static void Dtool_PyModuleClassInit_LMatrix3d_CRow(PyObject *module);

/**
 * Forward declarations for top-level class LMatrix4d
 */
typedef LMatrix4d LMatrix4d_localtype;
Define_Module_Class(panda3d.core, LMatrix4d, LMatrix4d_localtype, LMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
static void Dtool_PyModuleClassInit_LMatrix4d(PyObject *module);
LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);

/**
 * Forward declarations for top-level class LMatrix4d_Row
 */
typedef LMatrix4d::Row LMatrix4d_Row_localtype;
Define_Module_Class(panda3d.core, LMatrix4d_Row, LMatrix4d_Row_localtype, Row);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d_Row = &Dtool_LMatrix4d_Row;
static void Dtool_PyModuleClassInit_LMatrix4d_Row(PyObject *module);

/**
 * Forward declarations for top-level class LMatrix4d_CRow
 */
typedef LMatrix4d::CRow LMatrix4d_CRow_localtype;
Define_Module_Class(panda3d.core, LMatrix4d_CRow, LMatrix4d_CRow_localtype, CRow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d_CRow = &Dtool_LMatrix4d_CRow;
static void Dtool_PyModuleClassInit_LMatrix4d_CRow(PyObject *module);

/**
 * Forward declarations for top-level class UnalignedLMatrix4d
 */
typedef UnalignedLMatrix4d UnalignedLMatrix4d_localtype;
Define_Module_Class(panda3d.core, UnalignedLMatrix4d, UnalignedLMatrix4d_localtype, UnalignedLMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UnalignedLMatrix4d = &Dtool_UnalignedLMatrix4d;
static void Dtool_PyModuleClassInit_UnalignedLMatrix4d(PyObject *module);
UnalignedLMatrix4d *Dtool_Coerce_UnalignedLMatrix4d(PyObject *args, UnalignedLMatrix4d &coerced);

/**
 * Forward declarations for top-level class LQuaternionf
 */
typedef LQuaternionf LQuaternionf_localtype;
Define_Module_Class(panda3d.core, LQuaternionf, LQuaternionf_localtype, LQuaternionf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
static void Dtool_PyModuleClassInit_LQuaternionf(PyObject *module);
LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);

/**
 * Forward declarations for top-level class LQuaterniond
 */
typedef LQuaterniond LQuaterniond_localtype;
Define_Module_Class(panda3d.core, LQuaterniond, LQuaterniond_localtype, LQuaterniond);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaterniond = &Dtool_LQuaterniond;
static void Dtool_PyModuleClassInit_LQuaterniond(PyObject *module);
LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced);

/**
 * Forward declarations for top-level class LRotationf
 */
typedef LRotationf LRotationf_localtype;
Define_Module_Class(panda3d.core, LRotationf, LRotationf_localtype, LRotationf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LRotationf = &Dtool_LRotationf;
static void Dtool_PyModuleClassInit_LRotationf(PyObject *module);
LRotationf *Dtool_Coerce_LRotationf(PyObject *args, LRotationf &coerced);

/**
 * Forward declarations for top-level class LRotationd
 */
typedef LRotationd LRotationd_localtype;
Define_Module_Class(panda3d.core, LRotationd, LRotationd_localtype, LRotationd);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LRotationd = &Dtool_LRotationd;
static void Dtool_PyModuleClassInit_LRotationd(PyObject *module);
LRotationd *Dtool_Coerce_LRotationd(PyObject *args, LRotationd &coerced);

/**
 * Forward declarations for top-level class LOrientationf
 */
typedef LOrientationf LOrientationf_localtype;
Define_Module_Class(panda3d.core, LOrientationf, LOrientationf_localtype, LOrientationf);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LOrientationf = &Dtool_LOrientationf;
static void Dtool_PyModuleClassInit_LOrientationf(PyObject *module);
LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced);

/**
 * Forward declarations for top-level class LOrientationd
 */
typedef LOrientationd LOrientationd_localtype;
Define_Module_Class(panda3d.core, LOrientationd, LOrientationd_localtype, LOrientationd);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LOrientationd = &Dtool_LOrientationd;
static void Dtool_PyModuleClassInit_LOrientationd(PyObject *module);
LOrientationd *Dtool_Coerce_LOrientationd(PyObject *args, LOrientationd &coerced);

/**
 * Forward declarations for top-level class ConfigVariableColor
 */
typedef ConfigVariableColor ConfigVariableColor_localtype;
Define_Module_Class(panda3d.core, ConfigVariableColor, ConfigVariableColor_localtype, ConfigVariableColor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableColor = &Dtool_ConfigVariableColor;
static void Dtool_PyModuleClassInit_ConfigVariableColor(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableColor(PyObject *args, ConfigVariableColor const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableColor(PyObject *args, ConfigVariableColor *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// ConfigFlags
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConfigFlags;
#else
extern struct Dtool_PyTypedObject Dtool_ConfigFlags;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigFlags = &Dtool_ConfigFlags;
#endif
// ConfigVariableBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConfigVariableBase;
#else
extern struct Dtool_PyTypedObject Dtool_ConfigVariableBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableBase = &Dtool_ConfigVariableBase;
#endif
// ConfigVariable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConfigVariable;
inline static bool Dtool_ConstCoerce_ConfigVariable(PyObject *args, ConfigVariable const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_ConfigVariable != NULL, false);
  nassertr(Dtool_Ptr_ConfigVariable->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, ConfigVariable const *&, bool&))Dtool_Ptr_ConfigVariable->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_ConfigVariable(PyObject *args, ConfigVariable *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_ConfigVariable != NULL, false);
  nassertr(Dtool_Ptr_ConfigVariable->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, ConfigVariable *&, bool&))Dtool_Ptr_ConfigVariable->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConfigVariable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariable = &Dtool_ConfigVariable;
extern bool Dtool_ConstCoerce_ConfigVariable(PyObject *args, ConfigVariable const *&coerced, bool &manage);
extern bool Dtool_Coerce_ConfigVariable(PyObject *args, ConfigVariable *&coerced, bool &manage);
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramIterator;
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != NULL, NULL);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != NULL, NULL);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * inline double deg_2_rad(double f)
 * inline float deg_2_rad(float f)
 */
static PyObject *Dtool_deg_2_rad_4(PyObject *, PyObject *arg) {
  {
    // -2 inline double deg_2_rad(double f)
    if (PyNumber_Check(arg)) {
      double return_value = deg_2_rad(PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline float deg_2_rad(float f)
    if (PyNumber_Check(arg)) {
      float return_value = deg_2_rad((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline double deg_2_rad(double f)
  // No coercion possible: inline float deg_2_rad(float f)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "deg_2_rad(double f)\n"
      "deg_2_rad(float f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_deg_2_rad_4_comment =
  "C++ Interface:\n"
  "deg_2_rad(double f)\n"
  "deg_2_rad(float f)\n";
#else
static const char *Dtool_deg_2_rad_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double rad_2_deg(double f)
 * inline float rad_2_deg(float f)
 */
static PyObject *Dtool_rad_2_deg_5(PyObject *, PyObject *arg) {
  {
    // -2 inline double rad_2_deg(double f)
    if (PyNumber_Check(arg)) {
      double return_value = rad_2_deg(PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline float rad_2_deg(float f)
    if (PyNumber_Check(arg)) {
      float return_value = rad_2_deg((float)PyFloat_AsDouble(arg));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline double rad_2_deg(double f)
  // No coercion possible: inline float rad_2_deg(float f)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rad_2_deg(double f)\n"
      "rad_2_deg(float f)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_rad_2_deg_5_comment =
  "C++ Interface:\n"
  "rad_2_deg(double f)\n"
  "rad_2_deg(float f)\n";
#else
static const char *Dtool_rad_2_deg_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CoordinateSystem get_default_coordinate_system(void)
 */
static PyObject *Dtool_get_default_coordinate_system_547(PyObject *, PyObject *) {
  // 1-CoordinateSystem get_default_coordinate_system(void)
  CoordinateSystem return_value = get_default_coordinate_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_default_coordinate_system_547_comment =
  "C++ Interface:\n"
  "get_default_coordinate_system()\n";
#else
static const char *Dtool_get_default_coordinate_system_547_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CoordinateSystem parse_coordinate_system_string(std::string const &str)
 */
static PyObject *Dtool_parse_coordinate_system_string_548(PyObject *, PyObject *arg) {
  // 1-CoordinateSystem parse_coordinate_system_string(std::string const &str)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    CoordinateSystem return_value = parse_coordinate_system_string(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_coordinate_system_string(str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_parse_coordinate_system_string_548_comment =
  "C++ Interface:\n"
  "parse_coordinate_system_string(str str)\n";
#else
static const char *Dtool_parse_coordinate_system_string_548_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string format_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_format_coordinate_system_549(PyObject *, PyObject *arg) {
  // 1-std::string format_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = format_coordinate_system((CoordinateSystem)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_coordinate_system(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_format_coordinate_system_549_comment =
  "C++ Interface:\n"
  "format_coordinate_system(int cs)\n";
#else
static const char *Dtool_format_coordinate_system_549_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool is_right_handed(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_is_right_handed_550(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool is_right_handed(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:is_right_handed", (char **)keyword_list, &param0)) {
    bool return_value = is_right_handed((CoordinateSystem)param0);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_right_handed(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_is_right_handed_550_comment =
  "C++ Interface:\n"
  "is_right_handed(int cs)\n";
#else
static const char *Dtool_is_right_handed_550_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d transpose(LMatrix3d const &a)
 * inline LMatrix3f transpose(LMatrix3f const &a)
 * inline LMatrix4d transpose(LMatrix4d const &a)
 * inline LMatrix4f transpose(LMatrix4f const &a)
 */
static PyObject *Dtool_transpose_1233(PyObject *, PyObject *arg) {
  {
    // -2 inline LMatrix4d transpose(LMatrix4d const &a)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4d *return_value = new LMatrix4d(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LMatrix3d transpose(LMatrix3d const &a)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3d *return_value = new LMatrix3d(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  {
    // -2 inline LMatrix4f transpose(LMatrix4f const &a)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4f *return_value = new LMatrix4f(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  {
    // -2 inline LMatrix3f transpose(LMatrix3f const &a)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3f *return_value = new LMatrix3f(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LMatrix4d transpose(LMatrix4d const &a)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4d *return_value = new LMatrix4d(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LMatrix3d transpose(LMatrix3d const &a)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3d *return_value = new LMatrix3d(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  {
    // -2 inline LMatrix4f transpose(LMatrix4f const &a)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4f *return_value = new LMatrix4f(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  {
    // -2 inline LMatrix3f transpose(LMatrix3f const &a)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3f *return_value = new LMatrix3f(transpose(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transpose(const LMatrix4d a)\n"
      "transpose(const LMatrix3d a)\n"
      "transpose(const LMatrix4f a)\n"
      "transpose(const LMatrix3f a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_transpose_1233_comment =
  "C++ Interface:\n"
  "transpose(const LMatrix4d a)\n"
  "transpose(const LMatrix3d a)\n"
  "transpose(const LMatrix4f a)\n"
  "transpose(const LMatrix3f a)\n";
#else
static const char *Dtool_transpose_1233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d invert(LMatrix3d const &a)
 * inline LMatrix3f invert(LMatrix3f const &a)
 * inline LMatrix4d invert(LMatrix4d const &a)
 * inline LMatrix4f invert(LMatrix4f const &a)
 * inline LQuaterniond invert(LQuaterniond const &a)
 * inline LQuaternionf invert(LQuaternionf const &a)
 */
static PyObject *Dtool_invert_1234(PyObject *, PyObject *arg) {
  {
    // -2 inline LQuaterniond invert(LQuaterniond const &a)
    LQuaterniond const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaterniond, (void **)&arg_this);
    if (arg_this != NULL) {
      LQuaterniond *return_value = new LQuaterniond(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  {
    // -2 inline LQuaternionf invert(LQuaternionf const &a)
    LQuaternionf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
    if (arg_this != NULL) {
      LQuaternionf *return_value = new LQuaternionf(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  {
    // -2 inline LMatrix3d invert(LMatrix3d const &a)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3d *return_value = new LMatrix3d(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  {
    // -2 inline LMatrix3f invert(LMatrix3f const &a)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3f *return_value = new LMatrix3f(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LMatrix4d invert(LMatrix4d const &a)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4d *return_value = new LMatrix4d(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LMatrix4f invert(LMatrix4f const &a)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4f *return_value = new LMatrix4f(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  {
    // -2 inline LQuaterniond invert(LQuaterniond const &a)
    LQuaterniond arg_local;
    LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
    if ((arg_this != NULL)) {
      LQuaterniond *return_value = new LQuaterniond(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  {
    // -2 inline LQuaternionf invert(LQuaternionf const &a)
    LQuaternionf arg_local;
    LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != NULL)) {
      LQuaternionf *return_value = new LQuaternionf(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  {
    // -2 inline LMatrix3d invert(LMatrix3d const &a)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3d *return_value = new LMatrix3d(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  {
    // -2 inline LMatrix3f invert(LMatrix3f const &a)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3f *return_value = new LMatrix3f(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LMatrix4d invert(LMatrix4d const &a)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4d *return_value = new LMatrix4d(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LMatrix4f invert(LMatrix4f const &a)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4f *return_value = new LMatrix4f(invert(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert(const LQuaterniond a)\n"
      "invert(const LQuaternionf a)\n"
      "invert(const LMatrix3d a)\n"
      "invert(const LMatrix3f a)\n"
      "invert(const LMatrix4d a)\n"
      "invert(const LMatrix4f a)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_invert_1234_comment =
  "C++ Interface:\n"
  "invert(const LQuaterniond a)\n"
  "invert(const LQuaternionf a)\n"
  "invert(const LMatrix3d a)\n"
  "invert(const LMatrix3f a)\n"
  "invert(const LMatrix4d a)\n"
  "invert(const LMatrix4f a)\n";
#else
static const char *Dtool_invert_1234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q)
 * inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q)
 * inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q)
 * inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q)
 * inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m)
 * inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m)
 * inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m)
 * inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m)
 * inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m)
 * inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m)
 * inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m)
 * inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m)
 * inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m)
 * inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m)
 * inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m)
 * inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m)
 * inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m)
 * inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m)
 * inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m)
 * inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m)
 * inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m)
 * inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m)
 * inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m)
 * inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m)
 */
static PyObject *Dtool_operator_1555(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3d, (void **)&param0_this);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint3d *return_value = new LPoint3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint4f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint4f, (void **)&param0_this);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint4f *return_value = new LPoint4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector4d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector4d, (void **)&param0_this);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector4d *return_value = new LVector4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector3f *return_value = new LVector3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector3f *return_value = new LVector3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector4f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector4f, (void **)&param0_this);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector4f *return_value = new LVector4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector2f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector2f, (void **)&param0_this);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector2f *return_value = new LVector2f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint3f *return_value = new LPoint3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector3d *return_value = new LVector3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3d, (void **)&param0_this);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint3d *return_value = new LPoint3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint2d, (void **)&param0_this);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint2d *return_value = new LPoint2d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint3f *return_value = new LPoint3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint4d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint4d, (void **)&param0_this);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint4d *return_value = new LPoint4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector3d *return_value = new LVector3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector2d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector2d, (void **)&param0_this);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVector2d *return_value = new LVector2d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint2f, (void **)&param0_this);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LPoint2f *return_value = new LPoint2f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
      LQuaternionf const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LQuaternionf, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LMatrix3f *return_value = new LMatrix3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
      LQuaterniond const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LQuaterniond, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LMatrix3d *return_value = new LMatrix3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix4d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
      LQuaterniond const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LQuaterniond, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LMatrix4d *return_value = new LMatrix4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix4f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
      LQuaternionf const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LQuaternionf, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LMatrix4f *return_value = new LMatrix4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVecBase3f *return_value = new LVecBase3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVecBase4d *return_value = new LVecBase4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVecBase4f *return_value = new LVecBase4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        LVecBase3d *return_value = new LVecBase3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d param0_local;
      LPoint3d const *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint3d *return_value = new LPoint3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint4f param0_local;
      LPoint4f const *param0_this = Dtool_Coerce_LPoint4f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint4f *return_value = new LPoint4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector4d param0_local;
      LVector4d const *param0_this = Dtool_Coerce_LVector4d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector4d *return_value = new LVector4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f param0_local;
      LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector3f *return_value = new LVector3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f param0_local;
      LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector3f *return_value = new LVector3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector4f param0_local;
      LVector4f const *param0_this = Dtool_Coerce_LVector4f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector4f *return_value = new LVector4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector2f param0_local;
      LVector2f const *param0_this = Dtool_Coerce_LVector2f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector2f *return_value = new LVector2f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f param0_local;
      LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint3f *return_value = new LPoint3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d param0_local;
      LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector3d *return_value = new LVector3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d param0_local;
      LPoint3d const *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint3d *return_value = new LPoint3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2d param0_local;
      LPoint2d const *param0_this = Dtool_Coerce_LPoint2d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint2d *return_value = new LPoint2d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f param0_local;
      LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint3f *return_value = new LPoint3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint4d param0_local;
      LPoint4d const *param0_this = Dtool_Coerce_LPoint4d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint4d *return_value = new LPoint4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d param0_local;
      LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector3d *return_value = new LVector3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVector2d param0_local;
      LVector2d const *param0_this = Dtool_Coerce_LVector2d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVector2d *return_value = new LVector2d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2f param0_local;
      LPoint2f const *param0_this = Dtool_Coerce_LPoint2f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LPoint2f *return_value = new LPoint2f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix3f param0_local;
      LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
      LQuaternionf param1_local;
      LQuaternionf const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LMatrix3f *return_value = new LMatrix3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix3d param0_local;
      LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
      LQuaterniond param1_local;
      LQuaterniond const *param1_this = Dtool_Coerce_LQuaterniond(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LMatrix3d *return_value = new LMatrix3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix4d param0_local;
      LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
      LQuaterniond param1_local;
      LQuaterniond const *param1_this = Dtool_Coerce_LQuaterniond(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LMatrix4d *return_value = new LMatrix4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"m", "q", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LMatrix4f param0_local;
      LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
      LQuaternionf param1_local;
      LQuaternionf const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LMatrix4f *return_value = new LMatrix4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3f param0_local;
      LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVecBase3f *return_value = new LVecBase3f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4d param0_local;
      LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVecBase4d *return_value = new LVecBase4d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4f param0_local;
      LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVecBase4f *return_value = new LVecBase4f(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__mul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3d param0_local;
      LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        LVecBase3d *return_value = new LVecBase3d(operator *(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__mul__(const LPoint3d v, const LMatrix4d m)\n"
      "__mul__(const LPoint4f v, const LMatrix4f m)\n"
      "__mul__(const LVector4d v, const LMatrix4d m)\n"
      "__mul__(const LVector3f v, const LMatrix3f m)\n"
      "__mul__(const LVector3f v, const LMatrix4f m)\n"
      "__mul__(const LVector4f v, const LMatrix4f m)\n"
      "__mul__(const LVector2f v, const LMatrix3f m)\n"
      "__mul__(const LPoint3f v, const LMatrix3f m)\n"
      "__mul__(const LVector3d v, const LMatrix4d m)\n"
      "__mul__(const LPoint3d v, const LMatrix3d m)\n"
      "__mul__(const LPoint2d v, const LMatrix3d m)\n"
      "__mul__(const LPoint3f v, const LMatrix4f m)\n"
      "__mul__(const LPoint4d v, const LMatrix4d m)\n"
      "__mul__(const LVector3d v, const LMatrix3d m)\n"
      "__mul__(const LVector2d v, const LMatrix3d m)\n"
      "__mul__(const LPoint2f v, const LMatrix3f m)\n"
      "__mul__(const LMatrix3f m, const LQuaternionf q)\n"
      "__mul__(const LMatrix3d m, const LQuaterniond q)\n"
      "__mul__(const LMatrix4d m, const LQuaterniond q)\n"
      "__mul__(const LMatrix4f m, const LQuaternionf q)\n"
      "__mul__(const LVecBase3f v, const LMatrix3f m)\n"
      "__mul__(const LVecBase4d v, const LMatrix4d m)\n"
      "__mul__(const LVecBase4f v, const LMatrix4f m)\n"
      "__mul__(const LVecBase3d v, const LMatrix3d m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_operator_1555_comment =
  "C++ Interface:\n"
  "__mul__(const LPoint3d v, const LMatrix4d m)\n"
  "__mul__(const LPoint4f v, const LMatrix4f m)\n"
  "__mul__(const LVector4d v, const LMatrix4d m)\n"
  "__mul__(const LVector3f v, const LMatrix3f m)\n"
  "__mul__(const LVector3f v, const LMatrix4f m)\n"
  "__mul__(const LVector4f v, const LMatrix4f m)\n"
  "__mul__(const LVector2f v, const LMatrix3f m)\n"
  "__mul__(const LPoint3f v, const LMatrix3f m)\n"
  "__mul__(const LVector3d v, const LMatrix4d m)\n"
  "__mul__(const LPoint3d v, const LMatrix3d m)\n"
  "__mul__(const LPoint2d v, const LMatrix3d m)\n"
  "__mul__(const LPoint3f v, const LMatrix4f m)\n"
  "__mul__(const LPoint4d v, const LMatrix4d m)\n"
  "__mul__(const LVector3d v, const LMatrix3d m)\n"
  "__mul__(const LVector2d v, const LMatrix3d m)\n"
  "__mul__(const LPoint2f v, const LMatrix3f m)\n"
  "__mul__(const LMatrix3f m, const LQuaternionf q)\n"
  "__mul__(const LMatrix3d m, const LQuaterniond q)\n"
  "__mul__(const LMatrix4d m, const LQuaterniond q)\n"
  "__mul__(const LMatrix4f m, const LQuaternionf q)\n"
  "__mul__(const LVecBase3f v, const LMatrix3f m)\n"
  "__mul__(const LVecBase4d v, const LMatrix4d m)\n"
  "__mul__(const LVecBase4f v, const LMatrix4f m)\n"
  "__mul__(const LVecBase3d v, const LMatrix3d m)\n";
#else
static const char *Dtool_operator_1555_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void operator *=(LPoint2d &v, LMatrix3d const &m)
 * inline void operator *=(LPoint2f &v, LMatrix3f const &m)
 * inline void operator *=(LPoint3d &v, LMatrix3d const &m)
 * inline void operator *=(LPoint3d &v, LMatrix4d const &m)
 * inline void operator *=(LPoint3f &v, LMatrix3f const &m)
 * inline void operator *=(LPoint3f &v, LMatrix4f const &m)
 * inline void operator *=(LVecBase3d &v, LMatrix3d const &m)
 * inline void operator *=(LVecBase3f &v, LMatrix3f const &m)
 * inline void operator *=(LVecBase4d &v, LMatrix4d const &m)
 * inline void operator *=(LVecBase4f &v, LMatrix4f const &m)
 * inline void operator *=(LVector2d &v, LMatrix3d const &m)
 * inline void operator *=(LVector2f &v, LMatrix3f const &m)
 * inline void operator *=(LVector3d &v, LMatrix3d const &m)
 * inline void operator *=(LVector3d &v, LMatrix4d const &m)
 * inline void operator *=(LVector3f &v, LMatrix3f const &m)
 * inline void operator *=(LVector3f &v, LMatrix4f const &m)
 */
static PyObject *Dtool_operator_1556(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 inline void operator *=(LPoint2d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2d *param0_this = (LPoint2d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint2d, 0, "__imul__", false, false);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint2f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2f *param0_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint2f, 0, "__imul__", false, false);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3f &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint3f, 0, "__imul__", false, false);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d *param0_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint3d, 0, "__imul__", false, false);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint3f, 0, "__imul__", false, false);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3d &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d *param0_this = (LPoint3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LPoint3d, 0, "__imul__", false, false);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector2d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector2d *param0_this = (LVector2d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVector2d, 0, "__imul__", false, false);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3d &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d *param0_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVector3d, 0, "__imul__", false, false);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3f &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f *param0_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVector3f, 0, "__imul__", false, false);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f *param0_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVector3f, 0, "__imul__", false, false);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector2f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector2f *param0_this = (LVector2f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVector2f, 0, "__imul__", false, false);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d *param0_this = (LVector3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVector3d, 0, "__imul__", false, false);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase3d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3d *param0_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVecBase3d, 0, "__imul__", false, false);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase3f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3f *param0_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVecBase3f, 0, "__imul__", false, false);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase4d &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4d *param0_this = (LVecBase4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVecBase4d, 0, "__imul__", false, false);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase4f &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LVecBase4f, 0, "__imul__", false, false);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint2d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2d param0_local;
      LPoint2d *param0_this = Dtool_Coerce_LPoint2d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint2f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint2f param0_local;
      LPoint2f *param0_this = Dtool_Coerce_LPoint2f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3f &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f param0_local;
      LPoint3f *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d param0_local;
      LPoint3d *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3f param0_local;
      LPoint3f *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LPoint3d &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LPoint3d param0_local;
      LPoint3d *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector2d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector2d param0_local;
      LVector2d *param0_this = Dtool_Coerce_LVector2d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3d &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d param0_local;
      LVector3d *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3f &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f param0_local;
      LVector3f *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3f param0_local;
      LVector3f *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector2f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector2f param0_local;
      LVector2f *param0_this = Dtool_Coerce_LVector2f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVector3d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVector3d param0_local;
      LVector3d *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase3d &v, LMatrix3d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3d param0_local;
      LVecBase3d *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase3f &v, LMatrix3f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase3f param0_local;
      LVecBase3f *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase4d &v, LMatrix4d const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4d param0_local;
      LVecBase4d *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void operator *=(LVecBase4f &v, LMatrix4f const &m)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"v", "m", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:__imul__", (char **)keyword_list, &param0, &param1)) {
      LVecBase4f param0_local;
      LVecBase4f *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        operator *=(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__imul__(LPoint2d v, const LMatrix3d m)\n"
      "__imul__(LPoint2f v, const LMatrix3f m)\n"
      "__imul__(LPoint3f v, const LMatrix4f m)\n"
      "__imul__(LPoint3d v, const LMatrix3d m)\n"
      "__imul__(LPoint3f v, const LMatrix3f m)\n"
      "__imul__(LPoint3d v, const LMatrix4d m)\n"
      "__imul__(LVector2d v, const LMatrix3d m)\n"
      "__imul__(LVector3d v, const LMatrix4d m)\n"
      "__imul__(LVector3f v, const LMatrix4f m)\n"
      "__imul__(LVector3f v, const LMatrix3f m)\n"
      "__imul__(LVector2f v, const LMatrix3f m)\n"
      "__imul__(LVector3d v, const LMatrix3d m)\n"
      "__imul__(LVecBase3d v, const LMatrix3d m)\n"
      "__imul__(LVecBase3f v, const LMatrix3f m)\n"
      "__imul__(LVecBase4d v, const LMatrix4d m)\n"
      "__imul__(LVecBase4f v, const LMatrix4f m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_operator_1556_comment =
  "C++ Interface:\n"
  "__imul__(LPoint2d v, const LMatrix3d m)\n"
  "__imul__(LPoint2f v, const LMatrix3f m)\n"
  "__imul__(LPoint3f v, const LMatrix4f m)\n"
  "__imul__(LPoint3d v, const LMatrix3d m)\n"
  "__imul__(LPoint3f v, const LMatrix3f m)\n"
  "__imul__(LPoint3d v, const LMatrix4d m)\n"
  "__imul__(LVector2d v, const LMatrix3d m)\n"
  "__imul__(LVector3d v, const LMatrix4d m)\n"
  "__imul__(LVector3f v, const LMatrix4f m)\n"
  "__imul__(LVector3f v, const LMatrix3f m)\n"
  "__imul__(LVector2f v, const LMatrix3f m)\n"
  "__imul__(LVector3d v, const LMatrix3d m)\n"
  "__imul__(LVecBase3d v, const LMatrix3d m)\n"
  "__imul__(LVecBase3f v, const LMatrix3f m)\n"
  "__imul__(LVecBase4d v, const LMatrix4d m)\n"
  "__imul__(LVecBase4f v, const LMatrix4f m)\n";
#else
static const char *Dtool_operator_1556_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value)
 * inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value)
 * inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value)
 * inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value)
 */
static PyObject *Dtool_generic_write_datagram_1557(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Datagram, 0, "generic_write_datagram", false, false);
      LMatrix4d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        generic_write_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Datagram, 0, "generic_write_datagram", false, false);
      LMatrix3f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        generic_write_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Datagram, 0, "generic_write_datagram", false, false);
      LMatrix4f const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix4f, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        generic_write_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Datagram, 0, "generic_write_datagram", false, false);
      LMatrix3d const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LMatrix3d, (void **)&param1_this);
      if (param0_this != NULL && param1_this != NULL) {
        generic_write_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this;
      bool param0_manage = false;
      LMatrix4d param1_local;
      LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
      if (Dtool_Coerce_Datagram(param0, param0_this, param0_manage) && (param1_this != NULL)) {
        generic_write_datagram(*param0_this, *param1_this);
        if (param0_manage) {
          delete param0_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this;
      bool param0_manage = false;
      LMatrix3f param1_local;
      LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
      if (Dtool_Coerce_Datagram(param0, param0_this, param0_manage) && (param1_this != NULL)) {
        generic_write_datagram(*param0_this, *param1_this);
        if (param0_manage) {
          delete param0_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this;
      bool param0_manage = false;
      LMatrix4f param1_local;
      LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
      if (Dtool_Coerce_Datagram(param0, param0_this, param0_manage) && (param1_this != NULL)) {
        generic_write_datagram(*param0_this, *param1_this);
        if (param0_manage) {
          delete param0_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"dest", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_write_datagram", (char **)keyword_list, &param0, &param1)) {
      Datagram *param0_this;
      bool param0_manage = false;
      LMatrix3d param1_local;
      LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
      if (Dtool_Coerce_Datagram(param0, param0_this, param0_manage) && (param1_this != NULL)) {
        generic_write_datagram(*param0_this, *param1_this);
        if (param0_manage) {
          delete param0_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generic_write_datagram(Datagram dest, const LMatrix4d value)\n"
      "generic_write_datagram(Datagram dest, const LMatrix3f value)\n"
      "generic_write_datagram(Datagram dest, const LMatrix4f value)\n"
      "generic_write_datagram(Datagram dest, const LMatrix3d value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_generic_write_datagram_1557_comment =
  "C++ Interface:\n"
  "generic_write_datagram(Datagram dest, const LMatrix4d value)\n"
  "generic_write_datagram(Datagram dest, const LMatrix3f value)\n"
  "generic_write_datagram(Datagram dest, const LMatrix4f value)\n"
  "generic_write_datagram(Datagram dest, const LMatrix3d value)\n";
#else
static const char *Dtool_generic_write_datagram_1557_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source)
 * inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source)
 * inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source)
 * inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source)
 */
static PyObject *Dtool_generic_read_datagram_1558(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "generic_read_datagram", false, false);
      DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DatagramIterator, 1, "generic_read_datagram", false, false);
      if (param0_this != NULL && param1_this != NULL) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "generic_read_datagram", false, false);
      DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DatagramIterator, 1, "generic_read_datagram", false, false);
      if (param0_this != NULL && param1_this != NULL) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "generic_read_datagram", false, false);
      DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DatagramIterator, 1, "generic_read_datagram", false, false);
      if (param0_this != NULL && param1_this != NULL) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "generic_read_datagram", false, false);
      DatagramIterator *param1_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_DatagramIterator, 1, "generic_read_datagram", false, false);
      if (param0_this != NULL && param1_this != NULL) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix4f param0_local;
      LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
      DatagramIterator param1_local;
      DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix3f param0_local;
      LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
      DatagramIterator param1_local;
      DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix3d param0_local;
      LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
      DatagramIterator param1_local;
      DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source)
    PyObject *param0;
    PyObject *param1;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:generic_read_datagram", (char **)keyword_list, &param0, &param1)) {
      LMatrix4d param0_local;
      LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
      DatagramIterator param1_local;
      DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
      if ((param0_this != NULL) && (param1_this != NULL)) {
        generic_read_datagram(*param0_this, *param1_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generic_read_datagram(LMatrix4f result, DatagramIterator source)\n"
      "generic_read_datagram(LMatrix3f result, DatagramIterator source)\n"
      "generic_read_datagram(LMatrix3d result, DatagramIterator source)\n"
      "generic_read_datagram(LMatrix4d result, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_generic_read_datagram_1558_comment =
  "C++ Interface:\n"
  "generic_read_datagram(LMatrix4f result, DatagramIterator source)\n"
  "generic_read_datagram(LMatrix3f result, DatagramIterator source)\n"
  "generic_read_datagram(LMatrix3d result, DatagramIterator source)\n"
  "generic_read_datagram(LMatrix4d result, DatagramIterator source)\n";
#else
static const char *Dtool_generic_read_datagram_1558_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default)
 * void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default)
 * void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default)
 * inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_compose_matrix_1559(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:compose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "compose_matrix", false, false);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (double *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:compose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "compose_matrix", false, false);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (float *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:compose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (double *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:compose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (float *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
    {
      {
        // -2 inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "compose_matrix", false, false);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (double *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "compose_matrix", false, false);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (float *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (double *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            compose_matrix(*param0_this, (float *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
    {
      {
        // -2 inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3f const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          LVecBase3d const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          LVecBase3d const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3f const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 5:
  case 6:
    {
      {
        // -2 inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3f const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          LVecBase3f const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LVecBase3f, (void **)&param4_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          LVecBase3d const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
          LVecBase3d const *param4_this;
          DTOOL_Call_ExtractThisPointerForType(param4, Dtool_Ptr_LVecBase3d, (void **)&param4_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4f *param0_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3f const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4d *param0_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix4d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          LVecBase3d const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3d *param0_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3d, 0, "compose_matrix", false, false);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          LVecBase3d const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
          LVecBase3d const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3d, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3f *param0_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LMatrix3f, 0, "compose_matrix", false, false);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          LVecBase3f const *param2_this;
          DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
          LVecBase3f const *param3_this;
          DTOOL_Call_ExtractThisPointerForType(param3, Dtool_Ptr_LVecBase3f, (void **)&param3_this);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          LVecBase3f param4_local;
          LVecBase3f const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          LVecBase3d param4_local;
          LVecBase3d const *param4_this = Dtool_Coerce_LVecBase3d(param4, param4_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4f param0_local;
          LMatrix4f *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4d param0_local;
          LMatrix4d *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3d param0_local;
          LMatrix3d *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d const *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:compose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3f param0_local;
          LMatrix3f *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            compose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compose_matrix() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compose_matrix(LMatrix4d mat, buffer components)\n"
      "compose_matrix(LMatrix4f mat, buffer components)\n"
      "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d hpr)\n"
      "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f hpr)\n"
      "compose_matrix(LMatrix4d mat, buffer components, int cs)\n"
      "compose_matrix(LMatrix4f mat, buffer components, int cs)\n"
      "compose_matrix(LMatrix4f mat, const LVecBase3f scale, const LVecBase3f hpr, const LVecBase3f translate)\n"
      "compose_matrix(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d hpr, const LVecBase3d translate)\n"
      "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr)\n"
      "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f shear, const LVecBase3f hpr)\n"
      "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d hpr, int cs)\n"
      "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f hpr, int cs)\n"
      "compose_matrix(LMatrix4f mat, const LVecBase3f scale, const LVecBase3f shear, const LVecBase3f hpr, const LVecBase3f translate, int cs)\n"
      "compose_matrix(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, const LVecBase3d translate, int cs)\n"
      "compose_matrix(LMatrix4f mat, const LVecBase3f scale, const LVecBase3f hpr, const LVecBase3f translate, int cs)\n"
      "compose_matrix(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d hpr, const LVecBase3d translate, int cs)\n"
      "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, int cs)\n"
      "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f shear, const LVecBase3f hpr, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_compose_matrix_1559_comment =
  "C++ Interface:\n"
  "compose_matrix(LMatrix4d mat, buffer components)\n"
  "compose_matrix(LMatrix4f mat, buffer components)\n"
  "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d hpr)\n"
  "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f hpr)\n"
  "compose_matrix(LMatrix4d mat, buffer components, int cs)\n"
  "compose_matrix(LMatrix4f mat, buffer components, int cs)\n"
  "compose_matrix(LMatrix4f mat, const LVecBase3f scale, const LVecBase3f hpr, const LVecBase3f translate)\n"
  "compose_matrix(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d hpr, const LVecBase3d translate)\n"
  "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr)\n"
  "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f shear, const LVecBase3f hpr)\n"
  "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d hpr, int cs)\n"
  "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f hpr, int cs)\n"
  "compose_matrix(LMatrix4f mat, const LVecBase3f scale, const LVecBase3f shear, const LVecBase3f hpr, const LVecBase3f translate, int cs)\n"
  "compose_matrix(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, const LVecBase3d translate, int cs)\n"
  "compose_matrix(LMatrix4f mat, const LVecBase3f scale, const LVecBase3f hpr, const LVecBase3f translate, int cs)\n"
  "compose_matrix(LMatrix4d mat, const LVecBase3d scale, const LVecBase3d hpr, const LVecBase3d translate, int cs)\n"
  "compose_matrix(LMatrix3d mat, const LVecBase3d scale, const LVecBase3d shear, const LVecBase3d hpr, int cs)\n"
  "compose_matrix(LMatrix3f mat, const LVecBase3f scale, const LVecBase3f shear, const LVecBase3f hpr, int cs)\n";
#else
static const char *Dtool_compose_matrix_1559_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
 * bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
 * inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
 * bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
 * inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default)
 * inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default)
 * inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default)
 * inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default)
 * inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default)
 * inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default)
 */
static PyObject *Dtool_decompose_matrix_1560(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (double *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (float *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (double *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        static const char *keyword_list[] = {"mat", "components", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompose_matrix", (char **)keyword_list, &param0, &param1)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (float *)param1_view.buf);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
    {
      {
        // -2 inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "CS", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (double *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "CS", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          if (param0_this != NULL && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (float *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"mat", "scale", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "CS", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'd' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (double *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS)
        PyObject *param0;
        PyObject *param1;
        Py_buffer param1_view;
        int param2;
        static const char *keyword_list[] = {"mat", "components", "CS", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL) && PyObject_GetBuffer(param1, &param1_view, PyBUF_FORMAT | PyBUF_WRITABLE) == 0 && param1_view.format[0] == 'f' && param1_view.format[1] == 0 && param1_view.len == 12) {
            bool return_value = decompose_matrix(*param0_this, (float *)param1_view.buf, (CoordinateSystem)param2);
            PyBuffer_Release(&param1_view);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
    {
      {
        // -2 bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3d, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3d, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        int param3;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, (CoordinateSystem)param3);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 5:
  case 6:
    {
      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3d, 3, "decompose_matrix", false, false);
          LVecBase3d *param4_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_LVecBase3d, 4, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "decompose_matrix", false, false);
          LVecBase3f *param4_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_LVecBase3f, 4, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL && param4_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3d, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix", false, false);
          LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix", false, false);
          LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3d, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix", false, false);
          LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix", false, false);
          LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "decompose_matrix", false, false);
          if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          LVecBase3d param4_local;
          LVecBase3d *param4_this = Dtool_Coerce_LVecBase3d(param4, param4_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5 = ::CS_default;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOO|i:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          LVecBase3f param4_local;
          LVecBase3f *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL) && (param4_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, *param4_this, (CoordinateSystem)param5);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          LVecBase3d param1_local;
          LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
          LVecBase3d param2_local;
          LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
          LVecBase3d param3_local;
          LVecBase3d *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        static const char *keyword_list[] = {"mat", "scale", "hpr", "translate", "cs", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOOi:decompose_matrix", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          LVecBase3f param1_local;
          LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          LVecBase3f param2_local;
          LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
          LVecBase3f param3_local;
          LVecBase3f *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
          if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
            bool return_value = decompose_matrix(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "decompose_matrix() takes 2, 3, 4, 5 or 6 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompose_matrix(const LMatrix4d mat, buffer components)\n"
      "decompose_matrix(const LMatrix4f mat, buffer components)\n"
      "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d hpr)\n"
      "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f hpr)\n"
      "decompose_matrix(const LMatrix4d mat, buffer components, int CS)\n"
      "decompose_matrix(const LMatrix4f mat, buffer components, int CS)\n"
      "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr)\n"
      "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr)\n"
      "decompose_matrix(const LMatrix4d mat, LVecBase3d scale, LVecBase3d hpr, LVecBase3d translate)\n"
      "decompose_matrix(const LMatrix4f mat, LVecBase3f scale, LVecBase3f hpr, LVecBase3f translate)\n"
      "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d hpr, int cs)\n"
      "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f hpr, int cs)\n"
      "decompose_matrix(const LMatrix4d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr, LVecBase3d translate, int cs)\n"
      "decompose_matrix(const LMatrix4f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr, LVecBase3f translate, int cs)\n"
      "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr, int cs)\n"
      "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr, int cs)\n"
      "decompose_matrix(const LMatrix4d mat, LVecBase3d scale, LVecBase3d hpr, LVecBase3d translate, int cs)\n"
      "decompose_matrix(const LMatrix4f mat, LVecBase3f scale, LVecBase3f hpr, LVecBase3f translate, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decompose_matrix_1560_comment =
  "C++ Interface:\n"
  "decompose_matrix(const LMatrix4d mat, buffer components)\n"
  "decompose_matrix(const LMatrix4f mat, buffer components)\n"
  "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d hpr)\n"
  "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f hpr)\n"
  "decompose_matrix(const LMatrix4d mat, buffer components, int CS)\n"
  "decompose_matrix(const LMatrix4f mat, buffer components, int CS)\n"
  "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr)\n"
  "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr)\n"
  "decompose_matrix(const LMatrix4d mat, LVecBase3d scale, LVecBase3d hpr, LVecBase3d translate)\n"
  "decompose_matrix(const LMatrix4f mat, LVecBase3f scale, LVecBase3f hpr, LVecBase3f translate)\n"
  "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d hpr, int cs)\n"
  "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f hpr, int cs)\n"
  "decompose_matrix(const LMatrix4d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr, LVecBase3d translate, int cs)\n"
  "decompose_matrix(const LMatrix4f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr, LVecBase3f translate, int cs)\n"
  "decompose_matrix(const LMatrix3d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr, int cs)\n"
  "decompose_matrix(const LMatrix3f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr, int cs)\n"
  "decompose_matrix(const LMatrix4d mat, LVecBase3d scale, LVecBase3d hpr, LVecBase3d translate, int cs)\n"
  "decompose_matrix(const LMatrix4f mat, LVecBase3f scale, LVecBase3f hpr, LVecBase3f translate, int cs)\n";
#else
static const char *Dtool_decompose_matrix_1560_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
 * bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_decompose_matrix_old_hpr_1561(PyObject *, PyObject *args, PyObject *kwds) {
  {
    // -2 bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    int param4 = ::CS_default;
    static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|i:decompose_matrix_old_hpr", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
      LMatrix3d const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
      LVecBase3d *param1_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3d, 1, "decompose_matrix_old_hpr", false, false);
      LVecBase3d *param2_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3d, 2, "decompose_matrix_old_hpr", false, false);
      LVecBase3d *param3_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3d, 3, "decompose_matrix_old_hpr", false, false);
      if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
        bool return_value = decompose_matrix_old_hpr(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    int param4 = ::CS_default;
    static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|i:decompose_matrix_old_hpr", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
      LMatrix3f const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
      LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LVecBase3f, 1, "decompose_matrix_old_hpr", false, false);
      LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_LVecBase3f, 2, "decompose_matrix_old_hpr", false, false);
      LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_LVecBase3f, 3, "decompose_matrix_old_hpr", false, false);
      if (param0_this != NULL && param1_this != NULL && param2_this != NULL && param3_this != NULL) {
        bool return_value = decompose_matrix_old_hpr(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    int param4 = ::CS_default;
    static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|i:decompose_matrix_old_hpr", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
      LMatrix3d param0_local;
      LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
      LVecBase3d param1_local;
      LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
      LVecBase3d param2_local;
      LVecBase3d *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
      LVecBase3d param3_local;
      LVecBase3d *param3_this = Dtool_Coerce_LVecBase3d(param3, param3_local);
      if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
        bool return_value = decompose_matrix_old_hpr(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default)
    PyObject *param0;
    PyObject *param1;
    PyObject *param2;
    PyObject *param3;
    int param4 = ::CS_default;
    static const char *keyword_list[] = {"mat", "scale", "shear", "hpr", "cs", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO|i:decompose_matrix_old_hpr", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
      LMatrix3f param0_local;
      LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
      LVecBase3f param1_local;
      LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
      LVecBase3f param2_local;
      LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      LVecBase3f param3_local;
      LVecBase3f *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
      if ((param0_this != NULL) && (param1_this != NULL) && (param2_this != NULL) && (param3_this != NULL)) {
        bool return_value = decompose_matrix_old_hpr(*param0_this, *param1_this, *param2_this, *param3_this, (CoordinateSystem)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompose_matrix_old_hpr(const LMatrix3d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr, int cs)\n"
      "decompose_matrix_old_hpr(const LMatrix3f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decompose_matrix_old_hpr_1561_comment =
  "C++ Interface:\n"
  "decompose_matrix_old_hpr(const LMatrix3d mat, LVecBase3d scale, LVecBase3d shear, LVecBase3d hpr, int cs)\n"
  "decompose_matrix_old_hpr(const LMatrix3f mat, LVecBase3f scale, LVecBase3f shear, LVecBase3f hpr, int cs)\n";
#else
static const char *Dtool_decompose_matrix_old_hpr_1561_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr)
 * LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr)
 */
static PyObject *Dtool_old_to_new_hpr_1562(PyObject *, PyObject *arg) {
  {
    // -2 LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr)
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d(old_to_new_hpr(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr)
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f(old_to_new_hpr(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr)
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d(old_to_new_hpr(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr)
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f(old_to_new_hpr(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "old_to_new_hpr(const LVecBase3d old_hpr)\n"
      "old_to_new_hpr(const LVecBase3f old_hpr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_old_to_new_hpr_1562_comment =
  "C++ Interface:\n"
  "old_to_new_hpr(const LVecBase3d old_hpr)\n"
  "old_to_new_hpr(const LVecBase3f old_hpr)\n";
#else
static const char *Dtool_old_to_new_hpr_1562_comment = NULL;
#endif

/**
 * Python wrappers for functions of class MathNumbers
 */
/**
 * Python function wrapper for:
 * inline MathNumbers::MathNumbers(void) = default
 * inline MathNumbers::MathNumbers(MathNumbers const &) = default
 */
static int Dtool_Init_MathNumbers(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MathNumbers::MathNumbers(void) = default
      MathNumbers *return_value = new MathNumbers();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MathNumbers, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MathNumbers::MathNumbers(MathNumbers const &) = default
      MathNumbers const *arg_this = (MathNumbers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MathNumbers, 0, "MathNumbers.MathNumbers", true, true);
      if (arg_this != NULL) {
        MathNumbers *return_value = new MathNumbers(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MathNumbers, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MathNumbers() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MathNumbers()\n"
      "MathNumbers(const MathNumbers param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MathNumbers(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MathNumbers) {
    printf("MathNumbers ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MathNumbers *local_this = (MathNumbers *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MathNumbers) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MathNumbers(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MathNumbers) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase2f
 */
/**
 * Python function wrapper for:
 * LVecBase2f &LVecBase2f::operator =(LVecBase2f const &copy) = default
 * LVecBase2f &LVecBase2f::operator =(float fill_value) = default
 */
static PyObject *Dtool_LVecBase2f_operator_12(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase2f &LVecBase2f::operator =(LVecBase2f const &copy) = default
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase2f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, false);
    }
  }

  {
    // -2 LVecBase2f &LVecBase2f::operator =(float fill_value) = default
    if (PyNumber_Check(arg)) {
      (*local_this).operator =((float)PyFloat_AsDouble(arg));
      LVecBase2f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, false);
    }
  }

  {
    // -2 LVecBase2f &LVecBase2f::operator =(LVecBase2f const &copy) = default
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase2f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, false);
    }
  }

  // No coercion possible: LVecBase2f &LVecBase2f::operator =(float fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase2f self, const LVecBase2f copy)\n"
      "assign(const LVecBase2f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_operator_12_comment =
  "C++ Interface:\n"
  "assign(const LVecBase2f self, const LVecBase2f copy)\n"
  "assign(const LVecBase2f self, float fill_value)\n";
#else
static const char *Dtool_LVecBase2f_operator_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2f const &LVecBase2f::zero(void)
 */
static PyObject *Dtool_LVecBase2f_zero_13(PyObject *, PyObject *) {
  // 1-static inline LVecBase2f const &LVecBase2f::zero(void)
  LVecBase2f const *return_value = &(LVecBase2f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_zero_13_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_zero_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2f const &LVecBase2f::unit_x(void)
 */
static PyObject *Dtool_LVecBase2f_unit_x_14(PyObject *, PyObject *) {
  // 1-static inline LVecBase2f const &LVecBase2f::unit_x(void)
  LVecBase2f const *return_value = &(LVecBase2f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_unit_x_14_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_unit_x_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2f const &LVecBase2f::unit_y(void)
 */
static PyObject *Dtool_LVecBase2f_unit_y_15(PyObject *, PyObject *) {
  // 1-static inline LVecBase2f const &LVecBase2f::unit_y(void)
  LVecBase2f const *return_value = &(LVecBase2f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_unit_y_15_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_unit_y_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase2f::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase2f_reduce_16(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase2f::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase2f*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_reduce_16_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase2f self)\n";
#else
static const char *Dtool_LVecBase2f_reduce_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2f::is_nan(void) const
 */
static PyObject *Dtool_LVecBase2f_is_nan_21(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase2f::is_nan(void) const
  bool return_value = (*(const LVecBase2f*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_is_nan_21_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase2f self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_is_nan_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase2f::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase2f_get_cell_22(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase2f::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    float return_value = (*(const LVecBase2f*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase2f self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_get_cell_22_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase2f self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_get_cell_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::set_cell(int i, float value)
 */
static PyObject *Dtool_LVecBase2f_set_cell_23(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::set_cell(int i, float value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase2f self, int i, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_set_cell_23_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase2f self, int i, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_set_cell_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase2f::get_x(void) const
 */
static PyObject *Dtool_LVecBase2f_get_x_24(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase2f::get_x(void) const
  float return_value = (*(const LVecBase2f*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_get_x_24_comment =
  "C++ Interface:\n"
  "get_x(LVecBase2f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_get_x_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase2f::get_y(void) const
 */
static PyObject *Dtool_LVecBase2f_get_y_25(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase2f::get_y(void) const
  float return_value = (*(const LVecBase2f*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_get_y_25_comment =
  "C++ Interface:\n"
  "get_y(LVecBase2f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_get_y_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::set_x(float value)
 */
static PyObject *Dtool_LVecBase2f_set_x_26(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::set_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase2f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_set_x_26_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase2f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_set_x_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::set_y(float value)
 */
static PyObject *Dtool_LVecBase2f_set_y_27(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::set_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase2f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_set_y_27_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase2f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_set_y_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::add_to_cell(int i, float value)
 */
static PyObject *Dtool_LVecBase2f_add_to_cell_31(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::add_to_cell(int i, float value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase2f self, int i, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_add_to_cell_31_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase2f self, int i, float value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_add_to_cell_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::add_x(float value)
 */
static PyObject *Dtool_LVecBase2f_add_x_32(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::add_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_x((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase2f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_add_x_32_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase2f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_add_x_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::add_y(float value)
 */
static PyObject *Dtool_LVecBase2f_add_y_33(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::add_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_y((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase2f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_add_y_33_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase2f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_add_y_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase2f::get_num_components(void)
 */
static PyObject *Dtool_LVecBase2f_get_num_components_35(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase2f::get_num_components(void)
  int return_value = LVecBase2f::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_get_num_components_35_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, two.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_get_num_components_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::fill(float fill_value)
 */
static PyObject *Dtool_LVecBase2f_fill_36(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::fill(float fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase2f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_fill_36_comment =
  "C++ Interface:\n"
  "fill(const LVecBase2f self, float fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_fill_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::set(float x, float y)
 */
static PyObject *Dtool_LVecBase2f_set_37(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.set")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::set(float x, float y)
  float param1;
  float param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set((float)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase2f self, float x, float y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_set_37_comment =
  "C++ Interface:\n"
  "set(const LVecBase2f self, float x, float y)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_set_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase2f::dot(LVecBase2f const &other) const
 */
static PyObject *Dtool_LVecBase2f_dot_38(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase2f::dot(LVecBase2f const &other) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.dot", "LVecBase2f");
  }
  float return_value = (*(const LVecBase2f*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase2f self, const LVecBase2f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_dot_38_comment =
  "C++ Interface:\n"
  "dot(LVecBase2f self, const LVecBase2f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_dot_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase2f::length_squared(void) const
 */
static PyObject *Dtool_LVecBase2f_length_squared_39(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase2f::length_squared(void) const
  float return_value = (*(const LVecBase2f*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_length_squared_39_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase2f self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_length_squared_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase2f::length(void) const
 */
static PyObject *Dtool_LVecBase2f_length_40(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase2f::length(void) const
  float return_value = (*(const LVecBase2f*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_length_40_comment =
  "C++ Interface:\n"
  "length(LVecBase2f self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the vector, by the Pythagorean theorem.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_length_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2f::normalize(void)
 */
static PyObject *Dtool_LVecBase2f_normalize_41(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.normalize")) {
    return NULL;
  }
  // 1-inline bool LVecBase2f::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_normalize_41_comment =
  "C++ Interface:\n"
  "normalize(const LVecBase2f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector in place.  Returns true if the vector was normalized,\n"
  " * false if it was a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_normalize_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase2f::normalized(void) const
 */
static PyObject *Dtool_LVecBase2f_normalized_42(PyObject *self, PyObject *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase2f::normalized(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_normalized_42_comment =
  "C++ Interface:\n"
  "normalized(LVecBase2f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_normalized_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const
 */
static PyObject *Dtool_LVecBase2f_project_43(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.project", "LVecBase2f");
  }
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVecBase2f self, const LVecBase2f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_project_43_comment =
  "C++ Interface:\n"
  "project(LVecBase2f self, const LVecBase2f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_project_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2f::compare_to(LVecBase2f const &other) const
 * inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const
 */
static PyObject *Dtool_LVecBase2f_compare_to_47(PyObject *self, PyObject *args) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LVecBase2f::compare_to(LVecBase2f const &other) const
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.compare_to", "LVecBase2f");
      }
      int return_value = (*(const LVecBase2f*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const
      PyObject *param1;
      float param2;
      if (PyArg_ParseTuple(args, "Of:compare_to", &param1, &param2)) {
        LVecBase2f param1_local;
        LVecBase2f const *param1_this = Dtool_Coerce_LVecBase2f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase2f.compare_to", "LVecBase2f");
        }
        int return_value = (*(const LVecBase2f*)local_this).compare_to(*param1_this, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase2f self, const LVecBase2f other)\n"
      "compare_to(LVecBase2f self, const LVecBase2f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_compare_to_47_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase2f self, const LVecBase2f other)\n"
  "compare_to(LVecBase2f self, const LVecBase2f other, float threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts vectors lexicographically, componentwise.  Returns a number less than\n"
  " * 0 if this vector sorts before the other one, greater than zero if it sorts\n"
  " * after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LVecBase2f_compare_to_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase2f::get_hash(void) const
 * inline std::size_t LVecBase2f::get_hash(float threshold) const
 */
static PyObject *Dtool_LVecBase2f_get_hash_48(PyObject *self, PyObject *args) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LVecBase2f::get_hash(void) const
      std::size_t return_value = (*(const LVecBase2f*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LVecBase2f::get_hash(float threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LVecBase2f*)local_this).get_hash((float)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LVecBase2f self)\n"
      "get_hash(LVecBase2f self, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_get_hash_48_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase2f self)\n"
  "get_hash(LVecBase2f self, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_get_hash_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase2f::add_hash(std::size_t hash) const
 * inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const
 */
static PyObject *Dtool_LVecBase2f_add_hash_49(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LVecBase2f::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase2f*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const
      Py_ssize_t param1;
      float param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nf:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase2f*)local_this).add_hash((std::size_t)param1, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase2f self, int hash)\n"
      "add_hash(LVecBase2f self, int hash, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_add_hash_49_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase2f self, int hash)\n"
  "add_hash(LVecBase2f self, int hash, float threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_add_hash_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::componentwise_mult(LVecBase2f const &other)
 */
static PyObject *Dtool_LVecBase2f_componentwise_mult_60(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::componentwise_mult(LVecBase2f const &other)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.componentwise_mult", "LVecBase2f");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase2f self, const LVecBase2f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_componentwise_mult_60_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase2f self, const LVecBase2f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_componentwise_mult_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const
 */
static PyObject *Dtool_LVecBase2f_fmax_63(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.fmax", "LVecBase2f");
  }
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase2f self, const LVecBase2f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_fmax_63_comment =
  "C++ Interface:\n"
  "fmax(LVecBase2f self, const LVecBase2f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_fmax_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const
 */
static PyObject *Dtool_LVecBase2f_fmin_64(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.fmin", "LVecBase2f");
  }
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase2f self, const LVecBase2f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_fmin_64_comment =
  "C++ Interface:\n"
  "fmin(LVecBase2f self, const LVecBase2f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_fmin_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const
 * inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const
 */
static PyObject *Dtool_LVecBase2f_almost_equal_65(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.almost_equal", "LVecBase2f");
      }
      bool return_value = (*(const LVecBase2f*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase2f param1_local;
        LVecBase2f const *param1_this = Dtool_Coerce_LVecBase2f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase2f.almost_equal", "LVecBase2f");
        }
        bool return_value = (*(const LVecBase2f*)local_this).almost_equal(*param1_this, (float)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase2f self, const LVecBase2f other)\n"
      "almost_equal(LVecBase2f self, const LVecBase2f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_almost_equal_65_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase2f self, const LVecBase2f other)\n"
  "almost_equal(LVecBase2f self, const LVecBase2f other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_almost_equal_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase2f_output_66(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2f::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase2f.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase2f*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase2f self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_output_66_comment =
  "C++ Interface:\n"
  "output(LVecBase2f self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2f_output_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase2f_write_datagram_fixed_68(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase2f*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase2f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_write_datagram_fixed_68_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase2f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_write_datagram_fixed_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase2f_read_datagram_fixed_69(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase2f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_read_datagram_fixed_69_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase2f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase2f_read_datagram_fixed_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase2f_write_datagram_70(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2f::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.write_datagram", "Datagram");
  }
  (*(const LVecBase2f*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase2f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_write_datagram_70_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase2f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase2f_write_datagram_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2f::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase2f_read_datagram_71(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase2f::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase2f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_read_datagram_71_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase2f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase2f_read_datagram_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase2f::get_class_type(void)
 */
static PyObject *Dtool_LVecBase2f_get_class_type_72(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase2f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase2f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2f_get_class_type_72_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase2f_get_class_type_72_comment = NULL;
#endif

static PyObject *Dtool_LVecBase2f_x_Getter(PyObject *self, void *) {
  const LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase2f::get_x(void) const
  float return_value = (*(const LVecBase2f*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase2f_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase2f::set_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase2f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase2f_y_Getter(PyObject *self, void *) {
  const LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase2f::get_y(void) const
  float return_value = (*(const LVecBase2f*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase2f_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2f, (void **)&local_this, "LVecBase2f.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase2f::set_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase2f self, float value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline LVecBase2f::LVecBase2f(void) = default
 * inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default
 * inline LVecBase2f::LVecBase2f(float fill_value)
 * inline LVecBase2f::LVecBase2f(float x, float y)
 */
static int Dtool_Init_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase2f::LVecBase2f(void) = default
      LVecBase2f *return_value = new LVecBase2f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase2f", (char **)keyword_list, &param0)) {
          LVecBase2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase2f *return_value = new LVecBase2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase2f::LVecBase2f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LVecBase2f", (char **)keyword_list, &param0)) {
          LVecBase2f *return_value = new LVecBase2f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase2f", (char **)keyword_list, &param0)) {
          LVecBase2f param0_local;
          LVecBase2f const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase2f *return_value = new LVecBase2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase2f::LVecBase2f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase2f::LVecBase2f(float x, float y)
      float param0;
      float param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:LVecBase2f", (char **)keyword_list, &param0, &param1)) {
        LVecBase2f *return_value = new LVecBase2f((float)param0, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase2f() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase2f()\n"
      "LVecBase2f(const LVecBase2f param0)\n"
      "LVecBase2f(float fill_value)\n"
      "LVecBase2f(float x, float y)\n");
  }
  return -1;
}

LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  LVecBase2f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase2f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase2f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LVecBase2f::LVecBase2f(float fill_value)
    if (PyNumber_Check(arg)) {
      coerced = LVecBase2f((float)PyFloat_AsDouble(arg));
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LVecBase2f::LVecBase2f(float x, float y)
      float param0;
      float param1;
      if (PyArg_ParseTuple(args, "ff:LVecBase2f", &param0, &param1)) {
        coerced = LVecBase2f((float)param0, (float)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase2f) {
    printf("LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase2f *local_this = (LVecBase2f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase2f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase2f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase2d
 */
/**
 * Python function wrapper for:
 * LVecBase2d &LVecBase2d::operator =(LVecBase2d const &copy) = default
 * LVecBase2d &LVecBase2d::operator =(double fill_value) = default
 */
static PyObject *Dtool_LVecBase2d_operator_80(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase2d &LVecBase2d::operator =(LVecBase2d const &copy) = default
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase2d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, false);
    }
  }

  {
    // -2 LVecBase2d &LVecBase2d::operator =(double fill_value) = default
    if (PyNumber_Check(arg)) {
      (*local_this).operator =(PyFloat_AsDouble(arg));
      LVecBase2d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, false);
    }
  }

  {
    // -2 LVecBase2d &LVecBase2d::operator =(LVecBase2d const &copy) = default
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase2d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, false);
    }
  }

  // No coercion possible: LVecBase2d &LVecBase2d::operator =(double fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase2d self, const LVecBase2d copy)\n"
      "assign(const LVecBase2d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_operator_80_comment =
  "C++ Interface:\n"
  "assign(const LVecBase2d self, const LVecBase2d copy)\n"
  "assign(const LVecBase2d self, double fill_value)\n";
#else
static const char *Dtool_LVecBase2d_operator_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2d const &LVecBase2d::zero(void)
 */
static PyObject *Dtool_LVecBase2d_zero_81(PyObject *, PyObject *) {
  // 1-static inline LVecBase2d const &LVecBase2d::zero(void)
  LVecBase2d const *return_value = &(LVecBase2d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_zero_81_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_zero_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2d const &LVecBase2d::unit_x(void)
 */
static PyObject *Dtool_LVecBase2d_unit_x_82(PyObject *, PyObject *) {
  // 1-static inline LVecBase2d const &LVecBase2d::unit_x(void)
  LVecBase2d const *return_value = &(LVecBase2d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_unit_x_82_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_unit_x_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2d const &LVecBase2d::unit_y(void)
 */
static PyObject *Dtool_LVecBase2d_unit_y_83(PyObject *, PyObject *) {
  // 1-static inline LVecBase2d const &LVecBase2d::unit_y(void)
  LVecBase2d const *return_value = &(LVecBase2d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_unit_y_83_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_unit_y_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase2d::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase2d_reduce_84(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase2d::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase2d*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_reduce_84_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase2d self)\n";
#else
static const char *Dtool_LVecBase2d_reduce_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2d::is_nan(void) const
 */
static PyObject *Dtool_LVecBase2d_is_nan_89(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase2d::is_nan(void) const
  bool return_value = (*(const LVecBase2d*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_is_nan_89_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase2d self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_is_nan_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase2d::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase2d_get_cell_90(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase2d::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const LVecBase2d*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase2d self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_get_cell_90_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase2d self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_get_cell_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::set_cell(int i, double value)
 */
static PyObject *Dtool_LVecBase2d_set_cell_91(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::set_cell(int i, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase2d self, int i, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_set_cell_91_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase2d self, int i, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_set_cell_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase2d::get_x(void) const
 */
static PyObject *Dtool_LVecBase2d_get_x_92(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase2d::get_x(void) const
  double return_value = (*(const LVecBase2d*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_get_x_92_comment =
  "C++ Interface:\n"
  "get_x(LVecBase2d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_get_x_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase2d::get_y(void) const
 */
static PyObject *Dtool_LVecBase2d_get_y_93(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase2d::get_y(void) const
  double return_value = (*(const LVecBase2d*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_get_y_93_comment =
  "C++ Interface:\n"
  "get_y(LVecBase2d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_get_y_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::set_x(double value)
 */
static PyObject *Dtool_LVecBase2d_set_x_94(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::set_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase2d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_set_x_94_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase2d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_set_x_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::set_y(double value)
 */
static PyObject *Dtool_LVecBase2d_set_y_95(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::set_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase2d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_set_y_95_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase2d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_set_y_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::add_to_cell(int i, double value)
 */
static PyObject *Dtool_LVecBase2d_add_to_cell_99(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::add_to_cell(int i, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase2d self, int i, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_add_to_cell_99_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase2d self, int i, double value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_add_to_cell_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::add_x(double value)
 */
static PyObject *Dtool_LVecBase2d_add_x_100(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::add_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_x(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase2d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_add_x_100_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase2d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_add_x_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::add_y(double value)
 */
static PyObject *Dtool_LVecBase2d_add_y_101(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::add_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_y(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase2d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_add_y_101_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase2d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_add_y_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase2d::get_num_components(void)
 */
static PyObject *Dtool_LVecBase2d_get_num_components_103(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase2d::get_num_components(void)
  int return_value = LVecBase2d::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_get_num_components_103_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, two.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_get_num_components_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::fill(double fill_value)
 */
static PyObject *Dtool_LVecBase2d_fill_104(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::fill(double fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase2d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_fill_104_comment =
  "C++ Interface:\n"
  "fill(const LVecBase2d self, double fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_fill_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::set(double x, double y)
 */
static PyObject *Dtool_LVecBase2d_set_105(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.set")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::set(double x, double y)
  double param1;
  double param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set((double)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase2d self, double x, double y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_set_105_comment =
  "C++ Interface:\n"
  "set(const LVecBase2d self, double x, double y)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_set_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase2d::dot(LVecBase2d const &other) const
 */
static PyObject *Dtool_LVecBase2d_dot_106(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase2d::dot(LVecBase2d const &other) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.dot", "LVecBase2d");
  }
  double return_value = (*(const LVecBase2d*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase2d self, const LVecBase2d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_dot_106_comment =
  "C++ Interface:\n"
  "dot(LVecBase2d self, const LVecBase2d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_dot_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase2d::length_squared(void) const
 */
static PyObject *Dtool_LVecBase2d_length_squared_107(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase2d::length_squared(void) const
  double return_value = (*(const LVecBase2d*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_length_squared_107_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase2d self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_length_squared_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase2d::length(void) const
 */
static PyObject *Dtool_LVecBase2d_length_108(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase2d::length(void) const
  double return_value = (*(const LVecBase2d*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_length_108_comment =
  "C++ Interface:\n"
  "length(LVecBase2d self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the vector, by the Pythagorean theorem.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_length_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2d::normalize(void)
 */
static PyObject *Dtool_LVecBase2d_normalize_109(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.normalize")) {
    return NULL;
  }
  // 1-inline bool LVecBase2d::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_normalize_109_comment =
  "C++ Interface:\n"
  "normalize(const LVecBase2d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector in place.  Returns true if the vector was normalized,\n"
  " * false if it was a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_normalize_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase2d::normalized(void) const
 */
static PyObject *Dtool_LVecBase2d_normalized_110(PyObject *self, PyObject *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase2d::normalized(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_normalized_110_comment =
  "C++ Interface:\n"
  "normalized(LVecBase2d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_normalized_110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const
 */
static PyObject *Dtool_LVecBase2d_project_111(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.project", "LVecBase2d");
  }
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVecBase2d self, const LVecBase2d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_project_111_comment =
  "C++ Interface:\n"
  "project(LVecBase2d self, const LVecBase2d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_project_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2d::compare_to(LVecBase2d const &other) const
 * inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const
 */
static PyObject *Dtool_LVecBase2d_compare_to_115(PyObject *self, PyObject *args) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LVecBase2d::compare_to(LVecBase2d const &other) const
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.compare_to", "LVecBase2d");
      }
      int return_value = (*(const LVecBase2d*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "Od:compare_to", &param1, &param2)) {
        LVecBase2d param1_local;
        LVecBase2d const *param1_this = Dtool_Coerce_LVecBase2d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase2d.compare_to", "LVecBase2d");
        }
        int return_value = (*(const LVecBase2d*)local_this).compare_to(*param1_this, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase2d self, const LVecBase2d other)\n"
      "compare_to(LVecBase2d self, const LVecBase2d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_compare_to_115_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase2d self, const LVecBase2d other)\n"
  "compare_to(LVecBase2d self, const LVecBase2d other, double threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts vectors lexicographically, componentwise.  Returns a number less than\n"
  " * 0 if this vector sorts before the other one, greater than zero if it sorts\n"
  " * after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LVecBase2d_compare_to_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase2d::get_hash(void) const
 * inline std::size_t LVecBase2d::get_hash(double threshold) const
 */
static PyObject *Dtool_LVecBase2d_get_hash_116(PyObject *self, PyObject *args) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LVecBase2d::get_hash(void) const
      std::size_t return_value = (*(const LVecBase2d*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LVecBase2d::get_hash(double threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LVecBase2d*)local_this).get_hash(PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LVecBase2d self)\n"
      "get_hash(LVecBase2d self, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_get_hash_116_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase2d self)\n"
  "get_hash(LVecBase2d self, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_get_hash_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase2d::add_hash(std::size_t hash) const
 * inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const
 */
static PyObject *Dtool_LVecBase2d_add_hash_117(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LVecBase2d::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase2d*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const
      Py_ssize_t param1;
      double param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase2d*)local_this).add_hash((std::size_t)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase2d self, int hash)\n"
      "add_hash(LVecBase2d self, int hash, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_add_hash_117_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase2d self, int hash)\n"
  "add_hash(LVecBase2d self, int hash, double threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_add_hash_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::componentwise_mult(LVecBase2d const &other)
 */
static PyObject *Dtool_LVecBase2d_componentwise_mult_128(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::componentwise_mult(LVecBase2d const &other)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.componentwise_mult", "LVecBase2d");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase2d self, const LVecBase2d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_componentwise_mult_128_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase2d self, const LVecBase2d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_componentwise_mult_128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const
 */
static PyObject *Dtool_LVecBase2d_fmax_131(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.fmax", "LVecBase2d");
  }
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase2d self, const LVecBase2d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_fmax_131_comment =
  "C++ Interface:\n"
  "fmax(LVecBase2d self, const LVecBase2d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_fmax_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const
 */
static PyObject *Dtool_LVecBase2d_fmin_132(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.fmin", "LVecBase2d");
  }
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase2d self, const LVecBase2d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_fmin_132_comment =
  "C++ Interface:\n"
  "fmin(LVecBase2d self, const LVecBase2d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_fmin_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const
 * inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const
 */
static PyObject *Dtool_LVecBase2d_almost_equal_133(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.almost_equal", "LVecBase2d");
      }
      bool return_value = (*(const LVecBase2d*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase2d param1_local;
        LVecBase2d const *param1_this = Dtool_Coerce_LVecBase2d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase2d.almost_equal", "LVecBase2d");
        }
        bool return_value = (*(const LVecBase2d*)local_this).almost_equal(*param1_this, (double)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase2d self, const LVecBase2d other)\n"
      "almost_equal(LVecBase2d self, const LVecBase2d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_almost_equal_133_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase2d self, const LVecBase2d other)\n"
  "almost_equal(LVecBase2d self, const LVecBase2d other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_almost_equal_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase2d_output_134(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2d::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase2d.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase2d*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase2d self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_output_134_comment =
  "C++ Interface:\n"
  "output(LVecBase2d self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2d_output_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase2d_write_datagram_fixed_136(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase2d*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase2d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_write_datagram_fixed_136_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase2d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_write_datagram_fixed_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase2d_read_datagram_fixed_137(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase2d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_read_datagram_fixed_137_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase2d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase2d_read_datagram_fixed_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase2d_write_datagram_138(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2d::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.write_datagram", "Datagram");
  }
  (*(const LVecBase2d*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase2d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_write_datagram_138_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase2d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase2d_write_datagram_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2d::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase2d_read_datagram_139(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase2d::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase2d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_read_datagram_139_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase2d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase2d_read_datagram_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase2d::get_class_type(void)
 */
static PyObject *Dtool_LVecBase2d_get_class_type_140(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase2d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase2d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2d_get_class_type_140_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase2d_get_class_type_140_comment = NULL;
#endif

static PyObject *Dtool_LVecBase2d_x_Getter(PyObject *self, void *) {
  const LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase2d::get_x(void) const
  double return_value = (*(const LVecBase2d*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase2d_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase2d::set_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase2d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase2d_y_Getter(PyObject *self, void *) {
  const LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase2d::get_y(void) const
  double return_value = (*(const LVecBase2d*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase2d_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2d, (void **)&local_this, "LVecBase2d.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase2d::set_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase2d self, double value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline LVecBase2d::LVecBase2d(void) = default
 * inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default
 * inline LVecBase2d::LVecBase2d(double fill_value)
 * inline LVecBase2d::LVecBase2d(double x, double y)
 */
static int Dtool_Init_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase2d::LVecBase2d(void) = default
      LVecBase2d *return_value = new LVecBase2d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase2d", (char **)keyword_list, &param0)) {
          LVecBase2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase2d *return_value = new LVecBase2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase2d::LVecBase2d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LVecBase2d", (char **)keyword_list, &param0)) {
          LVecBase2d *return_value = new LVecBase2d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase2d", (char **)keyword_list, &param0)) {
          LVecBase2d param0_local;
          LVecBase2d const *param0_this = Dtool_Coerce_LVecBase2d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase2d *return_value = new LVecBase2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase2d::LVecBase2d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase2d::LVecBase2d(double x, double y)
      double param0;
      double param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:LVecBase2d", (char **)keyword_list, &param0, &param1)) {
        LVecBase2d *return_value = new LVecBase2d((double)param0, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase2d() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase2d()\n"
      "LVecBase2d(const LVecBase2d param0)\n"
      "LVecBase2d(double fill_value)\n"
      "LVecBase2d(double x, double y)\n");
  }
  return -1;
}

LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  LVecBase2d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase2d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase2d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LVecBase2d::LVecBase2d(double fill_value)
    if (PyNumber_Check(arg)) {
      coerced = LVecBase2d(PyFloat_AsDouble(arg));
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LVecBase2d::LVecBase2d(double x, double y)
      double param0;
      double param1;
      if (PyArg_ParseTuple(args, "dd:LVecBase2d", &param0, &param1)) {
        coerced = LVecBase2d((double)param0, (double)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase2d) {
    printf("LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase2d *local_this = (LVecBase2d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase2d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase2d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase2i
 */
/**
 * Python function wrapper for:
 * LVecBase2i &LVecBase2i::operator =(LVecBase2i const &copy) = default
 * LVecBase2i &LVecBase2i::operator =(int fill_value) = default
 */
static PyObject *Dtool_LVecBase2i_operator_148(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase2i &LVecBase2i::operator =(LVecBase2i const &copy) = default
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase2i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, false);
    }
  }

  {
    // -2 LVecBase2i &LVecBase2i::operator =(int fill_value) = default
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      (*local_this).operator =((int)arg_val);
      LVecBase2i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, false);
    }
  }

  {
    // -2 LVecBase2i &LVecBase2i::operator =(LVecBase2i const &copy) = default
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase2i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, false);
    }
  }

  // No coercion possible: LVecBase2i &LVecBase2i::operator =(int fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase2i self, const LVecBase2i copy)\n"
      "assign(const LVecBase2i self, int fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_operator_148_comment =
  "C++ Interface:\n"
  "assign(const LVecBase2i self, const LVecBase2i copy)\n"
  "assign(const LVecBase2i self, int fill_value)\n";
#else
static const char *Dtool_LVecBase2i_operator_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2i const &LVecBase2i::zero(void)
 */
static PyObject *Dtool_LVecBase2i_zero_149(PyObject *, PyObject *) {
  // 1-static inline LVecBase2i const &LVecBase2i::zero(void)
  LVecBase2i const *return_value = &(LVecBase2i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_zero_149_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_zero_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2i const &LVecBase2i::unit_x(void)
 */
static PyObject *Dtool_LVecBase2i_unit_x_150(PyObject *, PyObject *) {
  // 1-static inline LVecBase2i const &LVecBase2i::unit_x(void)
  LVecBase2i const *return_value = &(LVecBase2i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_unit_x_150_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_unit_x_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase2i const &LVecBase2i::unit_y(void)
 */
static PyObject *Dtool_LVecBase2i_unit_y_151(PyObject *, PyObject *) {
  // 1-static inline LVecBase2i const &LVecBase2i::unit_y(void)
  LVecBase2i const *return_value = &(LVecBase2i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_unit_y_151_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_unit_y_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase2i::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase2i_reduce_152(PyObject *self, PyObject *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase2i::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase2i*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_reduce_152_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase2i self)\n";
#else
static const char *Dtool_LVecBase2i_reduce_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2i::is_nan(void) const
 */
static PyObject *Dtool_LVecBase2i_is_nan_157(PyObject *self, PyObject *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase2i::is_nan(void) const
  bool return_value = (*(const LVecBase2i*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_is_nan_157_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase2i self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_is_nan_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2i::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase2i_get_cell_158(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase2i::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const LVecBase2i*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase2i self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_get_cell_158_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase2i self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_get_cell_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::set_cell(int i, int value)
 */
static PyObject *Dtool_LVecBase2i_set_cell_159(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::set_cell(int i, int value)
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase2i self, int i, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_set_cell_159_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase2i self, int i, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_set_cell_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2i::get_x(void) const
 */
static PyObject *Dtool_LVecBase2i_get_x_160(PyObject *self, PyObject *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase2i::get_x(void) const
  int return_value = (*(const LVecBase2i*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_get_x_160_comment =
  "C++ Interface:\n"
  "get_x(LVecBase2i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_get_x_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2i::get_y(void) const
 */
static PyObject *Dtool_LVecBase2i_get_y_161(PyObject *self, PyObject *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase2i::get_y(void) const
  int return_value = (*(const LVecBase2i*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_get_y_161_comment =
  "C++ Interface:\n"
  "get_y(LVecBase2i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_get_y_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::set_x(int value)
 */
static PyObject *Dtool_LVecBase2i_set_x_162(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::set_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_x((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase2i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_set_x_162_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase2i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_set_x_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::set_y(int value)
 */
static PyObject *Dtool_LVecBase2i_set_y_163(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::set_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_y((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase2i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_set_y_163_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase2i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_set_y_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::add_to_cell(int i, int value)
 */
static PyObject *Dtool_LVecBase2i_add_to_cell_167(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::add_to_cell(int i, int value)
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase2i self, int i, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_add_to_cell_167_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase2i self, int i, int value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_add_to_cell_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::add_x(int value)
 */
static PyObject *Dtool_LVecBase2i_add_x_168(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::add_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_x((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase2i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_add_x_168_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase2i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_add_x_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::add_y(int value)
 */
static PyObject *Dtool_LVecBase2i_add_y_169(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::add_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_y((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase2i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_add_y_169_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase2i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_add_y_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase2i::get_num_components(void)
 */
static PyObject *Dtool_LVecBase2i_get_num_components_171(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase2i::get_num_components(void)
  int return_value = LVecBase2i::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_get_num_components_171_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, two.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_get_num_components_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::fill(int fill_value)
 */
static PyObject *Dtool_LVecBase2i_fill_172(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::fill(int fill_value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).fill((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase2i self, int fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_fill_172_comment =
  "C++ Interface:\n"
  "fill(const LVecBase2i self, int fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_fill_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::set(int x, int y)
 */
static PyObject *Dtool_LVecBase2i_set_173(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.set")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::set(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase2i self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_set_173_comment =
  "C++ Interface:\n"
  "set(const LVecBase2i self, int x, int y)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_set_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2i::dot(LVecBase2i const &other) const
 */
static PyObject *Dtool_LVecBase2i_dot_174(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase2i::dot(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.dot", "LVecBase2i");
  }
  int return_value = (*(const LVecBase2i*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase2i self, const LVecBase2i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_dot_174_comment =
  "C++ Interface:\n"
  "dot(LVecBase2i self, const LVecBase2i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_dot_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2i::length_squared(void) const
 */
static PyObject *Dtool_LVecBase2i_length_squared_175(PyObject *self, PyObject *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase2i::length_squared(void) const
  int return_value = (*(const LVecBase2i*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_length_squared_175_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase2i self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_length_squared_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase2i::compare_to(LVecBase2i const &other) const
 */
static PyObject *Dtool_LVecBase2i_compare_to_179(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase2i::compare_to(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.compare_to", "LVecBase2i");
  }
  int return_value = (*(const LVecBase2i*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase2i self, const LVecBase2i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_compare_to_179_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase2i self, const LVecBase2i other)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_compare_to_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase2i::get_hash(void) const
 */
static PyObject *Dtool_LVecBase2i_get_hash_180(PyObject *self, PyObject *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t LVecBase2i::get_hash(void) const
  std::size_t return_value = (*(const LVecBase2i*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_get_hash_180_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase2i self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_get_hash_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase2i::add_hash(std::size_t hash) const
 */
static PyObject *Dtool_LVecBase2i_add_hash_181(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t LVecBase2i::add_hash(std::size_t hash) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::size_t return_value = (*(const LVecBase2i*)local_this).add_hash((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase2i self, int hash)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_add_hash_181_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase2i self, int hash)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_add_hash_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::componentwise_mult(LVecBase2i const &other)
 */
static PyObject *Dtool_LVecBase2i_componentwise_mult_192(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::componentwise_mult(LVecBase2i const &other)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.componentwise_mult", "LVecBase2i");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase2i self, const LVecBase2i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_componentwise_mult_192_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase2i self, const LVecBase2i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_componentwise_mult_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const
 */
static PyObject *Dtool_LVecBase2i_fmax_195(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.fmax", "LVecBase2i");
  }
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase2i self, const LVecBase2i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_fmax_195_comment =
  "C++ Interface:\n"
  "fmax(LVecBase2i self, const LVecBase2i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_fmax_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const
 */
static PyObject *Dtool_LVecBase2i_fmin_196(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.fmin", "LVecBase2i");
  }
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase2i self, const LVecBase2i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_fmin_196_comment =
  "C++ Interface:\n"
  "fmin(LVecBase2i self, const LVecBase2i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_fmin_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const
 * inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const
 */
static PyObject *Dtool_LVecBase2i_almost_equal_197(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.almost_equal", "LVecBase2i");
      }
      bool return_value = (*(const LVecBase2i*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase2i param1_local;
        LVecBase2i const *param1_this = Dtool_Coerce_LVecBase2i(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase2i.almost_equal", "LVecBase2i");
        }
        bool return_value = (*(const LVecBase2i*)local_this).almost_equal(*param1_this, (int)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase2i self, const LVecBase2i other)\n"
      "almost_equal(LVecBase2i self, const LVecBase2i other, int threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_almost_equal_197_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase2i self, const LVecBase2i other)\n"
  "almost_equal(LVecBase2i self, const LVecBase2i other, int threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_almost_equal_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase2i_output_198(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2i::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase2i.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase2i*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase2i self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_output_198_comment =
  "C++ Interface:\n"
  "output(LVecBase2i self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase2i_output_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase2i_write_datagram_fixed_200(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase2i*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase2i self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_write_datagram_fixed_200_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase2i self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_write_datagram_fixed_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase2i_read_datagram_fixed_201(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase2i self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_read_datagram_fixed_201_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase2i self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase2i_read_datagram_fixed_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase2i_write_datagram_202(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase2i::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.write_datagram", "Datagram");
  }
  (*(const LVecBase2i*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase2i self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_write_datagram_202_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase2i self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase2i_write_datagram_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase2i::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase2i_read_datagram_203(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase2i::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase2i self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_read_datagram_203_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase2i self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase2i_read_datagram_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase2i::get_class_type(void)
 */
static PyObject *Dtool_LVecBase2i_get_class_type_204(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase2i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase2i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase2i_get_class_type_204_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase2i_get_class_type_204_comment = NULL;
#endif

static PyObject *Dtool_LVecBase2i_x_Getter(PyObject *self, void *) {
  const LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase2i::get_x(void) const
  int return_value = (*(const LVecBase2i*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase2i_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase2i::set_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_x((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase2i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase2i_y_Getter(PyObject *self, void *) {
  const LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase2i::get_y(void) const
  int return_value = (*(const LVecBase2i*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase2i_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase2i, (void **)&local_this, "LVecBase2i.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase2i::set_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_y((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase2i self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline LVecBase2i::LVecBase2i(void) = default
 * inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default
 * inline LVecBase2i::LVecBase2i(int fill_value)
 * inline LVecBase2i::LVecBase2i(int x, int y)
 */
static int Dtool_Init_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase2i::LVecBase2i(void) = default
      LVecBase2i *return_value = new LVecBase2i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase2i", (char **)keyword_list, &param0)) {
          LVecBase2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase2i *return_value = new LVecBase2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase2i::LVecBase2i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LVecBase2i", (char **)keyword_list, &param0)) {
          LVecBase2i *return_value = new LVecBase2i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase2i", (char **)keyword_list, &param0)) {
          LVecBase2i param0_local;
          LVecBase2i const *param0_this = Dtool_Coerce_LVecBase2i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase2i *return_value = new LVecBase2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase2i::LVecBase2i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase2i::LVecBase2i(int x, int y)
      int param0;
      int param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:LVecBase2i", (char **)keyword_list, &param0, &param1)) {
        LVecBase2i *return_value = new LVecBase2i((int)param0, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase2i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase2i() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase2i()\n"
      "LVecBase2i(const LVecBase2i param0)\n"
      "LVecBase2i(int fill_value)\n"
      "LVecBase2i(int x, int y)\n");
  }
  return -1;
}

LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  LVecBase2i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase2i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase2i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LVecBase2i::LVecBase2i(int fill_value)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      coerced = LVecBase2i((int)arg_val);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LVecBase2i::LVecBase2i(int x, int y)
      int param0;
      int param1;
      if (PyArg_ParseTuple(args, "ii:LVecBase2i", &param0, &param1)) {
        coerced = LVecBase2i((int)param0, (int)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase2i) {
    printf("LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase2i *local_this = (LVecBase2i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase2i) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase2i) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector2f
 */
/**
 * Python function wrapper for:
 * static inline LVector2f const &LVector2f::zero(void)
 */
static PyObject *Dtool_LVector2f_zero_210(PyObject *, PyObject *) {
  // 1-static inline LVector2f const &LVector2f::zero(void)
  LVector2f const *return_value = &(LVector2f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_zero_210_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector2f_zero_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector2f const &LVector2f::unit_x(void)
 */
static PyObject *Dtool_LVector2f_unit_x_211(PyObject *, PyObject *) {
  // 1-static inline LVector2f const &LVector2f::unit_x(void)
  LVector2f const *return_value = &(LVector2f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_unit_x_211_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector2f_unit_x_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector2f const &LVector2f::unit_y(void)
 */
static PyObject *Dtool_LVector2f_unit_y_212(PyObject *, PyObject *) {
  // 1-static inline LVector2f const &LVector2f::unit_y(void)
  LVector2f const *return_value = &(LVector2f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_unit_y_212_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector2f_unit_y_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f LVector2f::normalized(void) const
 */
static PyObject *Dtool_LVector2f_normalized_218(PyObject *self, PyObject *) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2f LVector2f::normalized(void) const
  LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_normalized_218_comment =
  "C++ Interface:\n"
  "normalized(LVector2f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVector2f_normalized_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f LVector2f::project(LVecBase2f const &onto) const
 */
static PyObject *Dtool_LVector2f_project_219(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2f LVector2f::project(LVecBase2f const &onto) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector2f.project", "LVecBase2f");
  }
  LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVector2f self, const LVecBase2f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_project_219_comment =
  "C++ Interface:\n"
  "project(LVector2f self, const LVecBase2f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVector2f_project_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector2f::signed_angle_rad(LVector2f const &other) const
 */
static PyObject *Dtool_LVector2f_signed_angle_rad_220(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector2f::signed_angle_rad(LVector2f const &other) const
  LVector2f arg_local;
  LVector2f const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector2f.signed_angle_rad", "LVector2f");
  }
  float return_value = (*(const LVector2f*)local_this).signed_angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_rad(LVector2f self, const LVector2f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_signed_angle_rad_220_comment =
  "C++ Interface:\n"
  "signed_angle_rad(LVector2f self, const LVector2f other)\n"
  "\n"
  "/**\n"
  " * returns the signed angled between two vectors.  normalization is NOT\n"
  " * necessary\n"
  " */";
#else
static const char *Dtool_LVector2f_signed_angle_rad_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector2f::signed_angle_deg(LVector2f const &other) const
 */
static PyObject *Dtool_LVector2f_signed_angle_deg_221(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector2f::signed_angle_deg(LVector2f const &other) const
  LVector2f arg_local;
  LVector2f const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector2f.signed_angle_deg", "LVector2f");
  }
  float return_value = (*(const LVector2f*)local_this).signed_angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_deg(LVector2f self, const LVector2f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_signed_angle_deg_221_comment =
  "C++ Interface:\n"
  "signed_angle_deg(LVector2f self, const LVector2f other)\n"
  "\n"
  "/**\n"
  " * returns the signed angled between two vectors.  normalization is NOT\n"
  " * necessary\n"
  " */";
#else
static const char *Dtool_LVector2f_signed_angle_deg_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector2f::get_class_type(void)
 */
static PyObject *Dtool_LVector2f_get_class_type_223(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector2f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector2f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector2f_get_class_type_223_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector2f_get_class_type_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f::LVector2f(void) = default
 * inline LVector2f::LVector2f(LVecBase2f const &copy)
 * inline LVector2f::LVector2f(LVector2f const &) = default
 * inline LVector2f::LVector2f(float fill_value)
 * inline LVector2f::LVector2f(float x, float y)
 */
static int Dtool_Init_LVector2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector2f::LVector2f(void) = default
      LVector2f *return_value = new LVector2f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector2f::LVector2f(LVector2f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2f", (char **)keyword_list, &param0)) {
          LVector2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector2f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector2f *return_value = new LVector2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2f::LVector2f(LVecBase2f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2f", (char **)keyword_list, &param0)) {
          LVecBase2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector2f *return_value = new LVector2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2f::LVector2f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LVector2f", (char **)keyword_list, &param0)) {
          LVector2f *return_value = new LVector2f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2f::LVector2f(LVector2f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2f", (char **)keyword_list, &param0)) {
          LVector2f param0_local;
          LVector2f const *param0_this = Dtool_Coerce_LVector2f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector2f *return_value = new LVector2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2f::LVector2f(LVecBase2f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2f", (char **)keyword_list, &param0)) {
          LVecBase2f param0_local;
          LVecBase2f const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector2f *return_value = new LVector2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector2f::LVector2f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector2f::LVector2f(float x, float y)
      float param0;
      float param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:LVector2f", (char **)keyword_list, &param0, &param1)) {
        LVector2f *return_value = new LVector2f((float)param0, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector2f() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector2f()\n"
      "LVector2f(const LVector2f param0)\n"
      "LVector2f(const LVecBase2f copy)\n"
      "LVector2f(float fill_value)\n"
      "LVector2f(float x, float y)\n");
  }
  return -1;
}

LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  LVector2f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector2f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector2f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector2f::LVector2f(LVecBase2f const &copy)
      LVecBase2f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector2f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector2f::LVector2f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVector2f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LVector2f::LVector2f(float x, float y)
      float param0;
      float param1;
      if (PyArg_ParseTuple(args, "ff:LVector2f", &param0, &param1)) {
        coerced = LVector2f((float)param0, (float)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector2f) {
    printf("LVector2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector2f *local_this = (LVector2f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase2f) {
    return (LVecBase2f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase2f) {
    LVecBase2f* other_this = (LVecBase2f*)from_this;
    return (LVector2f*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector2d
 */
/**
 * Python function wrapper for:
 * static inline LVector2d const &LVector2d::zero(void)
 */
static PyObject *Dtool_LVector2d_zero_229(PyObject *, PyObject *) {
  // 1-static inline LVector2d const &LVector2d::zero(void)
  LVector2d const *return_value = &(LVector2d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_zero_229_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector2d_zero_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector2d const &LVector2d::unit_x(void)
 */
static PyObject *Dtool_LVector2d_unit_x_230(PyObject *, PyObject *) {
  // 1-static inline LVector2d const &LVector2d::unit_x(void)
  LVector2d const *return_value = &(LVector2d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_unit_x_230_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector2d_unit_x_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector2d const &LVector2d::unit_y(void)
 */
static PyObject *Dtool_LVector2d_unit_y_231(PyObject *, PyObject *) {
  // 1-static inline LVector2d const &LVector2d::unit_y(void)
  LVector2d const *return_value = &(LVector2d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_unit_y_231_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector2d_unit_y_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d LVector2d::normalized(void) const
 */
static PyObject *Dtool_LVector2d_normalized_237(PyObject *self, PyObject *) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2d LVector2d::normalized(void) const
  LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_normalized_237_comment =
  "C++ Interface:\n"
  "normalized(LVector2d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVector2d_normalized_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d LVector2d::project(LVecBase2d const &onto) const
 */
static PyObject *Dtool_LVector2d_project_238(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2d LVector2d::project(LVecBase2d const &onto) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector2d.project", "LVecBase2d");
  }
  LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVector2d self, const LVecBase2d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_project_238_comment =
  "C++ Interface:\n"
  "project(LVector2d self, const LVecBase2d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVector2d_project_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector2d::signed_angle_rad(LVector2d const &other) const
 */
static PyObject *Dtool_LVector2d_signed_angle_rad_239(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector2d::signed_angle_rad(LVector2d const &other) const
  LVector2d arg_local;
  LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector2d.signed_angle_rad", "LVector2d");
  }
  double return_value = (*(const LVector2d*)local_this).signed_angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_rad(LVector2d self, const LVector2d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_signed_angle_rad_239_comment =
  "C++ Interface:\n"
  "signed_angle_rad(LVector2d self, const LVector2d other)\n"
  "\n"
  "/**\n"
  " * returns the signed angled between two vectors.  normalization is NOT\n"
  " * necessary\n"
  " */";
#else
static const char *Dtool_LVector2d_signed_angle_rad_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector2d::signed_angle_deg(LVector2d const &other) const
 */
static PyObject *Dtool_LVector2d_signed_angle_deg_240(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector2d::signed_angle_deg(LVector2d const &other) const
  LVector2d arg_local;
  LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector2d.signed_angle_deg", "LVector2d");
  }
  double return_value = (*(const LVector2d*)local_this).signed_angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_deg(LVector2d self, const LVector2d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_signed_angle_deg_240_comment =
  "C++ Interface:\n"
  "signed_angle_deg(LVector2d self, const LVector2d other)\n"
  "\n"
  "/**\n"
  " * returns the signed angled between two vectors.  normalization is NOT\n"
  " * necessary\n"
  " */";
#else
static const char *Dtool_LVector2d_signed_angle_deg_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector2d::get_class_type(void)
 */
static PyObject *Dtool_LVector2d_get_class_type_242(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector2d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector2d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector2d_get_class_type_242_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector2d_get_class_type_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d::LVector2d(void) = default
 * inline LVector2d::LVector2d(LVecBase2d const &copy)
 * inline LVector2d::LVector2d(LVector2d const &) = default
 * inline LVector2d::LVector2d(double fill_value)
 * inline LVector2d::LVector2d(double x, double y)
 */
static int Dtool_Init_LVector2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector2d::LVector2d(void) = default
      LVector2d *return_value = new LVector2d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector2d::LVector2d(LVector2d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2d", (char **)keyword_list, &param0)) {
          LVector2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector2d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector2d *return_value = new LVector2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2d::LVector2d(LVecBase2d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2d", (char **)keyword_list, &param0)) {
          LVecBase2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector2d *return_value = new LVector2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2d::LVector2d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LVector2d", (char **)keyword_list, &param0)) {
          LVector2d *return_value = new LVector2d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2d::LVector2d(LVector2d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2d", (char **)keyword_list, &param0)) {
          LVector2d param0_local;
          LVector2d const *param0_this = Dtool_Coerce_LVector2d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector2d *return_value = new LVector2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2d::LVector2d(LVecBase2d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2d", (char **)keyword_list, &param0)) {
          LVecBase2d param0_local;
          LVecBase2d const *param0_this = Dtool_Coerce_LVecBase2d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector2d *return_value = new LVector2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector2d::LVector2d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector2d::LVector2d(double x, double y)
      double param0;
      double param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:LVector2d", (char **)keyword_list, &param0, &param1)) {
        LVector2d *return_value = new LVector2d((double)param0, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector2d() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector2d()\n"
      "LVector2d(const LVector2d param0)\n"
      "LVector2d(const LVecBase2d copy)\n"
      "LVector2d(double fill_value)\n"
      "LVector2d(double x, double y)\n");
  }
  return -1;
}

LVector2d *Dtool_Coerce_LVector2d(PyObject *args, LVector2d &coerced) {
  LVector2d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector2d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector2d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector2d::LVector2d(LVecBase2d const &copy)
      LVecBase2d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector2d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector2d::LVector2d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVector2d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LVector2d::LVector2d(double x, double y)
      double param0;
      double param1;
      if (PyArg_ParseTuple(args, "dd:LVector2d", &param0, &param1)) {
        coerced = LVector2d((double)param0, (double)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector2d) {
    printf("LVector2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector2d *local_this = (LVector2d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase2d) {
    return (LVecBase2d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase2d) {
    LVecBase2d* other_this = (LVecBase2d*)from_this;
    return (LVector2d*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector2i
 */
/**
 * Python function wrapper for:
 * static inline LVector2i const &LVector2i::zero(void)
 */
static PyObject *Dtool_LVector2i_zero_248(PyObject *, PyObject *) {
  // 1-static inline LVector2i const &LVector2i::zero(void)
  LVector2i const *return_value = &(LVector2i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2i_zero_248_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector2i_zero_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector2i const &LVector2i::unit_x(void)
 */
static PyObject *Dtool_LVector2i_unit_x_249(PyObject *, PyObject *) {
  // 1-static inline LVector2i const &LVector2i::unit_x(void)
  LVector2i const *return_value = &(LVector2i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2i_unit_x_249_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector2i_unit_x_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector2i const &LVector2i::unit_y(void)
 */
static PyObject *Dtool_LVector2i_unit_y_250(PyObject *, PyObject *) {
  // 1-static inline LVector2i const &LVector2i::unit_y(void)
  LVector2i const *return_value = &(LVector2i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector2i_unit_y_250_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector2i_unit_y_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector2i::get_class_type(void)
 */
static PyObject *Dtool_LVector2i_get_class_type_257(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector2i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector2i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector2i_get_class_type_257_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector2i_get_class_type_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2i::LVector2i(void) = default
 * inline LVector2i::LVector2i(LVecBase2i const &copy)
 * inline LVector2i::LVector2i(LVector2i const &) = default
 * inline LVector2i::LVector2i(int fill_value)
 * inline LVector2i::LVector2i(int x, int y)
 */
static int Dtool_Init_LVector2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector2i::LVector2i(void) = default
      LVector2i *return_value = new LVector2i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector2i::LVector2i(LVector2i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2i", (char **)keyword_list, &param0)) {
          LVector2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector2i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector2i *return_value = new LVector2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2i::LVector2i(LVecBase2i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2i", (char **)keyword_list, &param0)) {
          LVecBase2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector2i *return_value = new LVector2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2i::LVector2i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LVector2i", (char **)keyword_list, &param0)) {
          LVector2i *return_value = new LVector2i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2i::LVector2i(LVector2i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2i", (char **)keyword_list, &param0)) {
          LVector2i param0_local;
          LVector2i const *param0_this = Dtool_Coerce_LVector2i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector2i *return_value = new LVector2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector2i::LVector2i(LVecBase2i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector2i", (char **)keyword_list, &param0)) {
          LVecBase2i param0_local;
          LVecBase2i const *param0_this = Dtool_Coerce_LVecBase2i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector2i *return_value = new LVector2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector2i::LVector2i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector2i::LVector2i(int x, int y)
      int param0;
      int param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:LVector2i", (char **)keyword_list, &param0, &param1)) {
        LVector2i *return_value = new LVector2i((int)param0, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector2i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector2i() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector2i()\n"
      "LVector2i(const LVector2i param0)\n"
      "LVector2i(const LVecBase2i copy)\n"
      "LVector2i(int fill_value)\n"
      "LVector2i(int x, int y)\n");
  }
  return -1;
}

LVector2i *Dtool_Coerce_LVector2i(PyObject *args, LVector2i &coerced) {
  LVector2i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector2i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector2i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector2i::LVector2i(LVecBase2i const &copy)
      LVecBase2i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector2i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector2i::LVector2i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LVector2i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LVector2i::LVector2i(int x, int y)
      int param0;
      int param1;
      if (PyArg_ParseTuple(args, "ii:LVector2i", &param0, &param1)) {
        coerced = LVector2i((int)param0, (int)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector2i) {
    printf("LVector2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector2i *local_this = (LVector2i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase2i) {
    return (LVecBase2i *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase2i) {
    LVecBase2i* other_this = (LVecBase2i*)from_this;
    return (LVector2i*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint2f
 */
/**
 * Python function wrapper for:
 * static inline LPoint2f const &LPoint2f::zero(void)
 */
static PyObject *Dtool_LPoint2f_zero_263(PyObject *, PyObject *) {
  // 1-static inline LPoint2f const &LPoint2f::zero(void)
  LPoint2f const *return_value = &(LPoint2f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2f_zero_263_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint2f_zero_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint2f const &LPoint2f::unit_x(void)
 */
static PyObject *Dtool_LPoint2f_unit_x_264(PyObject *, PyObject *) {
  // 1-static inline LPoint2f const &LPoint2f::unit_x(void)
  LPoint2f const *return_value = &(LPoint2f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2f_unit_x_264_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint2f_unit_x_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint2f const &LPoint2f::unit_y(void)
 */
static PyObject *Dtool_LPoint2f_unit_y_265(PyObject *, PyObject *) {
  // 1-static inline LPoint2f const &LPoint2f::unit_y(void)
  LPoint2f const *return_value = &(LPoint2f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2f_unit_y_265_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint2f_unit_y_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f LPoint2f::normalized(void) const
 */
static PyObject *Dtool_LPoint2f_normalized_271(PyObject *self, PyObject *) {
  LPoint2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f LPoint2f::normalized(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2f_normalized_271_comment =
  "C++ Interface:\n"
  "normalized(LPoint2f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LPoint2f_normalized_271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const
 */
static PyObject *Dtool_LPoint2f_project_272(PyObject *self, PyObject *arg) {
  LPoint2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint2f.project", "LVecBase2f");
  }
  LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPoint2f self, const LVecBase2f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint2f_project_272_comment =
  "C++ Interface:\n"
  "project(LPoint2f self, const LVecBase2f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LPoint2f_project_272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint2f::get_class_type(void)
 */
static PyObject *Dtool_LPoint2f_get_class_type_274(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint2f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint2f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2f_get_class_type_274_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint2f_get_class_type_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f::LPoint2f(void) = default
 * inline LPoint2f::LPoint2f(LPoint2f const &) = default
 * inline LPoint2f::LPoint2f(LVecBase2f const &copy)
 * inline LPoint2f::LPoint2f(float fill_value)
 * inline LPoint2f::LPoint2f(float x, float y)
 */
static int Dtool_Init_LPoint2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint2f::LPoint2f(void) = default
      LPoint2f *return_value = new LPoint2f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint2f::LPoint2f(LPoint2f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2f", (char **)keyword_list, &param0)) {
          LPoint2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint2f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint2f *return_value = new LPoint2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2f::LPoint2f(LVecBase2f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2f", (char **)keyword_list, &param0)) {
          LVecBase2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint2f *return_value = new LPoint2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2f::LPoint2f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LPoint2f", (char **)keyword_list, &param0)) {
          LPoint2f *return_value = new LPoint2f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2f::LPoint2f(LPoint2f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2f", (char **)keyword_list, &param0)) {
          LPoint2f param0_local;
          LPoint2f const *param0_this = Dtool_Coerce_LPoint2f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint2f *return_value = new LPoint2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2f::LPoint2f(LVecBase2f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2f", (char **)keyword_list, &param0)) {
          LVecBase2f param0_local;
          LVecBase2f const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint2f *return_value = new LPoint2f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint2f::LPoint2f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint2f::LPoint2f(float x, float y)
      float param0;
      float param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:LPoint2f", (char **)keyword_list, &param0, &param1)) {
        LPoint2f *return_value = new LPoint2f((float)param0, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint2f() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint2f()\n"
      "LPoint2f(const LPoint2f param0)\n"
      "LPoint2f(const LVecBase2f copy)\n"
      "LPoint2f(float fill_value)\n"
      "LPoint2f(float x, float y)\n");
  }
  return -1;
}

LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  LPoint2f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint2f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint2f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint2f::LPoint2f(LVecBase2f const &copy)
      LVecBase2f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint2f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint2f::LPoint2f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LPoint2f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LPoint2f::LPoint2f(float x, float y)
      float param0;
      float param1;
      if (PyArg_ParseTuple(args, "ff:LPoint2f", &param0, &param1)) {
        coerced = LPoint2f((float)param0, (float)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint2f) {
    printf("LPoint2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint2f *local_this = (LPoint2f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase2f) {
    return (LVecBase2f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase2f) {
    LVecBase2f* other_this = (LVecBase2f*)from_this;
    return (LPoint2f*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint2d
 */
/**
 * Python function wrapper for:
 * static inline LPoint2d const &LPoint2d::zero(void)
 */
static PyObject *Dtool_LPoint2d_zero_280(PyObject *, PyObject *) {
  // 1-static inline LPoint2d const &LPoint2d::zero(void)
  LPoint2d const *return_value = &(LPoint2d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2d_zero_280_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint2d_zero_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint2d const &LPoint2d::unit_x(void)
 */
static PyObject *Dtool_LPoint2d_unit_x_281(PyObject *, PyObject *) {
  // 1-static inline LPoint2d const &LPoint2d::unit_x(void)
  LPoint2d const *return_value = &(LPoint2d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2d_unit_x_281_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint2d_unit_x_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint2d const &LPoint2d::unit_y(void)
 */
static PyObject *Dtool_LPoint2d_unit_y_282(PyObject *, PyObject *) {
  // 1-static inline LPoint2d const &LPoint2d::unit_y(void)
  LPoint2d const *return_value = &(LPoint2d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2d_unit_y_282_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint2d_unit_y_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d LPoint2d::normalized(void) const
 */
static PyObject *Dtool_LPoint2d_normalized_288(PyObject *self, PyObject *) {
  LPoint2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d LPoint2d::normalized(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2d_normalized_288_comment =
  "C++ Interface:\n"
  "normalized(LPoint2d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LPoint2d_normalized_288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const
 */
static PyObject *Dtool_LPoint2d_project_289(PyObject *self, PyObject *arg) {
  LPoint2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint2d.project", "LVecBase2d");
  }
  LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPoint2d self, const LVecBase2d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint2d_project_289_comment =
  "C++ Interface:\n"
  "project(LPoint2d self, const LVecBase2d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LPoint2d_project_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint2d::get_class_type(void)
 */
static PyObject *Dtool_LPoint2d_get_class_type_291(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint2d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint2d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2d_get_class_type_291_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint2d_get_class_type_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d::LPoint2d(void) = default
 * inline LPoint2d::LPoint2d(LPoint2d const &) = default
 * inline LPoint2d::LPoint2d(LVecBase2d const &copy)
 * inline LPoint2d::LPoint2d(double fill_value)
 * inline LPoint2d::LPoint2d(double x, double y)
 */
static int Dtool_Init_LPoint2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint2d::LPoint2d(void) = default
      LPoint2d *return_value = new LPoint2d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint2d::LPoint2d(LPoint2d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2d", (char **)keyword_list, &param0)) {
          LPoint2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint2d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint2d *return_value = new LPoint2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2d::LPoint2d(LVecBase2d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2d", (char **)keyword_list, &param0)) {
          LVecBase2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint2d *return_value = new LPoint2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2d::LPoint2d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LPoint2d", (char **)keyword_list, &param0)) {
          LPoint2d *return_value = new LPoint2d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2d::LPoint2d(LPoint2d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2d", (char **)keyword_list, &param0)) {
          LPoint2d param0_local;
          LPoint2d const *param0_this = Dtool_Coerce_LPoint2d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint2d *return_value = new LPoint2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2d::LPoint2d(LVecBase2d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2d", (char **)keyword_list, &param0)) {
          LVecBase2d param0_local;
          LVecBase2d const *param0_this = Dtool_Coerce_LVecBase2d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint2d *return_value = new LPoint2d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint2d::LPoint2d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint2d::LPoint2d(double x, double y)
      double param0;
      double param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:LPoint2d", (char **)keyword_list, &param0, &param1)) {
        LPoint2d *return_value = new LPoint2d((double)param0, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint2d() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint2d()\n"
      "LPoint2d(const LPoint2d param0)\n"
      "LPoint2d(const LVecBase2d copy)\n"
      "LPoint2d(double fill_value)\n"
      "LPoint2d(double x, double y)\n");
  }
  return -1;
}

LPoint2d *Dtool_Coerce_LPoint2d(PyObject *args, LPoint2d &coerced) {
  LPoint2d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint2d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint2d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint2d::LPoint2d(LVecBase2d const &copy)
      LVecBase2d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint2d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint2d::LPoint2d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LPoint2d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LPoint2d::LPoint2d(double x, double y)
      double param0;
      double param1;
      if (PyArg_ParseTuple(args, "dd:LPoint2d", &param0, &param1)) {
        coerced = LPoint2d((double)param0, (double)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint2d) {
    printf("LPoint2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint2d *local_this = (LPoint2d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase2d) {
    return (LVecBase2d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase2d) {
    LVecBase2d* other_this = (LVecBase2d*)from_this;
    return (LPoint2d*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint2i
 */
/**
 * Python function wrapper for:
 * static inline LPoint2i const &LPoint2i::zero(void)
 */
static PyObject *Dtool_LPoint2i_zero_297(PyObject *, PyObject *) {
  // 1-static inline LPoint2i const &LPoint2i::zero(void)
  LPoint2i const *return_value = &(LPoint2i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2i_zero_297_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint2i_zero_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint2i const &LPoint2i::unit_x(void)
 */
static PyObject *Dtool_LPoint2i_unit_x_298(PyObject *, PyObject *) {
  // 1-static inline LPoint2i const &LPoint2i::unit_x(void)
  LPoint2i const *return_value = &(LPoint2i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2i_unit_x_298_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint2i_unit_x_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint2i const &LPoint2i::unit_y(void)
 */
static PyObject *Dtool_LPoint2i_unit_y_299(PyObject *, PyObject *) {
  // 1-static inline LPoint2i const &LPoint2i::unit_y(void)
  LPoint2i const *return_value = &(LPoint2i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2i_unit_y_299_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint2i_unit_y_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint2i::get_class_type(void)
 */
static PyObject *Dtool_LPoint2i_get_class_type_306(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint2i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint2i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint2i_get_class_type_306_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint2i_get_class_type_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2i::LPoint2i(void) = default
 * inline LPoint2i::LPoint2i(LPoint2i const &) = default
 * inline LPoint2i::LPoint2i(LVecBase2i const &copy)
 * inline LPoint2i::LPoint2i(int fill_value)
 * inline LPoint2i::LPoint2i(int x, int y)
 */
static int Dtool_Init_LPoint2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint2i::LPoint2i(void) = default
      LPoint2i *return_value = new LPoint2i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint2i::LPoint2i(LPoint2i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2i", (char **)keyword_list, &param0)) {
          LPoint2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint2i, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint2i *return_value = new LPoint2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2i::LPoint2i(LVecBase2i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2i", (char **)keyword_list, &param0)) {
          LVecBase2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint2i *return_value = new LPoint2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2i::LPoint2i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LPoint2i", (char **)keyword_list, &param0)) {
          LPoint2i *return_value = new LPoint2i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2i::LPoint2i(LPoint2i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2i", (char **)keyword_list, &param0)) {
          LPoint2i param0_local;
          LPoint2i const *param0_this = Dtool_Coerce_LPoint2i(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint2i *return_value = new LPoint2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint2i::LPoint2i(LVecBase2i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint2i", (char **)keyword_list, &param0)) {
          LVecBase2i param0_local;
          LVecBase2i const *param0_this = Dtool_Coerce_LVecBase2i(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint2i *return_value = new LPoint2i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint2i::LPoint2i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint2i::LPoint2i(int x, int y)
      int param0;
      int param1;
      static const char *keyword_list[] = {"x", "y", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:LPoint2i", (char **)keyword_list, &param0, &param1)) {
        LPoint2i *return_value = new LPoint2i((int)param0, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint2i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint2i() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint2i()\n"
      "LPoint2i(const LPoint2i param0)\n"
      "LPoint2i(const LVecBase2i copy)\n"
      "LPoint2i(int fill_value)\n"
      "LPoint2i(int x, int y)\n");
  }
  return -1;
}

LPoint2i *Dtool_Coerce_LPoint2i(PyObject *args, LPoint2i &coerced) {
  LPoint2i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint2i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint2i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint2i::LPoint2i(LVecBase2i const &copy)
      LVecBase2i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint2i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint2i::LPoint2i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LPoint2i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline LPoint2i::LPoint2i(int x, int y)
      int param0;
      int param1;
      if (PyArg_ParseTuple(args, "ii:LPoint2i", &param0, &param1)) {
        coerced = LPoint2i((int)param0, (int)param1);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint2i) {
    printf("LPoint2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint2i *local_this = (LPoint2i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase2i) {
    return (LVecBase2i *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase2i) {
    LVecBase2i* other_this = (LVecBase2i*)from_this;
    return (LPoint2i*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase3f
 */
/**
 * Python function wrapper for:
 * LVecBase3f &LVecBase3f::operator =(LVecBase3f const &copy) = default
 * LVecBase3f &LVecBase3f::operator =(float fill_value) = default
 */
static PyObject *Dtool_LVecBase3f_operator_314(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase3f &LVecBase3f::operator =(LVecBase3f const &copy) = default
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase3f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, false);
    }
  }

  {
    // -2 LVecBase3f &LVecBase3f::operator =(float fill_value) = default
    if (PyNumber_Check(arg)) {
      (*local_this).operator =((float)PyFloat_AsDouble(arg));
      LVecBase3f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, false);
    }
  }

  {
    // -2 LVecBase3f &LVecBase3f::operator =(LVecBase3f const &copy) = default
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase3f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, false);
    }
  }

  // No coercion possible: LVecBase3f &LVecBase3f::operator =(float fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase3f self, const LVecBase3f copy)\n"
      "assign(const LVecBase3f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_operator_314_comment =
  "C++ Interface:\n"
  "assign(const LVecBase3f self, const LVecBase3f copy)\n"
  "assign(const LVecBase3f self, float fill_value)\n";
#else
static const char *Dtool_LVecBase3f_operator_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3f const &LVecBase3f::zero(void)
 */
static PyObject *Dtool_LVecBase3f_zero_315(PyObject *, PyObject *) {
  // 1-static inline LVecBase3f const &LVecBase3f::zero(void)
  LVecBase3f const *return_value = &(LVecBase3f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_zero_315_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_zero_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3f const &LVecBase3f::unit_x(void)
 */
static PyObject *Dtool_LVecBase3f_unit_x_316(PyObject *, PyObject *) {
  // 1-static inline LVecBase3f const &LVecBase3f::unit_x(void)
  LVecBase3f const *return_value = &(LVecBase3f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_unit_x_316_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_unit_x_316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3f const &LVecBase3f::unit_y(void)
 */
static PyObject *Dtool_LVecBase3f_unit_y_317(PyObject *, PyObject *) {
  // 1-static inline LVecBase3f const &LVecBase3f::unit_y(void)
  LVecBase3f const *return_value = &(LVecBase3f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_unit_y_317_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_unit_y_317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3f const &LVecBase3f::unit_z(void)
 */
static PyObject *Dtool_LVecBase3f_unit_z_318(PyObject *, PyObject *) {
  // 1-static inline LVecBase3f const &LVecBase3f::unit_z(void)
  LVecBase3f const *return_value = &(LVecBase3f::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_unit_z_318_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_unit_z_318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase3f::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase3f_reduce_319(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase3f::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase3f*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_reduce_319_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase3f self)\n";
#else
static const char *Dtool_LVecBase3f_reduce_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3f::is_nan(void) const
 */
static PyObject *Dtool_LVecBase3f_is_nan_324(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase3f::is_nan(void) const
  bool return_value = (*(const LVecBase3f*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_is_nan_324_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_is_nan_324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase3f_get_cell_325(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    float return_value = (*(const LVecBase3f*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase3f self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_cell_325_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase3f self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_cell_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::get_x(void) const
 */
static PyObject *Dtool_LVecBase3f_get_x_326(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::get_x(void) const
  float return_value = (*(const LVecBase3f*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_x_326_comment =
  "C++ Interface:\n"
  "get_x(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_x_326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::get_y(void) const
 */
static PyObject *Dtool_LVecBase3f_get_y_327(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::get_y(void) const
  float return_value = (*(const LVecBase3f*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_y_327_comment =
  "C++ Interface:\n"
  "get_y(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_y_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::get_z(void) const
 */
static PyObject *Dtool_LVecBase3f_get_z_328(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::get_z(void) const
  float return_value = (*(const LVecBase3f*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_z_328_comment =
  "C++ Interface:\n"
  "get_z(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_z_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::set_cell(int i, float value)
 */
static PyObject *Dtool_LVecBase3f_set_cell_329(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::set_cell(int i, float value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase3f self, int i, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_set_cell_329_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase3f self, int i, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_set_cell_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::set_x(float value)
 */
static PyObject *Dtool_LVecBase3f_set_x_330(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::set_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase3f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_set_x_330_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase3f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_set_x_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::set_y(float value)
 */
static PyObject *Dtool_LVecBase3f_set_y_331(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::set_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase3f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_set_y_331_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase3f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_set_y_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::set_z(float value)
 */
static PyObject *Dtool_LVecBase3f_set_z_332(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.set_z")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::set_z(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase3f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_set_z_332_comment =
  "C++ Interface:\n"
  "set_z(const LVecBase3f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_set_z_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase3f::get_xy(void) const
 */
static PyObject *Dtool_LVecBase3f_get_xy_333(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase3f::get_xy(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase3f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_xy_333_comment =
  "C++ Interface:\n"
  "get_xy(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_xy_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase3f::get_xz(void) const
 */
static PyObject *Dtool_LVecBase3f_get_xz_334(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase3f::get_xz(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase3f*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_xz_334_comment =
  "C++ Interface:\n"
  "get_xz(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_xz_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase3f::get_yz(void) const
 */
static PyObject *Dtool_LVecBase3f_get_yz_335(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase3f::get_yz(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase3f*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_yz_335_comment =
  "C++ Interface:\n"
  "get_yz(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_yz_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::add_to_cell(int i, float value)
 */
static PyObject *Dtool_LVecBase3f_add_to_cell_342(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::add_to_cell(int i, float value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase3f self, int i, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_add_to_cell_342_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase3f self, int i, float value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_add_to_cell_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::add_x(float value)
 */
static PyObject *Dtool_LVecBase3f_add_x_343(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::add_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_x((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase3f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_add_x_343_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase3f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_add_x_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::add_y(float value)
 */
static PyObject *Dtool_LVecBase3f_add_y_344(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::add_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_y((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase3f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_add_y_344_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase3f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_add_y_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::add_z(float value)
 */
static PyObject *Dtool_LVecBase3f_add_z_345(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.add_z")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::add_z(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_z((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z(const LVecBase3f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_add_z_345_comment =
  "C++ Interface:\n"
  "add_z(const LVecBase3f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_add_z_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase3f::get_num_components(void)
 */
static PyObject *Dtool_LVecBase3f_get_num_components_347(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase3f::get_num_components(void)
  int return_value = LVecBase3f::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_num_components_347_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, three.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_num_components_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::fill(float fill_value)
 */
static PyObject *Dtool_LVecBase3f_fill_348(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::fill(float fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase3f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_fill_348_comment =
  "C++ Interface:\n"
  "fill(const LVecBase3f self, float fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_fill_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::set(float x, float y, float z)
 */
static PyObject *Dtool_LVecBase3f_set_349(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.set")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::set(float x, float y, float z)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"x", "y", "z", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set((float)param1, (float)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase3f self, float x, float y, float z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_set_349_comment =
  "C++ Interface:\n"
  "set(const LVecBase3f self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_set_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::dot(LVecBase3f const &other) const
 */
static PyObject *Dtool_LVecBase3f_dot_350(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::dot(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.dot", "LVecBase3f");
  }
  float return_value = (*(const LVecBase3f*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_dot_350_comment =
  "C++ Interface:\n"
  "dot(LVecBase3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_dot_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::length_squared(void) const
 */
static PyObject *Dtool_LVecBase3f_length_squared_351(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::length_squared(void) const
  float return_value = (*(const LVecBase3f*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_length_squared_351_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_length_squared_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase3f::length(void) const
 */
static PyObject *Dtool_LVecBase3f_length_352(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase3f::length(void) const
  float return_value = (*(const LVecBase3f*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_length_352_comment =
  "C++ Interface:\n"
  "length(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the vector, by the Pythagorean theorem.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_length_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3f::normalize(void)
 */
static PyObject *Dtool_LVecBase3f_normalize_353(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.normalize")) {
    return NULL;
  }
  // 1-inline bool LVecBase3f::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_normalize_353_comment =
  "C++ Interface:\n"
  "normalize(const LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector in place.  Returns true if the vector was normalized,\n"
  " * false if it was a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_normalize_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase3f::normalized(void) const
 */
static PyObject *Dtool_LVecBase3f_normalized_354(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase3f::normalized(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_normalized_354_comment =
  "C++ Interface:\n"
  "normalized(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_normalized_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const
 */
static PyObject *Dtool_LVecBase3f_project_355(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.project", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVecBase3f self, const LVecBase3f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_project_355_comment =
  "C++ Interface:\n"
  "project(LVecBase3f self, const LVecBase3f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_project_355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const
 */
static PyObject *Dtool_LVecBase3f_cross_356(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.cross", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LVecBase3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_cross_356_comment =
  "C++ Interface:\n"
  "cross(LVecBase3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_cross_356_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const
 */
static PyObject *Dtool_LVecBase3f_get_standardized_hpr_360(PyObject *self, PyObject *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).get_standardized_hpr());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_standardized_hpr_360_comment =
  "C++ Interface:\n"
  "get_standardized_hpr(LVecBase3f self)\n"
  "\n"
  "/**\n"
  " * Try to un-spin the hpr to a standard form.  Like all standards, someone\n"
  " * decides between many arbitrary possible standards.  This function assumes\n"
  " * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the\n"
  " * same.  Another example is -90 and 270. Each element will be in the range\n"
  " * -180.0 to 179.99999. The original usage of this function is for human\n"
  " * readable output.\n"
  " *\n"
  " * It doesn't work so well for asserting that foo_hpr is roughly equal to\n"
  " * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:\n"
  " * get_standardized_rotation, LQuaternion::is_same_direction\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_standardized_hpr_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3f::compare_to(LVecBase3f const &other) const
 * inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const
 */
static PyObject *Dtool_LVecBase3f_compare_to_361(PyObject *self, PyObject *args) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LVecBase3f::compare_to(LVecBase3f const &other) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.compare_to", "LVecBase3f");
      }
      int return_value = (*(const LVecBase3f*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const
      PyObject *param1;
      float param2;
      if (PyArg_ParseTuple(args, "Of:compare_to", &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase3f.compare_to", "LVecBase3f");
        }
        int return_value = (*(const LVecBase3f*)local_this).compare_to(*param1_this, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase3f self, const LVecBase3f other)\n"
      "compare_to(LVecBase3f self, const LVecBase3f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_compare_to_361_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase3f self, const LVecBase3f other)\n"
  "compare_to(LVecBase3f self, const LVecBase3f other, float threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts vectors lexicographically, componentwise.  Returns a number less than\n"
  " * 0 if this vector sorts before the other one, greater than zero if it sorts\n"
  " * after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LVecBase3f_compare_to_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase3f::get_hash(void) const
 * inline std::size_t LVecBase3f::get_hash(float threshold) const
 */
static PyObject *Dtool_LVecBase3f_get_hash_362(PyObject *self, PyObject *args) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LVecBase3f::get_hash(void) const
      std::size_t return_value = (*(const LVecBase3f*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LVecBase3f::get_hash(float threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LVecBase3f*)local_this).get_hash((float)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LVecBase3f self)\n"
      "get_hash(LVecBase3f self, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_hash_362_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase3f self)\n"
  "get_hash(LVecBase3f self, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_get_hash_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase3f::add_hash(std::size_t hash) const
 * inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const
 */
static PyObject *Dtool_LVecBase3f_add_hash_363(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LVecBase3f::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase3f*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const
      Py_ssize_t param1;
      float param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nf:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase3f*)local_this).add_hash((std::size_t)param1, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase3f self, int hash)\n"
      "add_hash(LVecBase3f self, int hash, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_add_hash_363_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase3f self, int hash)\n"
  "add_hash(LVecBase3f self, int hash, float threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_add_hash_363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::componentwise_mult(LVecBase3f const &other)
 */
static PyObject *Dtool_LVecBase3f_componentwise_mult_374(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::componentwise_mult(LVecBase3f const &other)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.componentwise_mult", "LVecBase3f");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_componentwise_mult_374_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_componentwise_mult_374_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const
 */
static PyObject *Dtool_LVecBase3f_fmax_377(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.fmax", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_fmax_377_comment =
  "C++ Interface:\n"
  "fmax(LVecBase3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_fmax_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const
 */
static PyObject *Dtool_LVecBase3f_fmin_378(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.fmin", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_fmin_378_comment =
  "C++ Interface:\n"
  "fmin(LVecBase3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_fmin_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::cross_into(LVecBase3f const &other)
 */
static PyObject *Dtool_LVecBase3f_cross_into_379(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.cross_into")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::cross_into(LVecBase3f const &other)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.cross_into", "LVecBase3f");
  }
  (*local_this).cross_into(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross_into(const LVecBase3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_cross_into_379_comment =
  "C++ Interface:\n"
  "cross_into(const LVecBase3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_cross_into_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const
 * inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const
 */
static PyObject *Dtool_LVecBase3f_almost_equal_380(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.almost_equal", "LVecBase3f");
      }
      bool return_value = (*(const LVecBase3f*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase3f.almost_equal", "LVecBase3f");
        }
        bool return_value = (*(const LVecBase3f*)local_this).almost_equal(*param1_this, (float)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase3f self, const LVecBase3f other)\n"
      "almost_equal(LVecBase3f self, const LVecBase3f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_almost_equal_380_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase3f self, const LVecBase3f other)\n"
  "almost_equal(LVecBase3f self, const LVecBase3f other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_almost_equal_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase3f_output_381(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3f::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase3f.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase3f*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase3f self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_output_381_comment =
  "C++ Interface:\n"
  "output(LVecBase3f self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3f_output_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase3f_write_datagram_fixed_383(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase3f*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase3f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_write_datagram_fixed_383_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase3f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_write_datagram_fixed_383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase3f_read_datagram_fixed_384(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase3f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_read_datagram_fixed_384_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase3f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase3f_read_datagram_fixed_384_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase3f_write_datagram_385(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3f::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.write_datagram", "Datagram");
  }
  (*(const LVecBase3f*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase3f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_write_datagram_385_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase3f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase3f_write_datagram_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3f::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase3f_read_datagram_386(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase3f::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase3f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_read_datagram_386_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase3f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase3f_read_datagram_386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase3f::get_class_type(void)
 */
static PyObject *Dtool_LVecBase3f_get_class_type_387(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase3f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase3f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3f_get_class_type_387_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase3f_get_class_type_387_comment = NULL;
#endif

static PyObject *Dtool_LVecBase3f_x_Getter(PyObject *self, void *) {
  const LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase3f::get_x(void) const
  float return_value = (*(const LVecBase3f*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3f_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase3f::set_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase3f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3f_y_Getter(PyObject *self, void *) {
  const LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase3f::get_y(void) const
  float return_value = (*(const LVecBase3f*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3f_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase3f::set_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase3f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3f_z_Getter(PyObject *self, void *) {
  const LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase3f::get_z(void) const
  float return_value = (*(const LVecBase3f*)local_this).get_z();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3f_z_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3f, (void **)&local_this, "LVecBase3f.z")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete z attribute");
    return -1;
  }
  // 1-inline void LVecBase3f::set_z(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase3f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3f_xy_Getter(PyObject *self, void *) {
  const LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2f LVecBase3f::get_xy(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase3f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

static PyObject *Dtool_LVecBase3f_xz_Getter(PyObject *self, void *) {
  const LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2f LVecBase3f::get_xz(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase3f*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

static PyObject *Dtool_LVecBase3f_yz_Getter(PyObject *self, void *) {
  const LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2f LVecBase3f::get_yz(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase3f*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

/**
 * Python function wrapper for:
 * inline LVecBase3f::LVecBase3f(void) = default
 * inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z)
 * inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default
 * inline LVecBase3f::LVecBase3f(float fill_value)
 * inline LVecBase3f::LVecBase3f(float x, float y, float z)
 */
static int Dtool_Init_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase3f::LVecBase3f(void) = default
      LVecBase3f *return_value = new LVecBase3f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase3f", (char **)keyword_list, &param0)) {
          LVecBase3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase3f *return_value = new LVecBase3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase3f::LVecBase3f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LVecBase3f", (char **)keyword_list, &param0)) {
          LVecBase3f *return_value = new LVecBase3f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase3f", (char **)keyword_list, &param0)) {
          LVecBase3f param0_local;
          LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase3f *return_value = new LVecBase3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase3f::LVecBase3f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LVecBase3f", (char **)keyword_list, &param0, &param1)) {
        LVecBase2f param0_local;
        LVecBase2f const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVecBase3f.LVecBase3f", "LVecBase2f");
          return -1;
        }
        LVecBase3f *return_value = new LVecBase3f(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3f::LVecBase3f(float x, float y, float z)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:LVecBase3f", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f *return_value = new LVecBase3f((float)param0, (float)param1, (float)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase3f() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase3f()\n"
      "LVecBase3f(const LVecBase3f param0)\n"
      "LVecBase3f(float fill_value)\n"
      "LVecBase3f(const LVecBase2f copy, float z)\n"
      "LVecBase3f(float x, float y, float z)\n");
  }
  return -1;
}

LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  LVecBase3f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase3f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LVecBase3f::LVecBase3f(float fill_value)
    if (PyNumber_Check(arg)) {
      coerced = LVecBase3f((float)PyFloat_AsDouble(arg));
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LVecBase3f", &param0, &param1)) {
          LVecBase2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVecBase3f(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LVecBase3f::LVecBase3f(float x, float y, float z)
        float param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "fff:LVecBase3f", &param0, &param1, &param2)) {
          coerced = LVecBase3f((float)param0, (float)param1, (float)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase3f) {
    printf("LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase3f *local_this = (LVecBase3f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase3f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase3f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase3d
 */
/**
 * Python function wrapper for:
 * LVecBase3d &LVecBase3d::operator =(LVecBase3d const &copy) = default
 * LVecBase3d &LVecBase3d::operator =(double fill_value) = default
 */
static PyObject *Dtool_LVecBase3d_operator_395(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase3d &LVecBase3d::operator =(LVecBase3d const &copy) = default
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase3d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, false);
    }
  }

  {
    // -2 LVecBase3d &LVecBase3d::operator =(double fill_value) = default
    if (PyNumber_Check(arg)) {
      (*local_this).operator =(PyFloat_AsDouble(arg));
      LVecBase3d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, false);
    }
  }

  {
    // -2 LVecBase3d &LVecBase3d::operator =(LVecBase3d const &copy) = default
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase3d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, false);
    }
  }

  // No coercion possible: LVecBase3d &LVecBase3d::operator =(double fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase3d self, const LVecBase3d copy)\n"
      "assign(const LVecBase3d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_operator_395_comment =
  "C++ Interface:\n"
  "assign(const LVecBase3d self, const LVecBase3d copy)\n"
  "assign(const LVecBase3d self, double fill_value)\n";
#else
static const char *Dtool_LVecBase3d_operator_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3d const &LVecBase3d::zero(void)
 */
static PyObject *Dtool_LVecBase3d_zero_396(PyObject *, PyObject *) {
  // 1-static inline LVecBase3d const &LVecBase3d::zero(void)
  LVecBase3d const *return_value = &(LVecBase3d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_zero_396_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_zero_396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3d const &LVecBase3d::unit_x(void)
 */
static PyObject *Dtool_LVecBase3d_unit_x_397(PyObject *, PyObject *) {
  // 1-static inline LVecBase3d const &LVecBase3d::unit_x(void)
  LVecBase3d const *return_value = &(LVecBase3d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_unit_x_397_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_unit_x_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3d const &LVecBase3d::unit_y(void)
 */
static PyObject *Dtool_LVecBase3d_unit_y_398(PyObject *, PyObject *) {
  // 1-static inline LVecBase3d const &LVecBase3d::unit_y(void)
  LVecBase3d const *return_value = &(LVecBase3d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_unit_y_398_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_unit_y_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3d const &LVecBase3d::unit_z(void)
 */
static PyObject *Dtool_LVecBase3d_unit_z_399(PyObject *, PyObject *) {
  // 1-static inline LVecBase3d const &LVecBase3d::unit_z(void)
  LVecBase3d const *return_value = &(LVecBase3d::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_unit_z_399_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_unit_z_399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase3d::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase3d_reduce_400(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase3d::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase3d*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_reduce_400_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase3d self)\n";
#else
static const char *Dtool_LVecBase3d_reduce_400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3d::is_nan(void) const
 */
static PyObject *Dtool_LVecBase3d_is_nan_405(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase3d::is_nan(void) const
  bool return_value = (*(const LVecBase3d*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_is_nan_405_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_is_nan_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase3d_get_cell_406(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const LVecBase3d*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase3d self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_cell_406_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase3d self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_cell_406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::get_x(void) const
 */
static PyObject *Dtool_LVecBase3d_get_x_407(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::get_x(void) const
  double return_value = (*(const LVecBase3d*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_x_407_comment =
  "C++ Interface:\n"
  "get_x(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_x_407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::get_y(void) const
 */
static PyObject *Dtool_LVecBase3d_get_y_408(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::get_y(void) const
  double return_value = (*(const LVecBase3d*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_y_408_comment =
  "C++ Interface:\n"
  "get_y(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_y_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::get_z(void) const
 */
static PyObject *Dtool_LVecBase3d_get_z_409(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::get_z(void) const
  double return_value = (*(const LVecBase3d*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_z_409_comment =
  "C++ Interface:\n"
  "get_z(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_z_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::set_cell(int i, double value)
 */
static PyObject *Dtool_LVecBase3d_set_cell_410(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::set_cell(int i, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase3d self, int i, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_set_cell_410_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase3d self, int i, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_set_cell_410_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::set_x(double value)
 */
static PyObject *Dtool_LVecBase3d_set_x_411(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::set_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase3d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_set_x_411_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase3d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_set_x_411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::set_y(double value)
 */
static PyObject *Dtool_LVecBase3d_set_y_412(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::set_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase3d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_set_y_412_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase3d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_set_y_412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::set_z(double value)
 */
static PyObject *Dtool_LVecBase3d_set_z_413(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.set_z")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::set_z(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase3d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_set_z_413_comment =
  "C++ Interface:\n"
  "set_z(const LVecBase3d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_set_z_413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase3d::get_xy(void) const
 */
static PyObject *Dtool_LVecBase3d_get_xy_414(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase3d::get_xy(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase3d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_xy_414_comment =
  "C++ Interface:\n"
  "get_xy(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_xy_414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase3d::get_xz(void) const
 */
static PyObject *Dtool_LVecBase3d_get_xz_415(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase3d::get_xz(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase3d*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_xz_415_comment =
  "C++ Interface:\n"
  "get_xz(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_xz_415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase3d::get_yz(void) const
 */
static PyObject *Dtool_LVecBase3d_get_yz_416(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase3d::get_yz(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase3d*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_yz_416_comment =
  "C++ Interface:\n"
  "get_yz(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_yz_416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::add_to_cell(int i, double value)
 */
static PyObject *Dtool_LVecBase3d_add_to_cell_423(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::add_to_cell(int i, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase3d self, int i, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_add_to_cell_423_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase3d self, int i, double value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_add_to_cell_423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::add_x(double value)
 */
static PyObject *Dtool_LVecBase3d_add_x_424(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::add_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_x(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase3d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_add_x_424_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase3d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_add_x_424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::add_y(double value)
 */
static PyObject *Dtool_LVecBase3d_add_y_425(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::add_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_y(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase3d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_add_y_425_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase3d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_add_y_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::add_z(double value)
 */
static PyObject *Dtool_LVecBase3d_add_z_426(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.add_z")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::add_z(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_z(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z(const LVecBase3d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_add_z_426_comment =
  "C++ Interface:\n"
  "add_z(const LVecBase3d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_add_z_426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase3d::get_num_components(void)
 */
static PyObject *Dtool_LVecBase3d_get_num_components_428(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase3d::get_num_components(void)
  int return_value = LVecBase3d::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_num_components_428_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, three.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_num_components_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::fill(double fill_value)
 */
static PyObject *Dtool_LVecBase3d_fill_429(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::fill(double fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase3d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_fill_429_comment =
  "C++ Interface:\n"
  "fill(const LVecBase3d self, double fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_fill_429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::set(double x, double y, double z)
 */
static PyObject *Dtool_LVecBase3d_set_430(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.set")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::set(double x, double y, double z)
  double param1;
  double param2;
  double param3;
  static const char *keyword_list[] = {"x", "y", "z", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:set", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase3d self, double x, double y, double z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_set_430_comment =
  "C++ Interface:\n"
  "set(const LVecBase3d self, double x, double y, double z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_set_430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::dot(LVecBase3d const &other) const
 */
static PyObject *Dtool_LVecBase3d_dot_431(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::dot(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.dot", "LVecBase3d");
  }
  double return_value = (*(const LVecBase3d*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_dot_431_comment =
  "C++ Interface:\n"
  "dot(LVecBase3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_dot_431_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::length_squared(void) const
 */
static PyObject *Dtool_LVecBase3d_length_squared_432(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::length_squared(void) const
  double return_value = (*(const LVecBase3d*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_length_squared_432_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_length_squared_432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase3d::length(void) const
 */
static PyObject *Dtool_LVecBase3d_length_433(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase3d::length(void) const
  double return_value = (*(const LVecBase3d*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_length_433_comment =
  "C++ Interface:\n"
  "length(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the vector, by the Pythagorean theorem.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_length_433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3d::normalize(void)
 */
static PyObject *Dtool_LVecBase3d_normalize_434(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.normalize")) {
    return NULL;
  }
  // 1-inline bool LVecBase3d::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_normalize_434_comment =
  "C++ Interface:\n"
  "normalize(const LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector in place.  Returns true if the vector was normalized,\n"
  " * false if it was a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_normalize_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase3d::normalized(void) const
 */
static PyObject *Dtool_LVecBase3d_normalized_435(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase3d::normalized(void) const
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_normalized_435_comment =
  "C++ Interface:\n"
  "normalized(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_normalized_435_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const
 */
static PyObject *Dtool_LVecBase3d_project_436(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.project", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVecBase3d self, const LVecBase3d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_project_436_comment =
  "C++ Interface:\n"
  "project(LVecBase3d self, const LVecBase3d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_project_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const
 */
static PyObject *Dtool_LVecBase3d_cross_437(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.cross", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LVecBase3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_cross_437_comment =
  "C++ Interface:\n"
  "cross(LVecBase3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_cross_437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const
 */
static PyObject *Dtool_LVecBase3d_get_standardized_hpr_441(PyObject *self, PyObject *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).get_standardized_hpr());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_standardized_hpr_441_comment =
  "C++ Interface:\n"
  "get_standardized_hpr(LVecBase3d self)\n"
  "\n"
  "/**\n"
  " * Try to un-spin the hpr to a standard form.  Like all standards, someone\n"
  " * decides between many arbitrary possible standards.  This function assumes\n"
  " * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the\n"
  " * same.  Another example is -90 and 270. Each element will be in the range\n"
  " * -180.0 to 179.99999. The original usage of this function is for human\n"
  " * readable output.\n"
  " *\n"
  " * It doesn't work so well for asserting that foo_hpr is roughly equal to\n"
  " * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:\n"
  " * get_standardized_rotation, LQuaternion::is_same_direction\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_standardized_hpr_441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3d::compare_to(LVecBase3d const &other) const
 * inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const
 */
static PyObject *Dtool_LVecBase3d_compare_to_442(PyObject *self, PyObject *args) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LVecBase3d::compare_to(LVecBase3d const &other) const
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.compare_to", "LVecBase3d");
      }
      int return_value = (*(const LVecBase3d*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "Od:compare_to", &param1, &param2)) {
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase3d.compare_to", "LVecBase3d");
        }
        int return_value = (*(const LVecBase3d*)local_this).compare_to(*param1_this, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase3d self, const LVecBase3d other)\n"
      "compare_to(LVecBase3d self, const LVecBase3d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_compare_to_442_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase3d self, const LVecBase3d other)\n"
  "compare_to(LVecBase3d self, const LVecBase3d other, double threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts vectors lexicographically, componentwise.  Returns a number less than\n"
  " * 0 if this vector sorts before the other one, greater than zero if it sorts\n"
  " * after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LVecBase3d_compare_to_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase3d::get_hash(void) const
 * inline std::size_t LVecBase3d::get_hash(double threshold) const
 */
static PyObject *Dtool_LVecBase3d_get_hash_443(PyObject *self, PyObject *args) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LVecBase3d::get_hash(void) const
      std::size_t return_value = (*(const LVecBase3d*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LVecBase3d::get_hash(double threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LVecBase3d*)local_this).get_hash(PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LVecBase3d self)\n"
      "get_hash(LVecBase3d self, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_hash_443_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase3d self)\n"
  "get_hash(LVecBase3d self, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_get_hash_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase3d::add_hash(std::size_t hash) const
 * inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const
 */
static PyObject *Dtool_LVecBase3d_add_hash_444(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LVecBase3d::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase3d*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const
      Py_ssize_t param1;
      double param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase3d*)local_this).add_hash((std::size_t)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase3d self, int hash)\n"
      "add_hash(LVecBase3d self, int hash, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_add_hash_444_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase3d self, int hash)\n"
  "add_hash(LVecBase3d self, int hash, double threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_add_hash_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::componentwise_mult(LVecBase3d const &other)
 */
static PyObject *Dtool_LVecBase3d_componentwise_mult_455(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::componentwise_mult(LVecBase3d const &other)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.componentwise_mult", "LVecBase3d");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_componentwise_mult_455_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_componentwise_mult_455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const
 */
static PyObject *Dtool_LVecBase3d_fmax_458(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.fmax", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_fmax_458_comment =
  "C++ Interface:\n"
  "fmax(LVecBase3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_fmax_458_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const
 */
static PyObject *Dtool_LVecBase3d_fmin_459(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.fmin", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_fmin_459_comment =
  "C++ Interface:\n"
  "fmin(LVecBase3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_fmin_459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::cross_into(LVecBase3d const &other)
 */
static PyObject *Dtool_LVecBase3d_cross_into_460(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.cross_into")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::cross_into(LVecBase3d const &other)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.cross_into", "LVecBase3d");
  }
  (*local_this).cross_into(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross_into(const LVecBase3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_cross_into_460_comment =
  "C++ Interface:\n"
  "cross_into(const LVecBase3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_cross_into_460_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const
 * inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const
 */
static PyObject *Dtool_LVecBase3d_almost_equal_461(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.almost_equal", "LVecBase3d");
      }
      bool return_value = (*(const LVecBase3d*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase3d.almost_equal", "LVecBase3d");
        }
        bool return_value = (*(const LVecBase3d*)local_this).almost_equal(*param1_this, (double)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase3d self, const LVecBase3d other)\n"
      "almost_equal(LVecBase3d self, const LVecBase3d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_almost_equal_461_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase3d self, const LVecBase3d other)\n"
  "almost_equal(LVecBase3d self, const LVecBase3d other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_almost_equal_461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase3d_output_462(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3d::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase3d.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase3d*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase3d self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_output_462_comment =
  "C++ Interface:\n"
  "output(LVecBase3d self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3d_output_462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase3d_write_datagram_fixed_464(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase3d*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase3d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_write_datagram_fixed_464_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase3d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_write_datagram_fixed_464_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase3d_read_datagram_fixed_465(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase3d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_read_datagram_fixed_465_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase3d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase3d_read_datagram_fixed_465_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase3d_write_datagram_466(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3d::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.write_datagram", "Datagram");
  }
  (*(const LVecBase3d*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase3d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_write_datagram_466_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase3d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase3d_write_datagram_466_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3d::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase3d_read_datagram_467(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase3d::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase3d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_read_datagram_467_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase3d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase3d_read_datagram_467_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase3d::get_class_type(void)
 */
static PyObject *Dtool_LVecBase3d_get_class_type_468(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase3d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase3d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3d_get_class_type_468_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase3d_get_class_type_468_comment = NULL;
#endif

static PyObject *Dtool_LVecBase3d_x_Getter(PyObject *self, void *) {
  const LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase3d::get_x(void) const
  double return_value = (*(const LVecBase3d*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3d_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase3d::set_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase3d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3d_y_Getter(PyObject *self, void *) {
  const LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase3d::get_y(void) const
  double return_value = (*(const LVecBase3d*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3d_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase3d::set_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase3d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3d_z_Getter(PyObject *self, void *) {
  const LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase3d::get_z(void) const
  double return_value = (*(const LVecBase3d*)local_this).get_z();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3d_z_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3d, (void **)&local_this, "LVecBase3d.z")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete z attribute");
    return -1;
  }
  // 1-inline void LVecBase3d::set_z(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase3d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3d_xy_Getter(PyObject *self, void *) {
  const LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2d LVecBase3d::get_xy(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase3d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

static PyObject *Dtool_LVecBase3d_xz_Getter(PyObject *self, void *) {
  const LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2d LVecBase3d::get_xz(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase3d*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

static PyObject *Dtool_LVecBase3d_yz_Getter(PyObject *self, void *) {
  const LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2d LVecBase3d::get_yz(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase3d*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

/**
 * Python function wrapper for:
 * inline LVecBase3d::LVecBase3d(void) = default
 * inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z)
 * inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default
 * inline LVecBase3d::LVecBase3d(double fill_value)
 * inline LVecBase3d::LVecBase3d(double x, double y, double z)
 */
static int Dtool_Init_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase3d::LVecBase3d(void) = default
      LVecBase3d *return_value = new LVecBase3d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase3d", (char **)keyword_list, &param0)) {
          LVecBase3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase3d *return_value = new LVecBase3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase3d::LVecBase3d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LVecBase3d", (char **)keyword_list, &param0)) {
          LVecBase3d *return_value = new LVecBase3d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase3d", (char **)keyword_list, &param0)) {
          LVecBase3d param0_local;
          LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase3d *return_value = new LVecBase3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase3d::LVecBase3d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LVecBase3d", (char **)keyword_list, &param0, &param1)) {
        LVecBase2d param0_local;
        LVecBase2d const *param0_this = Dtool_Coerce_LVecBase2d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVecBase3d.LVecBase3d", "LVecBase2d");
          return -1;
        }
        LVecBase3d *return_value = new LVecBase3d(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3d, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3d::LVecBase3d(double x, double y, double z)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:LVecBase3d", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3d *return_value = new LVecBase3d((double)param0, (double)param1, (double)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase3d() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase3d()\n"
      "LVecBase3d(const LVecBase3d param0)\n"
      "LVecBase3d(double fill_value)\n"
      "LVecBase3d(const LVecBase2d copy, double z)\n"
      "LVecBase3d(double x, double y, double z)\n");
  }
  return -1;
}

LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  LVecBase3d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase3d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LVecBase3d::LVecBase3d(double fill_value)
    if (PyNumber_Check(arg)) {
      coerced = LVecBase3d(PyFloat_AsDouble(arg));
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LVecBase3d", &param0, &param1)) {
          LVecBase2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVecBase3d(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LVecBase3d::LVecBase3d(double x, double y, double z)
        double param0;
        double param1;
        double param2;
        if (PyArg_ParseTuple(args, "ddd:LVecBase3d", &param0, &param1, &param2)) {
          coerced = LVecBase3d((double)param0, (double)param1, (double)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase3d) {
    printf("LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase3d *local_this = (LVecBase3d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase3d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase3d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase3i
 */
/**
 * Python function wrapper for:
 * LVecBase3i &LVecBase3i::operator =(LVecBase3i const &copy) = default
 * LVecBase3i &LVecBase3i::operator =(int fill_value) = default
 */
static PyObject *Dtool_LVecBase3i_operator_476(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase3i &LVecBase3i::operator =(LVecBase3i const &copy) = default
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase3i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, false);
    }
  }

  {
    // -2 LVecBase3i &LVecBase3i::operator =(int fill_value) = default
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      (*local_this).operator =((int)arg_val);
      LVecBase3i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, false);
    }
  }

  {
    // -2 LVecBase3i &LVecBase3i::operator =(LVecBase3i const &copy) = default
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase3i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, false);
    }
  }

  // No coercion possible: LVecBase3i &LVecBase3i::operator =(int fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase3i self, const LVecBase3i copy)\n"
      "assign(const LVecBase3i self, int fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_operator_476_comment =
  "C++ Interface:\n"
  "assign(const LVecBase3i self, const LVecBase3i copy)\n"
  "assign(const LVecBase3i self, int fill_value)\n";
#else
static const char *Dtool_LVecBase3i_operator_476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3i const &LVecBase3i::zero(void)
 */
static PyObject *Dtool_LVecBase3i_zero_477(PyObject *, PyObject *) {
  // 1-static inline LVecBase3i const &LVecBase3i::zero(void)
  LVecBase3i const *return_value = &(LVecBase3i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_zero_477_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_zero_477_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3i const &LVecBase3i::unit_x(void)
 */
static PyObject *Dtool_LVecBase3i_unit_x_478(PyObject *, PyObject *) {
  // 1-static inline LVecBase3i const &LVecBase3i::unit_x(void)
  LVecBase3i const *return_value = &(LVecBase3i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_unit_x_478_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_unit_x_478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3i const &LVecBase3i::unit_y(void)
 */
static PyObject *Dtool_LVecBase3i_unit_y_479(PyObject *, PyObject *) {
  // 1-static inline LVecBase3i const &LVecBase3i::unit_y(void)
  LVecBase3i const *return_value = &(LVecBase3i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_unit_y_479_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_unit_y_479_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase3i const &LVecBase3i::unit_z(void)
 */
static PyObject *Dtool_LVecBase3i_unit_z_480(PyObject *, PyObject *) {
  // 1-static inline LVecBase3i const &LVecBase3i::unit_z(void)
  LVecBase3i const *return_value = &(LVecBase3i::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_unit_z_480_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_unit_z_480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase3i::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase3i_reduce_481(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase3i::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase3i*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_reduce_481_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase3i self)\n";
#else
static const char *Dtool_LVecBase3i_reduce_481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3i::is_nan(void) const
 */
static PyObject *Dtool_LVecBase3i_is_nan_486(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase3i::is_nan(void) const
  bool return_value = (*(const LVecBase3i*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_is_nan_486_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_is_nan_486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase3i_get_cell_487(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const LVecBase3i*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase3i self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_cell_487_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase3i self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_cell_487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::get_x(void) const
 */
static PyObject *Dtool_LVecBase3i_get_x_488(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::get_x(void) const
  int return_value = (*(const LVecBase3i*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_x_488_comment =
  "C++ Interface:\n"
  "get_x(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_x_488_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::get_y(void) const
 */
static PyObject *Dtool_LVecBase3i_get_y_489(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::get_y(void) const
  int return_value = (*(const LVecBase3i*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_y_489_comment =
  "C++ Interface:\n"
  "get_y(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_y_489_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::get_z(void) const
 */
static PyObject *Dtool_LVecBase3i_get_z_490(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::get_z(void) const
  int return_value = (*(const LVecBase3i*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_z_490_comment =
  "C++ Interface:\n"
  "get_z(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_z_490_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::set_cell(int i, int value)
 */
static PyObject *Dtool_LVecBase3i_set_cell_491(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::set_cell(int i, int value)
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase3i self, int i, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_set_cell_491_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase3i self, int i, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_set_cell_491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::set_x(int value)
 */
static PyObject *Dtool_LVecBase3i_set_x_492(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::set_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_x((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase3i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_set_x_492_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase3i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_set_x_492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::set_y(int value)
 */
static PyObject *Dtool_LVecBase3i_set_y_493(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::set_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_y((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase3i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_set_y_493_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase3i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_set_y_493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::set_z(int value)
 */
static PyObject *Dtool_LVecBase3i_set_z_494(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.set_z")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::set_z(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_z((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase3i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_set_z_494_comment =
  "C++ Interface:\n"
  "set_z(const LVecBase3i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_set_z_494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LVecBase3i::get_xy(void) const
 */
static PyObject *Dtool_LVecBase3i_get_xy_495(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LVecBase3i::get_xy(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase3i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_xy_495_comment =
  "C++ Interface:\n"
  "get_xy(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_xy_495_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LVecBase3i::get_xz(void) const
 */
static PyObject *Dtool_LVecBase3i_get_xz_496(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LVecBase3i::get_xz(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase3i*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_xz_496_comment =
  "C++ Interface:\n"
  "get_xz(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_xz_496_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LVecBase3i::get_yz(void) const
 */
static PyObject *Dtool_LVecBase3i_get_yz_497(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LVecBase3i::get_yz(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase3i*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_yz_497_comment =
  "C++ Interface:\n"
  "get_yz(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_yz_497_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::add_to_cell(int i, int value)
 */
static PyObject *Dtool_LVecBase3i_add_to_cell_504(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::add_to_cell(int i, int value)
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase3i self, int i, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_add_to_cell_504_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase3i self, int i, int value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_add_to_cell_504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::add_x(int value)
 */
static PyObject *Dtool_LVecBase3i_add_x_505(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::add_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_x((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase3i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_add_x_505_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase3i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_add_x_505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::add_y(int value)
 */
static PyObject *Dtool_LVecBase3i_add_y_506(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::add_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_y((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase3i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_add_y_506_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase3i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_add_y_506_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::add_z(int value)
 */
static PyObject *Dtool_LVecBase3i_add_z_507(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.add_z")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::add_z(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_z((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z(const LVecBase3i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_add_z_507_comment =
  "C++ Interface:\n"
  "add_z(const LVecBase3i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_add_z_507_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase3i::get_num_components(void)
 */
static PyObject *Dtool_LVecBase3i_get_num_components_509(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase3i::get_num_components(void)
  int return_value = LVecBase3i::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_num_components_509_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, three.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_num_components_509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::fill(int fill_value)
 */
static PyObject *Dtool_LVecBase3i_fill_510(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::fill(int fill_value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).fill((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase3i self, int fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_fill_510_comment =
  "C++ Interface:\n"
  "fill(const LVecBase3i self, int fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_fill_510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::set(int x, int y, int z)
 */
static PyObject *Dtool_LVecBase3i_set_511(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.set")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::set(int x, int y, int z)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"x", "y", "z", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase3i self, int x, int y, int z)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_set_511_comment =
  "C++ Interface:\n"
  "set(const LVecBase3i self, int x, int y, int z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_set_511_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::dot(LVecBase3i const &other) const
 */
static PyObject *Dtool_LVecBase3i_dot_512(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::dot(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.dot", "LVecBase3i");
  }
  int return_value = (*(const LVecBase3i*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_dot_512_comment =
  "C++ Interface:\n"
  "dot(LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_dot_512_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::length_squared(void) const
 */
static PyObject *Dtool_LVecBase3i_length_squared_513(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::length_squared(void) const
  int return_value = (*(const LVecBase3i*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_length_squared_513_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_length_squared_513_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const
 */
static PyObject *Dtool_LVecBase3i_cross_514(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.cross", "LVecBase3i");
  }
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_cross_514_comment =
  "C++ Interface:\n"
  "cross(LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_cross_514_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase3i::compare_to(LVecBase3i const &other) const
 */
static PyObject *Dtool_LVecBase3i_compare_to_518(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase3i::compare_to(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.compare_to", "LVecBase3i");
  }
  int return_value = (*(const LVecBase3i*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_compare_to_518_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_compare_to_518_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase3i::get_hash(void) const
 */
static PyObject *Dtool_LVecBase3i_get_hash_519(PyObject *self, PyObject *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t LVecBase3i::get_hash(void) const
  std::size_t return_value = (*(const LVecBase3i*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_hash_519_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase3i self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_get_hash_519_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase3i::add_hash(std::size_t hash) const
 */
static PyObject *Dtool_LVecBase3i_add_hash_520(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t LVecBase3i::add_hash(std::size_t hash) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::size_t return_value = (*(const LVecBase3i*)local_this).add_hash((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase3i self, int hash)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_add_hash_520_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase3i self, int hash)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_add_hash_520_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::componentwise_mult(LVecBase3i const &other)
 */
static PyObject *Dtool_LVecBase3i_componentwise_mult_531(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::componentwise_mult(LVecBase3i const &other)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.componentwise_mult", "LVecBase3i");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_componentwise_mult_531_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_componentwise_mult_531_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const
 */
static PyObject *Dtool_LVecBase3i_fmax_534(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.fmax", "LVecBase3i");
  }
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_fmax_534_comment =
  "C++ Interface:\n"
  "fmax(LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_fmax_534_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const
 */
static PyObject *Dtool_LVecBase3i_fmin_535(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.fmin", "LVecBase3i");
  }
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_fmin_535_comment =
  "C++ Interface:\n"
  "fmin(LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_fmin_535_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::cross_into(LVecBase3i const &other)
 */
static PyObject *Dtool_LVecBase3i_cross_into_536(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.cross_into")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::cross_into(LVecBase3i const &other)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.cross_into", "LVecBase3i");
  }
  (*local_this).cross_into(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross_into(const LVecBase3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_cross_into_536_comment =
  "C++ Interface:\n"
  "cross_into(const LVecBase3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_cross_into_536_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const
 * inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const
 */
static PyObject *Dtool_LVecBase3i_almost_equal_537(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.almost_equal", "LVecBase3i");
      }
      bool return_value = (*(const LVecBase3i*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase3i param1_local;
        LVecBase3i const *param1_this = Dtool_Coerce_LVecBase3i(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase3i.almost_equal", "LVecBase3i");
        }
        bool return_value = (*(const LVecBase3i*)local_this).almost_equal(*param1_this, (int)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase3i self, const LVecBase3i other)\n"
      "almost_equal(LVecBase3i self, const LVecBase3i other, int threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_almost_equal_537_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase3i self, const LVecBase3i other)\n"
  "almost_equal(LVecBase3i self, const LVecBase3i other, int threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_almost_equal_537_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase3i_output_538(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3i::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase3i.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase3i*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase3i self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_output_538_comment =
  "C++ Interface:\n"
  "output(LVecBase3i self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase3i_output_538_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase3i_write_datagram_fixed_540(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase3i*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase3i self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_write_datagram_fixed_540_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase3i self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_write_datagram_fixed_540_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase3i_read_datagram_fixed_541(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase3i self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_read_datagram_fixed_541_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase3i self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase3i_read_datagram_fixed_541_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase3i_write_datagram_542(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase3i::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.write_datagram", "Datagram");
  }
  (*(const LVecBase3i*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase3i self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_write_datagram_542_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase3i self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase3i_write_datagram_542_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase3i::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase3i_read_datagram_543(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase3i::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase3i self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_read_datagram_543_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase3i self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase3i_read_datagram_543_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase3i::get_class_type(void)
 */
static PyObject *Dtool_LVecBase3i_get_class_type_544(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase3i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase3i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase3i_get_class_type_544_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase3i_get_class_type_544_comment = NULL;
#endif

static PyObject *Dtool_LVecBase3i_x_Getter(PyObject *self, void *) {
  const LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase3i::get_x(void) const
  int return_value = (*(const LVecBase3i*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3i_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase3i::set_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_x((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase3i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3i_y_Getter(PyObject *self, void *) {
  const LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase3i::get_y(void) const
  int return_value = (*(const LVecBase3i*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3i_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase3i::set_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_y((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase3i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3i_z_Getter(PyObject *self, void *) {
  const LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase3i::get_z(void) const
  int return_value = (*(const LVecBase3i*)local_this).get_z();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase3i_z_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase3i, (void **)&local_this, "LVecBase3i.z")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete z attribute");
    return -1;
  }
  // 1-inline void LVecBase3i::set_z(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_z((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase3i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase3i_xy_Getter(PyObject *self, void *) {
  const LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i LVecBase3i::get_xy(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase3i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_LVecBase3i_xz_Getter(PyObject *self, void *) {
  const LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i LVecBase3i::get_xz(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase3i*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_LVecBase3i_yz_Getter(PyObject *self, void *) {
  const LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i LVecBase3i::get_yz(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase3i*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

/**
 * Python function wrapper for:
 * inline LVecBase3i::LVecBase3i(void) = default
 * inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z)
 * inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default
 * inline LVecBase3i::LVecBase3i(int fill_value)
 * inline LVecBase3i::LVecBase3i(int x, int y, int z)
 */
static int Dtool_Init_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase3i::LVecBase3i(void) = default
      LVecBase3i *return_value = new LVecBase3i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase3i", (char **)keyword_list, &param0)) {
          LVecBase3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase3i *return_value = new LVecBase3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase3i::LVecBase3i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LVecBase3i", (char **)keyword_list, &param0)) {
          LVecBase3i *return_value = new LVecBase3i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase3i", (char **)keyword_list, &param0)) {
          LVecBase3i param0_local;
          LVecBase3i const *param0_this = Dtool_Coerce_LVecBase3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase3i *return_value = new LVecBase3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase3i::LVecBase3i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:LVecBase3i", (char **)keyword_list, &param0, &param1)) {
        LVecBase2i param0_local;
        LVecBase2i const *param0_this = Dtool_Coerce_LVecBase2i(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVecBase3i.LVecBase3i", "LVecBase2i");
          return -1;
        }
        LVecBase3i *return_value = new LVecBase3i(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3i, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3i::LVecBase3i(int x, int y, int z)
      int param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:LVecBase3i", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3i *return_value = new LVecBase3i((int)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase3i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase3i() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase3i()\n"
      "LVecBase3i(const LVecBase3i param0)\n"
      "LVecBase3i(int fill_value)\n"
      "LVecBase3i(const LVecBase2i copy, int z)\n"
      "LVecBase3i(int x, int y, int z)\n");
  }
  return -1;
}

LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  LVecBase3i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase3i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase3i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LVecBase3i::LVecBase3i(int fill_value)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      coerced = LVecBase3i((int)arg_val);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:LVecBase3i", &param0, &param1)) {
          LVecBase2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVecBase3i(*param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LVecBase3i::LVecBase3i(int x, int y, int z)
        int param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "iii:LVecBase3i", &param0, &param1, &param2)) {
          coerced = LVecBase3i((int)param0, (int)param1, (int)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase3i) {
    printf("LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase3i *local_this = (LVecBase3i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase3i) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase3i) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector3f
 */
/**
 * Python function wrapper for:
 * static inline LVector3f const &LVector3f::zero(void)
 */
static PyObject *Dtool_LVector3f_zero_555(PyObject *, PyObject *) {
  // 1-static inline LVector3f const &LVector3f::zero(void)
  LVector3f const *return_value = &(LVector3f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_zero_555_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_zero_555_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f const &LVector3f::unit_x(void)
 */
static PyObject *Dtool_LVector3f_unit_x_556(PyObject *, PyObject *) {
  // 1-static inline LVector3f const &LVector3f::unit_x(void)
  LVector3f const *return_value = &(LVector3f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_unit_x_556_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_unit_x_556_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f const &LVector3f::unit_y(void)
 */
static PyObject *Dtool_LVector3f_unit_y_557(PyObject *, PyObject *) {
  // 1-static inline LVector3f const &LVector3f::unit_y(void)
  LVector3f const *return_value = &(LVector3f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_unit_y_557_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_unit_y_557_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f const &LVector3f::unit_z(void)
 */
static PyObject *Dtool_LVector3f_unit_z_558(PyObject *, PyObject *) {
  // 1-static inline LVector3f const &LVector3f::unit_z(void)
  LVector3f const *return_value = &(LVector3f::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_unit_z_558_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_unit_z_558_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f LVector3f::get_xy(void) const
 */
static PyObject *Dtool_LVector3f_get_xy_559(PyObject *self, PyObject *) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2f LVector3f::get_xy(void) const
  LVector2f *return_value = new LVector2f((*(const LVector3f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_get_xy_559_comment =
  "C++ Interface:\n"
  "get_xy(LVector3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_get_xy_559_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f LVector3f::get_xz(void) const
 */
static PyObject *Dtool_LVector3f_get_xz_560(PyObject *self, PyObject *) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2f LVector3f::get_xz(void) const
  LVector2f *return_value = new LVector2f((*(const LVector3f*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_get_xz_560_comment =
  "C++ Interface:\n"
  "get_xz(LVector3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_get_xz_560_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f LVector3f::get_yz(void) const
 */
static PyObject *Dtool_LVector3f_get_yz_561(PyObject *self, PyObject *) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2f LVector3f::get_yz(void) const
  LVector2f *return_value = new LVector2f((*(const LVector3f*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_get_yz_561_comment =
  "C++ Interface:\n"
  "get_yz(LVector3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_get_yz_561_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LVector3f::cross(LVecBase3f const &other) const
 */
static PyObject *Dtool_LVector3f_cross_568(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LVector3f::cross(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3f.cross", "LVecBase3f");
  }
  LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LVector3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_cross_568_comment =
  "C++ Interface:\n"
  "cross(LVector3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVector3f_cross_568_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LVector3f::normalized(void) const
 */
static PyObject *Dtool_LVector3f_normalized_569(PyObject *self, PyObject *) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LVector3f::normalized(void) const
  LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_normalized_569_comment =
  "C++ Interface:\n"
  "normalized(LVector3f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVector3f_normalized_569_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LVector3f::project(LVecBase3f const &onto) const
 */
static PyObject *Dtool_LVector3f_project_570(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LVector3f::project(LVecBase3f const &onto) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3f.project", "LVecBase3f");
  }
  LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVector3f self, const LVecBase3f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_project_570_comment =
  "C++ Interface:\n"
  "project(LVector3f self, const LVecBase3f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVector3f_project_570_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector3f::angle_rad(LVector3f const &other) const
 */
static PyObject *Dtool_LVector3f_angle_rad_571(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector3f::angle_rad(LVector3f const &other) const
  LVector3f arg_local;
  LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3f.angle_rad", "LVector3f");
  }
  float return_value = (*(const LVector3f*)local_this).angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_rad(LVector3f self, const LVector3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_angle_rad_571_comment =
  "C++ Interface:\n"
  "angle_rad(LVector3f self, const LVector3f other)\n"
  "\n"
  "/**\n"
  " * Returns the unsigned angle between this vector and the other one, expressed\n"
  " * in radians.  Both vectors should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3f_angle_rad_571_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector3f::angle_deg(LVector3f const &other) const
 */
static PyObject *Dtool_LVector3f_angle_deg_572(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector3f::angle_deg(LVector3f const &other) const
  LVector3f arg_local;
  LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3f.angle_deg", "LVector3f");
  }
  float return_value = (*(const LVector3f*)local_this).angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_deg(LVector3f self, const LVector3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_angle_deg_572_comment =
  "C++ Interface:\n"
  "angle_deg(LVector3f self, const LVector3f other)\n"
  "\n"
  "/**\n"
  " * Returns the angle between this vector and the other one, expressed in\n"
  " * degrees.  Both vectors should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3f_angle_deg_572_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const
 */
static PyObject *Dtool_LVector3f_signed_angle_rad_573(PyObject *self, PyObject *args, PyObject *kwds) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "ref", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:signed_angle_rad", (char **)keyword_list, &param1, &param2)) {
    LVector3f param1_local;
    LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LVector3f.signed_angle_rad", "LVector3f");
    }
    LVector3f param2_local;
    LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LVector3f.signed_angle_rad", "LVector3f");
    }
    float return_value = (*(const LVector3f*)local_this).signed_angle_rad(*param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_rad(LVector3f self, const LVector3f other, const LVector3f ref)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_signed_angle_rad_573_comment =
  "C++ Interface:\n"
  "signed_angle_rad(LVector3f self, const LVector3f other, const LVector3f ref)\n"
  "\n"
  "/**\n"
  " * returns the signed angle between two vectors.  The angle is positive if the\n"
  " * rotation from this vector to other is clockwise when looking in the\n"
  " * direction of the ref vector.\n"
  " *\n"
  " * Vectors (except the ref vector) should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3f_signed_angle_rad_573_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const
 */
static PyObject *Dtool_LVector3f_signed_angle_deg_574(PyObject *self, PyObject *args, PyObject *kwds) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "ref", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:signed_angle_deg", (char **)keyword_list, &param1, &param2)) {
    LVector3f param1_local;
    LVector3f const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LVector3f.signed_angle_deg", "LVector3f");
    }
    LVector3f param2_local;
    LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LVector3f.signed_angle_deg", "LVector3f");
    }
    float return_value = (*(const LVector3f*)local_this).signed_angle_deg(*param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_deg(LVector3f self, const LVector3f other, const LVector3f ref)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_signed_angle_deg_574_comment =
  "C++ Interface:\n"
  "signed_angle_deg(LVector3f self, const LVector3f other, const LVector3f ref)\n"
  "\n"
  "/**\n"
  " * Returns the signed angle between two vectors.  The angle is positive if the\n"
  " * rotation from this vector to other is clockwise when looking in the\n"
  " * direction of the ref vector.\n"
  " *\n"
  " * Vectors (except the ref vector) should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3f_signed_angle_deg_574_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector3f::relative_angle_rad(LVector3f const &other) const
 */
static PyObject *Dtool_LVector3f_relative_angle_rad_575(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector3f::relative_angle_rad(LVector3f const &other) const
  LVector3f arg_local;
  LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3f.relative_angle_rad", "LVector3f");
  }
  float return_value = (*(const LVector3f*)local_this).relative_angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "relative_angle_rad(LVector3f self, const LVector3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_relative_angle_rad_575_comment =
  "C++ Interface:\n"
  "relative_angle_rad(LVector3f self, const LVector3f other)\n"
  "\n"
  "/**\n"
  " * This method is deprecated.  Do not use.\n"
  " */";
#else
static const char *Dtool_LVector3f_relative_angle_rad_575_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVector3f::relative_angle_deg(LVector3f const &other) const
 */
static PyObject *Dtool_LVector3f_relative_angle_deg_576(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVector3f::relative_angle_deg(LVector3f const &other) const
  LVector3f arg_local;
  LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3f.relative_angle_deg", "LVector3f");
  }
  float return_value = (*(const LVector3f*)local_this).relative_angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "relative_angle_deg(LVector3f self, const LVector3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_relative_angle_deg_576_comment =
  "C++ Interface:\n"
  "relative_angle_deg(LVector3f self, const LVector3f other)\n"
  "\n"
  "/**\n"
  " * This method is deprecated.  Do not use.\n"
  " */";
#else
static const char *Dtool_LVector3f_relative_angle_deg_576_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_up_579(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:up", (char **)keyword_list, &param0)) {
    LVector3f *return_value = new LVector3f(LVector3f::up((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "up(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_up_579_comment =
  "C++ Interface:\n"
  "up(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the up vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3f_up_579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_right_580(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:right", (char **)keyword_list, &param0)) {
    LVector3f *return_value = new LVector3f(LVector3f::right((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "right(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_right_580_comment =
  "C++ Interface:\n"
  "right(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the right vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3f_right_580_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_forward_581(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:forward", (char **)keyword_list, &param0)) {
    LVector3f *return_value = new LVector3f(LVector3f::forward((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "forward(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_forward_581_comment =
  "C++ Interface:\n"
  "forward(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the forward vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3f_forward_581_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_down_582(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:down", (char **)keyword_list, &param0)) {
    LVector3f *return_value = new LVector3f(LVector3f::down((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "down(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_down_582_comment =
  "C++ Interface:\n"
  "down(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the down vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3f_down_582_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_left_583(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:left", (char **)keyword_list, &param0)) {
    LVector3f *return_value = new LVector3f(LVector3f::left((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "left(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_left_583_comment =
  "C++ Interface:\n"
  "left(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the left vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3f_left_583_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_back_584(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:back", (char **)keyword_list, &param0)) {
    LVector3f *return_value = new LVector3f(LVector3f::back((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "back(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_back_584_comment =
  "C++ Interface:\n"
  "back(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the back vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3f_back_584_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3f_rfu_585(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default)
  float param0;
  float param1;
  float param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"right", "fwd", "up", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|i:rfu", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVector3f *return_value = new LVector3f(LVector3f::rfu((float)param0, (float)param1, (float)param2, (CoordinateSystem)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rfu(float right, float fwd, float up, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_rfu_585_comment =
  "C++ Interface:\n"
  "rfu(float right, float fwd, float up, int cs)\n"
  "\n"
  "// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,\n"
  "\n"
  "/**\n"
  " * Returns a vector that is described by its right, forward, and up\n"
  " * components, in whatever way the coordinate system represents that vector.\n"
  " */";
#else
static const char *Dtool_LVector3f_rfu_585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector3f::get_class_type(void)
 */
static PyObject *Dtool_LVector3f_get_class_type_587(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector3f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector3f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3f_get_class_type_587_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector3f_get_class_type_587_comment = NULL;
#endif

static PyObject *Dtool_LVector3f_xy_Getter(PyObject *self, void *) {
  const LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2f LVector3f::get_xy(void) const
  LVector2f *return_value = new LVector2f((*(const LVector3f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static PyObject *Dtool_LVector3f_xz_Getter(PyObject *self, void *) {
  const LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2f LVector3f::get_xz(void) const
  LVector2f *return_value = new LVector2f((*(const LVector3f*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static PyObject *Dtool_LVector3f_yz_Getter(PyObject *self, void *) {
  const LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2f LVector3f::get_yz(void) const
  LVector2f *return_value = new LVector2f((*(const LVector3f*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

/**
 * Python function wrapper for:
 * inline LVector3f::LVector3f(void) = default
 * inline LVector3f::LVector3f(LVecBase2f const &copy, float z)
 * inline LVector3f::LVector3f(LVecBase3f const &copy)
 * inline LVector3f::LVector3f(LVector3f const &) = default
 * inline LVector3f::LVector3f(float fill_value)
 * inline LVector3f::LVector3f(float x, float y, float z)
 */
static int Dtool_Init_LVector3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector3f::LVector3f(void) = default
      LVector3f *return_value = new LVector3f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector3f::LVector3f(LVector3f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3f", (char **)keyword_list, &param0)) {
          LVector3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector3f *return_value = new LVector3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3f::LVector3f(LVecBase3f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3f", (char **)keyword_list, &param0)) {
          LVecBase3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector3f *return_value = new LVector3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3f::LVector3f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LVector3f", (char **)keyword_list, &param0)) {
          LVector3f *return_value = new LVector3f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3f::LVector3f(LVector3f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3f", (char **)keyword_list, &param0)) {
          LVector3f param0_local;
          LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector3f *return_value = new LVector3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3f::LVector3f(LVecBase3f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3f", (char **)keyword_list, &param0)) {
          LVecBase3f param0_local;
          LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector3f *return_value = new LVector3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector3f::LVector3f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector3f::LVector3f(LVecBase2f const &copy, float z)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LVector3f", (char **)keyword_list, &param0, &param1)) {
        LVecBase2f param0_local;
        LVecBase2f const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVector3f.LVector3f", "LVecBase2f");
          return -1;
        }
        LVector3f *return_value = new LVector3f(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVector3f::LVector3f(float x, float y, float z)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:LVector3f", (char **)keyword_list, &param0, &param1, &param2)) {
        LVector3f *return_value = new LVector3f((float)param0, (float)param1, (float)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector3f() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector3f()\n"
      "LVector3f(const LVector3f param0)\n"
      "LVector3f(const LVecBase3f copy)\n"
      "LVector3f(float fill_value)\n"
      "LVector3f(const LVecBase2f copy, float z)\n"
      "LVector3f(float x, float y, float z)\n");
  }
  return -1;
}

LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  LVector3f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector3f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector3f::LVector3f(LVecBase3f const &copy)
      LVecBase3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector3f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector3f::LVector3f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVector3f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVector3f::LVector3f(LVecBase2f const &copy, float z)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LVector3f", &param0, &param1)) {
          LVecBase2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVector3f(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LVector3f::LVector3f(float x, float y, float z)
        float param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "fff:LVector3f", &param0, &param1, &param2)) {
          coerced = LVector3f((float)param0, (float)param1, (float)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector3f) {
    printf("LVector3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector3f *local_this = (LVector3f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase3f) {
    return (LVecBase3f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase3f) {
    LVecBase3f* other_this = (LVecBase3f*)from_this;
    return (LVector3f*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector3d
 */
/**
 * Python function wrapper for:
 * static inline LVector3d const &LVector3d::zero(void)
 */
static PyObject *Dtool_LVector3d_zero_593(PyObject *, PyObject *) {
  // 1-static inline LVector3d const &LVector3d::zero(void)
  LVector3d const *return_value = &(LVector3d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_zero_593_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_zero_593_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d const &LVector3d::unit_x(void)
 */
static PyObject *Dtool_LVector3d_unit_x_594(PyObject *, PyObject *) {
  // 1-static inline LVector3d const &LVector3d::unit_x(void)
  LVector3d const *return_value = &(LVector3d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_unit_x_594_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_unit_x_594_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d const &LVector3d::unit_y(void)
 */
static PyObject *Dtool_LVector3d_unit_y_595(PyObject *, PyObject *) {
  // 1-static inline LVector3d const &LVector3d::unit_y(void)
  LVector3d const *return_value = &(LVector3d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_unit_y_595_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_unit_y_595_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d const &LVector3d::unit_z(void)
 */
static PyObject *Dtool_LVector3d_unit_z_596(PyObject *, PyObject *) {
  // 1-static inline LVector3d const &LVector3d::unit_z(void)
  LVector3d const *return_value = &(LVector3d::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_unit_z_596_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_unit_z_596_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d LVector3d::get_xy(void) const
 */
static PyObject *Dtool_LVector3d_get_xy_597(PyObject *self, PyObject *) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2d LVector3d::get_xy(void) const
  LVector2d *return_value = new LVector2d((*(const LVector3d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_get_xy_597_comment =
  "C++ Interface:\n"
  "get_xy(LVector3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_get_xy_597_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d LVector3d::get_xz(void) const
 */
static PyObject *Dtool_LVector3d_get_xz_598(PyObject *self, PyObject *) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2d LVector3d::get_xz(void) const
  LVector2d *return_value = new LVector2d((*(const LVector3d*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_get_xz_598_comment =
  "C++ Interface:\n"
  "get_xz(LVector3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_get_xz_598_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d LVector3d::get_yz(void) const
 */
static PyObject *Dtool_LVector3d_get_yz_599(PyObject *self, PyObject *) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2d LVector3d::get_yz(void) const
  LVector2d *return_value = new LVector2d((*(const LVector3d*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_get_yz_599_comment =
  "C++ Interface:\n"
  "get_yz(LVector3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_get_yz_599_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LVector3d::cross(LVecBase3d const &other) const
 */
static PyObject *Dtool_LVector3d_cross_606(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LVector3d::cross(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3d.cross", "LVecBase3d");
  }
  LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LVector3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_cross_606_comment =
  "C++ Interface:\n"
  "cross(LVector3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVector3d_cross_606_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LVector3d::normalized(void) const
 */
static PyObject *Dtool_LVector3d_normalized_607(PyObject *self, PyObject *) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LVector3d::normalized(void) const
  LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_normalized_607_comment =
  "C++ Interface:\n"
  "normalized(LVector3d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVector3d_normalized_607_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LVector3d::project(LVecBase3d const &onto) const
 */
static PyObject *Dtool_LVector3d_project_608(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LVector3d::project(LVecBase3d const &onto) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3d.project", "LVecBase3d");
  }
  LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVector3d self, const LVecBase3d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_project_608_comment =
  "C++ Interface:\n"
  "project(LVector3d self, const LVecBase3d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVector3d_project_608_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector3d::angle_rad(LVector3d const &other) const
 */
static PyObject *Dtool_LVector3d_angle_rad_609(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector3d::angle_rad(LVector3d const &other) const
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3d.angle_rad", "LVector3d");
  }
  double return_value = (*(const LVector3d*)local_this).angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_rad(LVector3d self, const LVector3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_angle_rad_609_comment =
  "C++ Interface:\n"
  "angle_rad(LVector3d self, const LVector3d other)\n"
  "\n"
  "/**\n"
  " * Returns the unsigned angle between this vector and the other one, expressed\n"
  " * in radians.  Both vectors should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3d_angle_rad_609_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector3d::angle_deg(LVector3d const &other) const
 */
static PyObject *Dtool_LVector3d_angle_deg_610(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector3d::angle_deg(LVector3d const &other) const
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3d.angle_deg", "LVector3d");
  }
  double return_value = (*(const LVector3d*)local_this).angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_deg(LVector3d self, const LVector3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_angle_deg_610_comment =
  "C++ Interface:\n"
  "angle_deg(LVector3d self, const LVector3d other)\n"
  "\n"
  "/**\n"
  " * Returns the angle between this vector and the other one, expressed in\n"
  " * degrees.  Both vectors should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3d_angle_deg_610_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const
 */
static PyObject *Dtool_LVector3d_signed_angle_rad_611(PyObject *self, PyObject *args, PyObject *kwds) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "ref", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:signed_angle_rad", (char **)keyword_list, &param1, &param2)) {
    LVector3d param1_local;
    LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LVector3d.signed_angle_rad", "LVector3d");
    }
    LVector3d param2_local;
    LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LVector3d.signed_angle_rad", "LVector3d");
    }
    double return_value = (*(const LVector3d*)local_this).signed_angle_rad(*param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_rad(LVector3d self, const LVector3d other, const LVector3d ref)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_signed_angle_rad_611_comment =
  "C++ Interface:\n"
  "signed_angle_rad(LVector3d self, const LVector3d other, const LVector3d ref)\n"
  "\n"
  "/**\n"
  " * returns the signed angle between two vectors.  The angle is positive if the\n"
  " * rotation from this vector to other is clockwise when looking in the\n"
  " * direction of the ref vector.\n"
  " *\n"
  " * Vectors (except the ref vector) should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3d_signed_angle_rad_611_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const
 */
static PyObject *Dtool_LVector3d_signed_angle_deg_612(PyObject *self, PyObject *args, PyObject *kwds) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other", "ref", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:signed_angle_deg", (char **)keyword_list, &param1, &param2)) {
    LVector3d param1_local;
    LVector3d const *param1_this = Dtool_Coerce_LVector3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LVector3d.signed_angle_deg", "LVector3d");
    }
    LVector3d param2_local;
    LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LVector3d.signed_angle_deg", "LVector3d");
    }
    double return_value = (*(const LVector3d*)local_this).signed_angle_deg(*param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "signed_angle_deg(LVector3d self, const LVector3d other, const LVector3d ref)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_signed_angle_deg_612_comment =
  "C++ Interface:\n"
  "signed_angle_deg(LVector3d self, const LVector3d other, const LVector3d ref)\n"
  "\n"
  "/**\n"
  " * Returns the signed angle between two vectors.  The angle is positive if the\n"
  " * rotation from this vector to other is clockwise when looking in the\n"
  " * direction of the ref vector.\n"
  " *\n"
  " * Vectors (except the ref vector) should be initially normalized.\n"
  " */";
#else
static const char *Dtool_LVector3d_signed_angle_deg_612_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector3d::relative_angle_rad(LVector3d const &other) const
 */
static PyObject *Dtool_LVector3d_relative_angle_rad_613(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector3d::relative_angle_rad(LVector3d const &other) const
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3d.relative_angle_rad", "LVector3d");
  }
  double return_value = (*(const LVector3d*)local_this).relative_angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "relative_angle_rad(LVector3d self, const LVector3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_relative_angle_rad_613_comment =
  "C++ Interface:\n"
  "relative_angle_rad(LVector3d self, const LVector3d other)\n"
  "\n"
  "/**\n"
  " * This method is deprecated.  Do not use.\n"
  " */";
#else
static const char *Dtool_LVector3d_relative_angle_rad_613_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVector3d::relative_angle_deg(LVector3d const &other) const
 */
static PyObject *Dtool_LVector3d_relative_angle_deg_614(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVector3d::relative_angle_deg(LVector3d const &other) const
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3d.relative_angle_deg", "LVector3d");
  }
  double return_value = (*(const LVector3d*)local_this).relative_angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "relative_angle_deg(LVector3d self, const LVector3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_relative_angle_deg_614_comment =
  "C++ Interface:\n"
  "relative_angle_deg(LVector3d self, const LVector3d other)\n"
  "\n"
  "/**\n"
  " * This method is deprecated.  Do not use.\n"
  " */";
#else
static const char *Dtool_LVector3d_relative_angle_deg_614_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_up_617(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:up", (char **)keyword_list, &param0)) {
    LVector3d *return_value = new LVector3d(LVector3d::up((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "up(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_up_617_comment =
  "C++ Interface:\n"
  "up(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the up vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3d_up_617_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_right_618(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:right", (char **)keyword_list, &param0)) {
    LVector3d *return_value = new LVector3d(LVector3d::right((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "right(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_right_618_comment =
  "C++ Interface:\n"
  "right(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the right vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3d_right_618_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_forward_619(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:forward", (char **)keyword_list, &param0)) {
    LVector3d *return_value = new LVector3d(LVector3d::forward((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "forward(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_forward_619_comment =
  "C++ Interface:\n"
  "forward(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the forward vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3d_forward_619_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_down_620(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:down", (char **)keyword_list, &param0)) {
    LVector3d *return_value = new LVector3d(LVector3d::down((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "down(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_down_620_comment =
  "C++ Interface:\n"
  "down(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the down vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3d_down_620_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_left_621(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:left", (char **)keyword_list, &param0)) {
    LVector3d *return_value = new LVector3d(LVector3d::left((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "left(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_left_621_comment =
  "C++ Interface:\n"
  "left(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the left vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3d_left_621_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_back_622(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:back", (char **)keyword_list, &param0)) {
    LVector3d *return_value = new LVector3d(LVector3d::back((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "back(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_back_622_comment =
  "C++ Interface:\n"
  "back(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the back vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3d_back_622_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3d_rfu_623(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default)
  double param0;
  double param1;
  double param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"right", "fwd", "up", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|i:rfu", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVector3d *return_value = new LVector3d(LVector3d::rfu((double)param0, (double)param1, (double)param2, (CoordinateSystem)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rfu(double right, double fwd, double up, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_rfu_623_comment =
  "C++ Interface:\n"
  "rfu(double right, double fwd, double up, int cs)\n"
  "\n"
  "// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,\n"
  "\n"
  "/**\n"
  " * Returns a vector that is described by its right, forward, and up\n"
  " * components, in whatever way the coordinate system represents that vector.\n"
  " */";
#else
static const char *Dtool_LVector3d_rfu_623_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector3d::get_class_type(void)
 */
static PyObject *Dtool_LVector3d_get_class_type_625(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector3d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector3d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3d_get_class_type_625_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector3d_get_class_type_625_comment = NULL;
#endif

static PyObject *Dtool_LVector3d_xy_Getter(PyObject *self, void *) {
  const LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2d LVector3d::get_xy(void) const
  LVector2d *return_value = new LVector2d((*(const LVector3d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

static PyObject *Dtool_LVector3d_xz_Getter(PyObject *self, void *) {
  const LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2d LVector3d::get_xz(void) const
  LVector2d *return_value = new LVector2d((*(const LVector3d*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

static PyObject *Dtool_LVector3d_yz_Getter(PyObject *self, void *) {
  const LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2d LVector3d::get_yz(void) const
  LVector2d *return_value = new LVector2d((*(const LVector3d*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

/**
 * Python function wrapper for:
 * inline LVector3d::LVector3d(void) = default
 * inline LVector3d::LVector3d(LVecBase2d const &copy, double z)
 * inline LVector3d::LVector3d(LVecBase3d const &copy)
 * inline LVector3d::LVector3d(LVector3d const &) = default
 * inline LVector3d::LVector3d(double fill_value)
 * inline LVector3d::LVector3d(double x, double y, double z)
 */
static int Dtool_Init_LVector3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector3d::LVector3d(void) = default
      LVector3d *return_value = new LVector3d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector3d::LVector3d(LVector3d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3d", (char **)keyword_list, &param0)) {
          LVector3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector3d *return_value = new LVector3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3d::LVector3d(LVecBase3d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3d", (char **)keyword_list, &param0)) {
          LVecBase3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector3d *return_value = new LVector3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3d::LVector3d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LVector3d", (char **)keyword_list, &param0)) {
          LVector3d *return_value = new LVector3d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3d::LVector3d(LVector3d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3d", (char **)keyword_list, &param0)) {
          LVector3d param0_local;
          LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector3d *return_value = new LVector3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3d::LVector3d(LVecBase3d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3d", (char **)keyword_list, &param0)) {
          LVecBase3d param0_local;
          LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector3d *return_value = new LVector3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector3d::LVector3d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector3d::LVector3d(LVecBase2d const &copy, double z)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LVector3d", (char **)keyword_list, &param0, &param1)) {
        LVecBase2d param0_local;
        LVecBase2d const *param0_this = Dtool_Coerce_LVecBase2d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVector3d.LVector3d", "LVecBase2d");
          return -1;
        }
        LVector3d *return_value = new LVector3d(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVector3d::LVector3d(double x, double y, double z)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:LVector3d", (char **)keyword_list, &param0, &param1, &param2)) {
        LVector3d *return_value = new LVector3d((double)param0, (double)param1, (double)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector3d() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector3d()\n"
      "LVector3d(const LVector3d param0)\n"
      "LVector3d(const LVecBase3d copy)\n"
      "LVector3d(double fill_value)\n"
      "LVector3d(const LVecBase2d copy, double z)\n"
      "LVector3d(double x, double y, double z)\n");
  }
  return -1;
}

LVector3d *Dtool_Coerce_LVector3d(PyObject *args, LVector3d &coerced) {
  LVector3d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector3d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector3d::LVector3d(LVecBase3d const &copy)
      LVecBase3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector3d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector3d::LVector3d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVector3d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVector3d::LVector3d(LVecBase2d const &copy, double z)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LVector3d", &param0, &param1)) {
          LVecBase2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVector3d(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LVector3d::LVector3d(double x, double y, double z)
        double param0;
        double param1;
        double param2;
        if (PyArg_ParseTuple(args, "ddd:LVector3d", &param0, &param1, &param2)) {
          coerced = LVector3d((double)param0, (double)param1, (double)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector3d) {
    printf("LVector3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector3d *local_this = (LVector3d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase3d) {
    return (LVecBase3d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase3d) {
    LVecBase3d* other_this = (LVecBase3d*)from_this;
    return (LVector3d*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector3i
 */
/**
 * Python function wrapper for:
 * static inline LVector3i const &LVector3i::zero(void)
 */
static PyObject *Dtool_LVector3i_zero_631(PyObject *, PyObject *) {
  // 1-static inline LVector3i const &LVector3i::zero(void)
  LVector3i const *return_value = &(LVector3i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_zero_631_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_zero_631_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i const &LVector3i::unit_x(void)
 */
static PyObject *Dtool_LVector3i_unit_x_632(PyObject *, PyObject *) {
  // 1-static inline LVector3i const &LVector3i::unit_x(void)
  LVector3i const *return_value = &(LVector3i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_unit_x_632_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_unit_x_632_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i const &LVector3i::unit_y(void)
 */
static PyObject *Dtool_LVector3i_unit_y_633(PyObject *, PyObject *) {
  // 1-static inline LVector3i const &LVector3i::unit_y(void)
  LVector3i const *return_value = &(LVector3i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_unit_y_633_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_unit_y_633_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i const &LVector3i::unit_z(void)
 */
static PyObject *Dtool_LVector3i_unit_z_634(PyObject *, PyObject *) {
  // 1-static inline LVector3i const &LVector3i::unit_z(void)
  LVector3i const *return_value = &(LVector3i::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_unit_z_634_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_unit_z_634_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2i LVector3i::get_xy(void) const
 */
static PyObject *Dtool_LVector3i_get_xy_635(PyObject *self, PyObject *) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2i LVector3i::get_xy(void) const
  LVector2i *return_value = new LVector2i((*(const LVector3i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_get_xy_635_comment =
  "C++ Interface:\n"
  "get_xy(LVector3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_get_xy_635_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2i LVector3i::get_xz(void) const
 */
static PyObject *Dtool_LVector3i_get_xz_636(PyObject *self, PyObject *) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2i LVector3i::get_xz(void) const
  LVector2i *return_value = new LVector2i((*(const LVector3i*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_get_xz_636_comment =
  "C++ Interface:\n"
  "get_xz(LVector3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_get_xz_636_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2i LVector3i::get_yz(void) const
 */
static PyObject *Dtool_LVector3i_get_yz_637(PyObject *self, PyObject *) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2i LVector3i::get_yz(void) const
  LVector2i *return_value = new LVector2i((*(const LVector3i*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_get_yz_637_comment =
  "C++ Interface:\n"
  "get_yz(LVector3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_get_yz_637_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3i LVector3i::cross(LVecBase3i const &other) const
 */
static PyObject *Dtool_LVector3i_cross_644(PyObject *self, PyObject *arg) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3i LVector3i::cross(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector3i.cross", "LVecBase3i");
  }
  LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LVector3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_cross_644_comment =
  "C++ Interface:\n"
  "cross(LVector3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVector3i_cross_644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_up_647(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:up", (char **)keyword_list, &param0)) {
    LVector3i *return_value = new LVector3i(LVector3i::up((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "up(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_up_647_comment =
  "C++ Interface:\n"
  "up(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the up vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3i_up_647_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_right_648(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:right", (char **)keyword_list, &param0)) {
    LVector3i *return_value = new LVector3i(LVector3i::right((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "right(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_right_648_comment =
  "C++ Interface:\n"
  "right(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the right vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3i_right_648_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_forward_649(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:forward", (char **)keyword_list, &param0)) {
    LVector3i *return_value = new LVector3i(LVector3i::forward((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "forward(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_forward_649_comment =
  "C++ Interface:\n"
  "forward(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the forward vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3i_forward_649_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_down_650(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:down", (char **)keyword_list, &param0)) {
    LVector3i *return_value = new LVector3i(LVector3i::down((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "down(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_down_650_comment =
  "C++ Interface:\n"
  "down(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the down vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3i_down_650_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_left_651(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:left", (char **)keyword_list, &param0)) {
    LVector3i *return_value = new LVector3i(LVector3i::left((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "left(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_left_651_comment =
  "C++ Interface:\n"
  "left(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the left vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3i_left_651_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_back_652(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:back", (char **)keyword_list, &param0)) {
    LVector3i *return_value = new LVector3i(LVector3i::back((CoordinateSystem)param0));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "back(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_back_652_comment =
  "C++ Interface:\n"
  "back(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the back vector for the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LVector3i_back_652_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LVector3i_rfu_653(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default)
  int param0;
  int param1;
  int param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"right", "fwd", "up", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii|i:rfu", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LVector3i *return_value = new LVector3i(LVector3i::rfu((int)param0, (int)param1, (int)param2, (CoordinateSystem)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rfu(int right, int fwd, int up, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_rfu_653_comment =
  "C++ Interface:\n"
  "rfu(int right, int fwd, int up, int cs)\n"
  "\n"
  "// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,\n"
  "\n"
  "/**\n"
  " * Returns a vector that is described by its right, forward, and up\n"
  " * components, in whatever way the coordinate system represents that vector.\n"
  " */";
#else
static const char *Dtool_LVector3i_rfu_653_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector3i::get_class_type(void)
 */
static PyObject *Dtool_LVector3i_get_class_type_655(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector3i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector3i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector3i_get_class_type_655_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector3i_get_class_type_655_comment = NULL;
#endif

static PyObject *Dtool_LVector3i_xy_Getter(PyObject *self, void *) {
  const LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2i LVector3i::get_xy(void) const
  LVector2i *return_value = new LVector2i((*(const LVector3i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

static PyObject *Dtool_LVector3i_xz_Getter(PyObject *self, void *) {
  const LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2i LVector3i::get_xz(void) const
  LVector2i *return_value = new LVector2i((*(const LVector3i*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

static PyObject *Dtool_LVector3i_yz_Getter(PyObject *self, void *) {
  const LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2i LVector3i::get_yz(void) const
  LVector2i *return_value = new LVector2i((*(const LVector3i*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

/**
 * Python function wrapper for:
 * inline LVector3i::LVector3i(void) = default
 * inline LVector3i::LVector3i(LVecBase2i const &copy, int z)
 * inline LVector3i::LVector3i(LVecBase3i const &copy)
 * inline LVector3i::LVector3i(LVector3i const &) = default
 * inline LVector3i::LVector3i(int fill_value)
 * inline LVector3i::LVector3i(int x, int y, int z)
 */
static int Dtool_Init_LVector3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector3i::LVector3i(void) = default
      LVector3i *return_value = new LVector3i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector3i::LVector3i(LVector3i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3i", (char **)keyword_list, &param0)) {
          LVector3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector3i *return_value = new LVector3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3i::LVector3i(LVecBase3i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3i", (char **)keyword_list, &param0)) {
          LVecBase3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector3i *return_value = new LVector3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3i::LVector3i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LVector3i", (char **)keyword_list, &param0)) {
          LVector3i *return_value = new LVector3i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3i::LVector3i(LVector3i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3i", (char **)keyword_list, &param0)) {
          LVector3i param0_local;
          LVector3i const *param0_this = Dtool_Coerce_LVector3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector3i *return_value = new LVector3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector3i::LVector3i(LVecBase3i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector3i", (char **)keyword_list, &param0)) {
          LVecBase3i param0_local;
          LVecBase3i const *param0_this = Dtool_Coerce_LVecBase3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector3i *return_value = new LVector3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector3i::LVector3i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector3i::LVector3i(LVecBase2i const &copy, int z)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:LVector3i", (char **)keyword_list, &param0, &param1)) {
        LVecBase2i param0_local;
        LVecBase2i const *param0_this = Dtool_Coerce_LVecBase2i(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVector3i.LVector3i", "LVecBase2i");
          return -1;
        }
        LVector3i *return_value = new LVector3i(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVector3i::LVector3i(int x, int y, int z)
      int param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:LVector3i", (char **)keyword_list, &param0, &param1, &param2)) {
        LVector3i *return_value = new LVector3i((int)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector3i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector3i() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector3i()\n"
      "LVector3i(const LVector3i param0)\n"
      "LVector3i(const LVecBase3i copy)\n"
      "LVector3i(int fill_value)\n"
      "LVector3i(const LVecBase2i copy, int z)\n"
      "LVector3i(int x, int y, int z)\n");
  }
  return -1;
}

LVector3i *Dtool_Coerce_LVector3i(PyObject *args, LVector3i &coerced) {
  LVector3i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector3i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector3i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector3i::LVector3i(LVecBase3i const &copy)
      LVecBase3i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector3i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector3i::LVector3i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LVector3i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVector3i::LVector3i(LVecBase2i const &copy, int z)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:LVector3i", &param0, &param1)) {
          LVecBase2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVector3i(*param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LVector3i::LVector3i(int x, int y, int z)
        int param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "iii:LVector3i", &param0, &param1, &param2)) {
          coerced = LVector3i((int)param0, (int)param1, (int)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector3i) {
    printf("LVector3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector3i *local_this = (LVector3i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase3i) {
    return (LVecBase3i *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase3i) {
    LVecBase3i* other_this = (LVecBase3i*)from_this;
    return (LVector3i*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint3f
 */
/**
 * Python function wrapper for:
 * static inline LPoint3f const &LPoint3f::zero(void)
 */
static PyObject *Dtool_LPoint3f_zero_661(PyObject *, PyObject *) {
  // 1-static inline LPoint3f const &LPoint3f::zero(void)
  LPoint3f const *return_value = &(LPoint3f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_zero_661_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint3f_zero_661_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3f const &LPoint3f::unit_x(void)
 */
static PyObject *Dtool_LPoint3f_unit_x_662(PyObject *, PyObject *) {
  // 1-static inline LPoint3f const &LPoint3f::unit_x(void)
  LPoint3f const *return_value = &(LPoint3f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_unit_x_662_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint3f_unit_x_662_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3f const &LPoint3f::unit_y(void)
 */
static PyObject *Dtool_LPoint3f_unit_y_663(PyObject *, PyObject *) {
  // 1-static inline LPoint3f const &LPoint3f::unit_y(void)
  LPoint3f const *return_value = &(LPoint3f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_unit_y_663_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint3f_unit_y_663_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3f const &LPoint3f::unit_z(void)
 */
static PyObject *Dtool_LPoint3f_unit_z_664(PyObject *, PyObject *) {
  // 1-static inline LPoint3f const &LPoint3f::unit_z(void)
  LPoint3f const *return_value = &(LPoint3f::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_unit_z_664_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z point.\n"
  " */";
#else
static const char *Dtool_LPoint3f_unit_z_664_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f LPoint3f::get_xy(void) const
 */
static PyObject *Dtool_LPoint3f_get_xy_665(PyObject *self, PyObject *) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f LPoint3f::get_xy(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint3f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_get_xy_665_comment =
  "C++ Interface:\n"
  "get_xy(LPoint3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3f_get_xy_665_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f LPoint3f::get_xz(void) const
 */
static PyObject *Dtool_LPoint3f_get_xz_666(PyObject *self, PyObject *) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f LPoint3f::get_xz(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint3f*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_get_xz_666_comment =
  "C++ Interface:\n"
  "get_xz(LPoint3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3f_get_xz_666_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f LPoint3f::get_yz(void) const
 */
static PyObject *Dtool_LPoint3f_get_yz_667(PyObject *self, PyObject *) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f LPoint3f::get_yz(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint3f*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_get_yz_667_comment =
  "C++ Interface:\n"
  "get_yz(LPoint3f self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3f_get_yz_667_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const
 */
static PyObject *Dtool_LPoint3f_cross_674(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint3f.cross", "LVecBase3f");
  }
  LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LPoint3f self, const LVecBase3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_cross_674_comment =
  "C++ Interface:\n"
  "cross(LPoint3f self, const LVecBase3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPoint3f_cross_674_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LPoint3f::normalized(void) const
 */
static PyObject *Dtool_LPoint3f_normalized_675(PyObject *self, PyObject *) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f LPoint3f::normalized(void) const
  LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_normalized_675_comment =
  "C++ Interface:\n"
  "normalized(LPoint3f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LPoint3f_normalized_675_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const
 */
static PyObject *Dtool_LPoint3f_project_676(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint3f.project", "LVecBase3f");
  }
  LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPoint3f self, const LVecBase3f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_project_676_comment =
  "C++ Interface:\n"
  "project(LPoint3f self, const LVecBase3f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LPoint3f_project_676_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LPoint3f_origin_679(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:origin", (char **)keyword_list, &param0)) {
    LPoint3f const *return_value = &(LPoint3f::origin((CoordinateSystem)param0));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "origin(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_origin_679_comment =
  "C++ Interface:\n"
  "origin(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the origin of the indicated coordinate system.  This is always 0,\n"
  " * 0, 0 with all of our existing coordinate systems; it's hard to imagine it\n"
  " * ever being different.\n"
  " */";
#else
static const char *Dtool_LPoint3f_origin_679_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LPoint3f_rfu_680(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default)
  float param0;
  float param1;
  float param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"right", "fwd", "up", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|i:rfu", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LPoint3f *return_value = new LPoint3f(LPoint3f::rfu((float)param0, (float)param1, (float)param2, (CoordinateSystem)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rfu(float right, float fwd, float up, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_rfu_680_comment =
  "C++ Interface:\n"
  "rfu(float right, float fwd, float up, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a point described by right, forward, up displacements from the\n"
  " * origin, wherever that maps to in the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LPoint3f_rfu_680_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint3f::get_class_type(void)
 */
static PyObject *Dtool_LPoint3f_get_class_type_682(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint3f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint3f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3f_get_class_type_682_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint3f_get_class_type_682_comment = NULL;
#endif

static PyObject *Dtool_LPoint3f_xy_Getter(PyObject *self, void *) {
  const LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2f LPoint3f::get_xy(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint3f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static PyObject *Dtool_LPoint3f_xz_Getter(PyObject *self, void *) {
  const LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2f LPoint3f::get_xz(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint3f*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static PyObject *Dtool_LPoint3f_yz_Getter(PyObject *self, void *) {
  const LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2f LPoint3f::get_yz(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint3f*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

/**
 * Python function wrapper for:
 * inline LPoint3f::LPoint3f(void) = default
 * inline LPoint3f::LPoint3f(LPoint3f const &) = default
 * inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z)
 * inline LPoint3f::LPoint3f(LVecBase3f const &copy)
 * inline LPoint3f::LPoint3f(float fill_value)
 * inline LPoint3f::LPoint3f(float x, float y, float z)
 */
static int Dtool_Init_LPoint3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint3f::LPoint3f(void) = default
      LPoint3f *return_value = new LPoint3f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint3f::LPoint3f(LPoint3f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3f", (char **)keyword_list, &param0)) {
          LPoint3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint3f *return_value = new LPoint3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3f::LPoint3f(LVecBase3f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3f", (char **)keyword_list, &param0)) {
          LVecBase3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint3f *return_value = new LPoint3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3f::LPoint3f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LPoint3f", (char **)keyword_list, &param0)) {
          LPoint3f *return_value = new LPoint3f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3f::LPoint3f(LPoint3f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3f", (char **)keyword_list, &param0)) {
          LPoint3f param0_local;
          LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint3f *return_value = new LPoint3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3f::LPoint3f(LVecBase3f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3f", (char **)keyword_list, &param0)) {
          LVecBase3f param0_local;
          LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint3f *return_value = new LPoint3f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint3f::LPoint3f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LPoint3f", (char **)keyword_list, &param0, &param1)) {
        LVecBase2f param0_local;
        LVecBase2f const *param0_this = Dtool_Coerce_LVecBase2f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPoint3f.LPoint3f", "LVecBase2f");
          return -1;
        }
        LPoint3f *return_value = new LPoint3f(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f::LPoint3f(float x, float y, float z)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:LPoint3f", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f *return_value = new LPoint3f((float)param0, (float)param1, (float)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint3f() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint3f()\n"
      "LPoint3f(const LPoint3f param0)\n"
      "LPoint3f(const LVecBase3f copy)\n"
      "LPoint3f(float fill_value)\n"
      "LPoint3f(const LVecBase2f copy, float z)\n"
      "LPoint3f(float x, float y, float z)\n");
  }
  return -1;
}

LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  LPoint3f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint3f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint3f::LPoint3f(LVecBase3f const &copy)
      LVecBase3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint3f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint3f::LPoint3f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LPoint3f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LPoint3f", &param0, &param1)) {
          LVecBase2f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LPoint3f(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPoint3f::LPoint3f(float x, float y, float z)
        float param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "fff:LPoint3f", &param0, &param1, &param2)) {
          coerced = LPoint3f((float)param0, (float)param1, (float)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint3f) {
    printf("LPoint3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint3f *local_this = (LPoint3f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase3f) {
    return (LVecBase3f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase3f) {
    LVecBase3f* other_this = (LVecBase3f*)from_this;
    return (LPoint3f*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint3d
 */
/**
 * Python function wrapper for:
 * static inline LPoint3d const &LPoint3d::zero(void)
 */
static PyObject *Dtool_LPoint3d_zero_688(PyObject *, PyObject *) {
  // 1-static inline LPoint3d const &LPoint3d::zero(void)
  LPoint3d const *return_value = &(LPoint3d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_zero_688_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint3d_zero_688_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3d const &LPoint3d::unit_x(void)
 */
static PyObject *Dtool_LPoint3d_unit_x_689(PyObject *, PyObject *) {
  // 1-static inline LPoint3d const &LPoint3d::unit_x(void)
  LPoint3d const *return_value = &(LPoint3d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_unit_x_689_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint3d_unit_x_689_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3d const &LPoint3d::unit_y(void)
 */
static PyObject *Dtool_LPoint3d_unit_y_690(PyObject *, PyObject *) {
  // 1-static inline LPoint3d const &LPoint3d::unit_y(void)
  LPoint3d const *return_value = &(LPoint3d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_unit_y_690_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint3d_unit_y_690_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3d const &LPoint3d::unit_z(void)
 */
static PyObject *Dtool_LPoint3d_unit_z_691(PyObject *, PyObject *) {
  // 1-static inline LPoint3d const &LPoint3d::unit_z(void)
  LPoint3d const *return_value = &(LPoint3d::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_unit_z_691_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z point.\n"
  " */";
#else
static const char *Dtool_LPoint3d_unit_z_691_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d LPoint3d::get_xy(void) const
 */
static PyObject *Dtool_LPoint3d_get_xy_692(PyObject *self, PyObject *) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d LPoint3d::get_xy(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint3d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_get_xy_692_comment =
  "C++ Interface:\n"
  "get_xy(LPoint3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3d_get_xy_692_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d LPoint3d::get_xz(void) const
 */
static PyObject *Dtool_LPoint3d_get_xz_693(PyObject *self, PyObject *) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d LPoint3d::get_xz(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint3d*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_get_xz_693_comment =
  "C++ Interface:\n"
  "get_xz(LPoint3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3d_get_xz_693_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d LPoint3d::get_yz(void) const
 */
static PyObject *Dtool_LPoint3d_get_yz_694(PyObject *self, PyObject *) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d LPoint3d::get_yz(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint3d*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_get_yz_694_comment =
  "C++ Interface:\n"
  "get_yz(LPoint3d self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3d_get_yz_694_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const
 */
static PyObject *Dtool_LPoint3d_cross_701(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint3d.cross", "LVecBase3d");
  }
  LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LPoint3d self, const LVecBase3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_cross_701_comment =
  "C++ Interface:\n"
  "cross(LPoint3d self, const LVecBase3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPoint3d_cross_701_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LPoint3d::normalized(void) const
 */
static PyObject *Dtool_LPoint3d_normalized_702(PyObject *self, PyObject *) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d LPoint3d::normalized(void) const
  LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_normalized_702_comment =
  "C++ Interface:\n"
  "normalized(LPoint3d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LPoint3d_normalized_702_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const
 */
static PyObject *Dtool_LPoint3d_project_703(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint3d.project", "LVecBase3d");
  }
  LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPoint3d self, const LVecBase3d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_project_703_comment =
  "C++ Interface:\n"
  "project(LPoint3d self, const LVecBase3d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LPoint3d_project_703_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LPoint3d_origin_706(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:origin", (char **)keyword_list, &param0)) {
    LPoint3d const *return_value = &(LPoint3d::origin((CoordinateSystem)param0));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "origin(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_origin_706_comment =
  "C++ Interface:\n"
  "origin(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the origin of the indicated coordinate system.  This is always 0,\n"
  " * 0, 0 with all of our existing coordinate systems; it's hard to imagine it\n"
  " * ever being different.\n"
  " */";
#else
static const char *Dtool_LPoint3d_origin_706_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LPoint3d_rfu_707(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default)
  double param0;
  double param1;
  double param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"right", "fwd", "up", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|i:rfu", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LPoint3d *return_value = new LPoint3d(LPoint3d::rfu((double)param0, (double)param1, (double)param2, (CoordinateSystem)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rfu(double right, double fwd, double up, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_rfu_707_comment =
  "C++ Interface:\n"
  "rfu(double right, double fwd, double up, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a point described by right, forward, up displacements from the\n"
  " * origin, wherever that maps to in the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LPoint3d_rfu_707_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint3d::get_class_type(void)
 */
static PyObject *Dtool_LPoint3d_get_class_type_709(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint3d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint3d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3d_get_class_type_709_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint3d_get_class_type_709_comment = NULL;
#endif

static PyObject *Dtool_LPoint3d_xy_Getter(PyObject *self, void *) {
  const LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2d LPoint3d::get_xy(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint3d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

static PyObject *Dtool_LPoint3d_xz_Getter(PyObject *self, void *) {
  const LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2d LPoint3d::get_xz(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint3d*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

static PyObject *Dtool_LPoint3d_yz_Getter(PyObject *self, void *) {
  const LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2d LPoint3d::get_yz(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint3d*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

/**
 * Python function wrapper for:
 * inline LPoint3d::LPoint3d(void) = default
 * inline LPoint3d::LPoint3d(LPoint3d const &) = default
 * inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z)
 * inline LPoint3d::LPoint3d(LVecBase3d const &copy)
 * inline LPoint3d::LPoint3d(double fill_value)
 * inline LPoint3d::LPoint3d(double x, double y, double z)
 */
static int Dtool_Init_LPoint3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint3d::LPoint3d(void) = default
      LPoint3d *return_value = new LPoint3d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint3d::LPoint3d(LPoint3d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3d", (char **)keyword_list, &param0)) {
          LPoint3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint3d *return_value = new LPoint3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3d::LPoint3d(LVecBase3d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3d", (char **)keyword_list, &param0)) {
          LVecBase3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint3d *return_value = new LPoint3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3d::LPoint3d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LPoint3d", (char **)keyword_list, &param0)) {
          LPoint3d *return_value = new LPoint3d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3d::LPoint3d(LPoint3d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3d", (char **)keyword_list, &param0)) {
          LPoint3d param0_local;
          LPoint3d const *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint3d *return_value = new LPoint3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3d::LPoint3d(LVecBase3d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3d", (char **)keyword_list, &param0)) {
          LVecBase3d param0_local;
          LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint3d *return_value = new LPoint3d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint3d::LPoint3d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LPoint3d", (char **)keyword_list, &param0, &param1)) {
        LVecBase2d param0_local;
        LVecBase2d const *param0_this = Dtool_Coerce_LVecBase2d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPoint3d.LPoint3d", "LVecBase2d");
          return -1;
        }
        LPoint3d *return_value = new LPoint3d(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3d::LPoint3d(double x, double y, double z)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:LPoint3d", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3d *return_value = new LPoint3d((double)param0, (double)param1, (double)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint3d() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint3d()\n"
      "LPoint3d(const LPoint3d param0)\n"
      "LPoint3d(const LVecBase3d copy)\n"
      "LPoint3d(double fill_value)\n"
      "LPoint3d(const LVecBase2d copy, double z)\n"
      "LPoint3d(double x, double y, double z)\n");
  }
  return -1;
}

LPoint3d *Dtool_Coerce_LPoint3d(PyObject *args, LPoint3d &coerced) {
  LPoint3d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint3d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint3d::LPoint3d(LVecBase3d const &copy)
      LVecBase3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint3d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint3d::LPoint3d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LPoint3d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LPoint3d", &param0, &param1)) {
          LVecBase2d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LPoint3d(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPoint3d::LPoint3d(double x, double y, double z)
        double param0;
        double param1;
        double param2;
        if (PyArg_ParseTuple(args, "ddd:LPoint3d", &param0, &param1, &param2)) {
          coerced = LPoint3d((double)param0, (double)param1, (double)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint3d) {
    printf("LPoint3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint3d *local_this = (LPoint3d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase3d) {
    return (LVecBase3d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase3d) {
    LVecBase3d* other_this = (LVecBase3d*)from_this;
    return (LPoint3d*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint3i
 */
/**
 * Python function wrapper for:
 * static inline LPoint3i const &LPoint3i::zero(void)
 */
static PyObject *Dtool_LPoint3i_zero_715(PyObject *, PyObject *) {
  // 1-static inline LPoint3i const &LPoint3i::zero(void)
  LPoint3i const *return_value = &(LPoint3i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_zero_715_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint3i_zero_715_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3i const &LPoint3i::unit_x(void)
 */
static PyObject *Dtool_LPoint3i_unit_x_716(PyObject *, PyObject *) {
  // 1-static inline LPoint3i const &LPoint3i::unit_x(void)
  LPoint3i const *return_value = &(LPoint3i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_unit_x_716_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint3i_unit_x_716_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3i const &LPoint3i::unit_y(void)
 */
static PyObject *Dtool_LPoint3i_unit_y_717(PyObject *, PyObject *) {
  // 1-static inline LPoint3i const &LPoint3i::unit_y(void)
  LPoint3i const *return_value = &(LPoint3i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_unit_y_717_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint3i_unit_y_717_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3i const &LPoint3i::unit_z(void)
 */
static PyObject *Dtool_LPoint3i_unit_z_718(PyObject *, PyObject *) {
  // 1-static inline LPoint3i const &LPoint3i::unit_z(void)
  LPoint3i const *return_value = &(LPoint3i::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_unit_z_718_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z point.\n"
  " */";
#else
static const char *Dtool_LPoint3i_unit_z_718_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2i LPoint3i::get_xy(void) const
 */
static PyObject *Dtool_LPoint3i_get_xy_719(PyObject *self, PyObject *) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2i LPoint3i::get_xy(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint3i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_get_xy_719_comment =
  "C++ Interface:\n"
  "get_xy(LPoint3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3i_get_xy_719_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2i LPoint3i::get_xz(void) const
 */
static PyObject *Dtool_LPoint3i_get_xz_720(PyObject *self, PyObject *) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2i LPoint3i::get_xz(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint3i*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_get_xz_720_comment =
  "C++ Interface:\n"
  "get_xz(LPoint3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the first and last components\n"
  " * of this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3i_get_xz_720_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2i LPoint3i::get_yz(void) const
 */
static PyObject *Dtool_LPoint3i_get_yz_721(PyObject *self, PyObject *) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2i LPoint3i::get_yz(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint3i*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_get_yz_721_comment =
  "C++ Interface:\n"
  "get_yz(LPoint3i self)\n"
  "\n"
  "/**\n"
  " * Returns a 2-component vector that shares just the last two components of\n"
  " * this vector.\n"
  " */";
#else
static const char *Dtool_LPoint3i_get_yz_721_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const
 */
static PyObject *Dtool_LPoint3i_cross_728(PyObject *self, PyObject *arg) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint3i.cross", "LVecBase3i");
  }
  LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).cross(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cross(LPoint3i self, const LVecBase3i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_cross_728_comment =
  "C++ Interface:\n"
  "cross(LPoint3i self, const LVecBase3i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LPoint3i_cross_728_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LPoint3i_origin_731(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default)
  int param0 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:origin", (char **)keyword_list, &param0)) {
    LPoint3i const *return_value = &(LPoint3i::origin((CoordinateSystem)param0));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "origin(int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_origin_731_comment =
  "C++ Interface:\n"
  "origin(int cs)\n"
  "\n"
  "/**\n"
  " * Returns the origin of the indicated coordinate system.  This is always 0,\n"
  " * 0, 0 with all of our existing coordinate systems; it's hard to imagine it\n"
  " * ever being different.\n"
  " */";
#else
static const char *Dtool_LPoint3i_origin_731_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LPoint3i_rfu_732(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default)
  int param0;
  int param1;
  int param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"right", "fwd", "up", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii|i:rfu", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    LPoint3i *return_value = new LPoint3i(LPoint3i::rfu((int)param0, (int)param1, (int)param2, (CoordinateSystem)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rfu(int right, int fwd, int up, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_rfu_732_comment =
  "C++ Interface:\n"
  "rfu(int right, int fwd, int up, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a point described by right, forward, up displacements from the\n"
  " * origin, wherever that maps to in the given coordinate system.\n"
  " */";
#else
static const char *Dtool_LPoint3i_rfu_732_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint3i::get_class_type(void)
 */
static PyObject *Dtool_LPoint3i_get_class_type_734(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint3i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint3i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint3i_get_class_type_734_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint3i_get_class_type_734_comment = NULL;
#endif

static PyObject *Dtool_LPoint3i_xy_Getter(PyObject *self, void *) {
  const LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2i LPoint3i::get_xy(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint3i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

static PyObject *Dtool_LPoint3i_xz_Getter(PyObject *self, void *) {
  const LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2i LPoint3i::get_xz(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint3i*)local_this).get_xz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

static PyObject *Dtool_LPoint3i_yz_Getter(PyObject *self, void *) {
  const LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2i LPoint3i::get_yz(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint3i*)local_this).get_yz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

/**
 * Python function wrapper for:
 * inline LPoint3i::LPoint3i(void) = default
 * inline LPoint3i::LPoint3i(LPoint3i const &) = default
 * inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z)
 * inline LPoint3i::LPoint3i(LVecBase3i const &copy)
 * inline LPoint3i::LPoint3i(int fill_value)
 * inline LPoint3i::LPoint3i(int x, int y, int z)
 */
static int Dtool_Init_LPoint3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint3i::LPoint3i(void) = default
      LPoint3i *return_value = new LPoint3i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint3i::LPoint3i(LPoint3i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3i", (char **)keyword_list, &param0)) {
          LPoint3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint3i *return_value = new LPoint3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3i::LPoint3i(LVecBase3i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3i", (char **)keyword_list, &param0)) {
          LVecBase3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint3i *return_value = new LPoint3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3i::LPoint3i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LPoint3i", (char **)keyword_list, &param0)) {
          LPoint3i *return_value = new LPoint3i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3i::LPoint3i(LPoint3i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3i", (char **)keyword_list, &param0)) {
          LPoint3i param0_local;
          LPoint3i const *param0_this = Dtool_Coerce_LPoint3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint3i *return_value = new LPoint3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint3i::LPoint3i(LVecBase3i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint3i", (char **)keyword_list, &param0)) {
          LVecBase3i param0_local;
          LVecBase3i const *param0_this = Dtool_Coerce_LVecBase3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint3i *return_value = new LPoint3i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint3i::LPoint3i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"copy", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:LPoint3i", (char **)keyword_list, &param0, &param1)) {
        LVecBase2i param0_local;
        LVecBase2i const *param0_this = Dtool_Coerce_LVecBase2i(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPoint3i.LPoint3i", "LVecBase2i");
          return -1;
        }
        LPoint3i *return_value = new LPoint3i(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3i::LPoint3i(int x, int y, int z)
      int param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"x", "y", "z", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:LPoint3i", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3i *return_value = new LPoint3i((int)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint3i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint3i() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint3i()\n"
      "LPoint3i(const LPoint3i param0)\n"
      "LPoint3i(const LVecBase3i copy)\n"
      "LPoint3i(int fill_value)\n"
      "LPoint3i(const LVecBase2i copy, int z)\n"
      "LPoint3i(int x, int y, int z)\n");
  }
  return -1;
}

LPoint3i *Dtool_Coerce_LPoint3i(PyObject *args, LPoint3i &coerced) {
  LPoint3i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint3i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint3i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint3i::LPoint3i(LVecBase3i const &copy)
      LVecBase3i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint3i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint3i::LPoint3i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LPoint3i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:LPoint3i", &param0, &param1)) {
          LVecBase2i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase2i, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LPoint3i(*param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LPoint3i::LPoint3i(int x, int y, int z)
        int param0;
        int param1;
        int param2;
        if (PyArg_ParseTuple(args, "iii:LPoint3i", &param0, &param1, &param2)) {
          coerced = LPoint3i((int)param0, (int)param1, (int)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint3i) {
    printf("LPoint3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint3i *local_this = (LPoint3i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase3i) {
    return (LVecBase3i *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase3i) {
    LVecBase3i* other_this = (LVecBase3i*)from_this;
    return (LPoint3i*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase4f
 */
/**
 * Python function wrapper for:
 * LVecBase4f &LVecBase4f::operator =(LVecBase4f const &copy) = default
 * LVecBase4f &LVecBase4f::operator =(float fill_value) = default
 */
static PyObject *Dtool_LVecBase4f_operator_742(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase4f &LVecBase4f::operator =(LVecBase4f const &copy) = default
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, false);
    }
  }

  {
    // -2 LVecBase4f &LVecBase4f::operator =(float fill_value) = default
    if (PyNumber_Check(arg)) {
      (*local_this).operator =((float)PyFloat_AsDouble(arg));
      LVecBase4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, false);
    }
  }

  {
    // -2 LVecBase4f &LVecBase4f::operator =(LVecBase4f const &copy) = default
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, false);
    }
  }

  // No coercion possible: LVecBase4f &LVecBase4f::operator =(float fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase4f self, const LVecBase4f copy)\n"
      "assign(const LVecBase4f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_operator_742_comment =
  "C++ Interface:\n"
  "assign(const LVecBase4f self, const LVecBase4f copy)\n"
  "assign(const LVecBase4f self, float fill_value)\n";
#else
static const char *Dtool_LVecBase4f_operator_742_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4f const &LVecBase4f::zero(void)
 */
static PyObject *Dtool_LVecBase4f_zero_743(PyObject *, PyObject *) {
  // 1-static inline LVecBase4f const &LVecBase4f::zero(void)
  LVecBase4f const *return_value = &(LVecBase4f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_zero_743_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_zero_743_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4f const &LVecBase4f::unit_x(void)
 */
static PyObject *Dtool_LVecBase4f_unit_x_744(PyObject *, PyObject *) {
  // 1-static inline LVecBase4f const &LVecBase4f::unit_x(void)
  LVecBase4f const *return_value = &(LVecBase4f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_unit_x_744_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_unit_x_744_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4f const &LVecBase4f::unit_y(void)
 */
static PyObject *Dtool_LVecBase4f_unit_y_745(PyObject *, PyObject *) {
  // 1-static inline LVecBase4f const &LVecBase4f::unit_y(void)
  LVecBase4f const *return_value = &(LVecBase4f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_unit_y_745_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_unit_y_745_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4f const &LVecBase4f::unit_z(void)
 */
static PyObject *Dtool_LVecBase4f_unit_z_746(PyObject *, PyObject *) {
  // 1-static inline LVecBase4f const &LVecBase4f::unit_z(void)
  LVecBase4f const *return_value = &(LVecBase4f::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_unit_z_746_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_unit_z_746_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4f const &LVecBase4f::unit_w(void)
 */
static PyObject *Dtool_LVecBase4f_unit_w_747(PyObject *, PyObject *) {
  // 1-static inline LVecBase4f const &LVecBase4f::unit_w(void)
  LVecBase4f const *return_value = &(LVecBase4f::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_unit_w_747_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_unit_w_747_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase4f::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase4f_reduce_748(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase4f::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase4f*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_reduce_748_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase4f self)\n";
#else
static const char *Dtool_LVecBase4f_reduce_748_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4f::is_nan(void) const
 */
static PyObject *Dtool_LVecBase4f_is_nan_753(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase4f::is_nan(void) const
  bool return_value = (*(const LVecBase4f*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_is_nan_753_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_is_nan_753_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase4f_get_cell_754(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    float return_value = (*(const LVecBase4f*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase4f self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_cell_754_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase4f self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_cell_754_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::set_cell(int i, float value)
 */
static PyObject *Dtool_LVecBase4f_set_cell_755(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::set_cell(int i, float value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase4f self, int i, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_set_cell_755_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase4f self, int i, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_set_cell_755_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::get_x(void) const
 */
static PyObject *Dtool_LVecBase4f_get_x_756(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::get_x(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_x_756_comment =
  "C++ Interface:\n"
  "get_x(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_x_756_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::get_y(void) const
 */
static PyObject *Dtool_LVecBase4f_get_y_757(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::get_y(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_y_757_comment =
  "C++ Interface:\n"
  "get_y(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_y_757_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::get_z(void) const
 */
static PyObject *Dtool_LVecBase4f_get_z_758(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::get_z(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_z_758_comment =
  "C++ Interface:\n"
  "get_z(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_z_758_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::get_w(void) const
 */
static PyObject *Dtool_LVecBase4f_get_w_759(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::get_w(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_w_759_comment =
  "C++ Interface:\n"
  "get_w(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_w_759_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LVecBase4f::get_xyz(void) const
 */
static PyObject *Dtool_LVecBase4f_get_xyz_760(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LVecBase4f::get_xyz(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase4f*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_xyz_760_comment =
  "C++ Interface:\n"
  "get_xyz(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_xyz_760_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LVecBase4f::get_xy(void) const
 */
static PyObject *Dtool_LVecBase4f_get_xy_761(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LVecBase4f::get_xy(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase4f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_xy_761_comment =
  "C++ Interface:\n"
  "get_xy(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_xy_761_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::set_x(float value)
 */
static PyObject *Dtool_LVecBase4f_set_x_762(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::set_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_set_x_762_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_set_x_762_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::set_y(float value)
 */
static PyObject *Dtool_LVecBase4f_set_y_763(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::set_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_set_y_763_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_set_y_763_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::set_z(float value)
 */
static PyObject *Dtool_LVecBase4f_set_z_764(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.set_z")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::set_z(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_set_z_764_comment =
  "C++ Interface:\n"
  "set_z(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_set_z_764_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::set_w(float value)
 */
static PyObject *Dtool_LVecBase4f_set_w_765(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.set_w")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::set_w(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_w((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_w(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_set_w_765_comment =
  "C++ Interface:\n"
  "set_w(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_set_w_765_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::add_to_cell(int i, float value)
 */
static PyObject *Dtool_LVecBase4f_add_to_cell_771(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::add_to_cell(int i, float value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase4f self, int i, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_add_to_cell_771_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase4f self, int i, float value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_add_to_cell_771_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::add_x(float value)
 */
static PyObject *Dtool_LVecBase4f_add_x_772(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::add_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_x((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_add_x_772_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_add_x_772_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::add_y(float value)
 */
static PyObject *Dtool_LVecBase4f_add_y_773(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::add_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_y((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_add_y_773_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_add_y_773_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::add_z(float value)
 */
static PyObject *Dtool_LVecBase4f_add_z_774(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.add_z")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::add_z(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_z((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_add_z_774_comment =
  "C++ Interface:\n"
  "add_z(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_add_z_774_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::add_w(float value)
 */
static PyObject *Dtool_LVecBase4f_add_w_775(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.add_w")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::add_w(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_w((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_w(const LVecBase4f self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_add_w_775_comment =
  "C++ Interface:\n"
  "add_w(const LVecBase4f self, float value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_add_w_775_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase4f::get_num_components(void)
 */
static PyObject *Dtool_LVecBase4f_get_num_components_777(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase4f::get_num_components(void)
  int return_value = LVecBase4f::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_num_components_777_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, four.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_num_components_777_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::fill(float fill_value)
 */
static PyObject *Dtool_LVecBase4f_fill_779(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::fill(float fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase4f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_fill_779_comment =
  "C++ Interface:\n"
  "fill(const LVecBase4f self, float fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_fill_779_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::set(float x, float y, float z, float w)
 */
static PyObject *Dtool_LVecBase4f_set_780(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.set")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::set(float x, float y, float z, float w)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase4f self, float x, float y, float z, float w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_set_780_comment =
  "C++ Interface:\n"
  "set(const LVecBase4f self, float x, float y, float z, float w)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_set_780_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::dot(LVecBase4f const &other) const
 */
static PyObject *Dtool_LVecBase4f_dot_781(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::dot(LVecBase4f const &other) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.dot", "LVecBase4f");
  }
  float return_value = (*(const LVecBase4f*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase4f self, const LVecBase4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_dot_781_comment =
  "C++ Interface:\n"
  "dot(LVecBase4f self, const LVecBase4f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_dot_781_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::length_squared(void) const
 */
static PyObject *Dtool_LVecBase4f_length_squared_782(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::length_squared(void) const
  float return_value = (*(const LVecBase4f*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_length_squared_782_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_length_squared_782_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LVecBase4f::length(void) const
 */
static PyObject *Dtool_LVecBase4f_length_783(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LVecBase4f::length(void) const
  float return_value = (*(const LVecBase4f*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_length_783_comment =
  "C++ Interface:\n"
  "length(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the vector, by the Pythagorean theorem.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_length_783_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4f::normalize(void)
 */
static PyObject *Dtool_LVecBase4f_normalize_784(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.normalize")) {
    return NULL;
  }
  // 1-inline bool LVecBase4f::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_normalize_784_comment =
  "C++ Interface:\n"
  "normalize(const LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector in place.  Returns true if the vector was normalized,\n"
  " * false if it was a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_normalize_784_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f LVecBase4f::normalized(void) const
 */
static PyObject *Dtool_LVecBase4f_normalized_785(PyObject *self, PyObject *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f LVecBase4f::normalized(void) const
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_normalized_785_comment =
  "C++ Interface:\n"
  "normalized(LVecBase4f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_normalized_785_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const
 */
static PyObject *Dtool_LVecBase4f_project_786(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.project", "LVecBase4f");
  }
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVecBase4f self, const LVecBase4f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_project_786_comment =
  "C++ Interface:\n"
  "project(LVecBase4f self, const LVecBase4f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_project_786_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4f::compare_to(LVecBase4f const &other) const
 * inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const
 */
static PyObject *Dtool_LVecBase4f_compare_to_790(PyObject *self, PyObject *args) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LVecBase4f::compare_to(LVecBase4f const &other) const
      LVecBase4f arg_local;
      LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.compare_to", "LVecBase4f");
      }
      int return_value = (*(const LVecBase4f*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const
      PyObject *param1;
      float param2;
      if (PyArg_ParseTuple(args, "Of:compare_to", &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4f const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase4f.compare_to", "LVecBase4f");
        }
        int return_value = (*(const LVecBase4f*)local_this).compare_to(*param1_this, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase4f self, const LVecBase4f other)\n"
      "compare_to(LVecBase4f self, const LVecBase4f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_compare_to_790_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase4f self, const LVecBase4f other)\n"
  "compare_to(LVecBase4f self, const LVecBase4f other, float threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts vectors lexicographically, componentwise.  Returns a number less than\n"
  " * 0 if this vector sorts before the other one, greater than zero if it sorts\n"
  " * after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LVecBase4f_compare_to_790_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase4f::get_hash(void) const
 * inline std::size_t LVecBase4f::get_hash(float threshold) const
 */
static PyObject *Dtool_LVecBase4f_get_hash_791(PyObject *self, PyObject *args) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LVecBase4f::get_hash(void) const
      std::size_t return_value = (*(const LVecBase4f*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LVecBase4f::get_hash(float threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LVecBase4f*)local_this).get_hash((float)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LVecBase4f self)\n"
      "get_hash(LVecBase4f self, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_hash_791_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase4f self)\n"
  "get_hash(LVecBase4f self, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_get_hash_791_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase4f::add_hash(std::size_t hash) const
 * inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const
 */
static PyObject *Dtool_LVecBase4f_add_hash_792(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LVecBase4f::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase4f*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const
      Py_ssize_t param1;
      float param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nf:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase4f*)local_this).add_hash((std::size_t)param1, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase4f self, int hash)\n"
      "add_hash(LVecBase4f self, int hash, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_add_hash_792_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase4f self, int hash)\n"
  "add_hash(LVecBase4f self, int hash, float threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_add_hash_792_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::componentwise_mult(LVecBase4f const &other)
 */
static PyObject *Dtool_LVecBase4f_componentwise_mult_803(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::componentwise_mult(LVecBase4f const &other)
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.componentwise_mult", "LVecBase4f");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase4f self, const LVecBase4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_componentwise_mult_803_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase4f self, const LVecBase4f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_componentwise_mult_803_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const
 */
static PyObject *Dtool_LVecBase4f_fmax_806(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.fmax", "LVecBase4f");
  }
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase4f self, const LVecBase4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_fmax_806_comment =
  "C++ Interface:\n"
  "fmax(LVecBase4f self, const LVecBase4f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_fmax_806_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const
 */
static PyObject *Dtool_LVecBase4f_fmin_807(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.fmin", "LVecBase4f");
  }
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase4f self, const LVecBase4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_fmin_807_comment =
  "C++ Interface:\n"
  "fmin(LVecBase4f self, const LVecBase4f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_fmin_807_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const
 * inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const
 */
static PyObject *Dtool_LVecBase4f_almost_equal_808(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const
      LVecBase4f arg_local;
      LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.almost_equal", "LVecBase4f");
      }
      bool return_value = (*(const LVecBase4f*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4f const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase4f.almost_equal", "LVecBase4f");
        }
        bool return_value = (*(const LVecBase4f*)local_this).almost_equal(*param1_this, (float)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase4f self, const LVecBase4f other)\n"
      "almost_equal(LVecBase4f self, const LVecBase4f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_almost_equal_808_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase4f self, const LVecBase4f other)\n"
  "almost_equal(LVecBase4f self, const LVecBase4f other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_almost_equal_808_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase4f_output_809(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4f::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase4f.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase4f*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase4f self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_output_809_comment =
  "C++ Interface:\n"
  "output(LVecBase4f self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4f_output_809_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase4f_write_datagram_fixed_811(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase4f*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase4f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_write_datagram_fixed_811_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase4f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_write_datagram_fixed_811_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase4f_read_datagram_fixed_812(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase4f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_read_datagram_fixed_812_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase4f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase4f_read_datagram_fixed_812_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase4f_write_datagram_813(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4f::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.write_datagram", "Datagram");
  }
  (*(const LVecBase4f*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase4f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_write_datagram_813_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase4f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase4f_write_datagram_813_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4f::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase4f_read_datagram_814(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase4f::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase4f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_read_datagram_814_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase4f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase4f_read_datagram_814_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase4f::get_class_type(void)
 */
static PyObject *Dtool_LVecBase4f_get_class_type_815(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase4f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase4f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4f_get_class_type_815_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase4f_get_class_type_815_comment = NULL;
#endif

static PyObject *Dtool_LVecBase4f_x_Getter(PyObject *self, void *) {
  const LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase4f::get_x(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4f_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase4f::set_x(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase4f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4f_y_Getter(PyObject *self, void *) {
  const LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase4f::get_y(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4f_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase4f::set_y(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase4f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4f_z_Getter(PyObject *self, void *) {
  const LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline float LVecBase4f::get_z(void) const
  float return_value = (*(const LVecBase4f*)local_this).get_z();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4f_z_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4f, (void **)&local_this, "LVecBase4f.z")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete z attribute");
    return -1;
  }
  // 1-inline void LVecBase4f::set_z(float value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase4f self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4f_xyz_Getter(PyObject *self, void *) {
  const LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3f LVecBase4f::get_xyz(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase4f*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

static PyObject *Dtool_LVecBase4f_xy_Getter(PyObject *self, void *) {
  const LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2f LVecBase4f::get_xy(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase4f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
}

/**
 * Python function wrapper for:
 * inline LVecBase4f::LVecBase4f(void) = default
 * inline LVecBase4f::LVecBase4f(LPoint3f const &point)
 * inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w)
 * inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default
 * inline LVecBase4f::LVecBase4f(LVector3f const &vector)
 * inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy)
 * inline LVecBase4f::LVecBase4f(float fill_value)
 * inline LVecBase4f::LVecBase4f(float x, float y, float z, float w)
 */
static int Dtool_Init_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase4f::LVecBase4f(void) = default
      LVecBase4f *return_value = new LVecBase4f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase4f::LVecBase4f(LPoint3f const &point)
        PyObject *param0;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          LPoint3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(LVector3f const &vector)
        PyObject *param0;
        static const char *keyword_list[] = {"vector", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          LVector3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LVecBase4f", (char **)keyword_list, &param0)) {
          LVecBase4f *return_value = new LVecBase4f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(LPoint3f const &point)
        PyObject *param0;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          LPoint3f param0_local;
          LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(LVector3f const &vector)
        PyObject *param0;
        static const char *keyword_list[] = {"vector", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          LVector3f param0_local;
          LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4f", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4f param0_local;
          UnalignedLVecBase4f const *param0_this = Dtool_Coerce_UnalignedLVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4f *return_value = new LVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase4f::LVecBase4f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LVecBase4f", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVecBase4f.LVecBase4f", "LVecBase3f");
          return -1;
        }
        LVecBase4f *return_value = new LVecBase4f(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVecBase4f::LVecBase4f(float x, float y, float z, float w)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LVecBase4f", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVecBase4f *return_value = new LVecBase4f((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase4f() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase4f()\n"
      "LVecBase4f(const LPoint3f point)\n"
      "LVecBase4f(const LVector3f vector)\n"
      "LVecBase4f(const LVecBase4f param0)\n"
      "LVecBase4f(const UnalignedLVecBase4f copy)\n"
      "LVecBase4f(float fill_value)\n"
      "LVecBase4f(const LVecBase3f copy, float w)\n"
      "LVecBase4f(float x, float y, float z, float w)\n");
  }
  return -1;
}

LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  LVecBase4f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase4f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVecBase4f::LVecBase4f(LPoint3f const &point)
      LPoint3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4f::LVecBase4f(LVector3f const &vector)
      LVector3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy)
      UnalignedLVecBase4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLVecBase4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4f::LVecBase4f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVecBase4f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LVecBase4f", &param0, &param1)) {
          LVecBase3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVecBase4f(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LVecBase4f::LVecBase4f(float x, float y, float z, float w)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LVecBase4f", &param0, &param1, &param2, &param3)) {
          coerced = LVecBase4f((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase4f) {
    printf("LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase4f *local_this = (LVecBase4f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UnalignedLVecBase4f
 */
/**
 * Python function wrapper for:
 * inline void UnalignedLVecBase4f::set(float x, float y, float z, float w)
 */
static PyObject *Dtool_UnalignedLVecBase4f_set_820(PyObject *self, PyObject *args, PyObject *kwds) {
  UnalignedLVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLVecBase4f, (void **)&local_this, "UnalignedLVecBase4f.set")) {
    return NULL;
  }
  // 1-inline void UnalignedLVecBase4f::set(float x, float y, float z, float w)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set((float)param1, (float)param2, (float)param3, (float)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const UnalignedLVecBase4f self, float x, float y, float z, float w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4f_set_820_comment =
  "C++ Interface:\n"
  "set(const UnalignedLVecBase4f self, float x, float y, float z, float w)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLVecBase4f_set_820_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int UnalignedLVecBase4f::get_num_components(void)
 */
static PyObject *Dtool_UnalignedLVecBase4f_get_num_components_824(PyObject *, PyObject *) {
  // 1-static constexpr int UnalignedLVecBase4f::get_num_components(void)
  int return_value = UnalignedLVecBase4f::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4f_get_num_components_824_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, 4.\n"
  " */";
#else
static const char *Dtool_UnalignedLVecBase4f_get_num_components_824_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnalignedLVecBase4f::get_class_type(void)
 */
static PyObject *Dtool_UnalignedLVecBase4f_get_class_type_825(PyObject *, PyObject *) {
  // 1-static TypeHandle UnalignedLVecBase4f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UnalignedLVecBase4f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4f_get_class_type_825_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnalignedLVecBase4f_get_class_type_825_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default
 * inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy)
 * inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default
 * inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w)
 */
static int Dtool_Init_UnalignedLVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default
      UnalignedLVecBase4f *return_value = new UnalignedLVecBase4f();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4f", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            UnalignedLVecBase4f *return_value = new UnalignedLVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4f", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            UnalignedLVecBase4f *return_value = new UnalignedLVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4f", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            UnalignedLVecBase4f *return_value = new UnalignedLVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4f", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4f param0_local;
          UnalignedLVecBase4f const *param0_this = Dtool_Coerce_UnalignedLVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            UnalignedLVecBase4f *return_value = new UnalignedLVecBase4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4f, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
    {
      // 1-inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:UnalignedLVecBase4f", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        UnalignedLVecBase4f *return_value = new UnalignedLVecBase4f((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UnalignedLVecBase4f() takes 0, 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnalignedLVecBase4f()\n"
      "UnalignedLVecBase4f(const LVecBase4f copy)\n"
      "UnalignedLVecBase4f(const UnalignedLVecBase4f param0)\n"
      "UnalignedLVecBase4f(float x, float y, float z, float w)\n");
  }
  return -1;
}

UnalignedLVecBase4f *Dtool_Coerce_UnalignedLVecBase4f(PyObject *args, UnalignedLVecBase4f &coerced) {
  UnalignedLVecBase4f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UnalignedLVecBase4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const UnalignedLVecBase4f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = UnalignedLVecBase4f(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w)
      float param0;
      float param1;
      float param2;
      float param3;
      if (PyArg_ParseTuple(args, "ffff:UnalignedLVecBase4f", &param0, &param1, &param2, &param3)) {
        coerced = UnalignedLVecBase4f((float)param0, (float)param1, (float)param2, (float)param3);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_UnalignedLVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UnalignedLVecBase4f) {
    printf("UnalignedLVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UnalignedLVecBase4f *local_this = (UnalignedLVecBase4f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UnalignedLVecBase4f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UnalignedLVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UnalignedLVecBase4f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase4d
 */
/**
 * Python function wrapper for:
 * LVecBase4d &LVecBase4d::operator =(LVecBase4d const &copy) = default
 * LVecBase4d &LVecBase4d::operator =(double fill_value) = default
 */
static PyObject *Dtool_LVecBase4d_operator_833(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase4d &LVecBase4d::operator =(LVecBase4d const &copy) = default
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, false);
    }
  }

  {
    // -2 LVecBase4d &LVecBase4d::operator =(double fill_value) = default
    if (PyNumber_Check(arg)) {
      (*local_this).operator =(PyFloat_AsDouble(arg));
      LVecBase4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, false);
    }
  }

  {
    // -2 LVecBase4d &LVecBase4d::operator =(LVecBase4d const &copy) = default
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, false);
    }
  }

  // No coercion possible: LVecBase4d &LVecBase4d::operator =(double fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase4d self, const LVecBase4d copy)\n"
      "assign(const LVecBase4d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_operator_833_comment =
  "C++ Interface:\n"
  "assign(const LVecBase4d self, const LVecBase4d copy)\n"
  "assign(const LVecBase4d self, double fill_value)\n";
#else
static const char *Dtool_LVecBase4d_operator_833_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4d const &LVecBase4d::zero(void)
 */
static PyObject *Dtool_LVecBase4d_zero_834(PyObject *, PyObject *) {
  // 1-static inline LVecBase4d const &LVecBase4d::zero(void)
  LVecBase4d const *return_value = &(LVecBase4d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_zero_834_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_zero_834_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4d const &LVecBase4d::unit_x(void)
 */
static PyObject *Dtool_LVecBase4d_unit_x_835(PyObject *, PyObject *) {
  // 1-static inline LVecBase4d const &LVecBase4d::unit_x(void)
  LVecBase4d const *return_value = &(LVecBase4d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_unit_x_835_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_unit_x_835_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4d const &LVecBase4d::unit_y(void)
 */
static PyObject *Dtool_LVecBase4d_unit_y_836(PyObject *, PyObject *) {
  // 1-static inline LVecBase4d const &LVecBase4d::unit_y(void)
  LVecBase4d const *return_value = &(LVecBase4d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_unit_y_836_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_unit_y_836_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4d const &LVecBase4d::unit_z(void)
 */
static PyObject *Dtool_LVecBase4d_unit_z_837(PyObject *, PyObject *) {
  // 1-static inline LVecBase4d const &LVecBase4d::unit_z(void)
  LVecBase4d const *return_value = &(LVecBase4d::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_unit_z_837_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_unit_z_837_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4d const &LVecBase4d::unit_w(void)
 */
static PyObject *Dtool_LVecBase4d_unit_w_838(PyObject *, PyObject *) {
  // 1-static inline LVecBase4d const &LVecBase4d::unit_w(void)
  LVecBase4d const *return_value = &(LVecBase4d::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_unit_w_838_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_unit_w_838_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase4d::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase4d_reduce_839(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase4d::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase4d*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_reduce_839_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase4d self)\n";
#else
static const char *Dtool_LVecBase4d_reduce_839_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4d::is_nan(void) const
 */
static PyObject *Dtool_LVecBase4d_is_nan_844(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase4d::is_nan(void) const
  bool return_value = (*(const LVecBase4d*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_is_nan_844_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_is_nan_844_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase4d_get_cell_845(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const LVecBase4d*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase4d self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_cell_845_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase4d self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_cell_845_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::set_cell(int i, double value)
 */
static PyObject *Dtool_LVecBase4d_set_cell_846(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::set_cell(int i, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase4d self, int i, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_set_cell_846_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase4d self, int i, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_set_cell_846_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::get_x(void) const
 */
static PyObject *Dtool_LVecBase4d_get_x_847(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::get_x(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_x_847_comment =
  "C++ Interface:\n"
  "get_x(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_x_847_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::get_y(void) const
 */
static PyObject *Dtool_LVecBase4d_get_y_848(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::get_y(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_y_848_comment =
  "C++ Interface:\n"
  "get_y(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_y_848_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::get_z(void) const
 */
static PyObject *Dtool_LVecBase4d_get_z_849(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::get_z(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_z_849_comment =
  "C++ Interface:\n"
  "get_z(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_z_849_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::get_w(void) const
 */
static PyObject *Dtool_LVecBase4d_get_w_850(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::get_w(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_w_850_comment =
  "C++ Interface:\n"
  "get_w(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_w_850_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LVecBase4d::get_xyz(void) const
 */
static PyObject *Dtool_LVecBase4d_get_xyz_851(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LVecBase4d::get_xyz(void) const
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase4d*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_xyz_851_comment =
  "C++ Interface:\n"
  "get_xyz(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_xyz_851_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LVecBase4d::get_xy(void) const
 */
static PyObject *Dtool_LVecBase4d_get_xy_852(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LVecBase4d::get_xy(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase4d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_xy_852_comment =
  "C++ Interface:\n"
  "get_xy(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_xy_852_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::set_x(double value)
 */
static PyObject *Dtool_LVecBase4d_set_x_853(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::set_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_set_x_853_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_set_x_853_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::set_y(double value)
 */
static PyObject *Dtool_LVecBase4d_set_y_854(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::set_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_set_y_854_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_set_y_854_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::set_z(double value)
 */
static PyObject *Dtool_LVecBase4d_set_z_855(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.set_z")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::set_z(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_set_z_855_comment =
  "C++ Interface:\n"
  "set_z(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_set_z_855_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::set_w(double value)
 */
static PyObject *Dtool_LVecBase4d_set_w_856(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.set_w")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::set_w(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_w(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_w(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_set_w_856_comment =
  "C++ Interface:\n"
  "set_w(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_set_w_856_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::add_to_cell(int i, double value)
 */
static PyObject *Dtool_LVecBase4d_add_to_cell_862(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::add_to_cell(int i, double value)
  int param1;
  double param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "id:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase4d self, int i, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_add_to_cell_862_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase4d self, int i, double value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_add_to_cell_862_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::add_x(double value)
 */
static PyObject *Dtool_LVecBase4d_add_x_863(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::add_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_x(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_add_x_863_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_add_x_863_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::add_y(double value)
 */
static PyObject *Dtool_LVecBase4d_add_y_864(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::add_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_y(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_add_y_864_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_add_y_864_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::add_z(double value)
 */
static PyObject *Dtool_LVecBase4d_add_z_865(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.add_z")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::add_z(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_z(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_add_z_865_comment =
  "C++ Interface:\n"
  "add_z(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_add_z_865_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::add_w(double value)
 */
static PyObject *Dtool_LVecBase4d_add_w_866(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.add_w")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::add_w(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_w(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_w(const LVecBase4d self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_add_w_866_comment =
  "C++ Interface:\n"
  "add_w(const LVecBase4d self, double value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_add_w_866_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase4d::get_num_components(void)
 */
static PyObject *Dtool_LVecBase4d_get_num_components_868(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase4d::get_num_components(void)
  int return_value = LVecBase4d::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_num_components_868_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, four.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_num_components_868_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::fill(double fill_value)
 */
static PyObject *Dtool_LVecBase4d_fill_870(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::fill(double fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase4d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_fill_870_comment =
  "C++ Interface:\n"
  "fill(const LVecBase4d self, double fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_fill_870_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::set(double x, double y, double z, double w)
 */
static PyObject *Dtool_LVecBase4d_set_871(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.set")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::set(double x, double y, double z, double w)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:set", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase4d self, double x, double y, double z, double w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_set_871_comment =
  "C++ Interface:\n"
  "set(const LVecBase4d self, double x, double y, double z, double w)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_set_871_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::dot(LVecBase4d const &other) const
 */
static PyObject *Dtool_LVecBase4d_dot_872(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::dot(LVecBase4d const &other) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.dot", "LVecBase4d");
  }
  double return_value = (*(const LVecBase4d*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase4d self, const LVecBase4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_dot_872_comment =
  "C++ Interface:\n"
  "dot(LVecBase4d self, const LVecBase4d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_dot_872_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::length_squared(void) const
 */
static PyObject *Dtool_LVecBase4d_length_squared_873(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::length_squared(void) const
  double return_value = (*(const LVecBase4d*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_length_squared_873_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_length_squared_873_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LVecBase4d::length(void) const
 */
static PyObject *Dtool_LVecBase4d_length_874(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LVecBase4d::length(void) const
  double return_value = (*(const LVecBase4d*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_length_874_comment =
  "C++ Interface:\n"
  "length(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Returns the length of the vector, by the Pythagorean theorem.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_length_874_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4d::normalize(void)
 */
static PyObject *Dtool_LVecBase4d_normalize_875(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.normalize")) {
    return NULL;
  }
  // 1-inline bool LVecBase4d::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_normalize_875_comment =
  "C++ Interface:\n"
  "normalize(const LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector in place.  Returns true if the vector was normalized,\n"
  " * false if it was a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_normalize_875_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d LVecBase4d::normalized(void) const
 */
static PyObject *Dtool_LVecBase4d_normalized_876(PyObject *self, PyObject *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d LVecBase4d::normalized(void) const
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_normalized_876_comment =
  "C++ Interface:\n"
  "normalized(LVecBase4d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_normalized_876_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const
 */
static PyObject *Dtool_LVecBase4d_project_877(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.project", "LVecBase4d");
  }
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVecBase4d self, const LVecBase4d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_project_877_comment =
  "C++ Interface:\n"
  "project(LVecBase4d self, const LVecBase4d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_project_877_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4d::compare_to(LVecBase4d const &other) const
 * inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const
 */
static PyObject *Dtool_LVecBase4d_compare_to_881(PyObject *self, PyObject *args) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LVecBase4d::compare_to(LVecBase4d const &other) const
      LVecBase4d arg_local;
      LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.compare_to", "LVecBase4d");
      }
      int return_value = (*(const LVecBase4d*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "Od:compare_to", &param1, &param2)) {
        LVecBase4d param1_local;
        LVecBase4d const *param1_this = Dtool_Coerce_LVecBase4d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase4d.compare_to", "LVecBase4d");
        }
        int return_value = (*(const LVecBase4d*)local_this).compare_to(*param1_this, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase4d self, const LVecBase4d other)\n"
      "compare_to(LVecBase4d self, const LVecBase4d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_compare_to_881_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase4d self, const LVecBase4d other)\n"
  "compare_to(LVecBase4d self, const LVecBase4d other, double threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts vectors lexicographically, componentwise.  Returns a number less than\n"
  " * 0 if this vector sorts before the other one, greater than zero if it sorts\n"
  " * after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LVecBase4d_compare_to_881_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase4d::get_hash(void) const
 * inline std::size_t LVecBase4d::get_hash(double threshold) const
 */
static PyObject *Dtool_LVecBase4d_get_hash_882(PyObject *self, PyObject *args) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LVecBase4d::get_hash(void) const
      std::size_t return_value = (*(const LVecBase4d*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LVecBase4d::get_hash(double threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LVecBase4d*)local_this).get_hash(PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LVecBase4d self)\n"
      "get_hash(LVecBase4d self, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_hash_882_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase4d self)\n"
  "get_hash(LVecBase4d self, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_get_hash_882_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase4d::add_hash(std::size_t hash) const
 * inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const
 */
static PyObject *Dtool_LVecBase4d_add_hash_883(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LVecBase4d::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase4d*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const
      Py_ssize_t param1;
      double param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LVecBase4d*)local_this).add_hash((std::size_t)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase4d self, int hash)\n"
      "add_hash(LVecBase4d self, int hash, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_add_hash_883_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase4d self, int hash)\n"
  "add_hash(LVecBase4d self, int hash, double threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_add_hash_883_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::componentwise_mult(LVecBase4d const &other)
 */
static PyObject *Dtool_LVecBase4d_componentwise_mult_894(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::componentwise_mult(LVecBase4d const &other)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.componentwise_mult", "LVecBase4d");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase4d self, const LVecBase4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_componentwise_mult_894_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase4d self, const LVecBase4d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_componentwise_mult_894_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const
 */
static PyObject *Dtool_LVecBase4d_fmax_897(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.fmax", "LVecBase4d");
  }
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase4d self, const LVecBase4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_fmax_897_comment =
  "C++ Interface:\n"
  "fmax(LVecBase4d self, const LVecBase4d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_fmax_897_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const
 */
static PyObject *Dtool_LVecBase4d_fmin_898(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.fmin", "LVecBase4d");
  }
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase4d self, const LVecBase4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_fmin_898_comment =
  "C++ Interface:\n"
  "fmin(LVecBase4d self, const LVecBase4d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_fmin_898_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const
 * inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const
 */
static PyObject *Dtool_LVecBase4d_almost_equal_899(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const
      LVecBase4d arg_local;
      LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.almost_equal", "LVecBase4d");
      }
      bool return_value = (*(const LVecBase4d*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase4d param1_local;
        LVecBase4d const *param1_this = Dtool_Coerce_LVecBase4d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase4d.almost_equal", "LVecBase4d");
        }
        bool return_value = (*(const LVecBase4d*)local_this).almost_equal(*param1_this, (double)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase4d self, const LVecBase4d other)\n"
      "almost_equal(LVecBase4d self, const LVecBase4d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_almost_equal_899_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase4d self, const LVecBase4d other)\n"
  "almost_equal(LVecBase4d self, const LVecBase4d other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_almost_equal_899_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase4d_output_900(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4d::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase4d.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase4d*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase4d self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_output_900_comment =
  "C++ Interface:\n"
  "output(LVecBase4d self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4d_output_900_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase4d_write_datagram_fixed_902(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase4d*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase4d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_write_datagram_fixed_902_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase4d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_write_datagram_fixed_902_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase4d_read_datagram_fixed_903(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase4d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_read_datagram_fixed_903_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase4d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase4d_read_datagram_fixed_903_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase4d_write_datagram_904(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4d::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.write_datagram", "Datagram");
  }
  (*(const LVecBase4d*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase4d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_write_datagram_904_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase4d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase4d_write_datagram_904_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4d::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase4d_read_datagram_905(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase4d::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase4d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_read_datagram_905_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase4d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase4d_read_datagram_905_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase4d::get_class_type(void)
 */
static PyObject *Dtool_LVecBase4d_get_class_type_906(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase4d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase4d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4d_get_class_type_906_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase4d_get_class_type_906_comment = NULL;
#endif

static PyObject *Dtool_LVecBase4d_x_Getter(PyObject *self, void *) {
  const LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase4d::get_x(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4d_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase4d::set_x(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_x(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase4d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4d_y_Getter(PyObject *self, void *) {
  const LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase4d::get_y(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4d_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase4d::set_y(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_y(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase4d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4d_z_Getter(PyObject *self, void *) {
  const LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double LVecBase4d::get_z(void) const
  double return_value = (*(const LVecBase4d*)local_this).get_z();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4d_z_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4d, (void **)&local_this, "LVecBase4d.z")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete z attribute");
    return -1;
  }
  // 1-inline void LVecBase4d::set_z(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_z(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase4d self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4d_xyz_Getter(PyObject *self, void *) {
  const LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3d LVecBase4d::get_xyz(void) const
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase4d*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
}

static PyObject *Dtool_LVecBase4d_xy_Getter(PyObject *self, void *) {
  const LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2d LVecBase4d::get_xy(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase4d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
}

/**
 * Python function wrapper for:
 * inline LVecBase4d::LVecBase4d(void) = default
 * inline LVecBase4d::LVecBase4d(LPoint3d const &point)
 * inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w)
 * inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default
 * inline LVecBase4d::LVecBase4d(LVector3d const &vector)
 * inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy)
 * inline LVecBase4d::LVecBase4d(double fill_value)
 * inline LVecBase4d::LVecBase4d(double x, double y, double z, double w)
 */
static int Dtool_Init_LVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase4d::LVecBase4d(void) = default
      LVecBase4d *return_value = new LVecBase4d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase4d::LVecBase4d(LPoint3d const &point)
        PyObject *param0;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          LPoint3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(LVector3d const &vector)
        PyObject *param0;
        static const char *keyword_list[] = {"vector", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          LVector3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LVecBase4d", (char **)keyword_list, &param0)) {
          LVecBase4d *return_value = new LVecBase4d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(LPoint3d const &point)
        PyObject *param0;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          LPoint3d param0_local;
          LPoint3d const *param0_this = Dtool_Coerce_LPoint3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(LVector3d const &vector)
        PyObject *param0;
        static const char *keyword_list[] = {"vector", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          LVector3d param0_local;
          LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4d", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4d param0_local;
          UnalignedLVecBase4d const *param0_this = Dtool_Coerce_UnalignedLVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4d *return_value = new LVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase4d::LVecBase4d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LVecBase4d", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVecBase4d.LVecBase4d", "LVecBase3d");
          return -1;
        }
        LVecBase4d *return_value = new LVecBase4d(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVecBase4d::LVecBase4d(double x, double y, double z, double w)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LVecBase4d", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVecBase4d *return_value = new LVecBase4d((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase4d() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase4d()\n"
      "LVecBase4d(const LPoint3d point)\n"
      "LVecBase4d(const LVector3d vector)\n"
      "LVecBase4d(const LVecBase4d param0)\n"
      "LVecBase4d(const UnalignedLVecBase4d copy)\n"
      "LVecBase4d(double fill_value)\n"
      "LVecBase4d(const LVecBase3d copy, double w)\n"
      "LVecBase4d(double x, double y, double z, double w)\n");
  }
  return -1;
}

LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  LVecBase4d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase4d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVecBase4d::LVecBase4d(LPoint3d const &point)
      LPoint3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4d::LVecBase4d(LVector3d const &vector)
      LVector3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy)
      UnalignedLVecBase4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLVecBase4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4d::LVecBase4d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVecBase4d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LVecBase4d", &param0, &param1)) {
          LVecBase3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVecBase4d(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LVecBase4d::LVecBase4d(double x, double y, double z, double w)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LVecBase4d", &param0, &param1, &param2, &param3)) {
          coerced = LVecBase4d((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase4d) {
    printf("LVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase4d *local_this = (LVecBase4d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UnalignedLVecBase4d
 */
/**
 * Python function wrapper for:
 * inline void UnalignedLVecBase4d::set(double x, double y, double z, double w)
 */
static PyObject *Dtool_UnalignedLVecBase4d_set_911(PyObject *self, PyObject *args, PyObject *kwds) {
  UnalignedLVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLVecBase4d, (void **)&local_this, "UnalignedLVecBase4d.set")) {
    return NULL;
  }
  // 1-inline void UnalignedLVecBase4d::set(double x, double y, double z, double w)
  double param1;
  double param2;
  double param3;
  double param4;
  static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:set", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set((double)param1, (double)param2, (double)param3, (double)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const UnalignedLVecBase4d self, double x, double y, double z, double w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4d_set_911_comment =
  "C++ Interface:\n"
  "set(const UnalignedLVecBase4d self, double x, double y, double z, double w)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLVecBase4d_set_911_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int UnalignedLVecBase4d::get_num_components(void)
 */
static PyObject *Dtool_UnalignedLVecBase4d_get_num_components_915(PyObject *, PyObject *) {
  // 1-static constexpr int UnalignedLVecBase4d::get_num_components(void)
  int return_value = UnalignedLVecBase4d::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4d_get_num_components_915_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, 4.\n"
  " */";
#else
static const char *Dtool_UnalignedLVecBase4d_get_num_components_915_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnalignedLVecBase4d::get_class_type(void)
 */
static PyObject *Dtool_UnalignedLVecBase4d_get_class_type_916(PyObject *, PyObject *) {
  // 1-static TypeHandle UnalignedLVecBase4d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UnalignedLVecBase4d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4d_get_class_type_916_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnalignedLVecBase4d_get_class_type_916_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default
 * inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy)
 * inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default
 * inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w)
 */
static int Dtool_Init_UnalignedLVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default
      UnalignedLVecBase4d *return_value = new UnalignedLVecBase4d();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4d", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            UnalignedLVecBase4d *return_value = new UnalignedLVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4d", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            UnalignedLVecBase4d *return_value = new UnalignedLVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4d", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4d param0_local;
          UnalignedLVecBase4d const *param0_this = Dtool_Coerce_UnalignedLVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            UnalignedLVecBase4d *return_value = new UnalignedLVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4d", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            UnalignedLVecBase4d *return_value = new UnalignedLVecBase4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4d, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
    {
      // 1-inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:UnalignedLVecBase4d", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        UnalignedLVecBase4d *return_value = new UnalignedLVecBase4d((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UnalignedLVecBase4d() takes 0, 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnalignedLVecBase4d()\n"
      "UnalignedLVecBase4d(const UnalignedLVecBase4d param0)\n"
      "UnalignedLVecBase4d(const LVecBase4d copy)\n"
      "UnalignedLVecBase4d(double x, double y, double z, double w)\n");
  }
  return -1;
}

UnalignedLVecBase4d *Dtool_Coerce_UnalignedLVecBase4d(PyObject *args, UnalignedLVecBase4d &coerced) {
  UnalignedLVecBase4d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UnalignedLVecBase4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const UnalignedLVecBase4d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy)
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = UnalignedLVecBase4d(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w)
      double param0;
      double param1;
      double param2;
      double param3;
      if (PyArg_ParseTuple(args, "dddd:UnalignedLVecBase4d", &param0, &param1, &param2, &param3)) {
        coerced = UnalignedLVecBase4d((double)param0, (double)param1, (double)param2, (double)param3);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_UnalignedLVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UnalignedLVecBase4d) {
    printf("UnalignedLVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UnalignedLVecBase4d *local_this = (UnalignedLVecBase4d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UnalignedLVecBase4d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UnalignedLVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UnalignedLVecBase4d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVecBase4i
 */
/**
 * Python function wrapper for:
 * LVecBase4i &LVecBase4i::operator =(LVecBase4i const &copy) = default
 * LVecBase4i &LVecBase4i::operator =(int fill_value) = default
 */
static PyObject *Dtool_LVecBase4i_operator_924(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.assign")) {
    return NULL;
  }
  {
    // -2 LVecBase4i &LVecBase4i::operator =(LVecBase4i const &copy) = default
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LVecBase4i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, false);
    }
  }

  {
    // -2 LVecBase4i &LVecBase4i::operator =(int fill_value) = default
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      (*local_this).operator =((int)arg_val);
      LVecBase4i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, false);
    }
  }

  {
    // -2 LVecBase4i &LVecBase4i::operator =(LVecBase4i const &copy) = default
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LVecBase4i *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, false);
    }
  }

  // No coercion possible: LVecBase4i &LVecBase4i::operator =(int fill_value) = default
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LVecBase4i self, const LVecBase4i copy)\n"
      "assign(const LVecBase4i self, int fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_operator_924_comment =
  "C++ Interface:\n"
  "assign(const LVecBase4i self, const LVecBase4i copy)\n"
  "assign(const LVecBase4i self, int fill_value)\n";
#else
static const char *Dtool_LVecBase4i_operator_924_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4i const &LVecBase4i::zero(void)
 */
static PyObject *Dtool_LVecBase4i_zero_925(PyObject *, PyObject *) {
  // 1-static inline LVecBase4i const &LVecBase4i::zero(void)
  LVecBase4i const *return_value = &(LVecBase4i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_zero_925_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_zero_925_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4i const &LVecBase4i::unit_x(void)
 */
static PyObject *Dtool_LVecBase4i_unit_x_926(PyObject *, PyObject *) {
  // 1-static inline LVecBase4i const &LVecBase4i::unit_x(void)
  LVecBase4i const *return_value = &(LVecBase4i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_unit_x_926_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_unit_x_926_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4i const &LVecBase4i::unit_y(void)
 */
static PyObject *Dtool_LVecBase4i_unit_y_927(PyObject *, PyObject *) {
  // 1-static inline LVecBase4i const &LVecBase4i::unit_y(void)
  LVecBase4i const *return_value = &(LVecBase4i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_unit_y_927_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_unit_y_927_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4i const &LVecBase4i::unit_z(void)
 */
static PyObject *Dtool_LVecBase4i_unit_z_928(PyObject *, PyObject *) {
  // 1-static inline LVecBase4i const &LVecBase4i::unit_z(void)
  LVecBase4i const *return_value = &(LVecBase4i::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_unit_z_928_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_unit_z_928_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVecBase4i const &LVecBase4i::unit_w(void)
 */
static PyObject *Dtool_LVecBase4i_unit_w_929(PyObject *, PyObject *) {
  // 1-static inline LVecBase4i const &LVecBase4i::unit_w(void)
  LVecBase4i const *return_value = &(LVecBase4i::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_unit_w_929_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W vector.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_unit_w_929_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LVecBase4i::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LVecBase4i_reduce_930(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LVecBase4i::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LVecBase4i*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_reduce_930_comment =
  "C++ Interface:\n"
  "__reduce__(LVecBase4i self)\n";
#else
static const char *Dtool_LVecBase4i_reduce_930_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4i::is_nan(void) const
 */
static PyObject *Dtool_LVecBase4i_is_nan_935(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LVecBase4i::is_nan(void) const
  bool return_value = (*(const LVecBase4i*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_is_nan_935_comment =
  "C++ Interface:\n"
  "is_nan(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the vector is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_is_nan_935_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::get_cell(int i) const
 */
static PyObject *Dtool_LVecBase4i_get_cell_936(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::get_cell(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const LVecBase4i*)local_this).get_cell((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LVecBase4i self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_cell_936_comment =
  "C++ Interface:\n"
  "get_cell(LVecBase4i self, int i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_cell_936_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::set_cell(int i, int value)
 */
static PyObject *Dtool_LVecBase4i_set_cell_937(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.set_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::set_cell(int i, int value)
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_cell((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LVecBase4i self, int i, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_set_cell_937_comment =
  "C++ Interface:\n"
  "set_cell(const LVecBase4i self, int i, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_set_cell_937_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::get_x(void) const
 */
static PyObject *Dtool_LVecBase4i_get_x_938(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::get_x(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_x();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_x_938_comment =
  "C++ Interface:\n"
  "get_x(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_x_938_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::get_y(void) const
 */
static PyObject *Dtool_LVecBase4i_get_y_939(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::get_y(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_y();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_y_939_comment =
  "C++ Interface:\n"
  "get_y(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_y_939_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::get_z(void) const
 */
static PyObject *Dtool_LVecBase4i_get_z_940(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::get_z(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_z();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_z_940_comment =
  "C++ Interface:\n"
  "get_z(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_z_940_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::get_w(void) const
 */
static PyObject *Dtool_LVecBase4i_get_w_941(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::get_w(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_w_941_comment =
  "C++ Interface:\n"
  "get_w(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_w_941_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i LVecBase4i::get_xyz(void) const
 */
static PyObject *Dtool_LVecBase4i_get_xyz_942(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3i LVecBase4i::get_xyz(void) const
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase4i*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_xyz_942_comment =
  "C++ Interface:\n"
  "get_xyz(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_xyz_942_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i LVecBase4i::get_xy(void) const
 */
static PyObject *Dtool_LVecBase4i_get_xy_943(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2i LVecBase4i::get_xy(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase4i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_xy_943_comment =
  "C++ Interface:\n"
  "get_xy(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_xy_943_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::set_x(int value)
 */
static PyObject *Dtool_LVecBase4i_set_x_944(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.set_x")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::set_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_x((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_set_x_944_comment =
  "C++ Interface:\n"
  "set_x(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_set_x_944_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::set_y(int value)
 */
static PyObject *Dtool_LVecBase4i_set_y_945(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.set_y")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::set_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_y((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_set_y_945_comment =
  "C++ Interface:\n"
  "set_y(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_set_y_945_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::set_z(int value)
 */
static PyObject *Dtool_LVecBase4i_set_z_946(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.set_z")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::set_z(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_z((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_set_z_946_comment =
  "C++ Interface:\n"
  "set_z(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_set_z_946_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::set_w(int value)
 */
static PyObject *Dtool_LVecBase4i_set_w_947(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.set_w")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::set_w(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_w((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_w(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_set_w_947_comment =
  "C++ Interface:\n"
  "set_w(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_set_w_947_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::add_to_cell(int i, int value)
 */
static PyObject *Dtool_LVecBase4i_add_to_cell_953(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.add_to_cell")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::add_to_cell(int i, int value)
  int param1;
  int param2;
  static const char *keyword_list[] = {"i", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:add_to_cell", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_to_cell((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_to_cell(const LVecBase4i self, int i, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_add_to_cell_953_comment =
  "C++ Interface:\n"
  "add_to_cell(const LVecBase4i self, int i, int value)\n"
  "\n"
  "// These next functions add to an existing value.  i.e.\n"
  "// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in\n"
  "// scripting languages:\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_add_to_cell_953_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::add_x(int value)
 */
static PyObject *Dtool_LVecBase4i_add_x_954(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.add_x")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::add_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_x((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_x(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_add_x_954_comment =
  "C++ Interface:\n"
  "add_x(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_add_x_954_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::add_y(int value)
 */
static PyObject *Dtool_LVecBase4i_add_y_955(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.add_y")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::add_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_y((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_y(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_add_y_955_comment =
  "C++ Interface:\n"
  "add_y(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_add_y_955_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::add_z(int value)
 */
static PyObject *Dtool_LVecBase4i_add_z_956(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.add_z")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::add_z(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_z((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_add_z_956_comment =
  "C++ Interface:\n"
  "add_z(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_add_z_956_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::add_w(int value)
 */
static PyObject *Dtool_LVecBase4i_add_w_957(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.add_w")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::add_w(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_w((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_w(const LVecBase4i self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_add_w_957_comment =
  "C++ Interface:\n"
  "add_w(const LVecBase4i self, int value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_add_w_957_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int LVecBase4i::get_num_components(void)
 */
static PyObject *Dtool_LVecBase4i_get_num_components_959(PyObject *, PyObject *) {
  // 1-static constexpr int LVecBase4i::get_num_components(void)
  int return_value = LVecBase4i::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_num_components_959_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, four.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_num_components_959_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::fill(int fill_value)
 */
static PyObject *Dtool_LVecBase4i_fill_961(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.fill")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::fill(int fill_value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).fill((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LVecBase4i self, int fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_fill_961_comment =
  "C++ Interface:\n"
  "fill(const LVecBase4i self, int fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the vector to the indicated fill_value.  This is\n"
  " * particularly useful for initializing to zero.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_fill_961_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::set(int x, int y, int z, int w)
 */
static PyObject *Dtool_LVecBase4i_set_962(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.set")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::set(int x, int y, int z, int w)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:set", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LVecBase4i self, int x, int y, int z, int w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_set_962_comment =
  "C++ Interface:\n"
  "set(const LVecBase4i self, int x, int y, int z, int w)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_set_962_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::dot(LVecBase4i const &other) const
 */
static PyObject *Dtool_LVecBase4i_dot_963(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::dot(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.dot", "LVecBase4i");
  }
  int return_value = (*(const LVecBase4i*)local_this).dot(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dot(LVecBase4i self, const LVecBase4i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_dot_963_comment =
  "C++ Interface:\n"
  "dot(LVecBase4i self, const LVecBase4i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_dot_963_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::length_squared(void) const
 */
static PyObject *Dtool_LVecBase4i_length_squared_964(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::length_squared(void) const
  int return_value = (*(const LVecBase4i*)local_this).length_squared();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_length_squared_964_comment =
  "C++ Interface:\n"
  "length_squared(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " * Returns the square of the vector's length, cheap and easy.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_length_squared_964_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LVecBase4i::compare_to(LVecBase4i const &other) const
 */
static PyObject *Dtool_LVecBase4i_compare_to_968(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LVecBase4i::compare_to(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.compare_to", "LVecBase4i");
  }
  int return_value = (*(const LVecBase4i*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase4i self, const LVecBase4i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_compare_to_968_comment =
  "C++ Interface:\n"
  "compare_to(LVecBase4i self, const LVecBase4i other)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_compare_to_968_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase4i::get_hash(void) const
 */
static PyObject *Dtool_LVecBase4i_get_hash_969(PyObject *self, PyObject *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t LVecBase4i::get_hash(void) const
  std::size_t return_value = (*(const LVecBase4i*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_hash_969_comment =
  "C++ Interface:\n"
  "get_hash(LVecBase4i self)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_get_hash_969_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LVecBase4i::add_hash(std::size_t hash) const
 */
static PyObject *Dtool_LVecBase4i_add_hash_970(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t LVecBase4i::add_hash(std::size_t hash) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::size_t return_value = (*(const LVecBase4i*)local_this).add_hash((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LVecBase4i self, int hash)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_add_hash_970_comment =
  "C++ Interface:\n"
  "add_hash(LVecBase4i self, int hash)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_add_hash_970_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::componentwise_mult(LVecBase4i const &other)
 */
static PyObject *Dtool_LVecBase4i_componentwise_mult_981(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::componentwise_mult(LVecBase4i const &other)
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.componentwise_mult", "LVecBase4i");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LVecBase4i self, const LVecBase4i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_componentwise_mult_981_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LVecBase4i self, const LVecBase4i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_componentwise_mult_981_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const
 */
static PyObject *Dtool_LVecBase4i_fmax_984(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.fmax", "LVecBase4i");
  }
  LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).fmax(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmax(LVecBase4i self, const LVecBase4i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_fmax_984_comment =
  "C++ Interface:\n"
  "fmax(LVecBase4i self, const LVecBase4i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_fmax_984_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const
 */
static PyObject *Dtool_LVecBase4i_fmin_985(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.fmin", "LVecBase4i");
  }
  LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).fmin(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fmin(LVecBase4i self, const LVecBase4i other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_fmin_985_comment =
  "C++ Interface:\n"
  "fmin(LVecBase4i self, const LVecBase4i other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_fmin_985_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const
 * inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const
 */
static PyObject *Dtool_LVecBase4i_almost_equal_986(PyObject *self, PyObject *args, PyObject *kwds) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const
      LVecBase4i arg_local;
      LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.almost_equal", "LVecBase4i");
      }
      bool return_value = (*(const LVecBase4i*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LVecBase4i param1_local;
        LVecBase4i const *param1_this = Dtool_Coerce_LVecBase4i(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LVecBase4i.almost_equal", "LVecBase4i");
        }
        bool return_value = (*(const LVecBase4i*)local_this).almost_equal(*param1_this, (int)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LVecBase4i self, const LVecBase4i other)\n"
      "almost_equal(LVecBase4i self, const LVecBase4i other, int threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_almost_equal_986_comment =
  "C++ Interface:\n"
  "almost_equal(LVecBase4i self, const LVecBase4i other)\n"
  "almost_equal(LVecBase4i self, const LVecBase4i other, int threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two vectors are memberwise equal within a default tolerance\n"
  " * based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_almost_equal_986_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::output(ostream &out) const
 */
static PyObject *Dtool_LVecBase4i_output_987(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4i::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LVecBase4i.output", false, true);
  if (arg_this != NULL) {
    (*(const LVecBase4i*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LVecBase4i self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_output_987_comment =
  "C++ Interface:\n"
  "output(LVecBase4i self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LVecBase4i_output_987_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase4i_write_datagram_fixed_989(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.write_datagram_fixed", "Datagram");
  }
  (*(const LVecBase4i*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LVecBase4i self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_write_datagram_fixed_989_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LVecBase4i self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the vector, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_write_datagram_fixed_989_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase4i_read_datagram_fixed_990(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.read_datagram_fixed")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LVecBase4i self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_read_datagram_fixed_990_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LVecBase4i self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LVecBase4i_read_datagram_fixed_990_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LVecBase4i_write_datagram_991(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LVecBase4i::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.write_datagram", "Datagram");
  }
  (*(const LVecBase4i*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LVecBase4i self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_write_datagram_991_comment =
  "C++ Interface:\n"
  "write_datagram(LVecBase4i self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the vector to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the vector using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LVecBase4i_write_datagram_991_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LVecBase4i::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LVecBase4i_read_datagram_992(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.read_datagram")) {
    return NULL;
  }
  // 1-inline void LVecBase4i::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LVecBase4i self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_read_datagram_992_comment =
  "C++ Interface:\n"
  "read_datagram(const LVecBase4i self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the vector from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LVecBase4i_read_datagram_992_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVecBase4i::get_class_type(void)
 */
static PyObject *Dtool_LVecBase4i_get_class_type_993(PyObject *, PyObject *) {
  // 1-static TypeHandle LVecBase4i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVecBase4i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVecBase4i_get_class_type_993_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVecBase4i_get_class_type_993_comment = NULL;
#endif

static PyObject *Dtool_LVecBase4i_x_Getter(PyObject *self, void *) {
  const LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase4i::get_x(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_x();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4i_x_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.x")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LVecBase4i::set_x(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_x((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LVecBase4i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4i_y_Getter(PyObject *self, void *) {
  const LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase4i::get_y(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_y();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4i_y_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.y")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LVecBase4i::set_y(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_y((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LVecBase4i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4i_z_Getter(PyObject *self, void *) {
  const LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int LVecBase4i::get_z(void) const
  int return_value = (*(const LVecBase4i*)local_this).get_z();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LVecBase4i_z_Setter(PyObject *self, PyObject *arg, void *) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LVecBase4i, (void **)&local_this, "LVecBase4i.z")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete z attribute");
    return -1;
  }
  // 1-inline void LVecBase4i::set_z(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_z((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z(const LVecBase4i self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_LVecBase4i_xyz_Getter(PyObject *self, void *) {
  const LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3i LVecBase4i::get_xyz(void) const
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase4i*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
}

static PyObject *Dtool_LVecBase4i_xy_Getter(PyObject *self, void *) {
  const LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i LVecBase4i::get_xy(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase4i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

/**
 * Python function wrapper for:
 * inline LVecBase4i::LVecBase4i(void) = default
 * inline LVecBase4i::LVecBase4i(LPoint3i const &point)
 * inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w)
 * inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default
 * inline LVecBase4i::LVecBase4i(LVector3i const &vector)
 * inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy)
 * inline LVecBase4i::LVecBase4i(int fill_value)
 * inline LVecBase4i::LVecBase4i(int x, int y, int z, int w)
 */
static int Dtool_Init_LVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVecBase4i::LVecBase4i(void) = default
      LVecBase4i *return_value = new LVecBase4i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVecBase4i::LVecBase4i(LPoint3i const &point)
        PyObject *param0;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          LPoint3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(LVector3i const &vector)
        PyObject *param0;
        static const char *keyword_list[] = {"vector", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          LVector3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          LVecBase4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LVecBase4i", (char **)keyword_list, &param0)) {
          LVecBase4i *return_value = new LVecBase4i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(LPoint3i const &point)
        PyObject *param0;
        static const char *keyword_list[] = {"point", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          LPoint3i param0_local;
          LPoint3i const *param0_this = Dtool_Coerce_LPoint3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(LVector3i const &vector)
        PyObject *param0;
        static const char *keyword_list[] = {"vector", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          LVector3i param0_local;
          LVector3i const *param0_this = Dtool_Coerce_LVector3i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4i param0_local;
          UnalignedLVecBase4i const *param0_this = Dtool_Coerce_UnalignedLVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVecBase4i", (char **)keyword_list, &param0)) {
          LVecBase4i param0_local;
          LVecBase4i const *param0_this = Dtool_Coerce_LVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVecBase4i *return_value = new LVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVecBase4i::LVecBase4i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:LVecBase4i", (char **)keyword_list, &param0, &param1)) {
        LVecBase3i param0_local;
        LVecBase3i const *param0_this = Dtool_Coerce_LVecBase3i(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVecBase4i.LVecBase4i", "LVecBase3i");
          return -1;
        }
        LVecBase4i *return_value = new LVecBase4i(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVecBase4i::LVecBase4i(int x, int y, int z, int w)
      int param0;
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:LVecBase4i", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVecBase4i *return_value = new LVecBase4i((int)param0, (int)param1, (int)param2, (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVecBase4i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVecBase4i() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVecBase4i()\n"
      "LVecBase4i(const LPoint3i point)\n"
      "LVecBase4i(const LVector3i vector)\n"
      "LVecBase4i(const UnalignedLVecBase4i copy)\n"
      "LVecBase4i(const LVecBase4i param0)\n"
      "LVecBase4i(int fill_value)\n"
      "LVecBase4i(const LVecBase3i copy, int w)\n"
      "LVecBase4i(int x, int y, int z, int w)\n");
  }
  return -1;
}

LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced) {
  LVecBase4i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVecBase4i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVecBase4i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVecBase4i::LVecBase4i(LPoint3i const &point)
      LPoint3i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4i::LVecBase4i(LVector3i const &vector)
      LVector3i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy)
      UnalignedLVecBase4i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLVecBase4i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVecBase4i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVecBase4i::LVecBase4i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LVecBase4i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:LVecBase4i", &param0, &param1)) {
          LVecBase3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVecBase4i(*param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LVecBase4i::LVecBase4i(int x, int y, int z, int w)
        int param0;
        int param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "iiii:LVecBase4i", &param0, &param1, &param2, &param3)) {
          coerced = LVecBase4i((int)param0, (int)param1, (int)param2, (int)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVecBase4i) {
    printf("LVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVecBase4i *local_this = (LVecBase4i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVecBase4i) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVecBase4i) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UnalignedLVecBase4i
 */
/**
 * Python function wrapper for:
 * inline void UnalignedLVecBase4i::set(int x, int y, int z, int w)
 */
static PyObject *Dtool_UnalignedLVecBase4i_set_998(PyObject *self, PyObject *args, PyObject *kwds) {
  UnalignedLVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLVecBase4i, (void **)&local_this, "UnalignedLVecBase4i.set")) {
    return NULL;
  }
  // 1-inline void UnalignedLVecBase4i::set(int x, int y, int z, int w)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:set", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).set((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const UnalignedLVecBase4i self, int x, int y, int z, int w)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4i_set_998_comment =
  "C++ Interface:\n"
  "set(const UnalignedLVecBase4i self, int x, int y, int z, int w)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLVecBase4i_set_998_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static constexpr int UnalignedLVecBase4i::get_num_components(void)
 */
static PyObject *Dtool_UnalignedLVecBase4i_get_num_components_1002(PyObject *, PyObject *) {
  // 1-static constexpr int UnalignedLVecBase4i::get_num_components(void)
  int return_value = UnalignedLVecBase4i::get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4i_get_num_components_1002_comment =
  "C++ Interface:\n"
  "get_num_components()\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the vector, 4.\n"
  " */";
#else
static const char *Dtool_UnalignedLVecBase4i_get_num_components_1002_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnalignedLVecBase4i::get_class_type(void)
 */
static PyObject *Dtool_UnalignedLVecBase4i_get_class_type_1003(PyObject *, PyObject *) {
  // 1-static TypeHandle UnalignedLVecBase4i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UnalignedLVecBase4i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLVecBase4i_get_class_type_1003_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnalignedLVecBase4i_get_class_type_1003_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default
 * inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy)
 * inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default
 * inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w)
 */
static int Dtool_Init_UnalignedLVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default
      UnalignedLVecBase4i *return_value = new UnalignedLVecBase4i();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4i", (char **)keyword_list, &param0)) {
          LVecBase4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            UnalignedLVecBase4i *return_value = new UnalignedLVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4i", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            UnalignedLVecBase4i *return_value = new UnalignedLVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4i", (char **)keyword_list, &param0)) {
          LVecBase4i param0_local;
          LVecBase4i const *param0_this = Dtool_Coerce_LVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            UnalignedLVecBase4i *return_value = new UnalignedLVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:UnalignedLVecBase4i", (char **)keyword_list, &param0)) {
          UnalignedLVecBase4i param0_local;
          UnalignedLVecBase4i const *param0_this = Dtool_Coerce_UnalignedLVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            UnalignedLVecBase4i *return_value = new UnalignedLVecBase4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4i, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 4:
    {
      // 1-inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w)
      int param0;
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:UnalignedLVecBase4i", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        UnalignedLVecBase4i *return_value = new UnalignedLVecBase4i((int)param0, (int)param1, (int)param2, (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLVecBase4i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UnalignedLVecBase4i() takes 0, 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnalignedLVecBase4i()\n"
      "UnalignedLVecBase4i(const LVecBase4i copy)\n"
      "UnalignedLVecBase4i(const UnalignedLVecBase4i param0)\n"
      "UnalignedLVecBase4i(int x, int y, int z, int w)\n");
  }
  return -1;
}

UnalignedLVecBase4i *Dtool_Coerce_UnalignedLVecBase4i(PyObject *args, UnalignedLVecBase4i &coerced) {
  UnalignedLVecBase4i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UnalignedLVecBase4i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const UnalignedLVecBase4i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy)
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = UnalignedLVecBase4i(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w)
      int param0;
      int param1;
      int param2;
      int param3;
      if (PyArg_ParseTuple(args, "iiii:UnalignedLVecBase4i", &param0, &param1, &param2, &param3)) {
        coerced = UnalignedLVecBase4i((int)param0, (int)param1, (int)param2, (int)param3);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_UnalignedLVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UnalignedLVecBase4i) {
    printf("UnalignedLVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UnalignedLVecBase4i *local_this = (UnalignedLVecBase4i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UnalignedLVecBase4i) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UnalignedLVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UnalignedLVecBase4i) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector4f
 */
/**
 * Python function wrapper for:
 * static inline LVector4f const &LVector4f::zero(void)
 */
static PyObject *Dtool_LVector4f_zero_1009(PyObject *, PyObject *) {
  // 1-static inline LVector4f const &LVector4f::zero(void)
  LVector4f const *return_value = &(LVector4f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_zero_1009_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector4f_zero_1009_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4f const &LVector4f::unit_x(void)
 */
static PyObject *Dtool_LVector4f_unit_x_1010(PyObject *, PyObject *) {
  // 1-static inline LVector4f const &LVector4f::unit_x(void)
  LVector4f const *return_value = &(LVector4f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_unit_x_1010_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector4f_unit_x_1010_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4f const &LVector4f::unit_y(void)
 */
static PyObject *Dtool_LVector4f_unit_y_1011(PyObject *, PyObject *) {
  // 1-static inline LVector4f const &LVector4f::unit_y(void)
  LVector4f const *return_value = &(LVector4f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_unit_y_1011_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector4f_unit_y_1011_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4f const &LVector4f::unit_z(void)
 */
static PyObject *Dtool_LVector4f_unit_z_1012(PyObject *, PyObject *) {
  // 1-static inline LVector4f const &LVector4f::unit_z(void)
  LVector4f const *return_value = &(LVector4f::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_unit_z_1012_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVector4f_unit_z_1012_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4f const &LVector4f::unit_w(void)
 */
static PyObject *Dtool_LVector4f_unit_w_1013(PyObject *, PyObject *) {
  // 1-static inline LVector4f const &LVector4f::unit_w(void)
  LVector4f const *return_value = &(LVector4f::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_unit_w_1013_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W vector.\n"
  " */";
#else
static const char *Dtool_LVector4f_unit_w_1013_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LVector4f::get_xyz(void) const
 */
static PyObject *Dtool_LVector4f_get_xyz_1014(PyObject *self, PyObject *) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LVector4f::get_xyz(void) const
  LVector3f *return_value = new LVector3f((*(const LVector4f*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_get_xyz_1014_comment =
  "C++ Interface:\n"
  "get_xyz(LVector4f self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LVector4f_get_xyz_1014_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2f LVector4f::get_xy(void) const
 */
static PyObject *Dtool_LVector4f_get_xy_1015(PyObject *self, PyObject *) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2f LVector4f::get_xy(void) const
  LVector2f *return_value = new LVector2f((*(const LVector4f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_get_xy_1015_comment =
  "C++ Interface:\n"
  "get_xy(LVector4f self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LVector4f_get_xy_1015_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector4f LVector4f::normalized(void) const
 */
static PyObject *Dtool_LVector4f_normalized_1023(PyObject *self, PyObject *) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector4f LVector4f::normalized(void) const
  LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_normalized_1023_comment =
  "C++ Interface:\n"
  "normalized(LVector4f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVector4f_normalized_1023_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector4f LVector4f::project(LVecBase4f const &onto) const
 */
static PyObject *Dtool_LVector4f_project_1024(PyObject *self, PyObject *arg) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector4f LVector4f::project(LVecBase4f const &onto) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector4f.project", "LVecBase4f");
  }
  LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVector4f self, const LVecBase4f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_project_1024_comment =
  "C++ Interface:\n"
  "project(LVector4f self, const LVecBase4f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVector4f_project_1024_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector4f::get_class_type(void)
 */
static PyObject *Dtool_LVector4f_get_class_type_1026(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector4f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector4f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4f_get_class_type_1026_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector4f_get_class_type_1026_comment = NULL;
#endif

static PyObject *Dtool_LVector4f_xyz_Getter(PyObject *self, void *) {
  const LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3f LVector4f::get_xyz(void) const
  LVector3f *return_value = new LVector3f((*(const LVector4f*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

static PyObject *Dtool_LVector4f_xy_Getter(PyObject *self, void *) {
  const LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2f LVector4f::get_xy(void) const
  LVector2f *return_value = new LVector2f((*(const LVector4f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

/**
 * Python function wrapper for:
 * inline LVector4f::LVector4f(void) = default
 * inline LVector4f::LVector4f(LVecBase3f const &copy, float w)
 * inline LVector4f::LVector4f(LVecBase4f const &copy)
 * inline LVector4f::LVector4f(LVector4f const &) = default
 * inline LVector4f::LVector4f(float fill_value)
 * inline LVector4f::LVector4f(float x, float y, float z, float w)
 */
static int Dtool_Init_LVector4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector4f::LVector4f(void) = default
      LVector4f *return_value = new LVector4f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector4f::LVector4f(LVector4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4f", (char **)keyword_list, &param0)) {
          LVector4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector4f *return_value = new LVector4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4f::LVector4f(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4f", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector4f *return_value = new LVector4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4f::LVector4f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LVector4f", (char **)keyword_list, &param0)) {
          LVector4f *return_value = new LVector4f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4f::LVector4f(LVector4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4f", (char **)keyword_list, &param0)) {
          LVector4f param0_local;
          LVector4f const *param0_this = Dtool_Coerce_LVector4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector4f *return_value = new LVector4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4f::LVector4f(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4f", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector4f *return_value = new LVector4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector4f::LVector4f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector4f::LVector4f(LVecBase3f const &copy, float w)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LVector4f", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVector4f.LVector4f", "LVecBase3f");
          return -1;
        }
        LVector4f *return_value = new LVector4f(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVector4f::LVector4f(float x, float y, float z, float w)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LVector4f", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVector4f *return_value = new LVector4f((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector4f() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector4f()\n"
      "LVector4f(const LVector4f param0)\n"
      "LVector4f(const LVecBase4f copy)\n"
      "LVector4f(float fill_value)\n"
      "LVector4f(const LVecBase3f copy, float w)\n"
      "LVector4f(float x, float y, float z, float w)\n");
  }
  return -1;
}

LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced) {
  LVector4f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector4f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector4f::LVector4f(LVecBase4f const &copy)
      LVecBase4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector4f::LVector4f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVector4f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVector4f::LVector4f(LVecBase3f const &copy, float w)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LVector4f", &param0, &param1)) {
          LVecBase3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVector4f(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LVector4f::LVector4f(float x, float y, float z, float w)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LVector4f", &param0, &param1, &param2, &param3)) {
          coerced = LVector4f((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector4f) {
    printf("LVector4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector4f *local_this = (LVector4f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LVector4f*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector4d
 */
/**
 * Python function wrapper for:
 * static inline LVector4d const &LVector4d::zero(void)
 */
static PyObject *Dtool_LVector4d_zero_1032(PyObject *, PyObject *) {
  // 1-static inline LVector4d const &LVector4d::zero(void)
  LVector4d const *return_value = &(LVector4d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_zero_1032_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector4d_zero_1032_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4d const &LVector4d::unit_x(void)
 */
static PyObject *Dtool_LVector4d_unit_x_1033(PyObject *, PyObject *) {
  // 1-static inline LVector4d const &LVector4d::unit_x(void)
  LVector4d const *return_value = &(LVector4d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_unit_x_1033_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector4d_unit_x_1033_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4d const &LVector4d::unit_y(void)
 */
static PyObject *Dtool_LVector4d_unit_y_1034(PyObject *, PyObject *) {
  // 1-static inline LVector4d const &LVector4d::unit_y(void)
  LVector4d const *return_value = &(LVector4d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_unit_y_1034_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector4d_unit_y_1034_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4d const &LVector4d::unit_z(void)
 */
static PyObject *Dtool_LVector4d_unit_z_1035(PyObject *, PyObject *) {
  // 1-static inline LVector4d const &LVector4d::unit_z(void)
  LVector4d const *return_value = &(LVector4d::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_unit_z_1035_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVector4d_unit_z_1035_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4d const &LVector4d::unit_w(void)
 */
static PyObject *Dtool_LVector4d_unit_w_1036(PyObject *, PyObject *) {
  // 1-static inline LVector4d const &LVector4d::unit_w(void)
  LVector4d const *return_value = &(LVector4d::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_unit_w_1036_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W vector.\n"
  " */";
#else
static const char *Dtool_LVector4d_unit_w_1036_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LVector4d::get_xyz(void) const
 */
static PyObject *Dtool_LVector4d_get_xyz_1037(PyObject *self, PyObject *) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LVector4d::get_xyz(void) const
  LVector3d *return_value = new LVector3d((*(const LVector4d*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_get_xyz_1037_comment =
  "C++ Interface:\n"
  "get_xyz(LVector4d self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LVector4d_get_xyz_1037_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2d LVector4d::get_xy(void) const
 */
static PyObject *Dtool_LVector4d_get_xy_1038(PyObject *self, PyObject *) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2d LVector4d::get_xy(void) const
  LVector2d *return_value = new LVector2d((*(const LVector4d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_get_xy_1038_comment =
  "C++ Interface:\n"
  "get_xy(LVector4d self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LVector4d_get_xy_1038_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector4d LVector4d::normalized(void) const
 */
static PyObject *Dtool_LVector4d_normalized_1046(PyObject *self, PyObject *) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector4d LVector4d::normalized(void) const
  LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_normalized_1046_comment =
  "C++ Interface:\n"
  "normalized(LVector4d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LVector4d_normalized_1046_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector4d LVector4d::project(LVecBase4d const &onto) const
 */
static PyObject *Dtool_LVector4d_project_1047(PyObject *self, PyObject *arg) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector4d LVector4d::project(LVecBase4d const &onto) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVector4d.project", "LVecBase4d");
  }
  LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LVector4d self, const LVecBase4d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_project_1047_comment =
  "C++ Interface:\n"
  "project(LVector4d self, const LVecBase4d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LVector4d_project_1047_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector4d::get_class_type(void)
 */
static PyObject *Dtool_LVector4d_get_class_type_1049(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector4d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector4d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4d_get_class_type_1049_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector4d_get_class_type_1049_comment = NULL;
#endif

static PyObject *Dtool_LVector4d_xyz_Getter(PyObject *self, void *) {
  const LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3d LVector4d::get_xyz(void) const
  LVector3d *return_value = new LVector3d((*(const LVector4d*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

static PyObject *Dtool_LVector4d_xy_Getter(PyObject *self, void *) {
  const LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2d LVector4d::get_xy(void) const
  LVector2d *return_value = new LVector2d((*(const LVector4d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
}

/**
 * Python function wrapper for:
 * inline LVector4d::LVector4d(void) = default
 * inline LVector4d::LVector4d(LVecBase3d const &copy, double w)
 * inline LVector4d::LVector4d(LVecBase4d const &copy)
 * inline LVector4d::LVector4d(LVector4d const &) = default
 * inline LVector4d::LVector4d(double fill_value)
 * inline LVector4d::LVector4d(double x, double y, double z, double w)
 */
static int Dtool_Init_LVector4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector4d::LVector4d(void) = default
      LVector4d *return_value = new LVector4d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector4d::LVector4d(LVector4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4d", (char **)keyword_list, &param0)) {
          LVector4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector4d *return_value = new LVector4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4d::LVector4d(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4d", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector4d *return_value = new LVector4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4d::LVector4d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LVector4d", (char **)keyword_list, &param0)) {
          LVector4d *return_value = new LVector4d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4d::LVector4d(LVector4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4d", (char **)keyword_list, &param0)) {
          LVector4d param0_local;
          LVector4d const *param0_this = Dtool_Coerce_LVector4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector4d *return_value = new LVector4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4d::LVector4d(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4d", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector4d *return_value = new LVector4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector4d::LVector4d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector4d::LVector4d(LVecBase3d const &copy, double w)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LVector4d", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVector4d.LVector4d", "LVecBase3d");
          return -1;
        }
        LVector4d *return_value = new LVector4d(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVector4d::LVector4d(double x, double y, double z, double w)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LVector4d", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVector4d *return_value = new LVector4d((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector4d() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector4d()\n"
      "LVector4d(const LVector4d param0)\n"
      "LVector4d(const LVecBase4d copy)\n"
      "LVector4d(double fill_value)\n"
      "LVector4d(const LVecBase3d copy, double w)\n"
      "LVector4d(double x, double y, double z, double w)\n");
  }
  return -1;
}

LVector4d *Dtool_Coerce_LVector4d(PyObject *args, LVector4d &coerced) {
  LVector4d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector4d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector4d::LVector4d(LVecBase4d const &copy)
      LVecBase4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector4d::LVector4d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LVector4d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVector4d::LVector4d(LVecBase3d const &copy, double w)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LVector4d", &param0, &param1)) {
          LVecBase3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVector4d(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LVector4d::LVector4d(double x, double y, double z, double w)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LVector4d", &param0, &param1, &param2, &param3)) {
          coerced = LVector4d((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector4d) {
    printf("LVector4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector4d *local_this = (LVector4d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LVector4d*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LVector4i
 */
/**
 * Python function wrapper for:
 * static inline LVector4i const &LVector4i::zero(void)
 */
static PyObject *Dtool_LVector4i_zero_1055(PyObject *, PyObject *) {
  // 1-static inline LVector4i const &LVector4i::zero(void)
  LVector4i const *return_value = &(LVector4i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_zero_1055_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length vector.\n"
  " */";
#else
static const char *Dtool_LVector4i_zero_1055_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4i const &LVector4i::unit_x(void)
 */
static PyObject *Dtool_LVector4i_unit_x_1056(PyObject *, PyObject *) {
  // 1-static inline LVector4i const &LVector4i::unit_x(void)
  LVector4i const *return_value = &(LVector4i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_unit_x_1056_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X vector.\n"
  " */";
#else
static const char *Dtool_LVector4i_unit_x_1056_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4i const &LVector4i::unit_y(void)
 */
static PyObject *Dtool_LVector4i_unit_y_1057(PyObject *, PyObject *) {
  // 1-static inline LVector4i const &LVector4i::unit_y(void)
  LVector4i const *return_value = &(LVector4i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_unit_y_1057_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y vector.\n"
  " */";
#else
static const char *Dtool_LVector4i_unit_y_1057_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4i const &LVector4i::unit_z(void)
 */
static PyObject *Dtool_LVector4i_unit_z_1058(PyObject *, PyObject *) {
  // 1-static inline LVector4i const &LVector4i::unit_z(void)
  LVector4i const *return_value = &(LVector4i::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_unit_z_1058_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z vector.\n"
  " */";
#else
static const char *Dtool_LVector4i_unit_z_1058_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LVector4i const &LVector4i::unit_w(void)
 */
static PyObject *Dtool_LVector4i_unit_w_1059(PyObject *, PyObject *) {
  // 1-static inline LVector4i const &LVector4i::unit_w(void)
  LVector4i const *return_value = &(LVector4i::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_unit_w_1059_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W vector.\n"
  " */";
#else
static const char *Dtool_LVector4i_unit_w_1059_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3i LVector4i::get_xyz(void) const
 */
static PyObject *Dtool_LVector4i_get_xyz_1060(PyObject *self, PyObject *) {
  LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3i LVector4i::get_xyz(void) const
  LVector3i *return_value = new LVector3i((*(const LVector4i*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_get_xyz_1060_comment =
  "C++ Interface:\n"
  "get_xyz(LVector4i self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LVector4i_get_xyz_1060_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector2i LVector4i::get_xy(void) const
 */
static PyObject *Dtool_LVector4i_get_xy_1061(PyObject *self, PyObject *) {
  LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector2i LVector4i::get_xy(void) const
  LVector2i *return_value = new LVector2i((*(const LVector4i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_get_xy_1061_comment =
  "C++ Interface:\n"
  "get_xy(LVector4i self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LVector4i_get_xy_1061_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LVector4i::get_class_type(void)
 */
static PyObject *Dtool_LVector4i_get_class_type_1070(PyObject *, PyObject *) {
  // 1-static TypeHandle LVector4i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LVector4i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LVector4i_get_class_type_1070_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LVector4i_get_class_type_1070_comment = NULL;
#endif

static PyObject *Dtool_LVector4i_xyz_Getter(PyObject *self, void *) {
  const LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3i LVector4i::get_xyz(void) const
  LVector3i *return_value = new LVector3i((*(const LVector4i*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
}

static PyObject *Dtool_LVector4i_xy_Getter(PyObject *self, void *) {
  const LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2i LVector4i::get_xy(void) const
  LVector2i *return_value = new LVector2i((*(const LVector4i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
}

/**
 * Python function wrapper for:
 * inline LVector4i::LVector4i(void) = default
 * inline LVector4i::LVector4i(LVecBase3i const &copy, int w)
 * inline LVector4i::LVector4i(LVecBase4i const &copy)
 * inline LVector4i::LVector4i(LVector4i const &) = default
 * inline LVector4i::LVector4i(int fill_value)
 * inline LVector4i::LVector4i(int x, int y, int z, int w)
 */
static int Dtool_Init_LVector4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LVector4i::LVector4i(void) = default
      LVector4i *return_value = new LVector4i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LVector4i::LVector4i(LVector4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4i", (char **)keyword_list, &param0)) {
          LVector4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector4i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector4i *return_value = new LVector4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4i::LVector4i(LVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4i", (char **)keyword_list, &param0)) {
          LVecBase4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            LVector4i *return_value = new LVector4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4i::LVector4i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LVector4i", (char **)keyword_list, &param0)) {
          LVector4i *return_value = new LVector4i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4i::LVector4i(LVector4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4i", (char **)keyword_list, &param0)) {
          LVector4i param0_local;
          LVector4i const *param0_this = Dtool_Coerce_LVector4i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector4i *return_value = new LVector4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LVector4i::LVector4i(LVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LVector4i", (char **)keyword_list, &param0)) {
          LVecBase4i param0_local;
          LVecBase4i const *param0_this = Dtool_Coerce_LVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            LVector4i *return_value = new LVector4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LVector4i::LVector4i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LVector4i::LVector4i(LVecBase3i const &copy, int w)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:LVector4i", (char **)keyword_list, &param0, &param1)) {
        LVecBase3i param0_local;
        LVecBase3i const *param0_this = Dtool_Coerce_LVecBase3i(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LVector4i.LVector4i", "LVecBase3i");
          return -1;
        }
        LVector4i *return_value = new LVector4i(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVector4i::LVector4i(int x, int y, int z, int w)
      int param0;
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:LVector4i", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVector4i *return_value = new LVector4i((int)param0, (int)param1, (int)param2, (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LVector4i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LVector4i() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LVector4i()\n"
      "LVector4i(const LVector4i param0)\n"
      "LVector4i(const LVecBase4i copy)\n"
      "LVector4i(int fill_value)\n"
      "LVector4i(const LVecBase3i copy, int w)\n"
      "LVector4i(int x, int y, int z, int w)\n");
  }
  return -1;
}

LVector4i *Dtool_Coerce_LVector4i(PyObject *args, LVector4i &coerced) {
  LVector4i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LVector4i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LVector4i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LVector4i::LVector4i(LVecBase4i const &copy)
      LVecBase4i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LVector4i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LVector4i::LVector4i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LVector4i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LVector4i::LVector4i(LVecBase3i const &copy, int w)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:LVector4i", &param0, &param1)) {
          LVecBase3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LVector4i(*param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LVector4i::LVector4i(int x, int y, int z, int w)
        int param0;
        int param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "iiii:LVector4i", &param0, &param1, &param2, &param3)) {
          coerced = LVector4i((int)param0, (int)param1, (int)param2, (int)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LVector4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LVector4i) {
    printf("LVector4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LVector4i *local_this = (LVector4i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LVector4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4i) {
    return (LVecBase4i *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LVector4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LVector4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4i) {
    LVecBase4i* other_this = (LVecBase4i*)from_this;
    return (LVector4i*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint4f
 */
/**
 * Python function wrapper for:
 * static inline LPoint4f const &LPoint4f::zero(void)
 */
static PyObject *Dtool_LPoint4f_zero_1076(PyObject *, PyObject *) {
  // 1-static inline LPoint4f const &LPoint4f::zero(void)
  LPoint4f const *return_value = &(LPoint4f::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_zero_1076_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint4f_zero_1076_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4f const &LPoint4f::unit_x(void)
 */
static PyObject *Dtool_LPoint4f_unit_x_1077(PyObject *, PyObject *) {
  // 1-static inline LPoint4f const &LPoint4f::unit_x(void)
  LPoint4f const *return_value = &(LPoint4f::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_unit_x_1077_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint4f_unit_x_1077_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4f const &LPoint4f::unit_y(void)
 */
static PyObject *Dtool_LPoint4f_unit_y_1078(PyObject *, PyObject *) {
  // 1-static inline LPoint4f const &LPoint4f::unit_y(void)
  LPoint4f const *return_value = &(LPoint4f::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_unit_y_1078_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint4f_unit_y_1078_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4f const &LPoint4f::unit_z(void)
 */
static PyObject *Dtool_LPoint4f_unit_z_1079(PyObject *, PyObject *) {
  // 1-static inline LPoint4f const &LPoint4f::unit_z(void)
  LPoint4f const *return_value = &(LPoint4f::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_unit_z_1079_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z point.\n"
  " */";
#else
static const char *Dtool_LPoint4f_unit_z_1079_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4f const &LPoint4f::unit_w(void)
 */
static PyObject *Dtool_LPoint4f_unit_w_1080(PyObject *, PyObject *) {
  // 1-static inline LPoint4f const &LPoint4f::unit_w(void)
  LPoint4f const *return_value = &(LPoint4f::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_unit_w_1080_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W point.\n"
  " */";
#else
static const char *Dtool_LPoint4f_unit_w_1080_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f LPoint4f::get_xyz(void) const
 */
static PyObject *Dtool_LPoint4f_get_xyz_1081(PyObject *self, PyObject *) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3f LPoint4f::get_xyz(void) const
  LPoint3f *return_value = new LPoint3f((*(const LPoint4f*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_get_xyz_1081_comment =
  "C++ Interface:\n"
  "get_xyz(LPoint4f self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LPoint4f_get_xyz_1081_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2f LPoint4f::get_xy(void) const
 */
static PyObject *Dtool_LPoint4f_get_xy_1082(PyObject *self, PyObject *) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2f LPoint4f::get_xy(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint4f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_get_xy_1082_comment =
  "C++ Interface:\n"
  "get_xy(LPoint4f self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LPoint4f_get_xy_1082_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f LPoint4f::normalized(void) const
 */
static PyObject *Dtool_LPoint4f_normalized_1090(PyObject *self, PyObject *) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4f LPoint4f::normalized(void) const
  LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_normalized_1090_comment =
  "C++ Interface:\n"
  "normalized(LPoint4f self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LPoint4f_normalized_1090_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const
 */
static PyObject *Dtool_LPoint4f_project_1091(PyObject *self, PyObject *arg) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint4f.project", "LVecBase4f");
  }
  LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPoint4f self, const LVecBase4f onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_project_1091_comment =
  "C++ Interface:\n"
  "project(LPoint4f self, const LVecBase4f onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LPoint4f_project_1091_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint4f::get_class_type(void)
 */
static PyObject *Dtool_LPoint4f_get_class_type_1093(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint4f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint4f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4f_get_class_type_1093_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint4f_get_class_type_1093_comment = NULL;
#endif

static PyObject *Dtool_LPoint4f_xyz_Getter(PyObject *self, void *) {
  const LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3f LPoint4f::get_xyz(void) const
  LPoint3f *return_value = new LPoint3f((*(const LPoint4f*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static PyObject *Dtool_LPoint4f_xy_Getter(PyObject *self, void *) {
  const LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2f LPoint4f::get_xy(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint4f*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

/**
 * Python function wrapper for:
 * inline LPoint4f::LPoint4f(void) = default
 * inline LPoint4f::LPoint4f(LPoint4f const &) = default
 * inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w)
 * inline LPoint4f::LPoint4f(LVecBase4f const &copy)
 * inline LPoint4f::LPoint4f(float fill_value)
 * inline LPoint4f::LPoint4f(float x, float y, float z, float w)
 */
static int Dtool_Init_LPoint4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint4f::LPoint4f(void) = default
      LPoint4f *return_value = new LPoint4f(0.0f);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint4f::LPoint4f(LPoint4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4f", (char **)keyword_list, &param0)) {
          LPoint4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint4f *return_value = new LPoint4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4f::LPoint4f(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4f", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint4f *return_value = new LPoint4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4f::LPoint4f(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LPoint4f", (char **)keyword_list, &param0)) {
          LPoint4f *return_value = new LPoint4f((float)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4f::LPoint4f(LPoint4f const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4f", (char **)keyword_list, &param0)) {
          LPoint4f param0_local;
          LPoint4f const *param0_this = Dtool_Coerce_LPoint4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint4f *return_value = new LPoint4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4f::LPoint4f(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4f", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint4f *return_value = new LPoint4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint4f::LPoint4f(float fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LPoint4f", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPoint4f.LPoint4f", "LVecBase3f");
          return -1;
        }
        LPoint4f *return_value = new LPoint4f(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPoint4f::LPoint4f(float x, float y, float z, float w)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LPoint4f", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint4f *return_value = new LPoint4f((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint4f() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint4f()\n"
      "LPoint4f(const LPoint4f param0)\n"
      "LPoint4f(const LVecBase4f copy)\n"
      "LPoint4f(float fill_value)\n"
      "LPoint4f(const LVecBase3f copy, float w)\n"
      "LPoint4f(float x, float y, float z, float w)\n");
  }
  return -1;
}

LPoint4f *Dtool_Coerce_LPoint4f(PyObject *args, LPoint4f &coerced) {
  LPoint4f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint4f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint4f::LPoint4f(LVecBase4f const &copy)
      LVecBase4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint4f::LPoint4f(float fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LPoint4f((float)PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LPoint4f", &param0, &param1)) {
          LVecBase3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LPoint4f(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPoint4f::LPoint4f(float x, float y, float z, float w)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LPoint4f", &param0, &param1, &param2, &param3)) {
          coerced = LPoint4f((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint4f) {
    printf("LPoint4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint4f *local_this = (LPoint4f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LPoint4f*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint4d
 */
/**
 * Python function wrapper for:
 * static inline LPoint4d const &LPoint4d::zero(void)
 */
static PyObject *Dtool_LPoint4d_zero_1099(PyObject *, PyObject *) {
  // 1-static inline LPoint4d const &LPoint4d::zero(void)
  LPoint4d const *return_value = &(LPoint4d::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_zero_1099_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint4d_zero_1099_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4d const &LPoint4d::unit_x(void)
 */
static PyObject *Dtool_LPoint4d_unit_x_1100(PyObject *, PyObject *) {
  // 1-static inline LPoint4d const &LPoint4d::unit_x(void)
  LPoint4d const *return_value = &(LPoint4d::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_unit_x_1100_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint4d_unit_x_1100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4d const &LPoint4d::unit_y(void)
 */
static PyObject *Dtool_LPoint4d_unit_y_1101(PyObject *, PyObject *) {
  // 1-static inline LPoint4d const &LPoint4d::unit_y(void)
  LPoint4d const *return_value = &(LPoint4d::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_unit_y_1101_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint4d_unit_y_1101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4d const &LPoint4d::unit_z(void)
 */
static PyObject *Dtool_LPoint4d_unit_z_1102(PyObject *, PyObject *) {
  // 1-static inline LPoint4d const &LPoint4d::unit_z(void)
  LPoint4d const *return_value = &(LPoint4d::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_unit_z_1102_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z point.\n"
  " */";
#else
static const char *Dtool_LPoint4d_unit_z_1102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4d const &LPoint4d::unit_w(void)
 */
static PyObject *Dtool_LPoint4d_unit_w_1103(PyObject *, PyObject *) {
  // 1-static inline LPoint4d const &LPoint4d::unit_w(void)
  LPoint4d const *return_value = &(LPoint4d::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_unit_w_1103_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W point.\n"
  " */";
#else
static const char *Dtool_LPoint4d_unit_w_1103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3d LPoint4d::get_xyz(void) const
 */
static PyObject *Dtool_LPoint4d_get_xyz_1104(PyObject *self, PyObject *) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3d LPoint4d::get_xyz(void) const
  LPoint3d *return_value = new LPoint3d((*(const LPoint4d*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_get_xyz_1104_comment =
  "C++ Interface:\n"
  "get_xyz(LPoint4d self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LPoint4d_get_xyz_1104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2d LPoint4d::get_xy(void) const
 */
static PyObject *Dtool_LPoint4d_get_xy_1105(PyObject *self, PyObject *) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2d LPoint4d::get_xy(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint4d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_get_xy_1105_comment =
  "C++ Interface:\n"
  "get_xy(LPoint4d self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LPoint4d_get_xy_1105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4d LPoint4d::normalized(void) const
 */
static PyObject *Dtool_LPoint4d_normalized_1113(PyObject *self, PyObject *) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4d LPoint4d::normalized(void) const
  LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_normalized_1113_comment =
  "C++ Interface:\n"
  "normalized(LPoint4d self)\n"
  "\n"
  "/**\n"
  " * Normalizes the vector and returns the normalized vector as a copy.  If the\n"
  " * vector was a zero-length vector, a zero length vector will be returned.\n"
  " */";
#else
static const char *Dtool_LPoint4d_normalized_1113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const
 */
static PyObject *Dtool_LPoint4d_project_1114(PyObject *self, PyObject *arg) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LPoint4d.project", "LVecBase4d");
  }
  LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).project(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "project(LPoint4d self, const LVecBase4d onto)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_project_1114_comment =
  "C++ Interface:\n"
  "project(LPoint4d self, const LVecBase4d onto)\n"
  "\n"
  "/**\n"
  " * Returns a new vector representing the projection of this vector onto\n"
  " * another one.  The resulting vector will be a scalar multiple of onto.\n"
  " */";
#else
static const char *Dtool_LPoint4d_project_1114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint4d::get_class_type(void)
 */
static PyObject *Dtool_LPoint4d_get_class_type_1116(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint4d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint4d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4d_get_class_type_1116_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint4d_get_class_type_1116_comment = NULL;
#endif

static PyObject *Dtool_LPoint4d_xyz_Getter(PyObject *self, void *) {
  const LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3d LPoint4d::get_xyz(void) const
  LPoint3d *return_value = new LPoint3d((*(const LPoint4d*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
}

static PyObject *Dtool_LPoint4d_xy_Getter(PyObject *self, void *) {
  const LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2d LPoint4d::get_xy(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint4d*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
}

/**
 * Python function wrapper for:
 * inline LPoint4d::LPoint4d(void) = default
 * inline LPoint4d::LPoint4d(LPoint4d const &) = default
 * inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w)
 * inline LPoint4d::LPoint4d(LVecBase4d const &copy)
 * inline LPoint4d::LPoint4d(double fill_value)
 * inline LPoint4d::LPoint4d(double x, double y, double z, double w)
 */
static int Dtool_Init_LPoint4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint4d::LPoint4d(void) = default
      LPoint4d *return_value = new LPoint4d(0.0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint4d::LPoint4d(LPoint4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4d", (char **)keyword_list, &param0)) {
          LPoint4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint4d *return_value = new LPoint4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4d::LPoint4d(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4d", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint4d *return_value = new LPoint4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4d::LPoint4d(double fill_value)
        double param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:LPoint4d", (char **)keyword_list, &param0)) {
          LPoint4d *return_value = new LPoint4d((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4d::LPoint4d(LPoint4d const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4d", (char **)keyword_list, &param0)) {
          LPoint4d param0_local;
          LPoint4d const *param0_this = Dtool_Coerce_LPoint4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint4d *return_value = new LPoint4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4d::LPoint4d(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4d", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint4d *return_value = new LPoint4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint4d::LPoint4d(double fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LPoint4d", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPoint4d.LPoint4d", "LVecBase3d");
          return -1;
        }
        LPoint4d *return_value = new LPoint4d(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPoint4d::LPoint4d(double x, double y, double z, double w)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LPoint4d", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint4d *return_value = new LPoint4d((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint4d() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint4d()\n"
      "LPoint4d(const LPoint4d param0)\n"
      "LPoint4d(const LVecBase4d copy)\n"
      "LPoint4d(double fill_value)\n"
      "LPoint4d(const LVecBase3d copy, double w)\n"
      "LPoint4d(double x, double y, double z, double w)\n");
  }
  return -1;
}

LPoint4d *Dtool_Coerce_LPoint4d(PyObject *args, LPoint4d &coerced) {
  LPoint4d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint4d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint4d::LPoint4d(LVecBase4d const &copy)
      LVecBase4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint4d::LPoint4d(double fill_value)
      if (PyNumber_Check(arg)) {
        coerced = LPoint4d(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LPoint4d", &param0, &param1)) {
          LVecBase3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LPoint4d(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPoint4d::LPoint4d(double x, double y, double z, double w)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LPoint4d", &param0, &param1, &param2, &param3)) {
          coerced = LPoint4d((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint4d) {
    printf("LPoint4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint4d *local_this = (LPoint4d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LPoint4d*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LPoint4i
 */
/**
 * Python function wrapper for:
 * static inline LPoint4i const &LPoint4i::zero(void)
 */
static PyObject *Dtool_LPoint4i_zero_1122(PyObject *, PyObject *) {
  // 1-static inline LPoint4i const &LPoint4i::zero(void)
  LPoint4i const *return_value = &(LPoint4i::zero());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_zero_1122_comment =
  "C++ Interface:\n"
  "zero()\n"
  "\n"
  "/**\n"
  " * Returns a zero-length point.\n"
  " */";
#else
static const char *Dtool_LPoint4i_zero_1122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4i const &LPoint4i::unit_x(void)
 */
static PyObject *Dtool_LPoint4i_unit_x_1123(PyObject *, PyObject *) {
  // 1-static inline LPoint4i const &LPoint4i::unit_x(void)
  LPoint4i const *return_value = &(LPoint4i::unit_x());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_unit_x_1123_comment =
  "C++ Interface:\n"
  "unit_x()\n"
  "\n"
  "/**\n"
  " * Returns a unit X point.\n"
  " */";
#else
static const char *Dtool_LPoint4i_unit_x_1123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4i const &LPoint4i::unit_y(void)
 */
static PyObject *Dtool_LPoint4i_unit_y_1124(PyObject *, PyObject *) {
  // 1-static inline LPoint4i const &LPoint4i::unit_y(void)
  LPoint4i const *return_value = &(LPoint4i::unit_y());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_unit_y_1124_comment =
  "C++ Interface:\n"
  "unit_y()\n"
  "\n"
  "/**\n"
  " * Returns a unit Y point.\n"
  " */";
#else
static const char *Dtool_LPoint4i_unit_y_1124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4i const &LPoint4i::unit_z(void)
 */
static PyObject *Dtool_LPoint4i_unit_z_1125(PyObject *, PyObject *) {
  // 1-static inline LPoint4i const &LPoint4i::unit_z(void)
  LPoint4i const *return_value = &(LPoint4i::unit_z());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_unit_z_1125_comment =
  "C++ Interface:\n"
  "unit_z()\n"
  "\n"
  "/**\n"
  " * Returns a unit Z point.\n"
  " */";
#else
static const char *Dtool_LPoint4i_unit_z_1125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LPoint4i const &LPoint4i::unit_w(void)
 */
static PyObject *Dtool_LPoint4i_unit_w_1126(PyObject *, PyObject *) {
  // 1-static inline LPoint4i const &LPoint4i::unit_w(void)
  LPoint4i const *return_value = &(LPoint4i::unit_w());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_unit_w_1126_comment =
  "C++ Interface:\n"
  "unit_w()\n"
  "\n"
  "/**\n"
  " * Returns a unit W point.\n"
  " */";
#else
static const char *Dtool_LPoint4i_unit_w_1126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3i LPoint4i::get_xyz(void) const
 */
static PyObject *Dtool_LPoint4i_get_xyz_1127(PyObject *self, PyObject *) {
  LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint3i LPoint4i::get_xyz(void) const
  LPoint3i *return_value = new LPoint3i((*(const LPoint4i*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_get_xyz_1127_comment =
  "C++ Interface:\n"
  "get_xyz(LPoint4i self)\n"
  "\n"
  "/**\n"
  " * Returns the x, y and z component of this vector\n"
  " */";
#else
static const char *Dtool_LPoint4i_get_xyz_1127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2i LPoint4i::get_xy(void) const
 */
static PyObject *Dtool_LPoint4i_get_xy_1128(PyObject *self, PyObject *) {
  LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LPoint2i LPoint4i::get_xy(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint4i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_get_xy_1128_comment =
  "C++ Interface:\n"
  "get_xy(LPoint4i self)\n"
  "\n"
  "/**\n"
  " * Returns the x and y component of this vector\n"
  " */";
#else
static const char *Dtool_LPoint4i_get_xy_1128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LPoint4i::get_class_type(void)
 */
static PyObject *Dtool_LPoint4i_get_class_type_1137(PyObject *, PyObject *) {
  // 1-static TypeHandle LPoint4i::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LPoint4i::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LPoint4i_get_class_type_1137_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LPoint4i_get_class_type_1137_comment = NULL;
#endif

static PyObject *Dtool_LPoint4i_xyz_Getter(PyObject *self, void *) {
  const LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3i LPoint4i::get_xyz(void) const
  LPoint3i *return_value = new LPoint3i((*(const LPoint4i*)local_this).get_xyz());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
}

static PyObject *Dtool_LPoint4i_xy_Getter(PyObject *self, void *) {
  const LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2i LPoint4i::get_xy(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint4i*)local_this).get_xy());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
}

/**
 * Python function wrapper for:
 * inline LPoint4i::LPoint4i(void) = default
 * inline LPoint4i::LPoint4i(LPoint4i const &) = default
 * inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w)
 * inline LPoint4i::LPoint4i(LVecBase4i const &copy)
 * inline LPoint4i::LPoint4i(int fill_value)
 * inline LPoint4i::LPoint4i(int x, int y, int z, int w)
 */
static int Dtool_Init_LPoint4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LPoint4i::LPoint4i(void) = default
      LPoint4i *return_value = new LPoint4i(0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LPoint4i::LPoint4i(LPoint4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4i", (char **)keyword_list, &param0)) {
          LPoint4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LPoint4i, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint4i *return_value = new LPoint4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4i::LPoint4i(LVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4i", (char **)keyword_list, &param0)) {
          LVecBase4i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4i, (void **)&param0_this);
          if (param0_this != NULL) {
            LPoint4i *return_value = new LPoint4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4i::LPoint4i(int fill_value)
        int param0;
        static const char *keyword_list[] = {"fill_value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LPoint4i", (char **)keyword_list, &param0)) {
          LPoint4i *return_value = new LPoint4i((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4i::LPoint4i(LPoint4i const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4i", (char **)keyword_list, &param0)) {
          LPoint4i param0_local;
          LPoint4i const *param0_this = Dtool_Coerce_LPoint4i(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint4i *return_value = new LPoint4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LPoint4i::LPoint4i(LVecBase4i const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LPoint4i", (char **)keyword_list, &param0)) {
          LVecBase4i param0_local;
          LVecBase4i const *param0_this = Dtool_Coerce_LVecBase4i(param0, param0_local);
          if ((param0_this != NULL)) {
            LPoint4i *return_value = new LPoint4i(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline LPoint4i::LPoint4i(int fill_value)
    }
    break;
  case 2:
    {
      // 1-inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"copy", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:LPoint4i", (char **)keyword_list, &param0, &param1)) {
        LVecBase3i param0_local;
        LVecBase3i const *param0_this = Dtool_Coerce_LVecBase3i(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LPoint4i.LPoint4i", "LVecBase3i");
          return -1;
        }
        LPoint4i *return_value = new LPoint4i(*param0_this, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LPoint4i::LPoint4i(int x, int y, int z, int w)
      int param0;
      int param1;
      int param2;
      int param3;
      static const char *keyword_list[] = {"x", "y", "z", "w", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:LPoint4i", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint4i *return_value = new LPoint4i((int)param0, (int)param1, (int)param2, (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LPoint4i, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LPoint4i() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LPoint4i()\n"
      "LPoint4i(const LPoint4i param0)\n"
      "LPoint4i(const LVecBase4i copy)\n"
      "LPoint4i(int fill_value)\n"
      "LPoint4i(const LVecBase3i copy, int w)\n"
      "LPoint4i(int x, int y, int z, int w)\n");
  }
  return -1;
}

LPoint4i *Dtool_Coerce_LPoint4i(PyObject *args, LPoint4i &coerced) {
  LPoint4i *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LPoint4i, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LPoint4i *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LPoint4i::LPoint4i(LVecBase4i const &copy)
      LVecBase4i const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LPoint4i(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LPoint4i::LPoint4i(int fill_value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return NULL;
        }
#endif
        coerced = LPoint4i((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w)
        PyObject *param0;
        int param1;
        if (PyArg_ParseTuple(args, "Oi:LPoint4i", &param0, &param1)) {
          LVecBase3i const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase3i, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LPoint4i(*param0_this, (int)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LPoint4i::LPoint4i(int x, int y, int z, int w)
        int param0;
        int param1;
        int param2;
        int param3;
        if (PyArg_ParseTuple(args, "iiii:LPoint4i", &param0, &param1, &param2, &param3)) {
          coerced = LPoint4i((int)param0, (int)param1, (int)param2, (int)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LPoint4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LPoint4i) {
    printf("LPoint4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LPoint4i *local_this = (LPoint4i *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LPoint4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4i) {
    return (LVecBase4i *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LPoint4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LPoint4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4i) {
    LVecBase4i* other_this = (LVecBase4i*)from_this;
    return (LPoint4i*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix3f
 */
/**
 * Python function wrapper for:
 * inline LMatrix3f &LMatrix3f::operator =(LMatrix3f const &other)
 * inline LMatrix3f &LMatrix3f::operator =(float fill_value)
 */
static PyObject *Dtool_LMatrix3f_operator_1152(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.assign")) {
    return NULL;
  }
  {
    // -2 inline LMatrix3f &LMatrix3f::operator =(LMatrix3f const &other)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LMatrix3f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, false);
    }
  }

  {
    // -2 inline LMatrix3f &LMatrix3f::operator =(float fill_value)
    if (PyNumber_Check(arg)) {
      (*local_this).operator =((float)PyFloat_AsDouble(arg));
      LMatrix3f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, false);
    }
  }

  {
    // -2 inline LMatrix3f &LMatrix3f::operator =(LMatrix3f const &other)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LMatrix3f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, false);
    }
  }

  // No coercion possible: inline LMatrix3f &LMatrix3f::operator =(float fill_value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LMatrix3f self, const LMatrix3f other)\n"
      "assign(const LMatrix3f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_operator_1152_comment =
  "C++ Interface:\n"
  "assign(const LMatrix3f self, const LMatrix3f other)\n"
  "assign(const LMatrix3f self, float fill_value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_operator_1152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LMatrix3f::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LMatrix3f_reduce_1156(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LMatrix3f::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LMatrix3f*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_reduce_1156_comment =
  "C++ Interface:\n"
  "__reduce__(LMatrix3f self)\n";
#else
static const char *Dtool_LMatrix3f_reduce_1156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::fill(float fill_value)
 */
static PyObject *Dtool_LMatrix3f_fill_1157(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.fill")) {
    return NULL;
  }
  // 1-void LMatrix3f::fill(float fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LMatrix3f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_fill_1157_comment =
  "C++ Interface:\n"
  "fill(const LMatrix3f self, float fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the matrix to the indicated fill_value.  This is of\n"
  " * questionable value, but is sometimes useful when initializing to zero.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_fill_1157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)
 */
static PyObject *Dtool_LMatrix3f_set_1158(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  static const char *keyword_list[] = {"e00", "e01", "e02", "e10", "e11", "e12", "e20", "e21", "e22", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    (*local_this).set((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LMatrix3f self, float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_1158_comment =
  "C++ Interface:\n"
  "set(const LMatrix3f self, float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_1158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_row(int row, LVecBase2f const &v)
 * inline void LMatrix3f::set_row(int row, LVecBase3f const &v)
 */
static PyObject *Dtool_LMatrix3f_set_row_1161(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_row")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3f::set_row(int row, LVecBase2f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase2f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase2f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3f::set_row(int row, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3f::set_row(int row, LVecBase2f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase2f param2_local;
      LVecBase2f const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3f::set_row(int row, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f param2_local;
      LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const LMatrix3f self, int row, const LVecBase2f v)\n"
      "set_row(const LMatrix3f self, int row, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_row_1161_comment =
  "C++ Interface:\n"
  "set_row(const LMatrix3f self, int row, const LVecBase2f v)\n"
  "set_row(const LMatrix3f self, int row, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix from a three-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix from a two-component vector,\n"
  " * ignoring the last column.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_row_1161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_col(int col, LVecBase2f const &v)
 * inline void LMatrix3f::set_col(int col, LVecBase3f const &v)
 */
static PyObject *Dtool_LMatrix3f_set_col_1162(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_col")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3f::set_col(int col, LVecBase2f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase2f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase2f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3f::set_col(int col, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3f::set_col(int col, LVecBase2f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase2f param2_local;
      LVecBase2f const *param2_this = Dtool_Coerce_LVecBase2f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3f::set_col(int col, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f param2_local;
      LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_col(const LMatrix3f self, int col, const LVecBase2f v)\n"
      "set_col(const LMatrix3f self, int col, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_col_1162_comment =
  "C++ Interface:\n"
  "set_col(const LMatrix3f self, int col, const LVecBase2f v)\n"
  "set_col(const LMatrix3f self, int col, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix from a three-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix from a two-component vector,\n"
  " * ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_col_1162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const
 * inline LVecBase3f LMatrix3f::get_row(int row) const
 */
static PyObject *Dtool_LMatrix3f_get_row_1163(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "row");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'row' (pos 1) not found");
      }
      // 1-inline LVecBase3f LMatrix3f::get_row(int row) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).get_row((int)arg_val));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"result_vec", "row", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_row", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.get_row", "LVecBase3f");
        }
        (*(const LMatrix3f*)local_this).get_row(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_row() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix3f self, int row)\n"
      "get_row(LMatrix3f self, LVecBase3f result_vec, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_row_1163_comment =
  "C++ Interface:\n"
  "get_row(LMatrix3f self, int row)\n"
  "get_row(LMatrix3f self, LVecBase3f result_vec, int row)\n"
  "\n"
  "// these versions inline better\n"
  "\n"
  "/**\n"
  " * Returns the indicated row of the matrix as a three-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the indicated row of the matrix as a three-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_row_1163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix3f::get_col(int col) const
 */
static PyObject *Dtool_LMatrix3f_get_col_1164(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix3f::get_col(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).get_col((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix3f self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_col_1164_comment =
  "C++ Interface:\n"
  "get_col(LMatrix3f self, int col)\n"
  "\n"
  "/**\n"
  " * Returns the indicated column of the matrix as a three-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_col_1164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LMatrix3f::get_row2(int row) const
 */
static PyObject *Dtool_LMatrix3f_get_row2_1169(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LMatrix3f::get_row2(int row) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2f *return_value = new LVecBase2f((*(const LMatrix3f*)local_this).get_row2((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row2(LMatrix3f self, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_row2_1169_comment =
  "C++ Interface:\n"
  "get_row2(LMatrix3f self, int row)\n"
  "\n"
  "/**\n"
  " * Returns the indicated row of the matrix as a two-component vector, ignoring\n"
  " * the last column.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_row2_1169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LMatrix3f::get_col2(int col) const
 */
static PyObject *Dtool_LMatrix3f_get_col2_1170(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LMatrix3f::get_col2(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2f *return_value = new LVecBase2f((*(const LMatrix3f*)local_this).get_col2((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col2(LMatrix3f self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_col2_1170_comment =
  "C++ Interface:\n"
  "get_col2(LMatrix3f self, int col)\n"
  "\n"
  "/**\n"
  " * Returns the indicated column of the matrix as a two-component vector,\n"
  " * ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_col2_1170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3f::is_nan(void) const
 */
static PyObject *Dtool_LMatrix3f_is_nan_1174(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix3f::is_nan(void) const
  bool return_value = (*(const LMatrix3f*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_is_nan_1174_comment =
  "C++ Interface:\n"
  "is_nan(LMatrix3f self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the matrix is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_is_nan_1174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3f::is_identity(void) const
 */
static PyObject *Dtool_LMatrix3f_is_identity_1175(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix3f::is_identity(void) const
  bool return_value = (*(const LMatrix3f*)local_this).is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_is_identity_1175_comment =
  "C++ Interface:\n"
  "is_identity(LMatrix3f self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is (close enough to) the identity matrix, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_is_identity_1175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LMatrix3f::get_cell(int row, int col) const
 */
static PyObject *Dtool_LMatrix3f_get_cell_1176(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LMatrix3f::get_cell(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_cell", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const LMatrix3f*)local_this).get_cell((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LMatrix3f self, int row, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_cell_1176_comment =
  "C++ Interface:\n"
  "get_cell(LMatrix3f self, int row, int col)\n"
  "\n"
  "/**\n"
  " * Returns a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_cell_1176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_cell(int row, int col, float value)
 */
static PyObject *Dtool_LMatrix3f_set_cell_1177(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_cell")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::set_cell(int row, int col, float value)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"row", "col", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_cell", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_cell((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LMatrix3f self, int row, int col, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_cell_1177_comment =
  "C++ Interface:\n"
  "set_cell(const LMatrix3f self, int row, int col, float value)\n"
  "\n"
  "/**\n"
  " * Changes a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_cell_1177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix3f::get_num_components(void) const
 */
static PyObject *Dtool_LMatrix3f_get_num_components_1179(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LMatrix3f::get_num_components(void) const
  int return_value = (*(const LMatrix3f*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_num_components_1179_comment =
  "C++ Interface:\n"
  "get_num_components(LMatrix3f self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the matrix, nine.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_num_components_1179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix3f::compare_to(LMatrix3f const &other) const
 * int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const
 */
static PyObject *Dtool_LMatrix3f_compare_to_1183(PyObject *self, PyObject *args) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LMatrix3f::compare_to(LMatrix3f const &other) const
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.compare_to", "LMatrix3f");
      }
      int return_value = (*(const LMatrix3f*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const
      PyObject *param1;
      float param2;
      if (PyArg_ParseTuple(args, "Of:compare_to", &param1, &param2)) {
        LMatrix3f param1_local;
        LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.compare_to", "LMatrix3f");
        }
        int return_value = (*(const LMatrix3f*)local_this).compare_to(*param1_this, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix3f self, const LMatrix3f other)\n"
      "compare_to(LMatrix3f self, const LMatrix3f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_compare_to_1183_comment =
  "C++ Interface:\n"
  "compare_to(LMatrix3f self, const LMatrix3f other)\n"
  "compare_to(LMatrix3f self, const LMatrix3f other, float threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts matrices lexicographically, componentwise.  Returns a number less\n"
  " * than 0 if this matrix sorts before the other one, greater than zero if it\n"
  " * sorts after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LMatrix3f_compare_to_1183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix3f::get_hash(void) const
 * inline std::size_t LMatrix3f::get_hash(float threshold) const
 */
static PyObject *Dtool_LMatrix3f_get_hash_1184(PyObject *self, PyObject *args) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LMatrix3f::get_hash(void) const
      std::size_t return_value = (*(const LMatrix3f*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LMatrix3f::get_hash(float threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LMatrix3f*)local_this).get_hash((float)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LMatrix3f self)\n"
      "get_hash(LMatrix3f self, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_hash_1184_comment =
  "C++ Interface:\n"
  "get_hash(LMatrix3f self)\n"
  "get_hash(LMatrix3f self, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_get_hash_1184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix3f::add_hash(std::size_t hash) const
 * inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const
 */
static PyObject *Dtool_LMatrix3f_add_hash_1185(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LMatrix3f::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix3f*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const
      Py_ssize_t param1;
      float param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nf:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix3f*)local_this).add_hash((std::size_t)param1, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LMatrix3f self, int hash)\n"
      "add_hash(LMatrix3f self, int hash, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_add_hash_1185_comment =
  "C++ Interface:\n"
  "add_hash(LMatrix3f self, int hash)\n"
  "add_hash(LMatrix3f self, int hash, float threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_add_hash_1185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_1186(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.xform", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).xform(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(LMatrix3f self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_1186_comment =
  "C++ Interface:\n"
  "xform(LMatrix3f self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * 3-component vector or point times matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_1186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_point_1187(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.xform_point", "LVecBase2f");
  }
  LVecBase2f *return_value = new LVecBase2f((*(const LMatrix3f*)local_this).xform_point(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point(LMatrix3f self, const LVecBase2f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_point_1187_comment =
  "C++ Interface:\n"
  "xform_point(LMatrix3f self, const LVecBase2f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component point (including translation component)\n"
  " * and returns the result.  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_point_1187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const
 * inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_vec_1188(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2f *return_value = new LVecBase2f((*(const LMatrix3f*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2f *return_value = new LVecBase2f((*(const LMatrix3f*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec(LMatrix3f self, const LVecBase3f v)\n"
      "xform_vec(LMatrix3f self, const LVecBase2f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_vec_1188_comment =
  "C++ Interface:\n"
  "xform_vec(LMatrix3f self, const LVecBase3f v)\n"
  "xform_vec(LMatrix3f self, const LVecBase2f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component vector (without translation component)\n"
  " * and returns the result.  This assumes the matrix is an affine transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector and returns the result.  This\n"
  " * assumes the matrix is an orthonormal transform.\n"
  " *\n"
  " * In practice, this is the same computation as xform().\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_vec_1188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_vec_general_1189(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.xform_vec_general", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).xform_vec_general(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general(LMatrix3f self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_vec_general_1189_comment =
  "C++ Interface:\n"
  "xform_vec_general(LMatrix3f self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component)\n"
  " * and returns the result, as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_vec_general_1189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::xform_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_in_place_1190(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix3f::xform_in_place(LVecBase3f &v) const
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.xform_in_place", "LVecBase3f");
  }
  (*(const LMatrix3f*)local_this).xform_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_in_place(LMatrix3f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_in_place_1190_comment =
  "C++ Interface:\n"
  "xform_in_place(LMatrix3f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * 3-component vector or point times matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_in_place_1190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_point_in_place_1191(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const
  LVecBase2f arg_local;
  LVecBase2f *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.xform_point_in_place", "LVecBase2f");
  }
  (*(const LMatrix3f*)local_this).xform_point_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_in_place(LMatrix3f self, LVecBase2f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_point_in_place_1191_comment =
  "C++ Interface:\n"
  "xform_point_in_place(LMatrix3f self, LVecBase2f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component point (including translation\n"
  " * component).  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_point_in_place_1191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const
 * inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_vec_in_place_1192(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const
    LVecBase2f *arg_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase2f, 1, "LMatrix3f.xform_vec_in_place", false, false);
    if (arg_this != NULL) {
      (*(const LMatrix3f*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const
    LVecBase3f *arg_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase3f, 1, "LMatrix3f.xform_vec_in_place", false, false);
    if (arg_this != NULL) {
      (*(const LMatrix3f*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const
    LVecBase2f arg_local;
    LVecBase2f *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LMatrix3f*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const
    LVecBase3f arg_local;
    LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LMatrix3f*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_in_place(LMatrix3f self, LVecBase2f v)\n"
      "xform_vec_in_place(LMatrix3f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_vec_in_place_1192_comment =
  "C++ Interface:\n"
  "xform_vec_in_place(LMatrix3f self, LVecBase2f v)\n"
  "xform_vec_in_place(LMatrix3f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component vector (without translation component).\n"
  " * This assumes the matrix is an affine transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector.  This assumes the matrix is an\n"
  " * orthonormal transform.\n"
  " *\n"
  " * In practice, this is the same computation as xform().\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_vec_in_place_1192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix3f_xform_vec_general_in_place_1193(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.xform_vec_general_in_place", "LVecBase3f");
  }
  (*(const LMatrix3f*)local_this).xform_vec_general_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general_in_place(LMatrix3f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_xform_vec_general_in_place_1193_comment =
  "C++ Interface:\n"
  "xform_vec_general_in_place(LMatrix3f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component),\n"
  " * as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_xform_vec_general_in_place_1193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2)
 */
static PyObject *Dtool_LMatrix3f_multiply_1194(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.multiply")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other1", "other2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:multiply", (char **)keyword_list, &param1, &param2)) {
    LMatrix3f param1_local;
    LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.multiply", "LMatrix3f");
    }
    LMatrix3f param2_local;
    LMatrix3f const *param2_this = Dtool_Coerce_LMatrix3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3f.multiply", "LMatrix3f");
    }
    (*local_this).multiply(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multiply(const LMatrix3f self, const LMatrix3f other1, const LMatrix3f other2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_multiply_1194_comment =
  "C++ Interface:\n"
  "multiply(const LMatrix3f self, const LMatrix3f other1, const LMatrix3f other2)\n"
  "\n"
  "// this = other1 * other2\n"
  "\n"
  "// this = other1 * other2";
#else
static const char *Dtool_LMatrix3f_multiply_1194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::componentwise_mult(LMatrix3f const &other)
 */
static PyObject *Dtool_LMatrix3f_componentwise_mult_1201(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::componentwise_mult(LMatrix3f const &other)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.componentwise_mult", "LMatrix3f");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LMatrix3f self, const LMatrix3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_componentwise_mult_1201_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LMatrix3f self, const LMatrix3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_componentwise_mult_1201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LMatrix3f::determinant(void) const
 */
static PyObject *Dtool_LMatrix3f_determinant_1202(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LMatrix3f::determinant(void) const
  float return_value = (*(const LMatrix3f*)local_this).determinant();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_determinant_1202_comment =
  "C++ Interface:\n"
  "determinant(LMatrix3f self)\n"
  "\n"
  "/**\n"
  " * Returns the determinant of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_determinant_1202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::transpose_from(LMatrix3f const &other)
 */
static PyObject *Dtool_LMatrix3f_transpose_from_1203(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.transpose_from")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::transpose_from(LMatrix3f const &other)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.transpose_from", "LMatrix3f");
  }
  (*local_this).transpose_from(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transpose_from(const LMatrix3f self, const LMatrix3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_transpose_from_1203_comment =
  "C++ Interface:\n"
  "transpose_from(const LMatrix3f self, const LMatrix3f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_transpose_from_1203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::transpose_in_place(void)
 */
static PyObject *Dtool_LMatrix3f_transpose_in_place_1204(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.transpose_in_place")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::transpose_in_place(void)
  (*local_this).transpose_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_transpose_in_place_1204_comment =
  "C++ Interface:\n"
  "transpose_in_place(const LMatrix3f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_transpose_in_place_1204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3f::invert_from(LMatrix3f const &other)
 */
static PyObject *Dtool_LMatrix3f_invert_from_1205(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.invert_from")) {
    return NULL;
  }
  // 1-inline bool LMatrix3f::invert_from(LMatrix3f const &other)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.invert_from", "LMatrix3f");
  }
  bool return_value = (*local_this).invert_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_from(const LMatrix3f self, const LMatrix3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_invert_from_1205_comment =
  "C++ Interface:\n"
  "invert_from(const LMatrix3f self, const LMatrix3f other)\n"
  "\n"
  "/**\n"
  " * Computes the inverse of the other matrix, and stores the result in this\n"
  " * matrix.  This is a fully general operation and makes no assumptions about\n"
  " * the type of transform represented by the matrix.\n"
  " *\n"
  " * The other matrix must be a different object than this matrix.  However, if\n"
  " * you need to invert a matrix in place, see invert_in_place.\n"
  " *\n"
  " * The return value is true if the matrix was successfully inverted, false if\n"
  " * there was a singularity.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_invert_from_1205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3f::invert_in_place(void)
 */
static PyObject *Dtool_LMatrix3f_invert_in_place_1206(PyObject *self, PyObject *) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.invert_in_place")) {
    return NULL;
  }
  // 1-inline bool LMatrix3f::invert_in_place(void)
  bool return_value = (*local_this).invert_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_invert_in_place_1206_comment =
  "C++ Interface:\n"
  "invert_in_place(const LMatrix3f self)\n"
  "\n"
  "/**\n"
  " * Inverts the current matrix.  Returns true if the inverse is successful,\n"
  " * false if the matrix was singular.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_invert_in_place_1206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other)
 * inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other)
 */
static PyObject *Dtool_LMatrix3f_invert_transpose_from_1207(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.invert_transpose_from")) {
    return NULL;
  }
  {
    // -2 inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_transpose_from(const LMatrix3f self, const LMatrix4f other)\n"
      "invert_transpose_from(const LMatrix3f self, const LMatrix3f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_invert_transpose_from_1207_comment =
  "C++ Interface:\n"
  "invert_transpose_from(const LMatrix3f self, const LMatrix4f other)\n"
  "invert_transpose_from(const LMatrix3f self, const LMatrix3f other)\n"
  "\n"
  "/**\n"
  " * Simultaneously computes the inverse of the indicated matrix, and then the\n"
  " * transpose of that inverse.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Simultaneously computes the inverse of the indicated matrix, and then the\n"
  " * transpose of that inverse.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_invert_transpose_from_1207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f const &LMatrix3f::ident_mat(void)
 */
static PyObject *Dtool_LMatrix3f_ident_mat_1208(PyObject *, PyObject *) {
  // 1-static inline LMatrix3f const &LMatrix3f::ident_mat(void)
  LMatrix3f const *return_value = &(LMatrix3f::ident_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_ident_mat_1208_comment =
  "C++ Interface:\n"
  "ident_mat()\n"
  "\n"
  "/**\n"
  " * Returns an identity matrix.\n"
  " *\n"
  " * This function definition must appear first, since some inline functions\n"
  " * below take advantage of it.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_ident_mat_1208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans)
 */
static PyObject *Dtool_LMatrix3f_set_translate_mat_1209(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_translate_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.set_translate_mat", "LVecBase2f");
  }
  (*local_this).set_translate_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_translate_mat(const LMatrix3f self, const LVecBase2f trans)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_translate_mat_1209_comment =
  "C++ Interface:\n"
  "set_translate_mat(const LMatrix3f self, const LVecBase2f trans)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_translate_mat_1209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_rotate_mat(float angle)
 * void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_set_rotate_mat_1210(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_rotate_mat")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "angle");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'angle' (pos 1) not found");
      }
      // 1-inline void LMatrix3f::set_rotate_mat(float angle)
      if (PyNumber_Check(arg)) {
        (*local_this).set_rotate_mat((float)PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
      float param1;
      PyObject *param2;
      int param3 = ::CS_default;
      static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:set_rotate_mat", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3f.set_rotate_mat", "LVecBase3f");
        }
        (*local_this).set_rotate_mat((float)param1, *param2_this, (CoordinateSystem)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_rotate_mat() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat(const LMatrix3f self, float angle)\n"
      "set_rotate_mat(const LMatrix3f self, float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_rotate_mat_1210_comment =
  "C++ Interface:\n"
  "set_rotate_mat(const LMatrix3f self, float angle)\n"
  "set_rotate_mat(const LMatrix3f self, float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_rotate_mat_1210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale)
 * inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale)
 */
static PyObject *Dtool_LMatrix3f_set_scale_mat_1211(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_scale_mat")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale)
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale)
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale)
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale)
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_mat(const LMatrix3f self, const LVecBase3f scale)\n"
      "set_scale_mat(const LMatrix3f self, const LVecBase2f scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_scale_mat_1211_comment =
  "C++ Interface:\n"
  "set_scale_mat(const LMatrix3f self, const LVecBase3f scale)\n"
  "set_scale_mat(const LMatrix3f self, const LVecBase2f scale)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale in each of the two\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale in each of the\n"
  " * three axes.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_scale_mat_1211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans)
 * static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty)
 */
static PyObject *Dtool_LMatrix3f_translate_mat_1212(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "trans");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'trans' (pos 1) not found");
      }
      // 1-static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans)
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix3f.translate_mat", "LVecBase2f");
      }
      LMatrix3f *return_value = new LMatrix3f(LMatrix3f::translate_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
    break;
  case 2:
    {
      // 1-static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty)
      float param0;
      float param1;
      static const char *keyword_list[] = {"tx", "ty", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:translate_mat", (char **)keyword_list, &param0, &param1)) {
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::translate_mat((float)param0, (float)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "translate_mat() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "translate_mat(const LVecBase2f trans)\n"
      "translate_mat(float tx, float ty)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_translate_mat_1212_comment =
  "C++ Interface:\n"
  "translate_mat(const LVecBase2f trans)\n"
  "translate_mat(float tx, float ty)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_translate_mat_1212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f LMatrix3f::rotate_mat(float angle)
 * static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_rotate_mat_1213(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "angle");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'angle' (pos 1) not found");
      }
      // 1-static inline LMatrix3f LMatrix3f::rotate_mat(float angle)
      if (PyNumber_Check(arg)) {
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::rotate_mat((float)PyFloat_AsDouble(arg)));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
      float param0;
      PyObject *param1;
      int param2 = ::CS_default;
      static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:rotate_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.rotate_mat", "LVecBase3f");
        }
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::rotate_mat((float)param0, *param1_this, (CoordinateSystem)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "rotate_mat() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat(float angle)\n"
      "rotate_mat(float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_rotate_mat_1213_comment =
  "C++ Interface:\n"
  "rotate_mat(float angle)\n"
  "rotate_mat(float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_rotate_mat_1213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale)
 * static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale)
 * static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy)
 * static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz)
 */
static PyObject *Dtool_LMatrix3f_scale_mat_1214(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      {
        // -2 static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale)
        LVecBase2f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
        if (arg_this != NULL) {
          LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
        }
      }

      {
        // -2 static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale)
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
        }
      }

      {
        // -2 static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale)
        LVecBase2f arg_local;
        LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
        if ((arg_this != NULL)) {
          LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
        }
      }

      {
        // -2 static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
        }
      }

    }
    break;
  case 2:
    {
      // 1-static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy)
      float param0;
      float param1;
      static const char *keyword_list[] = {"sx", "sy", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:scale_mat", (char **)keyword_list, &param0, &param1)) {
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_mat((float)param0, (float)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"sx", "sy", "sz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:scale_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_mat((float)param0, (float)param1, (float)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_mat() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_mat(const LVecBase2f scale)\n"
      "scale_mat(const LVecBase3f scale)\n"
      "scale_mat(float sx, float sy)\n"
      "scale_mat(float sx, float sy, float sz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_scale_mat_1214_comment =
  "C++ Interface:\n"
  "scale_mat(const LVecBase2f scale)\n"
  "scale_mat(const LVecBase3f scale)\n"
  "scale_mat(float sx, float sy)\n"
  "scale_mat(float sx, float sy, float sz)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the two axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the two axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_scale_mat_1214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_set_rotate_mat_normaxis_1215(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_rotate_mat_normaxis")) {
    return NULL;
  }
  // 1-void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
  float param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:set_rotate_mat_normaxis", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3f.set_rotate_mat_normaxis", "LVecBase3f");
    }
    (*local_this).set_rotate_mat_normaxis((float)param1, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat_normaxis(const LMatrix3f self, float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_rotate_mat_normaxis_1215_comment =
  "C++ Interface:\n"
  "set_rotate_mat_normaxis(const LMatrix3f self, float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * normalized.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_rotate_mat_normaxis_1215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_rotate_mat_normaxis_1216(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
  float param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:rotate_mat_normaxis", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.rotate_mat_normaxis", "LVecBase3f");
    }
    LMatrix3f *return_value = new LMatrix3f(LMatrix3f::rotate_mat_normaxis((float)param0, *param1_this, (CoordinateSystem)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat_normaxis(float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_rotate_mat_normaxis_1216_comment =
  "C++ Interface:\n"
  "rotate_mat_normaxis(float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * normalized.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_rotate_mat_normaxis_1216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_set_shear_mat_1217(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_shear_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shear_mat", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.set_shear_mat", "LVecBase3f");
    }
    (*local_this).set_shear_mat(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear_mat(const LMatrix3f self, const LVecBase3f shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_shear_mat_1217_comment =
  "C++ Interface:\n"
  "set_shear_mat(const LMatrix3f self, const LVecBase3f shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated shear in each of the\n"
  " * three planes.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_shear_mat_1217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_shear_mat_1218(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shear");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shear' (pos 1) not found");
      }
      // 1-static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix3f.shear_mat", "LVecBase3f");
      }
      LMatrix3f *return_value = new LMatrix3f(LMatrix3f::shear_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
    break;
  case 2:
    {
      // 1-static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix3f.shear_mat", "LVecBase3f");
        }
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::shear_mat(*param0_this, (CoordinateSystem)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
      float param0;
      float param1;
      float param2;
      int param3 = ::CS_default;
      static const char *keyword_list[] = {"shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|i:shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::shear_mat((float)param0, (float)param1, (float)param2, (CoordinateSystem)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "shear_mat() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "shear_mat(const LVecBase3f shear)\n"
      "shear_mat(const LVecBase3f shear, int cs)\n"
      "shear_mat(float shxy, float shxz, float shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_shear_mat_1218_comment =
  "C++ Interface:\n"
  "shear_mat(const LVecBase3f shear)\n"
  "shear_mat(const LVecBase3f shear, int cs)\n"
  "shear_mat(float shxy, float shxz, float shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_shear_mat_1218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_set_scale_shear_mat_1219(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.set_scale_shear_mat")) {
    return NULL;
  }
  // 1-void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:set_scale_shear_mat", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.set_scale_shear_mat", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3f.set_scale_shear_mat", "LVecBase3f");
    }
    (*local_this).set_scale_shear_mat(*param1_this, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_shear_mat(const LMatrix3f self, const LVecBase3f scale, const LVecBase3f shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_set_scale_shear_mat_1219_comment =
  "C++ Interface:\n"
  "set_scale_shear_mat(const LMatrix3f self, const LVecBase3f scale, const LVecBase3f shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_set_scale_shear_mat_1219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3f_scale_shear_mat_1220(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"scale", "shear", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:scale_shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix3f.scale_shear_mat", "LVecBase3f");
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.scale_shear_mat", "LVecBase3f");
        }
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_shear_mat(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix3f.scale_shear_mat", "LVecBase3f");
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.scale_shear_mat", "LVecBase3f");
        }
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_shear_mat(*param0_this, *param1_this, (CoordinateSystem)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
  case 6:
  case 7:
    {
      // 1-static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      int param6 = ::CS_default;
      static const char *keyword_list[] = {"sx", "sy", "sz", "shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff|i:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LMatrix3f *return_value = new LMatrix3f(LMatrix3f::scale_shear_mat((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (CoordinateSystem)param6));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_shear_mat() takes 2, 3, 6 or 7 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear)\n"
      "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear, int cs)\n"
      "scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_scale_shear_mat_1220_comment =
  "C++ Interface:\n"
  "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear)\n"
  "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear, int cs)\n"
  "scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_scale_shear_mat_1220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to)
 */
static PyObject *Dtool_LMatrix3f_convert_mat_1221(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to)
  int param0;
  int param1;
  static const char *keyword_list[] = {"from", "to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:convert_mat", (char **)keyword_list, &param0, &param1)) {
    LMatrix3f const *return_value = &(LMatrix3f::convert_mat((CoordinateSystem)param0, (CoordinateSystem)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "convert_mat(int from, int to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_convert_mat_1221_comment =
  "C++ Interface:\n"
  "convert_mat(int from, int to)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the indicated coordinate system to\n"
  " * the indicated coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_convert_mat_1221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const
 * bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const
 */
static PyObject *Dtool_LMatrix3f_almost_equal_1222(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.almost_equal", "LMatrix3f");
      }
      bool return_value = (*(const LMatrix3f*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LMatrix3f param1_local;
        LMatrix3f const *param1_this = Dtool_Coerce_LMatrix3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3f.almost_equal", "LMatrix3f");
        }
        bool return_value = (*(const LMatrix3f*)local_this).almost_equal(*param1_this, (float)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LMatrix3f self, const LMatrix3f other)\n"
      "almost_equal(LMatrix3f self, const LMatrix3f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_almost_equal_1222_comment =
  "C++ Interface:\n"
  "almost_equal(LMatrix3f self, const LMatrix3f other)\n"
  "almost_equal(LMatrix3f self, const LMatrix3f other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a default\n"
  " * tolerance based on the numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_almost_equal_1222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::output(ostream &out) const
 */
static PyObject *Dtool_LMatrix3f_output_1223(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3f::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LMatrix3f.output", false, true);
  if (arg_this != NULL) {
    (*(const LMatrix3f*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LMatrix3f self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_output_1223_comment =
  "C++ Interface:\n"
  "output(LMatrix3f self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_output_1223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LMatrix3f_write_1224(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3f::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LMatrix3f.write", false, true);
    if (param1_this != NULL) {
      (*(const LMatrix3f*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LMatrix3f self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_write_1224_comment =
  "C++ Interface:\n"
  "write(LMatrix3f self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3f_write_1224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix3f_write_datagram_fixed_1227(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3f::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.write_datagram_fixed", "Datagram");
  }
  (*(const LMatrix3f*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LMatrix3f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_write_datagram_fixed_1227_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LMatrix3f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the matrix, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_write_datagram_fixed_1227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::read_datagram_fixed(DatagramIterator &scan)
 */
static PyObject *Dtool_LMatrix3f_read_datagram_fixed_1228(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.read_datagram_fixed")) {
    return NULL;
  }
  // 1-void LMatrix3f::read_datagram_fixed(DatagramIterator &scan)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LMatrix3f self, DatagramIterator scan)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_read_datagram_fixed_1228_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LMatrix3f self, DatagramIterator scan)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LMatrix3f_read_datagram_fixed_1228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix3f_write_datagram_1229(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3f::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.write_datagram", "Datagram");
  }
  (*(const LMatrix3f*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LMatrix3f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_write_datagram_1229_comment =
  "C++ Interface:\n"
  "write_datagram(LMatrix3f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the matrix using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix3f_write_datagram_1229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3f::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LMatrix3f_read_datagram_1230(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3f, (void **)&local_this, "LMatrix3f.read_datagram")) {
    return NULL;
  }
  // 1-void LMatrix3f::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LMatrix3f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_read_datagram_1230_comment =
  "C++ Interface:\n"
  "read_datagram(const LMatrix3f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LMatrix3f_read_datagram_1230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LMatrix3f::get_class_type(void)
 */
static PyObject *Dtool_LMatrix3f_get_class_type_1231(PyObject *, PyObject *) {
  // 1-static TypeHandle LMatrix3f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LMatrix3f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3f_get_class_type_1231_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LMatrix3f_get_class_type_1231_comment = NULL;
#endif

/**
 * sequence length function for property LMatrix3f::rows
 */
static Py_ssize_t Dtool_LMatrix3f_rows_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix3f::size();
}

/**
 * sequence getter for property LMatrix3f::rows
 */
static PyObject *Dtool_LMatrix3f_rows_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix3f::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3f.rows[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix3f::get_row(int row) const
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).get_row(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix3f self, index)\n");
  }
}

static PyObject *Dtool_LMatrix3f_rows_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix3f_rows_Len;
  wrap->_getitem_func = &Dtool_LMatrix3f_rows_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LMatrix3f::cols
 */
static Py_ssize_t Dtool_LMatrix3f_cols_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix3f::size();
}

/**
 * sequence getter for property LMatrix3f::cols
 */
static PyObject *Dtool_LMatrix3f_cols_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix3f::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3f.cols[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix3f::get_col(int col) const
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix3f*)local_this).get_col(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix3f self, index)\n");
  }
}

static PyObject *Dtool_LMatrix3f_cols_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix3f_cols_Len;
  wrap->_getitem_func = &Dtool_LMatrix3f_cols_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline LMatrix3f::LMatrix3f(void)
 * inline LMatrix3f::LMatrix3f(LMatrix3f const &other)
 * inline LMatrix3f::LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)
 */
static int Dtool_Init_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix3f::LMatrix3f(void)
      LMatrix3f *return_value = new LMatrix3f(LMatrix3f::ident_mat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
        return -1;
      }
      // 1-inline LMatrix3f::LMatrix3f(LMatrix3f const &other)
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LMatrix3f.LMatrix3f", "LMatrix3f");
        return -1;
      }
      LMatrix3f *return_value = new LMatrix3f(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3f, true, false);
    }
    break;
  case 9:
    {
      // 1-inline LMatrix3f::LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      static const char *keyword_list[] = {"e00", "e01", "e02", "e10", "e11", "e12", "e20", "e21", "e22", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffffff:LMatrix3f", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
        LMatrix3f *return_value = new LMatrix3f((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LMatrix3f() takes 0, 1 or 9 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LMatrix3f()\n"
      "LMatrix3f(const LMatrix3f other)\n"
      "LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)\n");
  }
  return -1;
}

LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  LMatrix3f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LMatrix3f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LMatrix3f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 9) {
      // 1-inline LMatrix3f::LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      if (PyArg_ParseTuple(args, "fffffffff:LMatrix3f", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
        coerced = LMatrix3f((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3f_get_rows(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3f::size();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_LMatrix3f_get_row_1163(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3f_get_cols(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3f::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix3f_get_col_1164(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3f_get_col2s(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3f::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix3f_get_col2_1170(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3f_get_row2s(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3f::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix3f_get_row2_1169(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix3f) {
    printf("LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix3f *local_this = (LMatrix3f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix3f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix3f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix3f::Row
 */
/**
 * Python function wrapper for:
 * inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default
 */
static int Dtool_Init_LMatrix3f_Row(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Row() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default
  LMatrix3f::Row const *arg_this = (LMatrix3f::Row *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix3f_Row, 0, "Row.Row", true, true);
  if (arg_this != NULL) {
    LMatrix3f::Row *return_value = new LMatrix3f::Row(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3f_Row, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Row(const Row param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix3f_Row(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix3f_Row) {
    printf("LMatrix3f_Row ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix3f::Row *local_this = (LMatrix3f::Row *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix3f_Row) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix3f_Row(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix3f_Row) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix3f::CRow
 */
/**
 * Python function wrapper for:
 * inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default
 */
static int Dtool_Init_LMatrix3f_CRow(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CRow() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default
  LMatrix3f::CRow const *arg_this = (LMatrix3f::CRow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix3f_CRow, 0, "CRow.CRow", true, true);
  if (arg_this != NULL) {
    LMatrix3f::CRow *return_value = new LMatrix3f::CRow(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3f_CRow, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CRow(const CRow param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix3f_CRow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix3f_CRow) {
    printf("LMatrix3f_CRow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix3f::CRow *local_this = (LMatrix3f::CRow *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix3f_CRow) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix3f_CRow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix3f_CRow) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix4f
 */
/**
 * Python function wrapper for:
 * inline LMatrix4f &LMatrix4f::operator =(LMatrix4f const &other)
 * inline LMatrix4f &LMatrix4f::operator =(UnalignedLMatrix4f const &other)
 * inline LMatrix4f &LMatrix4f::operator =(float fill_value)
 */
static PyObject *Dtool_LMatrix4f_operator_1248(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.assign")) {
    return NULL;
  }
  {
    // -2 inline LMatrix4f &LMatrix4f::operator =(LMatrix4f const &other)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, false);
    }
  }

  {
    // -2 inline LMatrix4f &LMatrix4f::operator =(UnalignedLMatrix4f const &other)
    UnalignedLMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, false);
    }
  }

  {
    // -2 inline LMatrix4f &LMatrix4f::operator =(float fill_value)
    if (PyNumber_Check(arg)) {
      (*local_this).operator =((float)PyFloat_AsDouble(arg));
      LMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, false);
    }
  }

  {
    // -2 inline LMatrix4f &LMatrix4f::operator =(LMatrix4f const &other)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, false);
    }
  }

  {
    // -2 inline LMatrix4f &LMatrix4f::operator =(UnalignedLMatrix4f const &other)
    UnalignedLMatrix4f arg_local;
    UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, false);
    }
  }

  // No coercion possible: inline LMatrix4f &LMatrix4f::operator =(float fill_value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LMatrix4f self, const LMatrix4f other)\n"
      "assign(const LMatrix4f self, const UnalignedLMatrix4f other)\n"
      "assign(const LMatrix4f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_operator_1248_comment =
  "C++ Interface:\n"
  "assign(const LMatrix4f self, const LMatrix4f other)\n"
  "assign(const LMatrix4f self, const UnalignedLMatrix4f other)\n"
  "assign(const LMatrix4f self, float fill_value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_operator_1248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LMatrix4f::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LMatrix4f_reduce_1252(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LMatrix4f::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LMatrix4f*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_reduce_1252_comment =
  "C++ Interface:\n"
  "__reduce__(LMatrix4f self)\n";
#else
static const char *Dtool_LMatrix4f_reduce_1252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::fill(float fill_value)
 */
static PyObject *Dtool_LMatrix4f_fill_1253(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.fill")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::fill(float fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LMatrix4f self, float fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_fill_1253_comment =
  "C++ Interface:\n"
  "fill(const LMatrix4f self, float fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the matrix to the indicated fill_value.  This is of\n"
  " * questionable value, but is sometimes useful when initializing to zero.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_fill_1253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
 */
static PyObject *Dtool_LMatrix4f_set_1254(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  float param10;
  float param11;
  float param12;
  float param13;
  float param14;
  float param15;
  float param16;
  static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16)) {
    (*local_this).set((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15, (float)param16);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LMatrix4f self, float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_1254_comment =
  "C++ Interface:\n"
  "set(const LMatrix4f self, float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_1254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3)
 */
static PyObject *Dtool_LMatrix4f_set_upper_3_1255(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_upper_3")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.set_upper_3", "LMatrix3f");
  }
  (*local_this).set_upper_3(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_upper_3(const LMatrix4f self, const LMatrix3f upper3)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_upper_3_1255_comment =
  "C++ Interface:\n"
  "set_upper_3(const LMatrix4f self, const LMatrix3f upper3)\n"
  "\n"
  "// Get and set the upper 3x3 rotation matrix.\n"
  "\n"
  "/**\n"
  " * Sets the upper 3x3 submatrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_upper_3_1255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f LMatrix4f::get_upper_3(void) const
 */
static PyObject *Dtool_LMatrix4f_get_upper_3_1256(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3f LMatrix4f::get_upper_3(void) const
  LMatrix3f *return_value = new LMatrix3f((*(const LMatrix4f*)local_this).get_upper_3());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_upper_3_1256_comment =
  "C++ Interface:\n"
  "get_upper_3(LMatrix4f self)\n"
  "\n"
  "/**\n"
  " * Retrieves the upper 3x3 submatrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_upper_3_1256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_row(int row, LVecBase3f const &v)
 * inline void LMatrix4f::set_row(int row, LVecBase4f const &v)
 */
static PyObject *Dtool_LMatrix4f_set_row_1259(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_row")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix4f::set_row(int row, LVecBase4f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase4f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase4f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4f::set_row(int row, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4f::set_row(int row, LVecBase4f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase4f param2_local;
      LVecBase4f const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4f::set_row(int row, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f param2_local;
      LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const LMatrix4f self, int row, const LVecBase4f v)\n"
      "set_row(const LMatrix4f self, int row, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_row_1259_comment =
  "C++ Interface:\n"
  "set_row(const LMatrix4f self, int row, const LVecBase4f v)\n"
  "set_row(const LMatrix4f self, int row, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix with the indicated 3-component\n"
  " * vector, ignoring the last column.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_row_1259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_col(int col, LVecBase3f const &v)
 * inline void LMatrix4f::set_col(int col, LVecBase4f const &v)
 */
static PyObject *Dtool_LMatrix4f_set_col_1260(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_col")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix4f::set_col(int col, LVecBase4f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase4f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase4f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4f::set_col(int col, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3f, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4f::set_col(int col, LVecBase4f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase4f param2_local;
      LVecBase4f const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4f::set_col(int col, LVecBase3f const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3f param2_local;
      LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_col(const LMatrix4f self, int col, const LVecBase4f v)\n"
      "set_col(const LMatrix4f self, int col, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_col_1260_comment =
  "C++ Interface:\n"
  "set_col(const LMatrix4f self, int col, const LVecBase4f v)\n"
  "set_col(const LMatrix4f self, int col, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix with the indicated 3-component\n"
  " * vector, ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_col_1260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const
 * inline LVecBase4f LMatrix4f::get_row(int row) const
 */
static PyObject *Dtool_LMatrix4f_get_row_1261(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "row");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'row' (pos 1) not found");
      }
      // 1-inline LVecBase4f LMatrix4f::get_row(int row) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase4f *return_value = new LVecBase4f((*(const LMatrix4f*)local_this).get_row((int)arg_val));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"result_vec", "row", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_row", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param1_local;
        LVecBase4f *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.get_row", "LVecBase4f");
        }
        (*(const LMatrix4f*)local_this).get_row(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_row() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix4f self, int row)\n"
      "get_row(LMatrix4f self, LVecBase4f result_vec, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_row_1261_comment =
  "C++ Interface:\n"
  "get_row(LMatrix4f self, int row)\n"
  "get_row(LMatrix4f self, LVecBase4f result_vec, int row)\n"
  "\n"
  "// these versions inline better\n"
  "\n"
  "/**\n"
  " * Retrieves the indicated row of the matrix as a 4-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the indicated row of the matrix as a 4-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_row_1261_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f LMatrix4f::get_col(int col) const
 */
static PyObject *Dtool_LMatrix4f_get_col_1262(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f LMatrix4f::get_col(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase4f *return_value = new LVecBase4f((*(const LMatrix4f*)local_this).get_col((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix4f self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_col_1262_comment =
  "C++ Interface:\n"
  "get_col(LMatrix4f self, int col)\n"
  "\n"
  "/**\n"
  " * Retrieves the indicated column of the matrix as a 4-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_col_1262_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const
 * inline LVecBase3f LMatrix4f::get_row3(int row) const
 */
static PyObject *Dtool_LMatrix4f_get_row3_1263(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "row");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'row' (pos 1) not found");
      }
      // 1-inline LVecBase3f LMatrix4f::get_row3(int row) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3f *return_value = new LVecBase3f((*(const LMatrix4f*)local_this).get_row3((int)arg_val));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"result_vec", "row", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_row3", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.get_row3", "LVecBase3f");
        }
        (*(const LMatrix4f*)local_this).get_row3(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_row3() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row3(LMatrix4f self, int row)\n"
      "get_row3(LMatrix4f self, LVecBase3f result_vec, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_row3_1263_comment =
  "C++ Interface:\n"
  "get_row3(LMatrix4f self, int row)\n"
  "get_row3(LMatrix4f self, LVecBase3f result_vec, int row)\n"
  "\n"
  "/**\n"
  " * Retrieves the row column of the matrix as a 3-component vector, ignoring\n"
  " * the last column.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the row column of the matrix as a 3-component vector, ignoring the\n"
  " * last column.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_row3_1263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix4f::get_col3(int col) const
 */
static PyObject *Dtool_LMatrix4f_get_col3_1269(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix4f::get_col3(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3f *return_value = new LVecBase3f((*(const LMatrix4f*)local_this).get_col3((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col3(LMatrix4f self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_col3_1269_comment =
  "C++ Interface:\n"
  "get_col3(LMatrix4f self, int col)\n"
  "\n"
  "/**\n"
  " * Retrieves the indicated column of the matrix as a 3-component vector,\n"
  " * ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_col3_1269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4f::is_nan(void) const
 */
static PyObject *Dtool_LMatrix4f_is_nan_1271(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix4f::is_nan(void) const
  bool return_value = (*(const LMatrix4f*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_is_nan_1271_comment =
  "C++ Interface:\n"
  "is_nan(LMatrix4f self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the matrix is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_is_nan_1271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4f::is_identity(void) const
 */
static PyObject *Dtool_LMatrix4f_is_identity_1272(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix4f::is_identity(void) const
  bool return_value = (*(const LMatrix4f*)local_this).is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_is_identity_1272_comment =
  "C++ Interface:\n"
  "is_identity(LMatrix4f self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is (close enough to) the identity matrix, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_is_identity_1272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LMatrix4f::get_cell(int row, int col) const
 */
static PyObject *Dtool_LMatrix4f_get_cell_1273(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LMatrix4f::get_cell(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_cell", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const LMatrix4f*)local_this).get_cell((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LMatrix4f self, int row, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_cell_1273_comment =
  "C++ Interface:\n"
  "get_cell(LMatrix4f self, int row, int col)\n"
  "\n"
  "/**\n"
  " * Returns a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_cell_1273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_cell(int row, int col, float value)
 */
static PyObject *Dtool_LMatrix4f_set_cell_1274(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_cell")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set_cell(int row, int col, float value)
  int param1;
  int param2;
  float param3;
  static const char *keyword_list[] = {"row", "col", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iif:set_cell", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_cell((int)param1, (int)param2, (float)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LMatrix4f self, int row, int col, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_cell_1274_comment =
  "C++ Interface:\n"
  "set_cell(const LMatrix4f self, int row, int col, float value)\n"
  "\n"
  "/**\n"
  " * Changes a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_cell_1274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix4f::get_num_components(void) const
 */
static PyObject *Dtool_LMatrix4f_get_num_components_1276(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LMatrix4f::get_num_components(void) const
  int return_value = (*(const LMatrix4f*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_num_components_1276_comment =
  "C++ Interface:\n"
  "get_num_components(LMatrix4f self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the matrix, 16.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_num_components_1276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix4f::compare_to(LMatrix4f const &other) const
 * int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const
 */
static PyObject *Dtool_LMatrix4f_compare_to_1282(PyObject *self, PyObject *args) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LMatrix4f::compare_to(LMatrix4f const &other) const
      LMatrix4f arg_local;
      LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.compare_to", "LMatrix4f");
      }
      int return_value = (*(const LMatrix4f*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const
      PyObject *param1;
      float param2;
      if (PyArg_ParseTuple(args, "Of:compare_to", &param1, &param2)) {
        LMatrix4f param1_local;
        LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.compare_to", "LMatrix4f");
        }
        int return_value = (*(const LMatrix4f*)local_this).compare_to(*param1_this, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix4f self, const LMatrix4f other)\n"
      "compare_to(LMatrix4f self, const LMatrix4f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_compare_to_1282_comment =
  "C++ Interface:\n"
  "compare_to(LMatrix4f self, const LMatrix4f other)\n"
  "compare_to(LMatrix4f self, const LMatrix4f other, float threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts matrices lexicographically, componentwise.  Returns a number less\n"
  " * than 0 if this matrix sorts before the other one, greater than zero if it\n"
  " * sorts after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LMatrix4f_compare_to_1282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix4f::get_hash(void) const
 * inline std::size_t LMatrix4f::get_hash(float threshold) const
 */
static PyObject *Dtool_LMatrix4f_get_hash_1283(PyObject *self, PyObject *args) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LMatrix4f::get_hash(void) const
      std::size_t return_value = (*(const LMatrix4f*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LMatrix4f::get_hash(float threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LMatrix4f*)local_this).get_hash((float)PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LMatrix4f self)\n"
      "get_hash(LMatrix4f self, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_hash_1283_comment =
  "C++ Interface:\n"
  "get_hash(LMatrix4f self)\n"
  "get_hash(LMatrix4f self, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_get_hash_1283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix4f::add_hash(std::size_t hash) const
 * inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const
 */
static PyObject *Dtool_LMatrix4f_add_hash_1284(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LMatrix4f::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix4f*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const
      Py_ssize_t param1;
      float param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nf:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix4f*)local_this).add_hash((std::size_t)param1, (float)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LMatrix4f self, int hash)\n"
      "add_hash(LMatrix4f self, int hash, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_add_hash_1284_comment =
  "C++ Interface:\n"
  "add_hash(LMatrix4f self, int hash)\n"
  "add_hash(LMatrix4f self, int hash, float threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_add_hash_1284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_1285(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform", "LVecBase4f");
  }
  LVecBase4f *return_value = new LVecBase4f((*(const LMatrix4f*)local_this).xform(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(LMatrix4f self, const LVecBase4f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_1285_comment =
  "C++ Interface:\n"
  "xform(LMatrix4f self, const LVecBase4f v)\n"
  "\n"
  "/**\n"
  " * 4-component vector or point times matrix.  This is a fully general\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_1285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_point_1286(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_point", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix4f*)local_this).xform_point(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point(LMatrix4f self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_point_1286_comment =
  "C++ Interface:\n"
  "xform_point(LMatrix4f self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation component)\n"
  " * and returns the result.  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_point_1286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_point_general_1287(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_point_general", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix4f*)local_this).xform_point_general(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_general(LMatrix4f self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_point_general_1287_comment =
  "C++ Interface:\n"
  "xform_point_general(LMatrix4f self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation component)\n"
  " * and returns the result, as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_point_general_1287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_vec_1288(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_vec", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix4f*)local_this).xform_vec(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec(LMatrix4f self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_vec_1288_comment =
  "C++ Interface:\n"
  "xform_vec(LMatrix4f self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component)\n"
  " * and returns the result.  This assumes the matrix is an orthonormal\n"
  " * transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_vec_1288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_vec_general_1289(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_vec_general", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LMatrix4f*)local_this).xform_vec_general(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general(LMatrix4f self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_vec_general_1289_comment =
  "C++ Interface:\n"
  "xform_vec_general(LMatrix4f self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component)\n"
  " * and returns the result, as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_vec_general_1289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::xform_in_place(LVecBase4f &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_in_place_1290(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4f::xform_in_place(LVecBase4f &v) const
  LVecBase4f arg_local;
  LVecBase4f *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_in_place", "LVecBase4f");
  }
  (*(const LMatrix4f*)local_this).xform_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_in_place(LMatrix4f self, LVecBase4f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_in_place_1290_comment =
  "C++ Interface:\n"
  "xform_in_place(LMatrix4f self, LVecBase4f v)\n"
  "\n"
  "/**\n"
  " * 4-component vector or point times matrix.  This is a fully general\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_in_place_1290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_point_in_place_1291(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_point_in_place", "LVecBase3f");
  }
  (*(const LMatrix4f*)local_this).xform_point_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_in_place(LMatrix4f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_point_in_place_1291_comment =
  "C++ Interface:\n"
  "xform_point_in_place(LMatrix4f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation\n"
  " * component).  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_point_in_place_1291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_point_general_in_place_1292(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_point_general_in_place", "LVecBase3f");
  }
  (*(const LMatrix4f*)local_this).xform_point_general_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_general_in_place(LMatrix4f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_point_general_in_place_1292_comment =
  "C++ Interface:\n"
  "xform_point_general_in_place(LMatrix4f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation\n"
  " * component), as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_point_general_in_place_1292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_vec_in_place_1293(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_vec_in_place", "LVecBase3f");
  }
  (*(const LMatrix4f*)local_this).xform_vec_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_in_place(LMatrix4f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_vec_in_place_1293_comment =
  "C++ Interface:\n"
  "xform_vec_in_place(LMatrix4f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component).\n"
  " * This assumes the matrix is an orthonormal transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_vec_in_place_1293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const
 */
static PyObject *Dtool_LMatrix4f_xform_vec_general_in_place_1294(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const
  LVecBase3f arg_local;
  LVecBase3f *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.xform_vec_general_in_place", "LVecBase3f");
  }
  (*(const LMatrix4f*)local_this).xform_vec_general_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general_in_place(LMatrix4f self, LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_xform_vec_general_in_place_1294_comment =
  "C++ Interface:\n"
  "xform_vec_general_in_place(LMatrix4f self, LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component),\n"
  " * as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_xform_vec_general_in_place_1294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2)
 */
static PyObject *Dtool_LMatrix4f_multiply_1295(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.multiply")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other1", "other2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:multiply", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param1_local;
    LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.multiply", "LMatrix4f");
    }
    LMatrix4f param2_local;
    LMatrix4f const *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4f.multiply", "LMatrix4f");
    }
    (*local_this).multiply(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multiply(const LMatrix4f self, const LMatrix4f other1, const LMatrix4f other2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_multiply_1295_comment =
  "C++ Interface:\n"
  "multiply(const LMatrix4f self, const LMatrix4f other1, const LMatrix4f other2)\n"
  "\n"
  "// this = other1 * other2\n"
  "\n"
  "// this = other1 * other2";
#else
static const char *Dtool_LMatrix4f_multiply_1295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::componentwise_mult(LMatrix4f const &other)
 */
static PyObject *Dtool_LMatrix4f_componentwise_mult_1302(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::componentwise_mult(LMatrix4f const &other)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.componentwise_mult", "LMatrix4f");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LMatrix4f self, const LMatrix4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_componentwise_mult_1302_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LMatrix4f self, const LMatrix4f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_componentwise_mult_1302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::transpose_from(LMatrix4f const &other)
 */
static PyObject *Dtool_LMatrix4f_transpose_from_1303(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.transpose_from")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::transpose_from(LMatrix4f const &other)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.transpose_from", "LMatrix4f");
  }
  (*local_this).transpose_from(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transpose_from(const LMatrix4f self, const LMatrix4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_transpose_from_1303_comment =
  "C++ Interface:\n"
  "transpose_from(const LMatrix4f self, const LMatrix4f other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_transpose_from_1303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::transpose_in_place(void)
 */
static PyObject *Dtool_LMatrix4f_transpose_in_place_1304(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.transpose_in_place")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::transpose_in_place(void)
  (*local_this).transpose_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_transpose_in_place_1304_comment =
  "C++ Interface:\n"
  "transpose_in_place(const LMatrix4f self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_transpose_in_place_1304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4f::invert_from(LMatrix4f const &other)
 */
static PyObject *Dtool_LMatrix4f_invert_from_1305(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.invert_from")) {
    return NULL;
  }
  // 1-inline bool LMatrix4f::invert_from(LMatrix4f const &other)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.invert_from", "LMatrix4f");
  }
  bool return_value = (*local_this).invert_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_from(const LMatrix4f self, const LMatrix4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_invert_from_1305_comment =
  "C++ Interface:\n"
  "invert_from(const LMatrix4f self, const LMatrix4f other)\n"
  "\n"
  "/**\n"
  " * Computes the inverse of the other matrix, and stores the result in this\n"
  " * matrix.  This is a fully general operation and makes no assumptions about\n"
  " * the type of transform represented by the matrix.\n"
  " *\n"
  " * The other matrix must be a different object than this matrix.  However, if\n"
  " * you need to invert a matrix in place, see invert_in_place.\n"
  " *\n"
  " * The return value is true if the matrix was successfully inverted, false if\n"
  " * the was a singularity.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_invert_from_1305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other)
 */
static PyObject *Dtool_LMatrix4f_invert_affine_from_1306(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.invert_affine_from")) {
    return NULL;
  }
  // 1-inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.invert_affine_from", "LMatrix4f");
  }
  bool return_value = (*local_this).invert_affine_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_affine_from(const LMatrix4f self, const LMatrix4f other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_invert_affine_from_1306_comment =
  "C++ Interface:\n"
  "invert_affine_from(const LMatrix4f self, const LMatrix4f other)\n"
  "\n"
  "// bugbug: we could optimize this for rotationscaletranslation matrices\n"
  "// (transpose upper 3x3 and take negative of translation component)";
#else
static const char *Dtool_LMatrix4f_invert_affine_from_1306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4f::invert_in_place(void)
 */
static PyObject *Dtool_LMatrix4f_invert_in_place_1307(PyObject *self, PyObject *) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.invert_in_place")) {
    return NULL;
  }
  // 1-inline bool LMatrix4f::invert_in_place(void)
  bool return_value = (*local_this).invert_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_invert_in_place_1307_comment =
  "C++ Interface:\n"
  "invert_in_place(const LMatrix4f self)\n"
  "\n"
  "/**\n"
  " * Inverts the current matrix.  Returns true if the inverse is successful,\n"
  " * false if the matrix was singular.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_invert_in_place_1307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight)
 */
static PyObject *Dtool_LMatrix4f_accumulate_1308(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.accumulate")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"other", "weight", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:accumulate", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param1_local;
    LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.accumulate", "LMatrix4f");
    }
    (*local_this).accumulate(*param1_this, (float)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "accumulate(const LMatrix4f self, const LMatrix4f other, float weight)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_accumulate_1308_comment =
  "C++ Interface:\n"
  "accumulate(const LMatrix4f self, const LMatrix4f other, float weight)\n"
  "\n"
  "/**\n"
  " * Computes (*this) += other * weight.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_accumulate_1308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f const &LMatrix4f::ident_mat(void)
 */
static PyObject *Dtool_LMatrix4f_ident_mat_1309(PyObject *, PyObject *) {
  // 1-static inline LMatrix4f const &LMatrix4f::ident_mat(void)
  LMatrix4f const *return_value = &(LMatrix4f::ident_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_ident_mat_1309_comment =
  "C++ Interface:\n"
  "ident_mat()\n"
  "\n"
  "/**\n"
  " * Returns an identity matrix.\n"
  " *\n"
  " * This function definition must appear first, since some inline functions\n"
  " * below take advantage of it.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_ident_mat_1309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f const &LMatrix4f::ones_mat(void)
 */
static PyObject *Dtool_LMatrix4f_ones_mat_1310(PyObject *, PyObject *) {
  // 1-static inline LMatrix4f const &LMatrix4f::ones_mat(void)
  LMatrix4f const *return_value = &(LMatrix4f::ones_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_ones_mat_1310_comment =
  "C++ Interface:\n"
  "ones_mat()\n"
  "\n"
  "/**\n"
  " * Returns an matrix filled with ones.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_ones_mat_1310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f const &LMatrix4f::zeros_mat(void)
 */
static PyObject *Dtool_LMatrix4f_zeros_mat_1311(PyObject *, PyObject *) {
  // 1-static inline LMatrix4f const &LMatrix4f::zeros_mat(void)
  LMatrix4f const *return_value = &(LMatrix4f::zeros_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_zeros_mat_1311_comment =
  "C++ Interface:\n"
  "zeros_mat()\n"
  "\n"
  "/**\n"
  " * Returns an matrix filled with zeros.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_zeros_mat_1311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans)
 */
static PyObject *Dtool_LMatrix4f_set_translate_mat_1312(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_translate_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.set_translate_mat", "LVecBase3f");
  }
  (*local_this).set_translate_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_translate_mat(const LMatrix4f self, const LVecBase3f trans)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_translate_mat_1312_comment =
  "C++ Interface:\n"
  "set_translate_mat(const LMatrix4f self, const LVecBase3f trans)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_translate_mat_1312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_set_rotate_mat_1313(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_rotate_mat")) {
    return NULL;
  }
  // 1-void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
  float param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:set_rotate_mat", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4f.set_rotate_mat", "LVecBase3f");
    }
    (*local_this).set_rotate_mat((float)param1, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat(const LMatrix4f self, float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_rotate_mat_1313_comment =
  "C++ Interface:\n"
  "set_rotate_mat(const LMatrix4f self, float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Sets mat to a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_rotate_mat_1313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_set_rotate_mat_normaxis_1314(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_rotate_mat_normaxis")) {
    return NULL;
  }
  // 1-void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
  float param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:set_rotate_mat_normaxis", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4f.set_rotate_mat_normaxis", "LVecBase3f");
    }
    (*local_this).set_rotate_mat_normaxis((float)param1, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat_normaxis(const LMatrix4f self, float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_rotate_mat_normaxis_1314_comment =
  "C++ Interface:\n"
  "set_rotate_mat_normaxis(const LMatrix4f self, float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * prenormalized.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_rotate_mat_normaxis_1314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale)
 */
static PyObject *Dtool_LMatrix4f_set_scale_mat_1315(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_scale_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.set_scale_mat", "LVecBase3f");
  }
  (*local_this).set_scale_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_mat(const LMatrix4f self, const LVecBase3f scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_scale_mat_1315_comment =
  "C++ Interface:\n"
  "set_scale_mat(const LMatrix4f self, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale in each of the\n"
  " * three axes.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_scale_mat_1315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_set_shear_mat_1316(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_shear_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shear_mat", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.set_shear_mat", "LVecBase3f");
    }
    (*local_this).set_shear_mat(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear_mat(const LMatrix4f self, const LVecBase3f shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_shear_mat_1316_comment =
  "C++ Interface:\n"
  "set_shear_mat(const LMatrix4f self, const LVecBase3f shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated shear in each of the\n"
  " * three planes.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_shear_mat_1316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_set_scale_shear_mat_1317(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.set_scale_shear_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:set_scale_shear_mat", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.set_scale_shear_mat", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4f.set_scale_shear_mat", "LVecBase3f");
    }
    (*local_this).set_scale_shear_mat(*param1_this, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_shear_mat(const LMatrix4f self, const LVecBase3f scale, const LVecBase3f shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_set_scale_shear_mat_1317_comment =
  "C++ Interface:\n"
  "set_scale_shear_mat(const LMatrix4f self, const LVecBase3f scale, const LVecBase3f shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_set_scale_shear_mat_1317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans)
 * static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz)
 */
static PyObject *Dtool_LMatrix4f_translate_mat_1318(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "trans");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'trans' (pos 1) not found");
      }
      // 1-static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix4f.translate_mat", "LVecBase3f");
      }
      LMatrix4f *return_value = new LMatrix4f(LMatrix4f::translate_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"tx", "ty", "tz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:translate_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::translate_mat((float)param0, (float)param1, (float)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "translate_mat() takes 1 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "translate_mat(const LVecBase3f trans)\n"
      "translate_mat(float tx, float ty, float tz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_translate_mat_1318_comment =
  "C++ Interface:\n"
  "translate_mat(const LVecBase3f trans)\n"
  "translate_mat(float tx, float ty, float tz)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_translate_mat_1318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_rotate_mat_1319(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
  float param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:rotate_mat", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.rotate_mat", "LVecBase3f");
    }
    LMatrix4f *return_value = new LMatrix4f(LMatrix4f::rotate_mat((float)param0, *param1_this, (CoordinateSystem)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat(float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_rotate_mat_1319_comment =
  "C++ Interface:\n"
  "rotate_mat(float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_rotate_mat_1319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_rotate_mat_normaxis_1320(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default)
  float param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO|i:rotate_mat_normaxis", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.rotate_mat_normaxis", "LVecBase3f");
    }
    LMatrix4f *return_value = new LMatrix4f(LMatrix4f::rotate_mat_normaxis((float)param0, *param1_this, (CoordinateSystem)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat_normaxis(float angle, const LVecBase3f axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_rotate_mat_normaxis_1320_comment =
  "C++ Interface:\n"
  "rotate_mat_normaxis(float angle, const LVecBase3f axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * prenormalized.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_rotate_mat_normaxis_1320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale)
 * static inline LMatrix4f LMatrix4f::scale_mat(float scale)
 * static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz)
 */
static PyObject *Dtool_LMatrix4f_scale_mat_1321(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      {
        // -2 static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale)
        LVecBase3f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
        if (arg_this != NULL) {
          LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
        }
      }

      {
        // -2 static inline LMatrix4f LMatrix4f::scale_mat(float scale)
        if (PyNumber_Check(arg)) {
          LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_mat((float)PyFloat_AsDouble(arg)));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
        }
      }

      {
        // -2 static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if ((arg_this != NULL)) {
          LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
        }
      }

      // No coercion possible: static inline LMatrix4f LMatrix4f::scale_mat(float scale)
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"sx", "sy", "sz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:scale_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_mat((float)param0, (float)param1, (float)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_mat() takes 1 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_mat(const LVecBase3f scale)\n"
      "scale_mat(float scale)\n"
      "scale_mat(float sx, float sy, float sz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_scale_mat_1321_comment =
  "C++ Interface:\n"
  "scale_mat(const LVecBase3f scale)\n"
  "scale_mat(float scale)\n"
  "scale_mat(float sx, float sy, float sz)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated uniform scale.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_scale_mat_1321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_shear_mat_1322(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shear");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shear' (pos 1) not found");
      }
      // 1-static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs)
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix4f.shear_mat", "LVecBase3f");
      }
      LMatrix4f *return_value = new LMatrix4f(LMatrix4f::shear_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
    break;
  case 2:
    {
      // 1-static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4f.shear_mat", "LVecBase3f");
        }
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::shear_mat(*param0_this, (CoordinateSystem)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
      float param0;
      float param1;
      float param2;
      int param3 = ::CS_default;
      static const char *keyword_list[] = {"shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|i:shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::shear_mat((float)param0, (float)param1, (float)param2, (CoordinateSystem)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "shear_mat() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "shear_mat(const LVecBase3f shear)\n"
      "shear_mat(const LVecBase3f shear, int cs)\n"
      "shear_mat(float shxy, float shxz, float shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_shear_mat_1322_comment =
  "C++ Interface:\n"
  "shear_mat(const LVecBase3f shear)\n"
  "shear_mat(const LVecBase3f shear, int cs)\n"
  "shear_mat(float shxy, float shxz, float shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_shear_mat_1322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4f_scale_shear_mat_1323(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"scale", "shear", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:scale_shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4f.scale_shear_mat", "LVecBase3f");
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.scale_shear_mat", "LVecBase3f");
        }
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_shear_mat(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param0_local;
        LVecBase3f const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4f.scale_shear_mat", "LVecBase3f");
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.scale_shear_mat", "LVecBase3f");
        }
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_shear_mat(*param0_this, *param1_this, (CoordinateSystem)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
  case 6:
  case 7:
    {
      // 1-static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      int param6 = ::CS_default;
      static const char *keyword_list[] = {"sx", "sy", "sz", "shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff|i:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LMatrix4f *return_value = new LMatrix4f(LMatrix4f::scale_shear_mat((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (CoordinateSystem)param6));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_shear_mat() takes 2, 3, 6 or 7 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear)\n"
      "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear, int cs)\n"
      "scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_scale_shear_mat_1323_comment =
  "C++ Interface:\n"
  "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear)\n"
  "scale_shear_mat(const LVecBase3f scale, const LVecBase3f shear, int cs)\n"
  "scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_scale_shear_mat_1323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void)
 */
static PyObject *Dtool_LMatrix4f_y_to_z_up_mat_1324(PyObject *, PyObject *) {
  // 1-static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void)
  LMatrix4f const *return_value = &(LMatrix4f::y_to_z_up_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_y_to_z_up_mat_1324_comment =
  "C++ Interface:\n"
  "y_to_z_up_mat()\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the Y-up coordinate system to the\n"
  " * Z-up coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_y_to_z_up_mat_1324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void)
 */
static PyObject *Dtool_LMatrix4f_z_to_y_up_mat_1325(PyObject *, PyObject *) {
  // 1-static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void)
  LMatrix4f const *return_value = &(LMatrix4f::z_to_y_up_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_z_to_y_up_mat_1325_comment =
  "C++ Interface:\n"
  "z_to_y_up_mat()\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the Y-up coordinate system to the\n"
  " * Z-up coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_z_to_y_up_mat_1325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to)
 */
static PyObject *Dtool_LMatrix4f_convert_mat_1326(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to)
  int param0;
  int param1;
  static const char *keyword_list[] = {"from", "to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:convert_mat", (char **)keyword_list, &param0, &param1)) {
    LMatrix4f const *return_value = &(LMatrix4f::convert_mat((CoordinateSystem)param0, (CoordinateSystem)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "convert_mat(int from, int to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_convert_mat_1326_comment =
  "C++ Interface:\n"
  "convert_mat(int from, int to)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the indicated coordinate system to\n"
  " * the indicated coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_convert_mat_1326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const
 * bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const
 */
static PyObject *Dtool_LMatrix4f_almost_equal_1327(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const
      LMatrix4f arg_local;
      LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.almost_equal", "LMatrix4f");
      }
      bool return_value = (*(const LMatrix4f*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LMatrix4f param1_local;
        LMatrix4f const *param1_this = Dtool_Coerce_LMatrix4f(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.almost_equal", "LMatrix4f");
        }
        bool return_value = (*(const LMatrix4f*)local_this).almost_equal(*param1_this, (float)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LMatrix4f self, const LMatrix4f other)\n"
      "almost_equal(LMatrix4f self, const LMatrix4f other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_almost_equal_1327_comment =
  "C++ Interface:\n"
  "almost_equal(LMatrix4f self, const LMatrix4f other)\n"
  "almost_equal(LMatrix4f self, const LMatrix4f other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a default\n"
  " * tolerance based on the numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a specified\n"
  " * tolerance.  This is faster than the equivalence operator as this doesn't\n"
  " * have to guarantee that it is transitive.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_almost_equal_1327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::output(ostream &out) const
 */
static PyObject *Dtool_LMatrix4f_output_1328(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4f::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LMatrix4f.output", false, true);
  if (arg_this != NULL) {
    (*(const LMatrix4f*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LMatrix4f self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_output_1328_comment =
  "C++ Interface:\n"
  "output(LMatrix4f self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_output_1328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LMatrix4f_write_1329(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4f::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LMatrix4f.write", false, true);
    if (param1_this != NULL) {
      (*(const LMatrix4f*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LMatrix4f self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_write_1329_comment =
  "C++ Interface:\n"
  "write(LMatrix4f self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4f_write_1329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix4f_write_datagram_fixed_1332(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4f::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.write_datagram_fixed", "Datagram");
  }
  (*(const LMatrix4f*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LMatrix4f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_write_datagram_fixed_1332_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LMatrix4f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the matrix, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_write_datagram_fixed_1332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::read_datagram_fixed(DatagramIterator &scan)
 */
static PyObject *Dtool_LMatrix4f_read_datagram_fixed_1333(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.read_datagram_fixed")) {
    return NULL;
  }
  // 1-void LMatrix4f::read_datagram_fixed(DatagramIterator &scan)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LMatrix4f self, DatagramIterator scan)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_read_datagram_fixed_1333_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LMatrix4f self, DatagramIterator scan)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LMatrix4f_read_datagram_fixed_1333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix4f_write_datagram_1334(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4f::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.write_datagram", "Datagram");
  }
  (*(const LMatrix4f*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LMatrix4f self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_write_datagram_1334_comment =
  "C++ Interface:\n"
  "write_datagram(LMatrix4f self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the matrix using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix4f_write_datagram_1334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4f::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LMatrix4f_read_datagram_1335(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4f, (void **)&local_this, "LMatrix4f.read_datagram")) {
    return NULL;
  }
  // 1-void LMatrix4f::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LMatrix4f self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_read_datagram_1335_comment =
  "C++ Interface:\n"
  "read_datagram(const LMatrix4f self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LMatrix4f_read_datagram_1335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LMatrix4f::get_class_type(void)
 */
static PyObject *Dtool_LMatrix4f_get_class_type_1336(PyObject *, PyObject *) {
  // 1-static TypeHandle LMatrix4f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LMatrix4f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4f_get_class_type_1336_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LMatrix4f_get_class_type_1336_comment = NULL;
#endif

/**
 * sequence length function for property LMatrix4f::rows
 */
static Py_ssize_t Dtool_LMatrix4f_rows_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix4f::size();
}

/**
 * sequence getter for property LMatrix4f::rows
 */
static PyObject *Dtool_LMatrix4f_rows_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix4f::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4f.rows[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase4f LMatrix4f::get_row(int row) const
  LVecBase4f *return_value = new LVecBase4f((*(const LMatrix4f*)local_this).get_row(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix4f self, index)\n");
  }
}

static PyObject *Dtool_LMatrix4f_rows_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix4f_rows_Len;
  wrap->_getitem_func = &Dtool_LMatrix4f_rows_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LMatrix4f::cols
 */
static Py_ssize_t Dtool_LMatrix4f_cols_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix4f::size();
}

/**
 * sequence getter for property LMatrix4f::cols
 */
static PyObject *Dtool_LMatrix4f_cols_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix4f::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4f.cols[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase4f LMatrix4f::get_col(int col) const
  LVecBase4f *return_value = new LVecBase4f((*(const LMatrix4f*)local_this).get_col(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix4f self, index)\n");
  }
}

static PyObject *Dtool_LMatrix4f_cols_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix4f_cols_Len;
  wrap->_getitem_func = &Dtool_LMatrix4f_cols_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline LMatrix4f::LMatrix4f(void)
 * inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3)
 * inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans)
 * inline LMatrix4f::LMatrix4f(LMatrix4f const &other)
 * inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other)
 * inline LMatrix4f::LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
 */
static int Dtool_Init_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix4f::LMatrix4f(void)
      LMatrix4f *return_value = new LMatrix4f(LMatrix4f::ident_mat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LMatrix4f::LMatrix4f(LMatrix4f const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4f", (char **)keyword_list, &param0)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LMatrix4f *return_value = new LMatrix4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3)
        PyObject *param0;
        static const char *keyword_list[] = {"upper3", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4f", (char **)keyword_list, &param0)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LMatrix4f *return_value = new LMatrix4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4f", (char **)keyword_list, &param0)) {
          UnalignedLMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLMatrix4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LMatrix4f *return_value = new LMatrix4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4f::LMatrix4f(LMatrix4f const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4f", (char **)keyword_list, &param0)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LMatrix4f *return_value = new LMatrix4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3)
        PyObject *param0;
        static const char *keyword_list[] = {"upper3", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4f", (char **)keyword_list, &param0)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LMatrix4f *return_value = new LMatrix4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4f", (char **)keyword_list, &param0)) {
          UnalignedLMatrix4f param0_local;
          UnalignedLMatrix4f const *param0_this = Dtool_Coerce_UnalignedLMatrix4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LMatrix4f *return_value = new LMatrix4f(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"upper3", "trans", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LMatrix4f", (char **)keyword_list, &param0, &param1)) {
        LMatrix3f param0_local;
        LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4f.LMatrix4f", "LMatrix3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4f.LMatrix4f", "LVecBase3f");
          return -1;
        }
        LMatrix4f *return_value = new LMatrix4f(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
      }
    }
    break;
  case 16:
    {
      // 1-inline LMatrix4f::LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      float param10;
      float param11;
      float param12;
      float param13;
      float param14;
      float param15;
      static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff:LMatrix4f", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        LMatrix4f *return_value = new LMatrix4f((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LMatrix4f() takes 0, 1, 2 or 16 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LMatrix4f()\n"
      "LMatrix4f(const LMatrix4f other)\n"
      "LMatrix4f(const LMatrix3f upper3)\n"
      "LMatrix4f(const UnalignedLMatrix4f other)\n"
      "LMatrix4f(const LMatrix3f upper3, const LVecBase3f trans)\n"
      "LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)\n");
  }
  return -1;
}

LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  LMatrix4f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LMatrix4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LMatrix4f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3)
      LMatrix3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LMatrix4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other)
      UnalignedLMatrix4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LMatrix4f(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "LMatrix4f", 2, 2, &param0, &param1)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            coerced = LMatrix4f(*param0_this, *param1_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 16: {
        // 1-inline LMatrix4f::LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
        float param0;
        float param1;
        float param2;
        float param3;
        float param4;
        float param5;
        float param6;
        float param7;
        float param8;
        float param9;
        float param10;
        float param11;
        float param12;
        float param13;
        float param14;
        float param15;
        if (PyArg_ParseTuple(args, "ffffffffffffffff:LMatrix4f", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
          coerced = LMatrix4f((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix4f_get_rows(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix4f::size();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_LMatrix4f_get_row_1261(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix4f_get_cols(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix4f::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix4f_get_col_1262(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix4f_get_row3s(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix4f::size();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_LMatrix4f_get_row3_1263(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix4f) {
    printf("LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix4f *local_this = (LMatrix4f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix4f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix4f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix4f::Row
 */
/**
 * Python function wrapper for:
 * inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default
 */
static int Dtool_Init_LMatrix4f_Row(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Row() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default
  LMatrix4f::Row const *arg_this = (LMatrix4f::Row *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix4f_Row, 0, "Row.Row", true, true);
  if (arg_this != NULL) {
    LMatrix4f::Row *return_value = new LMatrix4f::Row(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f_Row, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Row(const Row param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix4f_Row(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix4f_Row) {
    printf("LMatrix4f_Row ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix4f::Row *local_this = (LMatrix4f::Row *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix4f_Row) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix4f_Row(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix4f_Row) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix4f::CRow
 */
/**
 * Python function wrapper for:
 * inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default
 */
static int Dtool_Init_LMatrix4f_CRow(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CRow() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default
  LMatrix4f::CRow const *arg_this = (LMatrix4f::CRow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix4f_CRow, 0, "CRow.CRow", true, true);
  if (arg_this != NULL) {
    LMatrix4f::CRow *return_value = new LMatrix4f::CRow(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4f_CRow, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CRow(const CRow param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix4f_CRow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix4f_CRow) {
    printf("LMatrix4f_CRow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix4f::CRow *local_this = (LMatrix4f::CRow *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix4f_CRow) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix4f_CRow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix4f_CRow) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UnalignedLMatrix4f
 */
/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(LMatrix4f const &copy)
 * inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy)
 */
static PyObject *Dtool_UnalignedLMatrix4f_operator_1341(PyObject *self, PyObject *arg) {
  UnalignedLMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLMatrix4f, (void **)&local_this, "UnalignedLMatrix4f.assign")) {
    return NULL;
  }
  {
    // -2 inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(LMatrix4f const &copy)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, false);
    }
  }

  {
    // -2 inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy)
    UnalignedLMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, false);
    }
  }

  {
    // -2 inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(LMatrix4f const &copy)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, false);
    }
  }

  {
    // -2 inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy)
    UnalignedLMatrix4f arg_local;
    UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4f *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4f, false, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const UnalignedLMatrix4f self, const LMatrix4f copy)\n"
      "assign(const UnalignedLMatrix4f self, const UnalignedLMatrix4f copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4f_operator_1341_comment =
  "C++ Interface:\n"
  "assign(const UnalignedLMatrix4f self, const LMatrix4f copy)\n"
  "assign(const UnalignedLMatrix4f self, const UnalignedLMatrix4f copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLMatrix4f_operator_1341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
 */
static PyObject *Dtool_UnalignedLMatrix4f_set_1342(PyObject *self, PyObject *args, PyObject *kwds) {
  UnalignedLMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLMatrix4f, (void **)&local_this, "UnalignedLMatrix4f.set")) {
    return NULL;
  }
  // 1-inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  float param10;
  float param11;
  float param12;
  float param13;
  float param14;
  float param15;
  float param16;
  static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16)) {
    (*local_this).set((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15, (float)param16);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const UnalignedLMatrix4f self, float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4f_set_1342_comment =
  "C++ Interface:\n"
  "set(const UnalignedLMatrix4f self, float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLMatrix4f_set_1342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int UnalignedLMatrix4f::get_num_components(void) const
 */
static PyObject *Dtool_UnalignedLMatrix4f_get_num_components_1345(PyObject *self, PyObject *) {
  UnalignedLMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int UnalignedLMatrix4f::get_num_components(void) const
  int return_value = (*(const UnalignedLMatrix4f*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4f_get_num_components_1345_comment =
  "C++ Interface:\n"
  "get_num_components(UnalignedLMatrix4f self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the matrix, sixteen.\n"
  " */";
#else
static const char *Dtool_UnalignedLMatrix4f_get_num_components_1345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnalignedLMatrix4f::get_class_type(void)
 */
static PyObject *Dtool_UnalignedLMatrix4f_get_class_type_1346(PyObject *, PyObject *) {
  // 1-static TypeHandle UnalignedLMatrix4f::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UnalignedLMatrix4f::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4f_get_class_type_1346_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnalignedLMatrix4f_get_class_type_1346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4f::UnalignedLMatrix4f(void)
 * inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy)
 * inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy)
 * inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
 */
static int Dtool_Init_UnalignedLMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline UnalignedLMatrix4f::UnalignedLMatrix4f(void)
      UnalignedLMatrix4f *return_value = new UnalignedLMatrix4f();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4f, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      {
        // -2 inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy)
        UnalignedLMatrix4f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4f, (void **)&arg_this);
        if (arg_this != NULL) {
          UnalignedLMatrix4f *return_value = new UnalignedLMatrix4f(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4f, true, false);
        }
      }

      {
        // -2 inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy)
        LMatrix4f const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
        if (arg_this != NULL) {
          UnalignedLMatrix4f *return_value = new UnalignedLMatrix4f(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4f, true, false);
        }
      }

      {
        // -2 inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy)
        UnalignedLMatrix4f arg_local;
        UnalignedLMatrix4f const *arg_this = Dtool_Coerce_UnalignedLMatrix4f(arg, arg_local);
        if ((arg_this != NULL)) {
          UnalignedLMatrix4f *return_value = new UnalignedLMatrix4f(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4f, true, false);
        }
      }

      {
        // -2 inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy)
        LMatrix4f arg_local;
        LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
        if ((arg_this != NULL)) {
          UnalignedLMatrix4f *return_value = new UnalignedLMatrix4f(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4f, true, false);
        }
      }

    }
    break;
  case 16:
    {
      // 1-inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      float param10;
      float param11;
      float param12;
      float param13;
      float param14;
      float param15;
      static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffffffff:UnalignedLMatrix4f", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        UnalignedLMatrix4f *return_value = new UnalignedLMatrix4f((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UnalignedLMatrix4f() takes 0, 1 or 16 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnalignedLMatrix4f()\n"
      "UnalignedLMatrix4f(const UnalignedLMatrix4f copy)\n"
      "UnalignedLMatrix4f(const LMatrix4f copy)\n"
      "UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)\n");
  }
  return -1;
}

UnalignedLMatrix4f *Dtool_Coerce_UnalignedLMatrix4f(PyObject *args, UnalignedLMatrix4f &coerced) {
  UnalignedLMatrix4f *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UnalignedLMatrix4f, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const UnalignedLMatrix4f *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = UnalignedLMatrix4f(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 16) {
      // 1-inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      float param10;
      float param11;
      float param12;
      float param13;
      float param14;
      float param15;
      if (PyArg_ParseTuple(args, "ffffffffffffffff:UnalignedLMatrix4f", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        coerced = UnalignedLMatrix4f((float)param0, (float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10, (float)param11, (float)param12, (float)param13, (float)param14, (float)param15);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_UnalignedLMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UnalignedLMatrix4f) {
    printf("UnalignedLMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UnalignedLMatrix4f *local_this = (UnalignedLMatrix4f *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UnalignedLMatrix4f) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UnalignedLMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UnalignedLMatrix4f) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix3d
 */
/**
 * Python function wrapper for:
 * inline LMatrix3d &LMatrix3d::operator =(LMatrix3d const &other)
 * inline LMatrix3d &LMatrix3d::operator =(double fill_value)
 */
static PyObject *Dtool_LMatrix3d_operator_1361(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.assign")) {
    return NULL;
  }
  {
    // -2 inline LMatrix3d &LMatrix3d::operator =(LMatrix3d const &other)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LMatrix3d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, false);
    }
  }

  {
    // -2 inline LMatrix3d &LMatrix3d::operator =(double fill_value)
    if (PyNumber_Check(arg)) {
      (*local_this).operator =(PyFloat_AsDouble(arg));
      LMatrix3d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, false);
    }
  }

  {
    // -2 inline LMatrix3d &LMatrix3d::operator =(LMatrix3d const &other)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LMatrix3d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, false);
    }
  }

  // No coercion possible: inline LMatrix3d &LMatrix3d::operator =(double fill_value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LMatrix3d self, const LMatrix3d other)\n"
      "assign(const LMatrix3d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_operator_1361_comment =
  "C++ Interface:\n"
  "assign(const LMatrix3d self, const LMatrix3d other)\n"
  "assign(const LMatrix3d self, double fill_value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_operator_1361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LMatrix3d::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LMatrix3d_reduce_1365(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LMatrix3d::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LMatrix3d*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_reduce_1365_comment =
  "C++ Interface:\n"
  "__reduce__(LMatrix3d self)\n";
#else
static const char *Dtool_LMatrix3d_reduce_1365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::fill(double fill_value)
 */
static PyObject *Dtool_LMatrix3d_fill_1366(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.fill")) {
    return NULL;
  }
  // 1-void LMatrix3d::fill(double fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LMatrix3d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_fill_1366_comment =
  "C++ Interface:\n"
  "fill(const LMatrix3d self, double fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the matrix to the indicated fill_value.  This is of\n"
  " * questionable value, but is sometimes useful when initializing to zero.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_fill_1366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)
 */
static PyObject *Dtool_LMatrix3d_set_1367(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)
  double param1;
  double param2;
  double param3;
  double param4;
  double param5;
  double param6;
  double param7;
  double param8;
  double param9;
  static const char *keyword_list[] = {"e00", "e01", "e02", "e10", "e11", "e12", "e20", "e21", "e22", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ddddddddd:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    (*local_this).set((double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LMatrix3d self, double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_1367_comment =
  "C++ Interface:\n"
  "set(const LMatrix3d self, double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_1367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_row(int row, LVecBase2d const &v)
 * inline void LMatrix3d::set_row(int row, LVecBase3d const &v)
 */
static PyObject *Dtool_LMatrix3d_set_row_1370(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_row")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3d::set_row(int row, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3d::set_row(int row, LVecBase2d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase2d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase2d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3d::set_row(int row, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d param2_local;
      LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3d::set_row(int row, LVecBase2d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase2d param2_local;
      LVecBase2d const *param2_this = Dtool_Coerce_LVecBase2d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const LMatrix3d self, int row, const LVecBase3d v)\n"
      "set_row(const LMatrix3d self, int row, const LVecBase2d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_row_1370_comment =
  "C++ Interface:\n"
  "set_row(const LMatrix3d self, int row, const LVecBase3d v)\n"
  "set_row(const LMatrix3d self, int row, const LVecBase2d v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix from a three-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix from a two-component vector,\n"
  " * ignoring the last column.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_row_1370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_col(int col, LVecBase2d const &v)
 * inline void LMatrix3d::set_col(int col, LVecBase3d const &v)
 */
static PyObject *Dtool_LMatrix3d_set_col_1371(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_col")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3d::set_col(int col, LVecBase2d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase2d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase2d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3d::set_col(int col, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3d::set_col(int col, LVecBase2d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase2d param2_local;
      LVecBase2d const *param2_this = Dtool_Coerce_LVecBase2d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix3d::set_col(int col, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d param2_local;
      LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_col(const LMatrix3d self, int col, const LVecBase2d v)\n"
      "set_col(const LMatrix3d self, int col, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_col_1371_comment =
  "C++ Interface:\n"
  "set_col(const LMatrix3d self, int col, const LVecBase2d v)\n"
  "set_col(const LMatrix3d self, int col, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix from a three-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix from a two-component vector,\n"
  " * ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_col_1371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const
 * inline LVecBase3d LMatrix3d::get_row(int row) const
 */
static PyObject *Dtool_LMatrix3d_get_row_1372(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "row");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'row' (pos 1) not found");
      }
      // 1-inline LVecBase3d LMatrix3d::get_row(int row) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).get_row((int)arg_val));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"result_vec", "row", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_row", (char **)keyword_list, &param1, &param2)) {
        LVecBase3d param1_local;
        LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.get_row", "LVecBase3d");
        }
        (*(const LMatrix3d*)local_this).get_row(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_row() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix3d self, int row)\n"
      "get_row(LMatrix3d self, LVecBase3d result_vec, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_row_1372_comment =
  "C++ Interface:\n"
  "get_row(LMatrix3d self, int row)\n"
  "get_row(LMatrix3d self, LVecBase3d result_vec, int row)\n"
  "\n"
  "// these versions inline better\n"
  "\n"
  "/**\n"
  " * Returns the indicated row of the matrix as a three-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the indicated row of the matrix as a three-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_row_1372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix3d::get_col(int col) const
 */
static PyObject *Dtool_LMatrix3d_get_col_1373(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix3d::get_col(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).get_col((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix3d self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_col_1373_comment =
  "C++ Interface:\n"
  "get_col(LMatrix3d self, int col)\n"
  "\n"
  "/**\n"
  " * Returns the indicated column of the matrix as a three-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_col_1373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LMatrix3d::get_row2(int row) const
 */
static PyObject *Dtool_LMatrix3d_get_row2_1378(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LMatrix3d::get_row2(int row) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2d *return_value = new LVecBase2d((*(const LMatrix3d*)local_this).get_row2((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row2(LMatrix3d self, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_row2_1378_comment =
  "C++ Interface:\n"
  "get_row2(LMatrix3d self, int row)\n"
  "\n"
  "/**\n"
  " * Returns the indicated row of the matrix as a two-component vector, ignoring\n"
  " * the last column.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_row2_1378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LMatrix3d::get_col2(int col) const
 */
static PyObject *Dtool_LMatrix3d_get_col2_1379(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LMatrix3d::get_col2(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2d *return_value = new LVecBase2d((*(const LMatrix3d*)local_this).get_col2((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col2(LMatrix3d self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_col2_1379_comment =
  "C++ Interface:\n"
  "get_col2(LMatrix3d self, int col)\n"
  "\n"
  "/**\n"
  " * Returns the indicated column of the matrix as a two-component vector,\n"
  " * ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_col2_1379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3d::is_nan(void) const
 */
static PyObject *Dtool_LMatrix3d_is_nan_1383(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix3d::is_nan(void) const
  bool return_value = (*(const LMatrix3d*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_is_nan_1383_comment =
  "C++ Interface:\n"
  "is_nan(LMatrix3d self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the matrix is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_is_nan_1383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3d::is_identity(void) const
 */
static PyObject *Dtool_LMatrix3d_is_identity_1384(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix3d::is_identity(void) const
  bool return_value = (*(const LMatrix3d*)local_this).is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_is_identity_1384_comment =
  "C++ Interface:\n"
  "is_identity(LMatrix3d self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is (close enough to) the identity matrix, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_is_identity_1384_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LMatrix3d::get_cell(int row, int col) const
 */
static PyObject *Dtool_LMatrix3d_get_cell_1385(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LMatrix3d::get_cell(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_cell", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*(const LMatrix3d*)local_this).get_cell((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LMatrix3d self, int row, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_cell_1385_comment =
  "C++ Interface:\n"
  "get_cell(LMatrix3d self, int row, int col)\n"
  "\n"
  "/**\n"
  " * Returns a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_cell_1385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_cell(int row, int col, double value)
 */
static PyObject *Dtool_LMatrix3d_set_cell_1386(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_cell")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::set_cell(int row, int col, double value)
  int param1;
  int param2;
  double param3;
  static const char *keyword_list[] = {"row", "col", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iid:set_cell", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_cell((int)param1, (int)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LMatrix3d self, int row, int col, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_cell_1386_comment =
  "C++ Interface:\n"
  "set_cell(const LMatrix3d self, int row, int col, double value)\n"
  "\n"
  "/**\n"
  " * Changes a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_cell_1386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix3d::get_num_components(void) const
 */
static PyObject *Dtool_LMatrix3d_get_num_components_1388(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LMatrix3d::get_num_components(void) const
  int return_value = (*(const LMatrix3d*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_num_components_1388_comment =
  "C++ Interface:\n"
  "get_num_components(LMatrix3d self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the matrix, nine.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_num_components_1388_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix3d::compare_to(LMatrix3d const &other) const
 * int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const
 */
static PyObject *Dtool_LMatrix3d_compare_to_1392(PyObject *self, PyObject *args) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LMatrix3d::compare_to(LMatrix3d const &other) const
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.compare_to", "LMatrix3d");
      }
      int return_value = (*(const LMatrix3d*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "Od:compare_to", &param1, &param2)) {
        LMatrix3d param1_local;
        LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.compare_to", "LMatrix3d");
        }
        int return_value = (*(const LMatrix3d*)local_this).compare_to(*param1_this, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix3d self, const LMatrix3d other)\n"
      "compare_to(LMatrix3d self, const LMatrix3d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_compare_to_1392_comment =
  "C++ Interface:\n"
  "compare_to(LMatrix3d self, const LMatrix3d other)\n"
  "compare_to(LMatrix3d self, const LMatrix3d other, double threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts matrices lexicographically, componentwise.  Returns a number less\n"
  " * than 0 if this matrix sorts before the other one, greater than zero if it\n"
  " * sorts after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LMatrix3d_compare_to_1392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix3d::get_hash(void) const
 * inline std::size_t LMatrix3d::get_hash(double threshold) const
 */
static PyObject *Dtool_LMatrix3d_get_hash_1393(PyObject *self, PyObject *args) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LMatrix3d::get_hash(void) const
      std::size_t return_value = (*(const LMatrix3d*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LMatrix3d::get_hash(double threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LMatrix3d*)local_this).get_hash(PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LMatrix3d self)\n"
      "get_hash(LMatrix3d self, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_hash_1393_comment =
  "C++ Interface:\n"
  "get_hash(LMatrix3d self)\n"
  "get_hash(LMatrix3d self, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_get_hash_1393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix3d::add_hash(std::size_t hash) const
 * inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const
 */
static PyObject *Dtool_LMatrix3d_add_hash_1394(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LMatrix3d::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix3d*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const
      Py_ssize_t param1;
      double param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix3d*)local_this).add_hash((std::size_t)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LMatrix3d self, int hash)\n"
      "add_hash(LMatrix3d self, int hash, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_add_hash_1394_comment =
  "C++ Interface:\n"
  "add_hash(LMatrix3d self, int hash)\n"
  "add_hash(LMatrix3d self, int hash, double threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_add_hash_1394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_1395(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.xform", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).xform(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(LMatrix3d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_1395_comment =
  "C++ Interface:\n"
  "xform(LMatrix3d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * 3-component vector or point times matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_1395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_point_1396(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.xform_point", "LVecBase2d");
  }
  LVecBase2d *return_value = new LVecBase2d((*(const LMatrix3d*)local_this).xform_point(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point(LMatrix3d self, const LVecBase2d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_point_1396_comment =
  "C++ Interface:\n"
  "xform_point(LMatrix3d self, const LVecBase2d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component point (including translation component)\n"
  " * and returns the result.  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_point_1396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const
 * inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_vec_1397(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2d *return_value = new LVecBase2d((*(const LMatrix3d*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2d *return_value = new LVecBase2d((*(const LMatrix3d*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).xform_vec(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec(LMatrix3d self, const LVecBase2d v)\n"
      "xform_vec(LMatrix3d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_vec_1397_comment =
  "C++ Interface:\n"
  "xform_vec(LMatrix3d self, const LVecBase2d v)\n"
  "xform_vec(LMatrix3d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component vector (without translation component)\n"
  " * and returns the result.  This assumes the matrix is an affine transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector and returns the result.  This\n"
  " * assumes the matrix is an orthonormal transform.\n"
  " *\n"
  " * In practice, this is the same computation as xform().\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_vec_1397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_vec_general_1398(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.xform_vec_general", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).xform_vec_general(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general(LMatrix3d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_vec_general_1398_comment =
  "C++ Interface:\n"
  "xform_vec_general(LMatrix3d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component)\n"
  " * and returns the result, as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_vec_general_1398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::xform_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_in_place_1399(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix3d::xform_in_place(LVecBase3d &v) const
  LVecBase3d arg_local;
  LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.xform_in_place", "LVecBase3d");
  }
  (*(const LMatrix3d*)local_this).xform_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_in_place(LMatrix3d self, LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_in_place_1399_comment =
  "C++ Interface:\n"
  "xform_in_place(LMatrix3d self, LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * 3-component vector or point times matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_in_place_1399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_point_in_place_1400(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const
  LVecBase2d arg_local;
  LVecBase2d *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.xform_point_in_place", "LVecBase2d");
  }
  (*(const LMatrix3d*)local_this).xform_point_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_in_place(LMatrix3d self, LVecBase2d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_point_in_place_1400_comment =
  "C++ Interface:\n"
  "xform_point_in_place(LMatrix3d self, LVecBase2d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component point (including translation\n"
  " * component).  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_point_in_place_1400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const
 * inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_vec_in_place_1401(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const
    LVecBase3d *arg_this = (LVecBase3d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase3d, 1, "LMatrix3d.xform_vec_in_place", false, false);
    if (arg_this != NULL) {
      (*(const LMatrix3d*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const
    LVecBase2d *arg_this = (LVecBase2d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LVecBase2d, 1, "LMatrix3d.xform_vec_in_place", false, false);
    if (arg_this != NULL) {
      (*(const LMatrix3d*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const
    LVecBase3d arg_local;
    LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LMatrix3d*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const
    LVecBase2d arg_local;
    LVecBase2d *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LMatrix3d*)local_this).xform_vec_in_place(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_in_place(LMatrix3d self, LVecBase3d v)\n"
      "xform_vec_in_place(LMatrix3d self, LVecBase2d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_vec_in_place_1401_comment =
  "C++ Interface:\n"
  "xform_vec_in_place(LMatrix3d self, LVecBase3d v)\n"
  "xform_vec_in_place(LMatrix3d self, LVecBase2d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 2-component vector (without translation component).\n"
  " * This assumes the matrix is an affine transform.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector.  This assumes the matrix is an\n"
  " * orthonormal transform.\n"
  " *\n"
  " * In practice, this is the same computation as xform().\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_vec_in_place_1401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix3d_xform_vec_general_in_place_1402(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const
  LVecBase3d arg_local;
  LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.xform_vec_general_in_place", "LVecBase3d");
  }
  (*(const LMatrix3d*)local_this).xform_vec_general_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general_in_place(LMatrix3d self, LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_xform_vec_general_in_place_1402_comment =
  "C++ Interface:\n"
  "xform_vec_general_in_place(LMatrix3d self, LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component),\n"
  " * as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_xform_vec_general_in_place_1402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2)
 */
static PyObject *Dtool_LMatrix3d_multiply_1403(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.multiply")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other1", "other2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:multiply", (char **)keyword_list, &param1, &param2)) {
    LMatrix3d param1_local;
    LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.multiply", "LMatrix3d");
    }
    LMatrix3d param2_local;
    LMatrix3d const *param2_this = Dtool_Coerce_LMatrix3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3d.multiply", "LMatrix3d");
    }
    (*local_this).multiply(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multiply(const LMatrix3d self, const LMatrix3d other1, const LMatrix3d other2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_multiply_1403_comment =
  "C++ Interface:\n"
  "multiply(const LMatrix3d self, const LMatrix3d other1, const LMatrix3d other2)\n"
  "\n"
  "// this = other1 * other2\n"
  "\n"
  "// this = other1 * other2";
#else
static const char *Dtool_LMatrix3d_multiply_1403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::componentwise_mult(LMatrix3d const &other)
 */
static PyObject *Dtool_LMatrix3d_componentwise_mult_1410(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::componentwise_mult(LMatrix3d const &other)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.componentwise_mult", "LMatrix3d");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LMatrix3d self, const LMatrix3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_componentwise_mult_1410_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LMatrix3d self, const LMatrix3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_componentwise_mult_1410_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LMatrix3d::determinant(void) const
 */
static PyObject *Dtool_LMatrix3d_determinant_1411(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LMatrix3d::determinant(void) const
  double return_value = (*(const LMatrix3d*)local_this).determinant();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_determinant_1411_comment =
  "C++ Interface:\n"
  "determinant(LMatrix3d self)\n"
  "\n"
  "/**\n"
  " * Returns the determinant of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_determinant_1411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::transpose_from(LMatrix3d const &other)
 */
static PyObject *Dtool_LMatrix3d_transpose_from_1412(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.transpose_from")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::transpose_from(LMatrix3d const &other)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.transpose_from", "LMatrix3d");
  }
  (*local_this).transpose_from(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transpose_from(const LMatrix3d self, const LMatrix3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_transpose_from_1412_comment =
  "C++ Interface:\n"
  "transpose_from(const LMatrix3d self, const LMatrix3d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_transpose_from_1412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::transpose_in_place(void)
 */
static PyObject *Dtool_LMatrix3d_transpose_in_place_1413(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.transpose_in_place")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::transpose_in_place(void)
  (*local_this).transpose_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_transpose_in_place_1413_comment =
  "C++ Interface:\n"
  "transpose_in_place(const LMatrix3d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_transpose_in_place_1413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3d::invert_from(LMatrix3d const &other)
 */
static PyObject *Dtool_LMatrix3d_invert_from_1414(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.invert_from")) {
    return NULL;
  }
  // 1-inline bool LMatrix3d::invert_from(LMatrix3d const &other)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.invert_from", "LMatrix3d");
  }
  bool return_value = (*local_this).invert_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_from(const LMatrix3d self, const LMatrix3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_invert_from_1414_comment =
  "C++ Interface:\n"
  "invert_from(const LMatrix3d self, const LMatrix3d other)\n"
  "\n"
  "/**\n"
  " * Computes the inverse of the other matrix, and stores the result in this\n"
  " * matrix.  This is a fully general operation and makes no assumptions about\n"
  " * the type of transform represented by the matrix.\n"
  " *\n"
  " * The other matrix must be a different object than this matrix.  However, if\n"
  " * you need to invert a matrix in place, see invert_in_place.\n"
  " *\n"
  " * The return value is true if the matrix was successfully inverted, false if\n"
  " * there was a singularity.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_invert_from_1414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3d::invert_in_place(void)
 */
static PyObject *Dtool_LMatrix3d_invert_in_place_1415(PyObject *self, PyObject *) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.invert_in_place")) {
    return NULL;
  }
  // 1-inline bool LMatrix3d::invert_in_place(void)
  bool return_value = (*local_this).invert_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_invert_in_place_1415_comment =
  "C++ Interface:\n"
  "invert_in_place(const LMatrix3d self)\n"
  "\n"
  "/**\n"
  " * Inverts the current matrix.  Returns true if the inverse is successful,\n"
  " * false if the matrix was singular.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_invert_in_place_1415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other)
 * inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other)
 */
static PyObject *Dtool_LMatrix3d_invert_transpose_from_1416(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.invert_transpose_from")) {
    return NULL;
  }
  {
    // -2 inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).invert_transpose_from(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_transpose_from(const LMatrix3d self, const LMatrix4d other)\n"
      "invert_transpose_from(const LMatrix3d self, const LMatrix3d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_invert_transpose_from_1416_comment =
  "C++ Interface:\n"
  "invert_transpose_from(const LMatrix3d self, const LMatrix4d other)\n"
  "invert_transpose_from(const LMatrix3d self, const LMatrix3d other)\n"
  "\n"
  "/**\n"
  " * Simultaneously computes the inverse of the indicated matrix, and then the\n"
  " * transpose of that inverse.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Simultaneously computes the inverse of the indicated matrix, and then the\n"
  " * transpose of that inverse.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_invert_transpose_from_1416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d const &LMatrix3d::ident_mat(void)
 */
static PyObject *Dtool_LMatrix3d_ident_mat_1417(PyObject *, PyObject *) {
  // 1-static inline LMatrix3d const &LMatrix3d::ident_mat(void)
  LMatrix3d const *return_value = &(LMatrix3d::ident_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_ident_mat_1417_comment =
  "C++ Interface:\n"
  "ident_mat()\n"
  "\n"
  "/**\n"
  " * Returns an identity matrix.\n"
  " *\n"
  " * This function definition must appear first, since some inline functions\n"
  " * below take advantage of it.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_ident_mat_1417_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans)
 */
static PyObject *Dtool_LMatrix3d_set_translate_mat_1418(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_translate_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.set_translate_mat", "LVecBase2d");
  }
  (*local_this).set_translate_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_translate_mat(const LMatrix3d self, const LVecBase2d trans)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_translate_mat_1418_comment =
  "C++ Interface:\n"
  "set_translate_mat(const LMatrix3d self, const LVecBase2d trans)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_translate_mat_1418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_rotate_mat(double angle)
 * void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_set_rotate_mat_1419(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_rotate_mat")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "angle");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'angle' (pos 1) not found");
      }
      // 1-inline void LMatrix3d::set_rotate_mat(double angle)
      if (PyNumber_Check(arg)) {
        (*local_this).set_rotate_mat(PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
      double param1;
      PyObject *param2;
      int param3 = ::CS_default;
      static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:set_rotate_mat", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3d param2_local;
        LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3d.set_rotate_mat", "LVecBase3d");
        }
        (*local_this).set_rotate_mat((double)param1, *param2_this, (CoordinateSystem)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_rotate_mat() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat(const LMatrix3d self, double angle)\n"
      "set_rotate_mat(const LMatrix3d self, double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_rotate_mat_1419_comment =
  "C++ Interface:\n"
  "set_rotate_mat(const LMatrix3d self, double angle)\n"
  "set_rotate_mat(const LMatrix3d self, double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_rotate_mat_1419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale)
 * inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale)
 */
static PyObject *Dtool_LMatrix3d_set_scale_mat_1420(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_scale_mat")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale)
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale)
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale)
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale)
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_scale_mat(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_mat(const LMatrix3d self, const LVecBase3d scale)\n"
      "set_scale_mat(const LMatrix3d self, const LVecBase2d scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_scale_mat_1420_comment =
  "C++ Interface:\n"
  "set_scale_mat(const LMatrix3d self, const LVecBase3d scale)\n"
  "set_scale_mat(const LMatrix3d self, const LVecBase2d scale)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale in each of the two\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale in each of the\n"
  " * three axes.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_scale_mat_1420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans)
 * static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty)
 */
static PyObject *Dtool_LMatrix3d_translate_mat_1421(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "trans");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'trans' (pos 1) not found");
      }
      // 1-static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans)
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix3d.translate_mat", "LVecBase2d");
      }
      LMatrix3d *return_value = new LMatrix3d(LMatrix3d::translate_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
    break;
  case 2:
    {
      // 1-static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty)
      double param0;
      double param1;
      static const char *keyword_list[] = {"tx", "ty", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:translate_mat", (char **)keyword_list, &param0, &param1)) {
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::translate_mat((double)param0, (double)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "translate_mat() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "translate_mat(const LVecBase2d trans)\n"
      "translate_mat(double tx, double ty)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_translate_mat_1421_comment =
  "C++ Interface:\n"
  "translate_mat(const LVecBase2d trans)\n"
  "translate_mat(double tx, double ty)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_translate_mat_1421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d LMatrix3d::rotate_mat(double angle)
 * static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_rotate_mat_1422(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "angle");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'angle' (pos 1) not found");
      }
      // 1-static inline LMatrix3d LMatrix3d::rotate_mat(double angle)
      if (PyNumber_Check(arg)) {
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::rotate_mat(PyFloat_AsDouble(arg)));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
      double param0;
      PyObject *param1;
      int param2 = ::CS_default;
      static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:rotate_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.rotate_mat", "LVecBase3d");
        }
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::rotate_mat((double)param0, *param1_this, (CoordinateSystem)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "rotate_mat() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat(double angle)\n"
      "rotate_mat(double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_rotate_mat_1422_comment =
  "C++ Interface:\n"
  "rotate_mat(double angle)\n"
  "rotate_mat(double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_rotate_mat_1422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale)
 * static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale)
 * static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy)
 * static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz)
 */
static PyObject *Dtool_LMatrix3d_scale_mat_1423(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      {
        // -2 static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale)
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
        }
      }

      {
        // -2 static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale)
        LVecBase2d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
        if (arg_this != NULL) {
          LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
        }
      }

      {
        // -2 static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
        }
      }

      {
        // -2 static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale)
        LVecBase2d arg_local;
        LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
        if ((arg_this != NULL)) {
          LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
        }
      }

    }
    break;
  case 2:
    {
      // 1-static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy)
      double param0;
      double param1;
      static const char *keyword_list[] = {"sx", "sy", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:scale_mat", (char **)keyword_list, &param0, &param1)) {
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_mat((double)param0, (double)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"sx", "sy", "sz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:scale_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_mat((double)param0, (double)param1, (double)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_mat() takes 1, 2 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_mat(const LVecBase3d scale)\n"
      "scale_mat(const LVecBase2d scale)\n"
      "scale_mat(double sx, double sy)\n"
      "scale_mat(double sx, double sy, double sz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_scale_mat_1423_comment =
  "C++ Interface:\n"
  "scale_mat(const LVecBase3d scale)\n"
  "scale_mat(const LVecBase2d scale)\n"
  "scale_mat(double sx, double sy)\n"
  "scale_mat(double sx, double sy, double sz)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the two axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the two axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_scale_mat_1423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_set_rotate_mat_normaxis_1424(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_rotate_mat_normaxis")) {
    return NULL;
  }
  // 1-void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
  double param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:set_rotate_mat_normaxis", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3d.set_rotate_mat_normaxis", "LVecBase3d");
    }
    (*local_this).set_rotate_mat_normaxis((double)param1, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat_normaxis(const LMatrix3d self, double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_rotate_mat_normaxis_1424_comment =
  "C++ Interface:\n"
  "set_rotate_mat_normaxis(const LMatrix3d self, double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * normalized.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_rotate_mat_normaxis_1424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_rotate_mat_normaxis_1425(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
  double param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:rotate_mat_normaxis", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.rotate_mat_normaxis", "LVecBase3d");
    }
    LMatrix3d *return_value = new LMatrix3d(LMatrix3d::rotate_mat_normaxis((double)param0, *param1_this, (CoordinateSystem)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat_normaxis(double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_rotate_mat_normaxis_1425_comment =
  "C++ Interface:\n"
  "rotate_mat_normaxis(double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * normalized.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_rotate_mat_normaxis_1425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_set_shear_mat_1426(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_shear_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shear_mat", (char **)keyword_list, &param1, &param2)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.set_shear_mat", "LVecBase3d");
    }
    (*local_this).set_shear_mat(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear_mat(const LMatrix3d self, const LVecBase3d shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_shear_mat_1426_comment =
  "C++ Interface:\n"
  "set_shear_mat(const LMatrix3d self, const LVecBase3d shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated shear in each of the\n"
  " * three planes.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_shear_mat_1426_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_shear_mat_1427(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shear");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shear' (pos 1) not found");
      }
      // 1-static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs)
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix3d.shear_mat", "LVecBase3d");
      }
      LMatrix3d *return_value = new LMatrix3d(LMatrix3d::shear_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
    break;
  case 2:
    {
      // 1-static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix3d.shear_mat", "LVecBase3d");
        }
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::shear_mat(*param0_this, (CoordinateSystem)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
      double param0;
      double param1;
      double param2;
      int param3 = ::CS_default;
      static const char *keyword_list[] = {"shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|i:shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::shear_mat((double)param0, (double)param1, (double)param2, (CoordinateSystem)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "shear_mat() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "shear_mat(const LVecBase3d shear)\n"
      "shear_mat(const LVecBase3d shear, int cs)\n"
      "shear_mat(double shxy, double shxz, double shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_shear_mat_1427_comment =
  "C++ Interface:\n"
  "shear_mat(const LVecBase3d shear)\n"
  "shear_mat(const LVecBase3d shear, int cs)\n"
  "shear_mat(double shxy, double shxz, double shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_shear_mat_1427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_set_scale_shear_mat_1428(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.set_scale_shear_mat")) {
    return NULL;
  }
  // 1-void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:set_scale_shear_mat", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.set_scale_shear_mat", "LVecBase3d");
    }
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix3d.set_scale_shear_mat", "LVecBase3d");
    }
    (*local_this).set_scale_shear_mat(*param1_this, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_shear_mat(const LMatrix3d self, const LVecBase3d scale, const LVecBase3d shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_set_scale_shear_mat_1428_comment =
  "C++ Interface:\n"
  "set_scale_shear_mat(const LMatrix3d self, const LVecBase3d scale, const LVecBase3d shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_set_scale_shear_mat_1428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix3d_scale_shear_mat_1429(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"scale", "shear", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:scale_shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix3d.scale_shear_mat", "LVecBase3d");
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.scale_shear_mat", "LVecBase3d");
        }
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_shear_mat(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix3d.scale_shear_mat", "LVecBase3d");
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.scale_shear_mat", "LVecBase3d");
        }
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_shear_mat(*param0_this, *param1_this, (CoordinateSystem)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
  case 6:
  case 7:
    {
      // 1-static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      int param6 = ::CS_default;
      static const char *keyword_list[] = {"sx", "sy", "sz", "shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddd|i:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LMatrix3d *return_value = new LMatrix3d(LMatrix3d::scale_shear_mat((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (CoordinateSystem)param6));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_shear_mat() takes 2, 3, 6 or 7 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear)\n"
      "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear, int cs)\n"
      "scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_scale_shear_mat_1429_comment =
  "C++ Interface:\n"
  "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear)\n"
  "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear, int cs)\n"
  "scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_scale_shear_mat_1429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to)
 */
static PyObject *Dtool_LMatrix3d_convert_mat_1430(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to)
  int param0;
  int param1;
  static const char *keyword_list[] = {"from", "to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:convert_mat", (char **)keyword_list, &param0, &param1)) {
    LMatrix3d const *return_value = &(LMatrix3d::convert_mat((CoordinateSystem)param0, (CoordinateSystem)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "convert_mat(int from, int to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_convert_mat_1430_comment =
  "C++ Interface:\n"
  "convert_mat(int from, int to)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the indicated coordinate system to\n"
  " * the indicated coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_convert_mat_1430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const
 * bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const
 */
static PyObject *Dtool_LMatrix3d_almost_equal_1431(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.almost_equal", "LMatrix3d");
      }
      bool return_value = (*(const LMatrix3d*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LMatrix3d param1_local;
        LMatrix3d const *param1_this = Dtool_Coerce_LMatrix3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix3d.almost_equal", "LMatrix3d");
        }
        bool return_value = (*(const LMatrix3d*)local_this).almost_equal(*param1_this, (double)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LMatrix3d self, const LMatrix3d other)\n"
      "almost_equal(LMatrix3d self, const LMatrix3d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_almost_equal_1431_comment =
  "C++ Interface:\n"
  "almost_equal(LMatrix3d self, const LMatrix3d other)\n"
  "almost_equal(LMatrix3d self, const LMatrix3d other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a default\n"
  " * tolerance based on the numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_almost_equal_1431_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::output(ostream &out) const
 */
static PyObject *Dtool_LMatrix3d_output_1432(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3d::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LMatrix3d.output", false, true);
  if (arg_this != NULL) {
    (*(const LMatrix3d*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LMatrix3d self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_output_1432_comment =
  "C++ Interface:\n"
  "output(LMatrix3d self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_output_1432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LMatrix3d_write_1433(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3d::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LMatrix3d.write", false, true);
    if (param1_this != NULL) {
      (*(const LMatrix3d*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LMatrix3d self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_write_1433_comment =
  "C++ Interface:\n"
  "write(LMatrix3d self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix3d_write_1433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix3d_write_datagram_fixed_1436(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3d::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.write_datagram_fixed", "Datagram");
  }
  (*(const LMatrix3d*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LMatrix3d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_write_datagram_fixed_1436_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LMatrix3d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the matrix, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_write_datagram_fixed_1436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::read_datagram_fixed(DatagramIterator &scan)
 */
static PyObject *Dtool_LMatrix3d_read_datagram_fixed_1437(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.read_datagram_fixed")) {
    return NULL;
  }
  // 1-void LMatrix3d::read_datagram_fixed(DatagramIterator &scan)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LMatrix3d self, DatagramIterator scan)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_read_datagram_fixed_1437_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LMatrix3d self, DatagramIterator scan)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LMatrix3d_read_datagram_fixed_1437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix3d_write_datagram_1438(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix3d::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.write_datagram", "Datagram");
  }
  (*(const LMatrix3d*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LMatrix3d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_write_datagram_1438_comment =
  "C++ Interface:\n"
  "write_datagram(LMatrix3d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the matrix using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix3d_write_datagram_1438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix3d::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LMatrix3d_read_datagram_1439(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix3d, (void **)&local_this, "LMatrix3d.read_datagram")) {
    return NULL;
  }
  // 1-void LMatrix3d::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LMatrix3d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_read_datagram_1439_comment =
  "C++ Interface:\n"
  "read_datagram(const LMatrix3d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LMatrix3d_read_datagram_1439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LMatrix3d::get_class_type(void)
 */
static PyObject *Dtool_LMatrix3d_get_class_type_1440(PyObject *, PyObject *) {
  // 1-static TypeHandle LMatrix3d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LMatrix3d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix3d_get_class_type_1440_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LMatrix3d_get_class_type_1440_comment = NULL;
#endif

/**
 * sequence length function for property LMatrix3d::rows
 */
static Py_ssize_t Dtool_LMatrix3d_rows_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix3d::size();
}

/**
 * sequence getter for property LMatrix3d::rows
 */
static PyObject *Dtool_LMatrix3d_rows_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix3d::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3d.rows[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix3d::get_row(int row) const
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).get_row(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix3d self, index)\n");
  }
}

static PyObject *Dtool_LMatrix3d_rows_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix3d_rows_Len;
  wrap->_getitem_func = &Dtool_LMatrix3d_rows_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LMatrix3d::cols
 */
static Py_ssize_t Dtool_LMatrix3d_cols_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix3d::size();
}

/**
 * sequence getter for property LMatrix3d::cols
 */
static PyObject *Dtool_LMatrix3d_cols_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix3d::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3d.cols[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix3d::get_col(int col) const
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix3d*)local_this).get_col(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix3d self, index)\n");
  }
}

static PyObject *Dtool_LMatrix3d_cols_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix3d_cols_Len;
  wrap->_getitem_func = &Dtool_LMatrix3d_cols_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline LMatrix3d::LMatrix3d(void)
 * inline LMatrix3d::LMatrix3d(LMatrix3d const &other)
 * inline LMatrix3d::LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)
 */
static int Dtool_Init_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix3d::LMatrix3d(void)
      LMatrix3d *return_value = new LMatrix3d(LMatrix3d::ident_mat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3d, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
        return -1;
      }
      // 1-inline LMatrix3d::LMatrix3d(LMatrix3d const &other)
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LMatrix3d.LMatrix3d", "LMatrix3d");
        return -1;
      }
      LMatrix3d *return_value = new LMatrix3d(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3d, true, false);
    }
    break;
  case 9:
    {
      // 1-inline LMatrix3d::LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      double param7;
      double param8;
      static const char *keyword_list[] = {"e00", "e01", "e02", "e10", "e11", "e12", "e20", "e21", "e22", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddddddddd:LMatrix3d", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
        LMatrix3d *return_value = new LMatrix3d((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LMatrix3d() takes 0, 1 or 9 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LMatrix3d()\n"
      "LMatrix3d(const LMatrix3d other)\n"
      "LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)\n");
  }
  return -1;
}

LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  LMatrix3d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LMatrix3d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LMatrix3d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 9) {
      // 1-inline LMatrix3d::LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      double param7;
      double param8;
      if (PyArg_ParseTuple(args, "ddddddddd:LMatrix3d", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
        coerced = LMatrix3d((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3d_get_rows(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3d::size();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_LMatrix3d_get_row_1372(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3d_get_cols(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3d::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix3d_get_col_1373(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3d_get_col2s(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3d::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix3d_get_col2_1379(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix3d_get_row2s(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix3d::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix3d_get_row2_1378(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix3d) {
    printf("LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix3d *local_this = (LMatrix3d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix3d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix3d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix3d::Row
 */
/**
 * Python function wrapper for:
 * inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default
 */
static int Dtool_Init_LMatrix3d_Row(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Row() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default
  LMatrix3d::Row const *arg_this = (LMatrix3d::Row *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix3d_Row, 0, "Row.Row", true, true);
  if (arg_this != NULL) {
    LMatrix3d::Row *return_value = new LMatrix3d::Row(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3d_Row, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Row(const Row param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix3d_Row(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix3d_Row) {
    printf("LMatrix3d_Row ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix3d::Row *local_this = (LMatrix3d::Row *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix3d_Row) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix3d_Row(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix3d_Row) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix3d::CRow
 */
/**
 * Python function wrapper for:
 * inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default
 */
static int Dtool_Init_LMatrix3d_CRow(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CRow() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default
  LMatrix3d::CRow const *arg_this = (LMatrix3d::CRow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix3d_CRow, 0, "CRow.CRow", true, true);
  if (arg_this != NULL) {
    LMatrix3d::CRow *return_value = new LMatrix3d::CRow(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix3d_CRow, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CRow(const CRow param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix3d_CRow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix3d_CRow) {
    printf("LMatrix3d_CRow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix3d::CRow *local_this = (LMatrix3d::CRow *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix3d_CRow) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix3d_CRow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix3d_CRow) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix4d
 */
/**
 * Python function wrapper for:
 * inline LMatrix4d &LMatrix4d::operator =(LMatrix4d const &other)
 * inline LMatrix4d &LMatrix4d::operator =(UnalignedLMatrix4d const &other)
 * inline LMatrix4d &LMatrix4d::operator =(double fill_value)
 */
static PyObject *Dtool_LMatrix4d_operator_1455(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.assign")) {
    return NULL;
  }
  {
    // -2 inline LMatrix4d &LMatrix4d::operator =(LMatrix4d const &other)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, false);
    }
  }

  {
    // -2 inline LMatrix4d &LMatrix4d::operator =(UnalignedLMatrix4d const &other)
    UnalignedLMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      LMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, false);
    }
  }

  {
    // -2 inline LMatrix4d &LMatrix4d::operator =(double fill_value)
    if (PyNumber_Check(arg)) {
      (*local_this).operator =(PyFloat_AsDouble(arg));
      LMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, false);
    }
  }

  {
    // -2 inline LMatrix4d &LMatrix4d::operator =(LMatrix4d const &other)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, false);
    }
  }

  {
    // -2 inline LMatrix4d &LMatrix4d::operator =(UnalignedLMatrix4d const &other)
    UnalignedLMatrix4d arg_local;
    UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      LMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, false);
    }
  }

  // No coercion possible: inline LMatrix4d &LMatrix4d::operator =(double fill_value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const LMatrix4d self, const LMatrix4d other)\n"
      "assign(const LMatrix4d self, const UnalignedLMatrix4d other)\n"
      "assign(const LMatrix4d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_operator_1455_comment =
  "C++ Interface:\n"
  "assign(const LMatrix4d self, const LMatrix4d other)\n"
  "assign(const LMatrix4d self, const UnalignedLMatrix4d other)\n"
  "assign(const LMatrix4d self, double fill_value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_operator_1455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *LMatrix4d::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_LMatrix4d_reduce_1459(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *LMatrix4d::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const LMatrix4d*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_reduce_1459_comment =
  "C++ Interface:\n"
  "__reduce__(LMatrix4d self)\n";
#else
static const char *Dtool_LMatrix4d_reduce_1459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::fill(double fill_value)
 */
static PyObject *Dtool_LMatrix4d_fill_1460(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.fill")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::fill(double fill_value)
  if (PyNumber_Check(arg)) {
    (*local_this).fill(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fill(const LMatrix4d self, double fill_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_fill_1460_comment =
  "C++ Interface:\n"
  "fill(const LMatrix4d self, double fill_value)\n"
  "\n"
  "/**\n"
  " * Sets each element of the matrix to the indicated fill_value.  This is of\n"
  " * questionable value, but is sometimes useful when initializing to zero.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_fill_1460_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
 */
static PyObject *Dtool_LMatrix4d_set_1461(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
  double param1;
  double param2;
  double param3;
  double param4;
  double param5;
  double param6;
  double param7;
  double param8;
  double param9;
  double param10;
  double param11;
  double param12;
  double param13;
  double param14;
  double param15;
  double param16;
  static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddddddddddddd:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16)) {
    (*local_this).set((double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9, (double)param10, (double)param11, (double)param12, (double)param13, (double)param14, (double)param15, (double)param16);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const LMatrix4d self, double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_1461_comment =
  "C++ Interface:\n"
  "set(const LMatrix4d self, double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_1461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3)
 */
static PyObject *Dtool_LMatrix4d_set_upper_3_1462(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_upper_3")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.set_upper_3", "LMatrix3d");
  }
  (*local_this).set_upper_3(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_upper_3(const LMatrix4d self, const LMatrix3d upper3)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_upper_3_1462_comment =
  "C++ Interface:\n"
  "set_upper_3(const LMatrix4d self, const LMatrix3d upper3)\n"
  "\n"
  "// Get and set the upper 3x3 rotation matrix.\n"
  "\n"
  "/**\n"
  " * Sets the upper 3x3 submatrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_upper_3_1462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d LMatrix4d::get_upper_3(void) const
 */
static PyObject *Dtool_LMatrix4d_get_upper_3_1463(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LMatrix3d LMatrix4d::get_upper_3(void) const
  LMatrix3d *return_value = new LMatrix3d((*(const LMatrix4d*)local_this).get_upper_3());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_upper_3_1463_comment =
  "C++ Interface:\n"
  "get_upper_3(LMatrix4d self)\n"
  "\n"
  "/**\n"
  " * Retrieves the upper 3x3 submatrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_upper_3_1463_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_row(int row, LVecBase3d const &v)
 * inline void LMatrix4d::set_row(int row, LVecBase4d const &v)
 */
static PyObject *Dtool_LMatrix4d_set_row_1466(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_row")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix4d::set_row(int row, LVecBase4d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase4d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase4d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4d::set_row(int row, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4d::set_row(int row, LVecBase4d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase4d param2_local;
      LVecBase4d const *param2_this = Dtool_Coerce_LVecBase4d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4d::set_row(int row, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"row", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_row", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d param2_local;
      LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_row((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_row(const LMatrix4d self, int row, const LVecBase4d v)\n"
      "set_row(const LMatrix4d self, int row, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_row_1466_comment =
  "C++ Interface:\n"
  "set_row(const LMatrix4d self, int row, const LVecBase4d v)\n"
  "set_row(const LMatrix4d self, int row, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated row of the matrix with the indicated 3-component\n"
  " * vector, ignoring the last column.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_row_1466_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_col(int col, LVecBase3d const &v)
 * inline void LMatrix4d::set_col(int col, LVecBase4d const &v)
 */
static PyObject *Dtool_LMatrix4d_set_col_1467(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_col")) {
    return NULL;
  }
  {
    // -2 inline void LMatrix4d::set_col(int col, LVecBase4d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase4d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase4d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4d::set_col(int col, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_LVecBase3d, (void **)&param2_this);
      if (param2_this != NULL) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4d::set_col(int col, LVecBase4d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase4d param2_local;
      LVecBase4d const *param2_this = Dtool_Coerce_LVecBase4d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LMatrix4d::set_col(int col, LVecBase3d const &v)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"col", "v", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_col", (char **)keyword_list, &param1, &param2)) {
      LVecBase3d param2_local;
      LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
      if ((param2_this != NULL)) {
        (*local_this).set_col((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_col(const LMatrix4d self, int col, const LVecBase4d v)\n"
      "set_col(const LMatrix4d self, int col, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_col_1467_comment =
  "C++ Interface:\n"
  "set_col(const LMatrix4d self, int col, const LVecBase4d v)\n"
  "set_col(const LMatrix4d self, int col, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the indicated column of the matrix with the indicated 3-component\n"
  " * vector, ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_col_1467_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const
 * inline LVecBase4d LMatrix4d::get_row(int row) const
 */
static PyObject *Dtool_LMatrix4d_get_row_1468(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "row");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'row' (pos 1) not found");
      }
      // 1-inline LVecBase4d LMatrix4d::get_row(int row) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase4d *return_value = new LVecBase4d((*(const LMatrix4d*)local_this).get_row((int)arg_val));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"result_vec", "row", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_row", (char **)keyword_list, &param1, &param2)) {
        LVecBase4d param1_local;
        LVecBase4d *param1_this = Dtool_Coerce_LVecBase4d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.get_row", "LVecBase4d");
        }
        (*(const LMatrix4d*)local_this).get_row(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_row() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix4d self, int row)\n"
      "get_row(LMatrix4d self, LVecBase4d result_vec, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_row_1468_comment =
  "C++ Interface:\n"
  "get_row(LMatrix4d self, int row)\n"
  "get_row(LMatrix4d self, LVecBase4d result_vec, int row)\n"
  "\n"
  "// these versions inline better\n"
  "\n"
  "/**\n"
  " * Retrieves the indicated row of the matrix as a 4-component vector.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the indicated row of the matrix as a 4-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_row_1468_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d LMatrix4d::get_col(int col) const
 */
static PyObject *Dtool_LMatrix4d_get_col_1469(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d LMatrix4d::get_col(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase4d *return_value = new LVecBase4d((*(const LMatrix4d*)local_this).get_col((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix4d self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_col_1469_comment =
  "C++ Interface:\n"
  "get_col(LMatrix4d self, int col)\n"
  "\n"
  "/**\n"
  " * Retrieves the indicated column of the matrix as a 4-component vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_col_1469_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const
 * inline LVecBase3d LMatrix4d::get_row3(int row) const
 */
static PyObject *Dtool_LMatrix4d_get_row3_1470(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "row");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'row' (pos 1) not found");
      }
      // 1-inline LVecBase3d LMatrix4d::get_row3(int row) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        LVecBase3d *return_value = new LVecBase3d((*(const LMatrix4d*)local_this).get_row3((int)arg_val));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"result_vec", "row", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_row3", (char **)keyword_list, &param1, &param2)) {
        LVecBase3d param1_local;
        LVecBase3d *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.get_row3", "LVecBase3d");
        }
        (*(const LMatrix4d*)local_this).get_row3(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_row3() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row3(LMatrix4d self, int row)\n"
      "get_row3(LMatrix4d self, LVecBase3d result_vec, int row)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_row3_1470_comment =
  "C++ Interface:\n"
  "get_row3(LMatrix4d self, int row)\n"
  "get_row3(LMatrix4d self, LVecBase3d result_vec, int row)\n"
  "\n"
  "/**\n"
  " * Retrieves the row column of the matrix as a 3-component vector, ignoring\n"
  " * the last column.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Stores the row column of the matrix as a 3-component vector, ignoring the\n"
  " * last column.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_row3_1470_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix4d::get_col3(int col) const
 */
static PyObject *Dtool_LMatrix4d_get_col3_1476(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix4d::get_col3(int col) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3d *return_value = new LVecBase3d((*(const LMatrix4d*)local_this).get_col3((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col3(LMatrix4d self, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_col3_1476_comment =
  "C++ Interface:\n"
  "get_col3(LMatrix4d self, int col)\n"
  "\n"
  "/**\n"
  " * Retrieves the indicated column of the matrix as a 3-component vector,\n"
  " * ignoring the last row.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_col3_1476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4d::is_nan(void) const
 */
static PyObject *Dtool_LMatrix4d_is_nan_1478(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix4d::is_nan(void) const
  bool return_value = (*(const LMatrix4d*)local_this).is_nan();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_is_nan_1478_comment =
  "C++ Interface:\n"
  "is_nan(LMatrix4d self)\n"
  "\n"
  "/**\n"
  " * Returns true if any component of the matrix is not-a-number, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_is_nan_1478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4d::is_identity(void) const
 */
static PyObject *Dtool_LMatrix4d_is_identity_1479(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LMatrix4d::is_identity(void) const
  bool return_value = (*(const LMatrix4d*)local_this).is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_is_identity_1479_comment =
  "C++ Interface:\n"
  "is_identity(LMatrix4d self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is (close enough to) the identity matrix, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_is_identity_1479_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LMatrix4d::get_cell(int row, int col) const
 */
static PyObject *Dtool_LMatrix4d_get_cell_1480(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LMatrix4d::get_cell(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:get_cell", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*(const LMatrix4d*)local_this).get_cell((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cell(LMatrix4d self, int row, int col)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_cell_1480_comment =
  "C++ Interface:\n"
  "get_cell(LMatrix4d self, int row, int col)\n"
  "\n"
  "/**\n"
  " * Returns a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_cell_1480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_cell(int row, int col, double value)
 */
static PyObject *Dtool_LMatrix4d_set_cell_1481(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_cell")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set_cell(int row, int col, double value)
  int param1;
  int param2;
  double param3;
  static const char *keyword_list[] = {"row", "col", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iid:set_cell", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_cell((int)param1, (int)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cell(const LMatrix4d self, int row, int col, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_cell_1481_comment =
  "C++ Interface:\n"
  "set_cell(const LMatrix4d self, int row, int col, double value)\n"
  "\n"
  "/**\n"
  " * Changes a particular element of the matrix.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_cell_1481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix4d::get_num_components(void) const
 */
static PyObject *Dtool_LMatrix4d_get_num_components_1483(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int LMatrix4d::get_num_components(void) const
  int return_value = (*(const LMatrix4d*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_num_components_1483_comment =
  "C++ Interface:\n"
  "get_num_components(LMatrix4d self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the matrix, 16.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_num_components_1483_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int LMatrix4d::compare_to(LMatrix4d const &other) const
 * int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const
 */
static PyObject *Dtool_LMatrix4d_compare_to_1489(PyObject *self, PyObject *args) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int LMatrix4d::compare_to(LMatrix4d const &other) const
      LMatrix4d arg_local;
      LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.compare_to", "LMatrix4d");
      }
      int return_value = (*(const LMatrix4d*)local_this).compare_to(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const
      PyObject *param1;
      double param2;
      if (PyArg_ParseTuple(args, "Od:compare_to", &param1, &param2)) {
        LMatrix4d param1_local;
        LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.compare_to", "LMatrix4d");
        }
        int return_value = (*(const LMatrix4d*)local_this).compare_to(*param1_this, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "compare_to() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix4d self, const LMatrix4d other)\n"
      "compare_to(LMatrix4d self, const LMatrix4d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_compare_to_1489_comment =
  "C++ Interface:\n"
  "compare_to(LMatrix4d self, const LMatrix4d other)\n"
  "compare_to(LMatrix4d self, const LMatrix4d other, double threshold)\n"
  "\n"
  "/**\n"
  " * This flavor of compare_to uses a default threshold value based on the\n"
  " * numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sorts matrices lexicographically, componentwise.  Returns a number less\n"
  " * than 0 if this matrix sorts before the other one, greater than zero if it\n"
  " * sorts after, 0 if they are equivalent (within the indicated tolerance).\n"
  " */";
#else
static const char *Dtool_LMatrix4d_compare_to_1489_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix4d::get_hash(void) const
 * inline std::size_t LMatrix4d::get_hash(double threshold) const
 */
static PyObject *Dtool_LMatrix4d_get_hash_1490(PyObject *self, PyObject *args) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::size_t LMatrix4d::get_hash(void) const
      std::size_t return_value = (*(const LMatrix4d*)local_this).get_hash();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::size_t LMatrix4d::get_hash(double threshold) const
      if (PyNumber_Check(arg)) {
        std::size_t return_value = (*(const LMatrix4d*)local_this).get_hash(PyFloat_AsDouble(arg));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_hash() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(LMatrix4d self)\n"
      "get_hash(LMatrix4d self, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_hash_1490_comment =
  "C++ Interface:\n"
  "get_hash(LMatrix4d self)\n"
  "get_hash(LMatrix4d self, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a suitable hash for phash_map.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_get_hash_1490_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LMatrix4d::add_hash(std::size_t hash) const
 * inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const
 */
static PyObject *Dtool_LMatrix4d_add_hash_1491(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hash");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hash' (pos 1) not found");
      }
      // 1-inline std::size_t LMatrix4d::add_hash(std::size_t hash) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:add_hash", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix4d*)local_this).add_hash((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const
      Py_ssize_t param1;
      double param2;
      static const char *keyword_list[] = {"hash", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:add_hash", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::size_t return_value = (*(const LMatrix4d*)local_this).add_hash((std::size_t)param1, (double)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_hash() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_hash(LMatrix4d self, int hash)\n"
      "add_hash(LMatrix4d self, int hash, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_add_hash_1491_comment =
  "C++ Interface:\n"
  "add_hash(LMatrix4d self, int hash)\n"
  "add_hash(LMatrix4d self, int hash, double threshold)\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the vector into the running hash.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_add_hash_1491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_1492(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform", "LVecBase4d");
  }
  LVecBase4d *return_value = new LVecBase4d((*(const LMatrix4d*)local_this).xform(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(LMatrix4d self, const LVecBase4d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_1492_comment =
  "C++ Interface:\n"
  "xform(LMatrix4d self, const LVecBase4d v)\n"
  "\n"
  "/**\n"
  " * 4-component vector or point times matrix.  This is a fully general\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_1492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_point_1493(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_point", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix4d*)local_this).xform_point(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point(LMatrix4d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_point_1493_comment =
  "C++ Interface:\n"
  "xform_point(LMatrix4d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation component)\n"
  " * and returns the result.  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_point_1493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_point_general_1494(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_point_general", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix4d*)local_this).xform_point_general(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_general(LMatrix4d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_point_general_1494_comment =
  "C++ Interface:\n"
  "xform_point_general(LMatrix4d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation component)\n"
  " * and returns the result, as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_point_general_1494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_vec_1495(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_vec", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix4d*)local_this).xform_vec(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec(LMatrix4d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_vec_1495_comment =
  "C++ Interface:\n"
  "xform_vec(LMatrix4d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component)\n"
  " * and returns the result.  This assumes the matrix is an orthonormal\n"
  " * transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_vec_1495_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_vec_general_1496(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_vec_general", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LMatrix4d*)local_this).xform_vec_general(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general(LMatrix4d self, const LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_vec_general_1496_comment =
  "C++ Interface:\n"
  "xform_vec_general(LMatrix4d self, const LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component)\n"
  " * and returns the result, as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_vec_general_1496_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::xform_in_place(LVecBase4d &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_in_place_1497(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4d::xform_in_place(LVecBase4d &v) const
  LVecBase4d arg_local;
  LVecBase4d *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_in_place", "LVecBase4d");
  }
  (*(const LMatrix4d*)local_this).xform_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_in_place(LMatrix4d self, LVecBase4d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_in_place_1497_comment =
  "C++ Interface:\n"
  "xform_in_place(LMatrix4d self, LVecBase4d v)\n"
  "\n"
  "/**\n"
  " * 4-component vector or point times matrix.  This is a fully general\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_in_place_1497_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_point_in_place_1498(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const
  LVecBase3d arg_local;
  LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_point_in_place", "LVecBase3d");
  }
  (*(const LMatrix4d*)local_this).xform_point_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_in_place(LMatrix4d self, LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_point_in_place_1498_comment =
  "C++ Interface:\n"
  "xform_point_in_place(LMatrix4d self, LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation\n"
  " * component).  This assumes the matrix is an affine transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_point_in_place_1498_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_point_general_in_place_1499(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const
  LVecBase3d arg_local;
  LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_point_general_in_place", "LVecBase3d");
  }
  (*(const LMatrix4d*)local_this).xform_point_general_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_point_general_in_place(LMatrix4d self, LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_point_general_in_place_1499_comment =
  "C++ Interface:\n"
  "xform_point_general_in_place(LMatrix4d self, LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component point (including translation\n"
  " * component), as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_point_general_in_place_1499_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_vec_in_place_1500(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const
  LVecBase3d arg_local;
  LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_vec_in_place", "LVecBase3d");
  }
  (*(const LMatrix4d*)local_this).xform_vec_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_in_place(LMatrix4d self, LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_vec_in_place_1500_comment =
  "C++ Interface:\n"
  "xform_vec_in_place(LMatrix4d self, LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component).\n"
  " * This assumes the matrix is an orthonormal transform.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_vec_in_place_1500_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const
 */
static PyObject *Dtool_LMatrix4d_xform_vec_general_in_place_1501(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const
  LVecBase3d arg_local;
  LVecBase3d *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.xform_vec_general_in_place", "LVecBase3d");
  }
  (*(const LMatrix4d*)local_this).xform_vec_general_in_place(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform_vec_general_in_place(LMatrix4d self, LVecBase3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_xform_vec_general_in_place_1501_comment =
  "C++ Interface:\n"
  "xform_vec_general_in_place(LMatrix4d self, LVecBase3d v)\n"
  "\n"
  "/**\n"
  " * The matrix transforms a 3-component vector (without translation component),\n"
  " * as a fully general operation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_xform_vec_general_in_place_1501_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2)
 */
static PyObject *Dtool_LMatrix4d_multiply_1502(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.multiply")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"other1", "other2", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:multiply", (char **)keyword_list, &param1, &param2)) {
    LMatrix4d param1_local;
    LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.multiply", "LMatrix4d");
    }
    LMatrix4d param2_local;
    LMatrix4d const *param2_this = Dtool_Coerce_LMatrix4d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4d.multiply", "LMatrix4d");
    }
    (*local_this).multiply(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multiply(const LMatrix4d self, const LMatrix4d other1, const LMatrix4d other2)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_multiply_1502_comment =
  "C++ Interface:\n"
  "multiply(const LMatrix4d self, const LMatrix4d other1, const LMatrix4d other2)\n"
  "\n"
  "// this = other1 * other2\n"
  "\n"
  "// this = other1 * other2";
#else
static const char *Dtool_LMatrix4d_multiply_1502_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::componentwise_mult(LMatrix4d const &other)
 */
static PyObject *Dtool_LMatrix4d_componentwise_mult_1509(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.componentwise_mult")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::componentwise_mult(LMatrix4d const &other)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.componentwise_mult", "LMatrix4d");
  }
  (*local_this).componentwise_mult(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "componentwise_mult(const LMatrix4d self, const LMatrix4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_componentwise_mult_1509_comment =
  "C++ Interface:\n"
  "componentwise_mult(const LMatrix4d self, const LMatrix4d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_componentwise_mult_1509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::transpose_from(LMatrix4d const &other)
 */
static PyObject *Dtool_LMatrix4d_transpose_from_1510(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.transpose_from")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::transpose_from(LMatrix4d const &other)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.transpose_from", "LMatrix4d");
  }
  (*local_this).transpose_from(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "transpose_from(const LMatrix4d self, const LMatrix4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_transpose_from_1510_comment =
  "C++ Interface:\n"
  "transpose_from(const LMatrix4d self, const LMatrix4d other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_transpose_from_1510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::transpose_in_place(void)
 */
static PyObject *Dtool_LMatrix4d_transpose_in_place_1511(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.transpose_in_place")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::transpose_in_place(void)
  (*local_this).transpose_in_place();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_transpose_in_place_1511_comment =
  "C++ Interface:\n"
  "transpose_in_place(const LMatrix4d self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_transpose_in_place_1511_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4d::invert_from(LMatrix4d const &other)
 */
static PyObject *Dtool_LMatrix4d_invert_from_1512(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.invert_from")) {
    return NULL;
  }
  // 1-inline bool LMatrix4d::invert_from(LMatrix4d const &other)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.invert_from", "LMatrix4d");
  }
  bool return_value = (*local_this).invert_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_from(const LMatrix4d self, const LMatrix4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_invert_from_1512_comment =
  "C++ Interface:\n"
  "invert_from(const LMatrix4d self, const LMatrix4d other)\n"
  "\n"
  "/**\n"
  " * Computes the inverse of the other matrix, and stores the result in this\n"
  " * matrix.  This is a fully general operation and makes no assumptions about\n"
  " * the type of transform represented by the matrix.\n"
  " *\n"
  " * The other matrix must be a different object than this matrix.  However, if\n"
  " * you need to invert a matrix in place, see invert_in_place.\n"
  " *\n"
  " * The return value is true if the matrix was successfully inverted, false if\n"
  " * the was a singularity.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_invert_from_1512_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other)
 */
static PyObject *Dtool_LMatrix4d_invert_affine_from_1513(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.invert_affine_from")) {
    return NULL;
  }
  // 1-inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.invert_affine_from", "LMatrix4d");
  }
  bool return_value = (*local_this).invert_affine_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_affine_from(const LMatrix4d self, const LMatrix4d other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_invert_affine_from_1513_comment =
  "C++ Interface:\n"
  "invert_affine_from(const LMatrix4d self, const LMatrix4d other)\n"
  "\n"
  "// bugbug: we could optimize this for rotationscaletranslation matrices\n"
  "// (transpose upper 3x3 and take negative of translation component)";
#else
static const char *Dtool_LMatrix4d_invert_affine_from_1513_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4d::invert_in_place(void)
 */
static PyObject *Dtool_LMatrix4d_invert_in_place_1514(PyObject *self, PyObject *) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.invert_in_place")) {
    return NULL;
  }
  // 1-inline bool LMatrix4d::invert_in_place(void)
  bool return_value = (*local_this).invert_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_invert_in_place_1514_comment =
  "C++ Interface:\n"
  "invert_in_place(const LMatrix4d self)\n"
  "\n"
  "/**\n"
  " * Inverts the current matrix.  Returns true if the inverse is successful,\n"
  " * false if the matrix was singular.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_invert_in_place_1514_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight)
 */
static PyObject *Dtool_LMatrix4d_accumulate_1515(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.accumulate")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight)
  PyObject *param1;
  double param2;
  static const char *keyword_list[] = {"other", "weight", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:accumulate", (char **)keyword_list, &param1, &param2)) {
    LMatrix4d param1_local;
    LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.accumulate", "LMatrix4d");
    }
    (*local_this).accumulate(*param1_this, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "accumulate(const LMatrix4d self, const LMatrix4d other, double weight)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_accumulate_1515_comment =
  "C++ Interface:\n"
  "accumulate(const LMatrix4d self, const LMatrix4d other, double weight)\n"
  "\n"
  "/**\n"
  " * Computes (*this) += other * weight.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_accumulate_1515_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d const &LMatrix4d::ident_mat(void)
 */
static PyObject *Dtool_LMatrix4d_ident_mat_1516(PyObject *, PyObject *) {
  // 1-static inline LMatrix4d const &LMatrix4d::ident_mat(void)
  LMatrix4d const *return_value = &(LMatrix4d::ident_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_ident_mat_1516_comment =
  "C++ Interface:\n"
  "ident_mat()\n"
  "\n"
  "/**\n"
  " * Returns an identity matrix.\n"
  " *\n"
  " * This function definition must appear first, since some inline functions\n"
  " * below take advantage of it.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_ident_mat_1516_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d const &LMatrix4d::ones_mat(void)
 */
static PyObject *Dtool_LMatrix4d_ones_mat_1517(PyObject *, PyObject *) {
  // 1-static inline LMatrix4d const &LMatrix4d::ones_mat(void)
  LMatrix4d const *return_value = &(LMatrix4d::ones_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_ones_mat_1517_comment =
  "C++ Interface:\n"
  "ones_mat()\n"
  "\n"
  "/**\n"
  " * Returns an matrix filled with ones.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_ones_mat_1517_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d const &LMatrix4d::zeros_mat(void)
 */
static PyObject *Dtool_LMatrix4d_zeros_mat_1518(PyObject *, PyObject *) {
  // 1-static inline LMatrix4d const &LMatrix4d::zeros_mat(void)
  LMatrix4d const *return_value = &(LMatrix4d::zeros_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_zeros_mat_1518_comment =
  "C++ Interface:\n"
  "zeros_mat()\n"
  "\n"
  "/**\n"
  " * Returns an matrix filled with zeros.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_zeros_mat_1518_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans)
 */
static PyObject *Dtool_LMatrix4d_set_translate_mat_1519(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_translate_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.set_translate_mat", "LVecBase3d");
  }
  (*local_this).set_translate_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_translate_mat(const LMatrix4d self, const LVecBase3d trans)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_translate_mat_1519_comment =
  "C++ Interface:\n"
  "set_translate_mat(const LMatrix4d self, const LVecBase3d trans)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_translate_mat_1519_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_set_rotate_mat_1520(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_rotate_mat")) {
    return NULL;
  }
  // 1-void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
  double param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:set_rotate_mat", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4d.set_rotate_mat", "LVecBase3d");
    }
    (*local_this).set_rotate_mat((double)param1, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat(const LMatrix4d self, double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_rotate_mat_1520_comment =
  "C++ Interface:\n"
  "set_rotate_mat(const LMatrix4d self, double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Sets mat to a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_rotate_mat_1520_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_set_rotate_mat_normaxis_1521(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_rotate_mat_normaxis")) {
    return NULL;
  }
  // 1-void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
  double param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:set_rotate_mat_normaxis", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4d.set_rotate_mat_normaxis", "LVecBase3d");
    }
    (*local_this).set_rotate_mat_normaxis((double)param1, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotate_mat_normaxis(const LMatrix4d self, double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_rotate_mat_normaxis_1521_comment =
  "C++ Interface:\n"
  "set_rotate_mat_normaxis(const LMatrix4d self, double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * prenormalized.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_rotate_mat_normaxis_1521_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale)
 */
static PyObject *Dtool_LMatrix4d_set_scale_mat_1522(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_scale_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.set_scale_mat", "LVecBase3d");
  }
  (*local_this).set_scale_mat(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_mat(const LMatrix4d self, const LVecBase3d scale)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_scale_mat_1522_comment =
  "C++ Interface:\n"
  "set_scale_mat(const LMatrix4d self, const LVecBase3d scale)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale in each of the\n"
  " * three axes.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_scale_mat_1522_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_set_shear_mat_1523(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_shear_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_shear_mat", (char **)keyword_list, &param1, &param2)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.set_shear_mat", "LVecBase3d");
    }
    (*local_this).set_shear_mat(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shear_mat(const LMatrix4d self, const LVecBase3d shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_shear_mat_1523_comment =
  "C++ Interface:\n"
  "set_shear_mat(const LMatrix4d self, const LVecBase3d shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated shear in each of the\n"
  " * three planes.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_shear_mat_1523_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_set_scale_shear_mat_1524(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.set_scale_shear_mat")) {
    return NULL;
  }
  // 1-inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  PyObject *param2;
  int param3 = ::CS_default;
  static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:set_scale_shear_mat", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.set_scale_shear_mat", "LVecBase3d");
    }
    LVecBase3d param2_local;
    LVecBase3d const *param2_this = Dtool_Coerce_LVecBase3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LMatrix4d.set_scale_shear_mat", "LVecBase3d");
    }
    (*local_this).set_scale_shear_mat(*param1_this, *param2_this, (CoordinateSystem)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_shear_mat(const LMatrix4d self, const LVecBase3d scale, const LVecBase3d shear, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_set_scale_shear_mat_1524_comment =
  "C++ Interface:\n"
  "set_scale_shear_mat(const LMatrix4d self, const LVecBase3d scale, const LVecBase3d shear, int cs)\n"
  "\n"
  "/**\n"
  " * Fills mat with a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_set_scale_shear_mat_1524_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans)
 * static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz)
 */
static PyObject *Dtool_LMatrix4d_translate_mat_1525(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "trans");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'trans' (pos 1) not found");
      }
      // 1-static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans)
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix4d.translate_mat", "LVecBase3d");
      }
      LMatrix4d *return_value = new LMatrix4d(LMatrix4d::translate_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"tx", "ty", "tz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:translate_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::translate_mat((double)param0, (double)param1, (double)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "translate_mat() takes 1 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "translate_mat(const LVecBase3d trans)\n"
      "translate_mat(double tx, double ty, double tz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_translate_mat_1525_comment =
  "C++ Interface:\n"
  "translate_mat(const LVecBase3d trans)\n"
  "translate_mat(double tx, double ty, double tz)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated translation.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_translate_mat_1525_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_rotate_mat_1526(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
  double param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:rotate_mat", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.rotate_mat", "LVecBase3d");
    }
    LMatrix4d *return_value = new LMatrix4d(LMatrix4d::rotate_mat((double)param0, *param1_this, (CoordinateSystem)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat(double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_rotate_mat_1526_comment =
  "C++ Interface:\n"
  "rotate_mat(double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_rotate_mat_1526_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_rotate_mat_normaxis_1527(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default)
  double param0;
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"angle", "axis", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO|i:rotate_mat_normaxis", (char **)keyword_list, &param0, &param1, &param2)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.rotate_mat_normaxis", "LVecBase3d");
    }
    LMatrix4d *return_value = new LMatrix4d(LMatrix4d::rotate_mat_normaxis((double)param0, *param1_this, (CoordinateSystem)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate_mat_normaxis(double angle, const LVecBase3d axis, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_rotate_mat_normaxis_1527_comment =
  "C++ Interface:\n"
  "rotate_mat_normaxis(double angle, const LVecBase3d axis, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that rotates by the given angle in degrees\n"
  " * counterclockwise about the indicated vector.  Assumes axis has been\n"
  " * prenormalized.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_rotate_mat_normaxis_1527_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale)
 * static inline LMatrix4d LMatrix4d::scale_mat(double scale)
 * static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz)
 */
static PyObject *Dtool_LMatrix4d_scale_mat_1528(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "scale");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'scale' (pos 1) not found");
      }
      {
        // -2 static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale)
        LVecBase3d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
        if (arg_this != NULL) {
          LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
        }
      }

      {
        // -2 static inline LMatrix4d LMatrix4d::scale_mat(double scale)
        if (PyNumber_Check(arg)) {
          LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_mat(PyFloat_AsDouble(arg)));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
        }
      }

      {
        // -2 static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale)
        LVecBase3d arg_local;
        LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
        if ((arg_this != NULL)) {
          LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_mat(*arg_this));
          if (return_value == NULL) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
        }
      }

      // No coercion possible: static inline LMatrix4d LMatrix4d::scale_mat(double scale)
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"sx", "sy", "sz", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:scale_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_mat((double)param0, (double)param1, (double)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_mat() takes 1 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_mat(const LVecBase3d scale)\n"
      "scale_mat(double scale)\n"
      "scale_mat(double sx, double sy, double sz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_scale_mat_1528_comment =
  "C++ Interface:\n"
  "scale_mat(const LVecBase3d scale)\n"
  "scale_mat(double scale)\n"
  "scale_mat(double sx, double sy, double sz)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale in each of the three\n"
  " * axes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated uniform scale.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_scale_mat_1528_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_shear_mat_1529(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "shear");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'shear' (pos 1) not found");
      }
      // 1-static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs)
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "LMatrix4d.shear_mat", "LVecBase3d");
      }
      LMatrix4d *return_value = new LMatrix4d(LMatrix4d::shear_mat(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
    break;
  case 2:
    {
      // 1-static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs)
      PyObject *param0;
      int param1;
      static const char *keyword_list[] = {"shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4d.shear_mat", "LVecBase3d");
        }
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::shear_mat(*param0_this, (CoordinateSystem)param1));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
      double param0;
      double param1;
      double param2;
      int param3 = ::CS_default;
      static const char *keyword_list[] = {"shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd|i:shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::shear_mat((double)param0, (double)param1, (double)param2, (CoordinateSystem)param3));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "shear_mat() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "shear_mat(const LVecBase3d shear)\n"
      "shear_mat(const LVecBase3d shear, int cs)\n"
      "shear_mat(double shxy, double shxz, double shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_shear_mat_1529_comment =
  "C++ Interface:\n"
  "shear_mat(const LVecBase3d shear)\n"
  "shear_mat(const LVecBase3d shear, int cs)\n"
  "shear_mat(double shxy, double shxz, double shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated shear in each of the three\n"
  " * planes.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_shear_mat_1529_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default)
 * static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LMatrix4d_scale_shear_mat_1530(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"scale", "shear", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:scale_shear_mat", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4d.scale_shear_mat", "LVecBase3d");
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.scale_shear_mat", "LVecBase3d");
        }
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_shear_mat(*param0_this, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"scale", "shear", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3d param0_local;
        LVecBase3d const *param0_this = Dtool_Coerce_LVecBase3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4d.scale_shear_mat", "LVecBase3d");
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.scale_shear_mat", "LVecBase3d");
        }
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_shear_mat(*param0_this, *param1_this, (CoordinateSystem)param2));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
  case 6:
  case 7:
    {
      // 1-static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      int param6 = ::CS_default;
      static const char *keyword_list[] = {"sx", "sy", "sz", "shxy", "shxz", "shyz", "cs", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddd|i:scale_shear_mat", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        LMatrix4d *return_value = new LMatrix4d(LMatrix4d::scale_shear_mat((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (CoordinateSystem)param6));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "scale_shear_mat() takes 2, 3, 6 or 7 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear)\n"
      "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear, int cs)\n"
      "scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_scale_shear_mat_1530_comment =
  "C++ Interface:\n"
  "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear)\n"
  "scale_shear_mat(const LVecBase3d scale, const LVecBase3d shear, int cs)\n"
  "scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, int cs)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a matrix that applies the indicated scale and shear.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_scale_shear_mat_1530_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void)
 */
static PyObject *Dtool_LMatrix4d_y_to_z_up_mat_1531(PyObject *, PyObject *) {
  // 1-static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void)
  LMatrix4d const *return_value = &(LMatrix4d::y_to_z_up_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_y_to_z_up_mat_1531_comment =
  "C++ Interface:\n"
  "y_to_z_up_mat()\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the Y-up coordinate system to the\n"
  " * Z-up coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_y_to_z_up_mat_1531_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void)
 */
static PyObject *Dtool_LMatrix4d_z_to_y_up_mat_1532(PyObject *, PyObject *) {
  // 1-static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void)
  LMatrix4d const *return_value = &(LMatrix4d::z_to_y_up_mat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_z_to_y_up_mat_1532_comment =
  "C++ Interface:\n"
  "z_to_y_up_mat()\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the Y-up coordinate system to the\n"
  " * Z-up coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_z_to_y_up_mat_1532_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to)
 */
static PyObject *Dtool_LMatrix4d_convert_mat_1533(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to)
  int param0;
  int param1;
  static const char *keyword_list[] = {"from", "to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:convert_mat", (char **)keyword_list, &param0, &param1)) {
    LMatrix4d const *return_value = &(LMatrix4d::convert_mat((CoordinateSystem)param0, (CoordinateSystem)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "convert_mat(int from, int to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_convert_mat_1533_comment =
  "C++ Interface:\n"
  "convert_mat(int from, int to)\n"
  "\n"
  "/**\n"
  " * Returns a matrix that transforms from the indicated coordinate system to\n"
  " * the indicated coordinate system.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_convert_mat_1533_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const
 * bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const
 */
static PyObject *Dtool_LMatrix4d_almost_equal_1534(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const
      LMatrix4d arg_local;
      LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.almost_equal", "LMatrix4d");
      }
      bool return_value = (*(const LMatrix4d*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LMatrix4d param1_local;
        LMatrix4d const *param1_this = Dtool_Coerce_LMatrix4d(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.almost_equal", "LMatrix4d");
        }
        bool return_value = (*(const LMatrix4d*)local_this).almost_equal(*param1_this, (double)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LMatrix4d self, const LMatrix4d other)\n"
      "almost_equal(LMatrix4d self, const LMatrix4d other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_almost_equal_1534_comment =
  "C++ Interface:\n"
  "almost_equal(LMatrix4d self, const LMatrix4d other)\n"
  "almost_equal(LMatrix4d self, const LMatrix4d other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a default\n"
  " * tolerance based on the numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two matrices are memberwise equal within a specified\n"
  " * tolerance.  This is faster than the equivalence operator as this doesn't\n"
  " * have to guarantee that it is transitive.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_almost_equal_1534_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::output(ostream &out) const
 */
static PyObject *Dtool_LMatrix4d_output_1535(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4d::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LMatrix4d.output", false, true);
  if (arg_this != NULL) {
    (*(const LMatrix4d*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LMatrix4d self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_output_1535_comment =
  "C++ Interface:\n"
  "output(LMatrix4d self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_output_1535_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_LMatrix4d_write_1536(PyObject *self, PyObject *args, PyObject *kwds) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4d::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "LMatrix4d.write", false, true);
    if (param1_this != NULL) {
      (*(const LMatrix4d*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(LMatrix4d self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_write_1536_comment =
  "C++ Interface:\n"
  "write(LMatrix4d self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LMatrix4d_write_1536_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::write_datagram_fixed(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix4d_write_datagram_fixed_1539(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4d::write_datagram_fixed(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.write_datagram_fixed", "Datagram");
  }
  (*(const LMatrix4d*)local_this).write_datagram_fixed(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram_fixed(LMatrix4d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_write_datagram_fixed_1539_comment =
  "C++ Interface:\n"
  "write_datagram_fixed(LMatrix4d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_float32() or add_float64(),\n"
  " * depending on the type of floats in the matrix, regardless of the setting of\n"
  " * Datagram::set_stdfloat_double().  This is appropriate when you want to\n"
  " * write a fixed-width value to the datagram, especially when you are not\n"
  " * writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_write_datagram_fixed_1539_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::read_datagram_fixed(DatagramIterator &scan)
 */
static PyObject *Dtool_LMatrix4d_read_datagram_fixed_1540(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.read_datagram_fixed")) {
    return NULL;
  }
  // 1-void LMatrix4d::read_datagram_fixed(DatagramIterator &scan)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.read_datagram_fixed", "DatagramIterator");
  }
  (*local_this).read_datagram_fixed(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram_fixed(const LMatrix4d self, DatagramIterator scan)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_read_datagram_fixed_1540_comment =
  "C++ Interface:\n"
  "read_datagram_fixed(const LMatrix4d self, DatagramIterator scan)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_float32() or get_float64().\n"
  " * See write_datagram_fixed().\n"
  " */";
#else
static const char *Dtool_LMatrix4d_read_datagram_fixed_1540_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_LMatrix4d_write_datagram_1541(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-void LMatrix4d::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.write_datagram", "Datagram");
  }
  (*(const LMatrix4d*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(LMatrix4d self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_write_datagram_1541_comment =
  "C++ Interface:\n"
  "write_datagram(LMatrix4d self, Datagram destination)\n"
  "\n"
  "/**\n"
  " * Writes the matrix to the Datagram using add_stdfloat().  This is\n"
  " * appropriate when you want to write the matrix using the standard width\n"
  " * setting, especially when you are writing a bam file.\n"
  " */";
#else
static const char *Dtool_LMatrix4d_write_datagram_1541_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LMatrix4d::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_LMatrix4d_read_datagram_1542(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LMatrix4d, (void **)&local_this, "LMatrix4d.read_datagram")) {
    return NULL;
  }
  // 1-void LMatrix4d::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const LMatrix4d self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_read_datagram_1542_comment =
  "C++ Interface:\n"
  "read_datagram(const LMatrix4d self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " * Reads the matrix from the Datagram using get_stdfloat().\n"
  " */";
#else
static const char *Dtool_LMatrix4d_read_datagram_1542_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LMatrix4d::get_class_type(void)
 */
static PyObject *Dtool_LMatrix4d_get_class_type_1543(PyObject *, PyObject *) {
  // 1-static TypeHandle LMatrix4d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LMatrix4d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LMatrix4d_get_class_type_1543_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LMatrix4d_get_class_type_1543_comment = NULL;
#endif

/**
 * sequence length function for property LMatrix4d::rows
 */
static Py_ssize_t Dtool_LMatrix4d_rows_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix4d::size();
}

/**
 * sequence getter for property LMatrix4d::rows
 */
static PyObject *Dtool_LMatrix4d_rows_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix4d::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4d.rows[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase4d LMatrix4d::get_row(int row) const
  LVecBase4d *return_value = new LVecBase4d((*(const LMatrix4d*)local_this).get_row(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_row(LMatrix4d self, index)\n");
  }
}

static PyObject *Dtool_LMatrix4d_rows_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix4d_rows_Len;
  wrap->_getitem_func = &Dtool_LMatrix4d_rows_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property LMatrix4d::cols
 */
static Py_ssize_t Dtool_LMatrix4d_cols_Len(PyObject *self) {
  return (Py_ssize_t)LMatrix4d::size();
}

/**
 * sequence getter for property LMatrix4d::cols
 */
static PyObject *Dtool_LMatrix4d_cols_Getitem(PyObject *self, Py_ssize_t index) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)LMatrix4d::size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4d.cols[] index out of range");
    return NULL;
  }
  // 1-inline LVecBase4d LMatrix4d::get_col(int col) const
  LVecBase4d *return_value = new LVecBase4d((*(const LMatrix4d*)local_this).get_col(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_col(LMatrix4d self, index)\n");
  }
}

static PyObject *Dtool_LMatrix4d_cols_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_LMatrix4d_cols_Len;
  wrap->_getitem_func = &Dtool_LMatrix4d_cols_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline LMatrix4d::LMatrix4d(void)
 * inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3)
 * inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans)
 * inline LMatrix4d::LMatrix4d(LMatrix4d const &other)
 * inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other)
 * inline LMatrix4d::LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
 */
static int Dtool_Init_LMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LMatrix4d::LMatrix4d(void)
      LMatrix4d *return_value = new LMatrix4d(LMatrix4d::ident_mat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3)
        PyObject *param0;
        static const char *keyword_list[] = {"upper3", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4d", (char **)keyword_list, &param0)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LMatrix4d *return_value = new LMatrix4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4d", (char **)keyword_list, &param0)) {
          UnalignedLMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_UnalignedLMatrix4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LMatrix4d *return_value = new LMatrix4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4d::LMatrix4d(LMatrix4d const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4d", (char **)keyword_list, &param0)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LMatrix4d *return_value = new LMatrix4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3)
        PyObject *param0;
        static const char *keyword_list[] = {"upper3", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4d", (char **)keyword_list, &param0)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LMatrix4d *return_value = new LMatrix4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4d", (char **)keyword_list, &param0)) {
          UnalignedLMatrix4d param0_local;
          UnalignedLMatrix4d const *param0_this = Dtool_Coerce_UnalignedLMatrix4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LMatrix4d *return_value = new LMatrix4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LMatrix4d::LMatrix4d(LMatrix4d const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LMatrix4d", (char **)keyword_list, &param0)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LMatrix4d *return_value = new LMatrix4d(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"upper3", "trans", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LMatrix4d", (char **)keyword_list, &param0, &param1)) {
        LMatrix3d param0_local;
        LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LMatrix4d.LMatrix4d", "LMatrix3d");
          return -1;
        }
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LMatrix4d.LMatrix4d", "LVecBase3d");
          return -1;
        }
        LMatrix4d *return_value = new LMatrix4d(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
      }
    }
    break;
  case 16:
    {
      // 1-inline LMatrix4d::LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      double param7;
      double param8;
      double param9;
      double param10;
      double param11;
      double param12;
      double param13;
      double param14;
      double param15;
      static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddddddddddddd:LMatrix4d", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        LMatrix4d *return_value = new LMatrix4d((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9, (double)param10, (double)param11, (double)param12, (double)param13, (double)param14, (double)param15);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LMatrix4d() takes 0, 1, 2 or 16 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LMatrix4d()\n"
      "LMatrix4d(const LMatrix3d upper3)\n"
      "LMatrix4d(const UnalignedLMatrix4d other)\n"
      "LMatrix4d(const LMatrix4d other)\n"
      "LMatrix4d(const LMatrix3d upper3, const LVecBase3d trans)\n"
      "LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)\n");
  }
  return -1;
}

LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  LMatrix4d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LMatrix4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LMatrix4d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3)
      LMatrix3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LMatrix4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other)
      UnalignedLMatrix4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LMatrix4d(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "LMatrix4d", 2, 2, &param0, &param1)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            coerced = LMatrix4d(*param0_this, *param1_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 16: {
        // 1-inline LMatrix4d::LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
        double param0;
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        double param8;
        double param9;
        double param10;
        double param11;
        double param12;
        double param13;
        double param14;
        double param15;
        if (PyArg_ParseTuple(args, "dddddddddddddddd:LMatrix4d", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
          coerced = LMatrix4d((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9, (double)param10, (double)param11, (double)param12, (double)param13, (double)param14, (double)param15);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix4d_get_rows(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix4d::size();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_LMatrix4d_get_row_1468(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix4d_get_cols(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix4d::size();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_LMatrix4d_get_col_1469(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_LMatrix4d_get_row3s(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)LMatrix4d::size();
  PyTupleObject args;
  PyObject_INIT_VAR(&args, &PyTuple_Type, 1);
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyTuple_SET_ITEM(&args, 0, index);
    PyObject *value = Dtool_LMatrix4d_get_row3_1470(self, (PyObject *)&args, NULL);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  _Py_ForgetReference((PyObject *)&args);
  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_LMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix4d) {
    printf("LMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix4d *local_this = (LMatrix4d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix4d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix4d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix4d::Row
 */
/**
 * Python function wrapper for:
 * inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default
 */
static int Dtool_Init_LMatrix4d_Row(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Row() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default
  LMatrix4d::Row const *arg_this = (LMatrix4d::Row *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix4d_Row, 0, "Row.Row", true, true);
  if (arg_this != NULL) {
    LMatrix4d::Row *return_value = new LMatrix4d::Row(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d_Row, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Row(const Row param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix4d_Row(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix4d_Row) {
    printf("LMatrix4d_Row ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix4d::Row *local_this = (LMatrix4d::Row *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix4d_Row) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix4d_Row(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix4d_Row) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LMatrix4d::CRow
 */
/**
 * Python function wrapper for:
 * inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default
 */
static int Dtool_Init_LMatrix4d_CRow(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CRow() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default
  LMatrix4d::CRow const *arg_this = (LMatrix4d::CRow *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix4d_CRow, 0, "CRow.CRow", true, true);
  if (arg_this != NULL) {
    LMatrix4d::CRow *return_value = new LMatrix4d::CRow(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LMatrix4d_CRow, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CRow(const CRow param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LMatrix4d_CRow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LMatrix4d_CRow) {
    printf("LMatrix4d_CRow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LMatrix4d::CRow *local_this = (LMatrix4d::CRow *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LMatrix4d_CRow) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LMatrix4d_CRow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LMatrix4d_CRow) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class UnalignedLMatrix4d
 */
/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(LMatrix4d const &copy)
 * inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy)
 */
static PyObject *Dtool_UnalignedLMatrix4d_operator_1548(PyObject *self, PyObject *arg) {
  UnalignedLMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLMatrix4d, (void **)&local_this, "UnalignedLMatrix4d.assign")) {
    return NULL;
  }
  {
    // -2 inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(LMatrix4d const &copy)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, false);
    }
  }

  {
    // -2 inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy)
    UnalignedLMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, false);
    }
  }

  {
    // -2 inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(LMatrix4d const &copy)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, false);
    }
  }

  {
    // -2 inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy)
    UnalignedLMatrix4d arg_local;
    UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      UnalignedLMatrix4d *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UnalignedLMatrix4d, false, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const UnalignedLMatrix4d self, const LMatrix4d copy)\n"
      "assign(const UnalignedLMatrix4d self, const UnalignedLMatrix4d copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4d_operator_1548_comment =
  "C++ Interface:\n"
  "assign(const UnalignedLMatrix4d self, const LMatrix4d copy)\n"
  "assign(const UnalignedLMatrix4d self, const UnalignedLMatrix4d copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLMatrix4d_operator_1548_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
 */
static PyObject *Dtool_UnalignedLMatrix4d_set_1549(PyObject *self, PyObject *args, PyObject *kwds) {
  UnalignedLMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UnalignedLMatrix4d, (void **)&local_this, "UnalignedLMatrix4d.set")) {
    return NULL;
  }
  // 1-inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
  double param1;
  double param2;
  double param3;
  double param4;
  double param5;
  double param6;
  double param7;
  double param8;
  double param9;
  double param10;
  double param11;
  double param12;
  double param13;
  double param14;
  double param15;
  double param16;
  static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddddddddddddd:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16)) {
    (*local_this).set((double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9, (double)param10, (double)param11, (double)param12, (double)param13, (double)param14, (double)param15, (double)param16);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const UnalignedLMatrix4d self, double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4d_set_1549_comment =
  "C++ Interface:\n"
  "set(const UnalignedLMatrix4d self, double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UnalignedLMatrix4d_set_1549_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int UnalignedLMatrix4d::get_num_components(void) const
 */
static PyObject *Dtool_UnalignedLMatrix4d_get_num_components_1552(PyObject *self, PyObject *) {
  UnalignedLMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int UnalignedLMatrix4d::get_num_components(void) const
  int return_value = (*(const UnalignedLMatrix4d*)local_this).get_num_components();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4d_get_num_components_1552_comment =
  "C++ Interface:\n"
  "get_num_components(UnalignedLMatrix4d self)\n"
  "\n"
  "/**\n"
  " * Returns the number of elements in the matrix, sixteen.\n"
  " */";
#else
static const char *Dtool_UnalignedLMatrix4d_get_num_components_1552_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle UnalignedLMatrix4d::get_class_type(void)
 */
static PyObject *Dtool_UnalignedLMatrix4d_get_class_type_1553(PyObject *, PyObject *) {
  // 1-static TypeHandle UnalignedLMatrix4d::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(UnalignedLMatrix4d::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UnalignedLMatrix4d_get_class_type_1553_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_UnalignedLMatrix4d_get_class_type_1553_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UnalignedLMatrix4d::UnalignedLMatrix4d(void)
 * inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy)
 * inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy)
 * inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
 */
static int Dtool_Init_UnalignedLMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline UnalignedLMatrix4d::UnalignedLMatrix4d(void)
      UnalignedLMatrix4d *return_value = new UnalignedLMatrix4d();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4d, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      {
        // -2 inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy)
        LMatrix4d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
        if (arg_this != NULL) {
          UnalignedLMatrix4d *return_value = new UnalignedLMatrix4d(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4d, true, false);
        }
      }

      {
        // -2 inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy)
        UnalignedLMatrix4d const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_UnalignedLMatrix4d, (void **)&arg_this);
        if (arg_this != NULL) {
          UnalignedLMatrix4d *return_value = new UnalignedLMatrix4d(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4d, true, false);
        }
      }

      {
        // -2 inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy)
        LMatrix4d arg_local;
        LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
        if ((arg_this != NULL)) {
          UnalignedLMatrix4d *return_value = new UnalignedLMatrix4d(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4d, true, false);
        }
      }

      {
        // -2 inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy)
        UnalignedLMatrix4d arg_local;
        UnalignedLMatrix4d const *arg_this = Dtool_Coerce_UnalignedLMatrix4d(arg, arg_local);
        if ((arg_this != NULL)) {
          UnalignedLMatrix4d *return_value = new UnalignedLMatrix4d(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4d, true, false);
        }
      }

    }
    break;
  case 16:
    {
      // 1-inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      double param7;
      double param8;
      double param9;
      double param10;
      double param11;
      double param12;
      double param13;
      double param14;
      double param15;
      static const char *keyword_list[] = {"e00", "e01", "e02", "e03", "e10", "e11", "e12", "e13", "e20", "e21", "e22", "e23", "e30", "e31", "e32", "e33", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddddddddddddddd:UnalignedLMatrix4d", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        UnalignedLMatrix4d *return_value = new UnalignedLMatrix4d((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9, (double)param10, (double)param11, (double)param12, (double)param13, (double)param14, (double)param15);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UnalignedLMatrix4d, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UnalignedLMatrix4d() takes 0, 1 or 16 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UnalignedLMatrix4d()\n"
      "UnalignedLMatrix4d(const LMatrix4d copy)\n"
      "UnalignedLMatrix4d(const UnalignedLMatrix4d copy)\n"
      "UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)\n");
  }
  return -1;
}

UnalignedLMatrix4d *Dtool_Coerce_UnalignedLMatrix4d(PyObject *args, UnalignedLMatrix4d &coerced) {
  UnalignedLMatrix4d *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_UnalignedLMatrix4d, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const UnalignedLMatrix4d *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = UnalignedLMatrix4d(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 16) {
      // 1-inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33)
      double param0;
      double param1;
      double param2;
      double param3;
      double param4;
      double param5;
      double param6;
      double param7;
      double param8;
      double param9;
      double param10;
      double param11;
      double param12;
      double param13;
      double param14;
      double param15;
      if (PyArg_ParseTuple(args, "dddddddddddddddd:UnalignedLMatrix4d", &param0, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15)) {
        coerced = UnalignedLMatrix4d((double)param0, (double)param1, (double)param2, (double)param3, (double)param4, (double)param5, (double)param6, (double)param7, (double)param8, (double)param9, (double)param10, (double)param11, (double)param12, (double)param13, (double)param14, (double)param15);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_UnalignedLMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_UnalignedLMatrix4d) {
    printf("UnalignedLMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  UnalignedLMatrix4d *local_this = (UnalignedLMatrix4d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_UnalignedLMatrix4d) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_UnalignedLMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_UnalignedLMatrix4d) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LQuaternionf
 */
/**
 * Python function wrapper for:
 * static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v)
 */
static PyObject *Dtool_LQuaternionf_pure_imaginary_1565(PyObject *, PyObject *arg) {
  // 1-static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v)
  LVector3f arg_local;
  LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "LQuaternionf.pure_imaginary", "LVector3f");
  }
  LQuaternionf *return_value = new LQuaternionf(LQuaternionf::pure_imaginary(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pure_imaginary(const LVector3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_pure_imaginary_1565_comment =
  "C++ Interface:\n"
  "pure_imaginary(const LVector3f v)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_pure_imaginary_1565_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf LQuaternionf::conjugate(void) const
 */
static PyObject *Dtool_LQuaternionf_conjugate_1566(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LQuaternionf LQuaternionf::conjugate(void) const
  LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).conjugate());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_conjugate_1566_comment =
  "C++ Interface:\n"
  "conjugate(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * Returns the complex conjugate of this quat.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_conjugate_1566_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const
 * inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const
 */
static PyObject *Dtool_LQuaternionf_xform_1567(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4f *return_value = new LVecBase4f((*(const LQuaternionf*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f((*(const LQuaternionf*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4f *return_value = new LVecBase4f((*(const LQuaternionf*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f((*(const LQuaternionf*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(LQuaternionf self, const LVecBase4f v)\n"
      "xform(LQuaternionf self, const LVecBase3f v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_xform_1567_comment =
  "C++ Interface:\n"
  "xform(LQuaternionf self, const LVecBase4f v)\n"
  "xform(LQuaternionf self, const LVecBase3f v)\n"
  "\n"
  "/**\n"
  " * Transforms a 3-d vector by the indicated rotation\n"
  " */\n"
  "\n"
  "/**\n"
  " * Transforms a 4-d vector by the indicated rotation\n"
  " */";
#else
static const char *Dtool_LQuaternionf_xform_1567_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const
 */
static PyObject *Dtool_LQuaternionf_multiply_1568(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.multiply", "LQuaternionf");
  }
  LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).multiply(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multiply(LQuaternionf self, const LQuaternionf rhs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_multiply_1568_comment =
  "C++ Interface:\n"
  "multiply(LQuaternionf self, const LQuaternionf rhs)\n"
  "\n"
  "/**\n"
  " * actual multiply call (non virtual)\n"
  " */";
#else
static const char *Dtool_LQuaternionf_multiply_1568_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::angle_rad(LQuaternionf const &other) const
 */
static PyObject *Dtool_LQuaternionf_angle_rad_1572(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::angle_rad(LQuaternionf const &other) const
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.angle_rad", "LQuaternionf");
  }
  float return_value = (*(const LQuaternionf*)local_this).angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_rad(LQuaternionf self, const LQuaternionf other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_angle_rad_1572_comment =
  "C++ Interface:\n"
  "angle_rad(LQuaternionf self, const LQuaternionf other)\n"
  "\n"
  "/**\n"
  " * Returns the angle between the orientation represented by this quaternion\n"
  " * and the other one, expressed in radians.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_angle_rad_1572_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::angle_deg(LQuaternionf const &other) const
 */
static PyObject *Dtool_LQuaternionf_angle_deg_1573(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::angle_deg(LQuaternionf const &other) const
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.angle_deg", "LQuaternionf");
  }
  float return_value = (*(const LQuaternionf*)local_this).angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_deg(LQuaternionf self, const LQuaternionf other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_angle_deg_1573_comment =
  "C++ Interface:\n"
  "angle_deg(LQuaternionf self, const LQuaternionf other)\n"
  "\n"
  "/**\n"
  " * Returns the angle between the orientation represented by this quaternion\n"
  " * and the other one, expressed in degrees.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_angle_deg_1573_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const
 * inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const
 */
static PyObject *Dtool_LQuaternionf_almost_equal_1577(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const
      LQuaternionf arg_local;
      LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.almost_equal", "LQuaternionf");
      }
      bool return_value = (*(const LQuaternionf*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LQuaternionf param1_local;
        LQuaternionf const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LQuaternionf.almost_equal", "LQuaternionf");
        }
        bool return_value = (*(const LQuaternionf*)local_this).almost_equal(*param1_this, (float)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LQuaternionf self, const LQuaternionf other)\n"
      "almost_equal(LQuaternionf self, const LQuaternionf other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_almost_equal_1577_comment =
  "C++ Interface:\n"
  "almost_equal(LQuaternionf self, const LQuaternionf other)\n"
  "almost_equal(LQuaternionf self, const LQuaternionf other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions are memberwise equal within a default\n"
  " * tolerance based on the numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_almost_equal_1577_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const
 */
static PyObject *Dtool_LQuaternionf_is_same_direction_1578(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.is_same_direction", "LQuaternionf");
  }
  bool return_value = (*(const LQuaternionf*)local_this).is_same_direction(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_same_direction(LQuaternionf self, const LQuaternionf other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_is_same_direction_1578_comment =
  "C++ Interface:\n"
  "is_same_direction(LQuaternionf self, const LQuaternionf other)\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions represent the same rotation within a\n"
  " * default tolerance based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_is_same_direction_1578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const
 */
static PyObject *Dtool_LQuaternionf_almost_same_direction_1579(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"other", "threshold", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:almost_same_direction", (char **)keyword_list, &param1, &param2)) {
    LQuaternionf param1_local;
    LQuaternionf const *param1_this = Dtool_Coerce_LQuaternionf(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LQuaternionf.almost_same_direction", "LQuaternionf");
    }
    bool return_value = (*(const LQuaternionf*)local_this).almost_same_direction(*param1_this, (float)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_same_direction(LQuaternionf self, const LQuaternionf other, float threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_almost_same_direction_1579_comment =
  "C++ Interface:\n"
  "almost_same_direction(LQuaternionf self, const LQuaternionf other, float threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions represent the same rotation within a\n"
  " * specified tolerance.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_almost_same_direction_1579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::output(ostream &) const
 */
static PyObject *Dtool_LQuaternionf_output_1580(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LQuaternionf::output(ostream &) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LQuaternionf.output", false, true);
  if (arg_this != NULL) {
    (*(const LQuaternionf*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LQuaternionf self, ostream param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_output_1580_comment =
  "C++ Interface:\n"
  "output(LQuaternionf self, ostream param0)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_output_1580_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LQuaternionf::extract_to_matrix(LMatrix3f &m) const
 * void LQuaternionf::extract_to_matrix(LMatrix4f &m) const
 */
static PyObject *Dtool_LQuaternionf_extract_to_matrix_1581(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 void LQuaternionf::extract_to_matrix(LMatrix4f &m) const
    LMatrix4f *arg_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix4f, 1, "LQuaternionf.extract_to_matrix", false, false);
    if (arg_this != NULL) {
      (*(const LQuaternionf*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaternionf::extract_to_matrix(LMatrix3f &m) const
    LMatrix3f *arg_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix3f, 1, "LQuaternionf.extract_to_matrix", false, false);
    if (arg_this != NULL) {
      (*(const LQuaternionf*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaternionf::extract_to_matrix(LMatrix4f &m) const
    LMatrix4f arg_local;
    LMatrix4f *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LQuaternionf*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaternionf::extract_to_matrix(LMatrix3f &m) const
    LMatrix3f arg_local;
    LMatrix3f *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LQuaternionf*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_to_matrix(LQuaternionf self, LMatrix4f m)\n"
      "extract_to_matrix(LQuaternionf self, LMatrix3f m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_extract_to_matrix_1581_comment =
  "C++ Interface:\n"
  "extract_to_matrix(LQuaternionf self, LMatrix4f m)\n"
  "extract_to_matrix(LQuaternionf self, LMatrix3f m)\n"
  "\n"
  "/**\n"
  " * Based on the quat lib from VRPN.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Based on the quat lib from VRPN.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_extract_to_matrix_1581_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LQuaternionf::set_from_matrix(LMatrix3f const &m)
 * inline void LQuaternionf::set_from_matrix(LMatrix4f const &m)
 */
static PyObject *Dtool_LQuaternionf_set_from_matrix_1582(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_from_matrix")) {
    return NULL;
  }
  {
    // -2 void LQuaternionf::set_from_matrix(LMatrix3f const &m)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LQuaternionf::set_from_matrix(LMatrix4f const &m)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaternionf::set_from_matrix(LMatrix3f const &m)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LQuaternionf::set_from_matrix(LMatrix4f const &m)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_matrix(const LQuaternionf self, const LMatrix3f m)\n"
      "set_from_matrix(const LQuaternionf self, const LMatrix4f m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_from_matrix_1582_comment =
  "C++ Interface:\n"
  "set_from_matrix(const LQuaternionf self, const LMatrix3f m)\n"
  "set_from_matrix(const LQuaternionf self, const LMatrix4f m)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the quaternion according to the rotation represented by the matrix.\n"
  " * Originally we tried an algorithm presented by Do-While Jones, but that\n"
  " * turned out to be broken.  This is based on the quat lib from UNC.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_from_matrix_1582_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LQuaternionf_set_hpr_1583(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_hpr")) {
    return NULL;
  }
  // 1-void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"hpr", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LQuaternionf.set_hpr", "LVecBase3f");
    }
    (*local_this).set_hpr(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const LQuaternionf self, const LVecBase3f hpr, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_hpr_1583_comment =
  "C++ Interface:\n"
  "set_hpr(const LQuaternionf self, const LVecBase3f hpr, int cs)\n"
  "\n"
  "/**\n"
  " * Sets the quaternion as the unit quaternion that is equivalent to these\n"
  " * Euler angles.  (from Real-time Rendering, p.49)\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_hpr_1583_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaternionf_get_hpr_1584(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_hpr", (char **)keyword_list, &param1)) {
    LVecBase3f *return_value = new LVecBase3f((*(const LQuaternionf*)local_this).get_hpr((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(LQuaternionf self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_hpr_1584_comment =
  "C++ Interface:\n"
  "get_hpr(LQuaternionf self, int cs)\n"
  "\n"
  "/**\n"
  " * Extracts the equivalent Euler angles from the unit quaternion.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_hpr_1584_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LQuaternionf::get_axis(void) const
 */
static PyObject *Dtool_LQuaternionf_get_axis_1585(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LQuaternionf::get_axis(void) const
  LVector3f *return_value = new LVector3f((*(const LQuaternionf*)local_this).get_axis());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_axis_1585_comment =
  "C++ Interface:\n"
  "get_axis(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * This, along with get_angle(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the axis; it\n"
  " * is not normalized.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_axis_1585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LQuaternionf::get_axis_normalized(void) const
 */
static PyObject *Dtool_LQuaternionf_get_axis_normalized_1586(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LQuaternionf::get_axis_normalized(void) const
  LVector3f *return_value = new LVector3f((*(const LQuaternionf*)local_this).get_axis_normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_axis_normalized_1586_comment =
  "C++ Interface:\n"
  "get_axis_normalized(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * This, along with get_angle(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the\n"
  " * normalized axis.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_axis_normalized_1586_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::get_angle_rad(void) const
 */
static PyObject *Dtool_LQuaternionf_get_angle_rad_1587(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::get_angle_rad(void) const
  float return_value = (*(const LQuaternionf*)local_this).get_angle_rad();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_angle_rad_1587_comment =
  "C++ Interface:\n"
  "get_angle_rad(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * This, along with get_axis(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the angle, in\n"
  " * radians counterclockwise about the axis.\n"
  " *\n"
  " * It is necessary to ensure the quaternion has been normalized (for instance,\n"
  " * with a call to normalize()) before calling this method.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_angle_rad_1587_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::get_angle(void) const
 */
static PyObject *Dtool_LQuaternionf_get_angle_1588(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::get_angle(void) const
  float return_value = (*(const LQuaternionf*)local_this).get_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_angle_1588_comment =
  "C++ Interface:\n"
  "get_angle(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * This, along with get_axis(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the angle, in\n"
  " * degrees counterclockwise about the axis.\n"
  " *\n"
  " * It is necessary to ensure the quaternion has been normalized (for instance,\n"
  " * with a call to normalize()) before calling this method.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_angle_1588_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis)
 */
static PyObject *Dtool_LQuaternionf_set_from_axis_angle_rad_1589(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_from_axis_angle_rad")) {
    return NULL;
  }
  // 1-inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"angle_rad", "axis", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_from_axis_angle_rad", (char **)keyword_list, &param1, &param2)) {
    LVector3f param2_local;
    LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LQuaternionf.set_from_axis_angle_rad", "LVector3f");
    }
    (*local_this).set_from_axis_angle_rad((float)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_axis_angle_rad(const LQuaternionf self, float angle_rad, const LVector3f axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_from_axis_angle_rad_1589_comment =
  "C++ Interface:\n"
  "set_from_axis_angle_rad(const LQuaternionf self, float angle_rad, const LVector3f axis)\n"
  "\n"
  "/**\n"
  " * angle_rad is the angle about the axis in radians.  axis must be normalized.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_from_axis_angle_rad_1589_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis)
 */
static PyObject *Dtool_LQuaternionf_set_from_axis_angle_1590(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_from_axis_angle")) {
    return NULL;
  }
  // 1-inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"angle_deg", "axis", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_from_axis_angle", (char **)keyword_list, &param1, &param2)) {
    LVector3f param2_local;
    LVector3f const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LQuaternionf.set_from_axis_angle", "LVector3f");
    }
    (*local_this).set_from_axis_angle((float)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_axis_angle(const LQuaternionf self, float angle_deg, const LVector3f axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_from_axis_angle_1590_comment =
  "C++ Interface:\n"
  "set_from_axis_angle(const LQuaternionf self, float angle_deg, const LVector3f axis)\n"
  "\n"
  "/**\n"
  " * angle_deg is the angle about the axis in degrees.  axis must be normalized.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_from_axis_angle_1590_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaternionf_get_up_1591(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_up", (char **)keyword_list, &param1)) {
    LVector3f *return_value = new LVector3f((*(const LQuaternionf*)local_this).get_up((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_up(LQuaternionf self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_up_1591_comment =
  "C++ Interface:\n"
  "get_up(LQuaternionf self, int cs)\n"
  "\n"
  "/**\n"
  " * Returns the orientation represented by this quaternion, expressed as an up\n"
  " * vector.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_up_1591_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaternionf_get_right_1592(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_right", (char **)keyword_list, &param1)) {
    LVector3f *return_value = new LVector3f((*(const LQuaternionf*)local_this).get_right((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_right(LQuaternionf self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_right_1592_comment =
  "C++ Interface:\n"
  "get_right(LQuaternionf self, int cs)\n"
  "\n"
  "/**\n"
  " * Returns the orientation represented by this quaternion, expressed as a\n"
  " * right vector.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_right_1592_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaternionf_get_forward_1593(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_forward", (char **)keyword_list, &param1)) {
    LVector3f *return_value = new LVector3f((*(const LQuaternionf*)local_this).get_forward((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_forward(LQuaternionf self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_forward_1593_comment =
  "C++ Interface:\n"
  "get_forward(LQuaternionf self, int cs)\n"
  "\n"
  "/**\n"
  " * Returns the orientation represented by this quaternion, expressed as a\n"
  " * forward vector.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_forward_1593_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::get_r(void) const
 */
static PyObject *Dtool_LQuaternionf_get_r_1594(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::get_r(void) const
  float return_value = (*(const LQuaternionf*)local_this).get_r();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_r_1594_comment =
  "C++ Interface:\n"
  "get_r(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_r_1594_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::get_i(void) const
 */
static PyObject *Dtool_LQuaternionf_get_i_1595(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::get_i(void) const
  float return_value = (*(const LQuaternionf*)local_this).get_i();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_i_1595_comment =
  "C++ Interface:\n"
  "get_i(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_i_1595_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::get_j(void) const
 */
static PyObject *Dtool_LQuaternionf_get_j_1596(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::get_j(void) const
  float return_value = (*(const LQuaternionf*)local_this).get_j();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_j_1596_comment =
  "C++ Interface:\n"
  "get_j(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_j_1596_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float LQuaternionf::get_k(void) const
 */
static PyObject *Dtool_LQuaternionf_get_k_1597(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LQuaternionf::get_k(void) const
  float return_value = (*(const LQuaternionf*)local_this).get_k();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_k_1597_comment =
  "C++ Interface:\n"
  "get_k(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_get_k_1597_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::set_r(float r)
 */
static PyObject *Dtool_LQuaternionf_set_r_1598(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_r")) {
    return NULL;
  }
  // 1-inline void LQuaternionf::set_r(float r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_r((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r(const LQuaternionf self, float r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_r_1598_comment =
  "C++ Interface:\n"
  "set_r(const LQuaternionf self, float r)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_r_1598_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::set_i(float i)
 */
static PyObject *Dtool_LQuaternionf_set_i_1599(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_i")) {
    return NULL;
  }
  // 1-inline void LQuaternionf::set_i(float i)
  if (PyNumber_Check(arg)) {
    (*local_this).set_i((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_i(const LQuaternionf self, float i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_i_1599_comment =
  "C++ Interface:\n"
  "set_i(const LQuaternionf self, float i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_i_1599_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::set_j(float j)
 */
static PyObject *Dtool_LQuaternionf_set_j_1600(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_j")) {
    return NULL;
  }
  // 1-inline void LQuaternionf::set_j(float j)
  if (PyNumber_Check(arg)) {
    (*local_this).set_j((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_j(const LQuaternionf self, float j)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_j_1600_comment =
  "C++ Interface:\n"
  "set_j(const LQuaternionf self, float j)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_j_1600_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaternionf::set_k(float k)
 */
static PyObject *Dtool_LQuaternionf_set_k_1601(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.set_k")) {
    return NULL;
  }
  // 1-inline void LQuaternionf::set_k(float k)
  if (PyNumber_Check(arg)) {
    (*local_this).set_k((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_k(const LQuaternionf self, float k)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_set_k_1601_comment =
  "C++ Interface:\n"
  "set_k(const LQuaternionf self, float k)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_set_k_1601_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::normalize(void)
 */
static PyObject *Dtool_LQuaternionf_normalize_1602(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.normalize")) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_normalize_1602_comment =
  "C++ Interface:\n"
  "normalize(const LQuaternionf self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaternionf_normalize_1602_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::conjugate_from(LQuaternionf const &other)
 */
static PyObject *Dtool_LQuaternionf_conjugate_from_1603(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.conjugate_from")) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::conjugate_from(LQuaternionf const &other)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.conjugate_from", "LQuaternionf");
  }
  bool return_value = (*local_this).conjugate_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "conjugate_from(const LQuaternionf self, const LQuaternionf other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_conjugate_from_1603_comment =
  "C++ Interface:\n"
  "conjugate_from(const LQuaternionf self, const LQuaternionf other)\n"
  "\n"
  "/**\n"
  " * Computes the conjugate of the other quat, and stores the result in this\n"
  " * quat.  This is a fully general operation and makes no assumptions about the\n"
  " * type of transform represented by the quat.\n"
  " *\n"
  " * The other quat must be a different object than this quat.  However, if you\n"
  " * need to get a conjugate of a quat in place, see conjugate_in_place.\n"
  " *\n"
  " * The return value is true if the quat was successfully inverted, false if\n"
  " * there was a singularity.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_conjugate_from_1603_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::conjugate_in_place(void)
 */
static PyObject *Dtool_LQuaternionf_conjugate_in_place_1604(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.conjugate_in_place")) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::conjugate_in_place(void)
  bool return_value = (*local_this).conjugate_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_conjugate_in_place_1604_comment =
  "C++ Interface:\n"
  "conjugate_in_place(const LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * Sets this to be the conjugate of the current quat.  Returns true if the\n"
  " * successful, false if the quat was singular.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_conjugate_in_place_1604_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::invert_from(LQuaternionf const &other)
 */
static PyObject *Dtool_LQuaternionf_invert_from_1605(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.invert_from")) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::invert_from(LQuaternionf const &other)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.invert_from", "LQuaternionf");
  }
  bool return_value = (*local_this).invert_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_from(const LQuaternionf self, const LQuaternionf other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_invert_from_1605_comment =
  "C++ Interface:\n"
  "invert_from(const LQuaternionf self, const LQuaternionf other)\n"
  "\n"
  "/**\n"
  " * Computes the inverse of the other quat, and stores the result in this quat.\n"
  " * This is a fully general operation and makes no assumptions about the type\n"
  " * of transform represented by the quat.\n"
  " *\n"
  " * The other quat must be a different object than this quat.  However, if you\n"
  " * need to invert a quat in place, see invert_in_place.\n"
  " *\n"
  " * The return value is true if the quat was successfully inverted, false if\n"
  " * there was a singularity.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_invert_from_1605_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::invert_in_place(void)
 */
static PyObject *Dtool_LQuaternionf_invert_in_place_1606(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaternionf, (void **)&local_this, "LQuaternionf.invert_in_place")) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::invert_in_place(void)
  bool return_value = (*local_this).invert_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_invert_in_place_1606_comment =
  "C++ Interface:\n"
  "invert_in_place(const LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * Inverts the current quat.  Returns true if the inverse is successful, false\n"
  " * if the quat was singular.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_invert_in_place_1606_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::is_identity(void) const
 */
static PyObject *Dtool_LQuaternionf_is_identity_1607(PyObject *self, PyObject *) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::is_identity(void) const
  bool return_value = (*(const LQuaternionf*)local_this).is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_is_identity_1607_comment =
  "C++ Interface:\n"
  "is_identity(LQuaternionf self)\n"
  "\n"
  "/**\n"
  " * Returns true if this quaternion represents the identity transformation: no\n"
  " * rotation.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_is_identity_1607_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaternionf::is_almost_identity(float tolerance) const
 */
static PyObject *Dtool_LQuaternionf_is_almost_identity_1608(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaternionf::is_almost_identity(float tolerance) const
  if (PyNumber_Check(arg)) {
    bool return_value = (*(const LQuaternionf*)local_this).is_almost_identity((float)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_almost_identity(LQuaternionf self, float tolerance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_is_almost_identity_1608_comment =
  "C++ Interface:\n"
  "is_almost_identity(LQuaternionf self, float tolerance)\n"
  "\n"
  "/**\n"
  " * Returns true if this quaternion represents the identity transformation\n"
  " * within a given tolerance.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_is_almost_identity_1608_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LQuaternionf const &LQuaternionf::ident_quat(void)
 */
static PyObject *Dtool_LQuaternionf_ident_quat_1609(PyObject *, PyObject *) {
  // 1-static inline LQuaternionf const &LQuaternionf::ident_quat(void)
  LQuaternionf const *return_value = &(LQuaternionf::ident_quat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_ident_quat_1609_comment =
  "C++ Interface:\n"
  "ident_quat()\n"
  "\n"
  "/**\n"
  " * Returns an identity quaternion.\n"
  " */";
#else
static const char *Dtool_LQuaternionf_ident_quat_1609_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LQuaternionf::get_class_type(void)
 */
static PyObject *Dtool_LQuaternionf_get_class_type_1610(PyObject *, PyObject *) {
  // 1-static TypeHandle LQuaternionf::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LQuaternionf::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaternionf_get_class_type_1610_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LQuaternionf_get_class_type_1610_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf::LQuaternionf(void)
 * inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default
 * inline LQuaternionf::LQuaternionf(LVecBase4f const &copy)
 * inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy)
 * inline LQuaternionf::LQuaternionf(float r, float i, float j, float k)
 */
static int Dtool_Init_LQuaternionf(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LQuaternionf::LQuaternionf(void)
      LQuaternionf *return_value = new LQuaternionf(LQuaternionf::ident_quat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaternionf", (char **)keyword_list, &param0)) {
          LQuaternionf const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LQuaternionf, (void **)&param0_this);
          if (param0_this != NULL) {
            LQuaternionf *return_value = new LQuaternionf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LQuaternionf::LQuaternionf(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaternionf", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LQuaternionf *return_value = new LQuaternionf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaternionf", (char **)keyword_list, &param0)) {
          LQuaternionf param0_local;
          LQuaternionf const *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          if ((param0_this != NULL)) {
            LQuaternionf *return_value = new LQuaternionf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LQuaternionf::LQuaternionf(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaternionf", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LQuaternionf *return_value = new LQuaternionf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy)
      float param0;
      PyObject *param1;
      static const char *keyword_list[] = {"r", "copy", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:LQuaternionf", (char **)keyword_list, &param0, &param1)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LQuaternionf.LQuaternionf", "LVecBase3f");
          return -1;
        }
        LQuaternionf *return_value = new LQuaternionf((float)param0, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LQuaternionf::LQuaternionf(float r, float i, float j, float k)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "i", "j", "k", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LQuaternionf", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LQuaternionf *return_value = new LQuaternionf((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaternionf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LQuaternionf() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LQuaternionf()\n"
      "LQuaternionf(const LQuaternionf param0)\n"
      "LQuaternionf(const LVecBase4f copy)\n"
      "LQuaternionf(float r, const LVecBase3f copy)\n"
      "LQuaternionf(float r, float i, float j, float k)\n");
  }
  return -1;
}

LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  LQuaternionf *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LQuaternionf, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LQuaternionf *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LQuaternionf::LQuaternionf(LVecBase4f const &copy)
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = LQuaternionf(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy)
        float param0;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "fO:LQuaternionf", &param0, &param1)) {
          LVecBase3f const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3f, (void **)&param1_this);
          if (param1_this != NULL) {
            coerced = LQuaternionf((float)param0, *param1_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LQuaternionf::LQuaternionf(float r, float i, float j, float k)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LQuaternionf", &param0, &param1, &param2, &param3)) {
          coerced = LQuaternionf((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LQuaternionf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LQuaternionf) {
    printf("LQuaternionf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LQuaternionf *local_this = (LQuaternionf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LQuaternionf) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LQuaternionf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LQuaternionf) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LQuaternionf*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LQuaterniond
 */
/**
 * Python function wrapper for:
 * static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v)
 */
static PyObject *Dtool_LQuaterniond_pure_imaginary_1614(PyObject *, PyObject *arg) {
  // 1-static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v)
  LVector3d arg_local;
  LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "LQuaterniond.pure_imaginary", "LVector3d");
  }
  LQuaterniond *return_value = new LQuaterniond(LQuaterniond::pure_imaginary(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pure_imaginary(const LVector3d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_pure_imaginary_1614_comment =
  "C++ Interface:\n"
  "pure_imaginary(const LVector3d v)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_pure_imaginary_1614_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaterniond LQuaterniond::conjugate(void) const
 */
static PyObject *Dtool_LQuaterniond_conjugate_1615(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LQuaterniond LQuaterniond::conjugate(void) const
  LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).conjugate());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_conjugate_1615_comment =
  "C++ Interface:\n"
  "conjugate(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * Returns the complex conjugate of this quat.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_conjugate_1615_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const
 * inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const
 */
static PyObject *Dtool_LQuaterniond_xform_1616(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d((*(const LQuaterniond*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4d *return_value = new LVecBase4d((*(const LQuaterniond*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d((*(const LQuaterniond*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4d *return_value = new LVecBase4d((*(const LQuaterniond*)local_this).xform(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(LQuaterniond self, const LVecBase3d v)\n"
      "xform(LQuaterniond self, const LVecBase4d v)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_xform_1616_comment =
  "C++ Interface:\n"
  "xform(LQuaterniond self, const LVecBase3d v)\n"
  "xform(LQuaterniond self, const LVecBase4d v)\n"
  "\n"
  "/**\n"
  " * Transforms a 3-d vector by the indicated rotation\n"
  " */\n"
  "\n"
  "/**\n"
  " * Transforms a 4-d vector by the indicated rotation\n"
  " */";
#else
static const char *Dtool_LQuaterniond_xform_1616_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const
 */
static PyObject *Dtool_LQuaterniond_multiply_1617(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.multiply", "LQuaterniond");
  }
  LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).multiply(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "multiply(LQuaterniond self, const LQuaterniond rhs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_multiply_1617_comment =
  "C++ Interface:\n"
  "multiply(LQuaterniond self, const LQuaterniond rhs)\n"
  "\n"
  "/**\n"
  " * actual multiply call (non virtual)\n"
  " */";
#else
static const char *Dtool_LQuaterniond_multiply_1617_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::angle_rad(LQuaterniond const &other) const
 */
static PyObject *Dtool_LQuaterniond_angle_rad_1621(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::angle_rad(LQuaterniond const &other) const
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.angle_rad", "LQuaterniond");
  }
  double return_value = (*(const LQuaterniond*)local_this).angle_rad(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_rad(LQuaterniond self, const LQuaterniond other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_angle_rad_1621_comment =
  "C++ Interface:\n"
  "angle_rad(LQuaterniond self, const LQuaterniond other)\n"
  "\n"
  "/**\n"
  " * Returns the angle between the orientation represented by this quaternion\n"
  " * and the other one, expressed in radians.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_angle_rad_1621_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::angle_deg(LQuaterniond const &other) const
 */
static PyObject *Dtool_LQuaterniond_angle_deg_1622(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::angle_deg(LQuaterniond const &other) const
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.angle_deg", "LQuaterniond");
  }
  double return_value = (*(const LQuaterniond*)local_this).angle_deg(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "angle_deg(LQuaterniond self, const LQuaterniond other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_angle_deg_1622_comment =
  "C++ Interface:\n"
  "angle_deg(LQuaterniond self, const LQuaterniond other)\n"
  "\n"
  "/**\n"
  " * Returns the angle between the orientation represented by this quaternion\n"
  " * and the other one, expressed in degrees.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_angle_deg_1622_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const
 * inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const
 */
static PyObject *Dtool_LQuaterniond_almost_equal_1626(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "other");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'other' (pos 1) not found");
      }
      // 1-inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const
      LQuaterniond arg_local;
      LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.almost_equal", "LQuaterniond");
      }
      bool return_value = (*(const LQuaterniond*)local_this).almost_equal(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const
      PyObject *param1;
      double param2;
      static const char *keyword_list[] = {"other", "threshold", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_equal", (char **)keyword_list, &param1, &param2)) {
        LQuaterniond param1_local;
        LQuaterniond const *param1_this = Dtool_Coerce_LQuaterniond(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LQuaterniond.almost_equal", "LQuaterniond");
        }
        bool return_value = (*(const LQuaterniond*)local_this).almost_equal(*param1_this, (double)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "almost_equal() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_equal(LQuaterniond self, const LQuaterniond other)\n"
      "almost_equal(LQuaterniond self, const LQuaterniond other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_almost_equal_1626_comment =
  "C++ Interface:\n"
  "almost_equal(LQuaterniond self, const LQuaterniond other)\n"
  "almost_equal(LQuaterniond self, const LQuaterniond other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions are memberwise equal within a default\n"
  " * tolerance based on the numeric type.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions are memberwise equal within a specified\n"
  " * tolerance.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_almost_equal_1626_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const
 */
static PyObject *Dtool_LQuaterniond_is_same_direction_1627(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.is_same_direction", "LQuaterniond");
  }
  bool return_value = (*(const LQuaterniond*)local_this).is_same_direction(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_same_direction(LQuaterniond self, const LQuaterniond other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_is_same_direction_1627_comment =
  "C++ Interface:\n"
  "is_same_direction(LQuaterniond self, const LQuaterniond other)\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions represent the same rotation within a\n"
  " * default tolerance based on the numeric type.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_is_same_direction_1627_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const
 */
static PyObject *Dtool_LQuaterniond_almost_same_direction_1628(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const
  PyObject *param1;
  double param2;
  static const char *keyword_list[] = {"other", "threshold", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:almost_same_direction", (char **)keyword_list, &param1, &param2)) {
    LQuaterniond param1_local;
    LQuaterniond const *param1_this = Dtool_Coerce_LQuaterniond(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LQuaterniond.almost_same_direction", "LQuaterniond");
    }
    bool return_value = (*(const LQuaterniond*)local_this).almost_same_direction(*param1_this, (double)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "almost_same_direction(LQuaterniond self, const LQuaterniond other, double threshold)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_almost_same_direction_1628_comment =
  "C++ Interface:\n"
  "almost_same_direction(LQuaterniond self, const LQuaterniond other, double threshold)\n"
  "\n"
  "/**\n"
  " * Returns true if two quaternions represent the same rotation within a\n"
  " * specified tolerance.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_almost_same_direction_1628_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::output(ostream &) const
 */
static PyObject *Dtool_LQuaterniond_output_1629(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void LQuaterniond::output(ostream &) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "LQuaterniond.output", false, true);
  if (arg_this != NULL) {
    (*(const LQuaterniond*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LQuaterniond self, ostream param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_output_1629_comment =
  "C++ Interface:\n"
  "output(LQuaterniond self, ostream param0)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_output_1629_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LQuaterniond::extract_to_matrix(LMatrix3d &m) const
 * void LQuaterniond::extract_to_matrix(LMatrix4d &m) const
 */
static PyObject *Dtool_LQuaterniond_extract_to_matrix_1630(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 void LQuaterniond::extract_to_matrix(LMatrix3d &m) const
    LMatrix3d *arg_this = (LMatrix3d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix3d, 1, "LQuaterniond.extract_to_matrix", false, false);
    if (arg_this != NULL) {
      (*(const LQuaterniond*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaterniond::extract_to_matrix(LMatrix4d &m) const
    LMatrix4d *arg_this = (LMatrix4d *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LMatrix4d, 1, "LQuaterniond.extract_to_matrix", false, false);
    if (arg_this != NULL) {
      (*(const LQuaterniond*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaterniond::extract_to_matrix(LMatrix3d &m) const
    LMatrix3d arg_local;
    LMatrix3d *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LQuaterniond*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaterniond::extract_to_matrix(LMatrix4d &m) const
    LMatrix4d arg_local;
    LMatrix4d *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*(const LQuaterniond*)local_this).extract_to_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_to_matrix(LQuaterniond self, LMatrix3d m)\n"
      "extract_to_matrix(LQuaterniond self, LMatrix4d m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_extract_to_matrix_1630_comment =
  "C++ Interface:\n"
  "extract_to_matrix(LQuaterniond self, LMatrix3d m)\n"
  "extract_to_matrix(LQuaterniond self, LMatrix4d m)\n"
  "\n"
  "/**\n"
  " * Based on the quat lib from VRPN.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Based on the quat lib from VRPN.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_extract_to_matrix_1630_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LQuaterniond::set_from_matrix(LMatrix3d const &m)
 * inline void LQuaterniond::set_from_matrix(LMatrix4d const &m)
 */
static PyObject *Dtool_LQuaterniond_set_from_matrix_1631(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_from_matrix")) {
    return NULL;
  }
  {
    // -2 void LQuaterniond::set_from_matrix(LMatrix3d const &m)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LQuaterniond::set_from_matrix(LMatrix4d const &m)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void LQuaterniond::set_from_matrix(LMatrix3d const &m)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void LQuaterniond::set_from_matrix(LMatrix4d const &m)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).set_from_matrix(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_matrix(const LQuaterniond self, const LMatrix3d m)\n"
      "set_from_matrix(const LQuaterniond self, const LMatrix4d m)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_from_matrix_1631_comment =
  "C++ Interface:\n"
  "set_from_matrix(const LQuaterniond self, const LMatrix3d m)\n"
  "set_from_matrix(const LQuaterniond self, const LMatrix4d m)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets the quaternion according to the rotation represented by the matrix.\n"
  " * Originally we tried an algorithm presented by Do-While Jones, but that\n"
  " * turned out to be broken.  This is based on the quat lib from UNC.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_from_matrix_1631_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default)
 */
static PyObject *Dtool_LQuaterniond_set_hpr_1632(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_hpr")) {
    return NULL;
  }
  // 1-void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default)
  PyObject *param1;
  int param2 = ::CS_default;
  static const char *keyword_list[] = {"hpr", "cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:set_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3d param1_local;
    LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "LQuaterniond.set_hpr", "LVecBase3d");
    }
    (*local_this).set_hpr(*param1_this, (CoordinateSystem)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const LQuaterniond self, const LVecBase3d hpr, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_hpr_1632_comment =
  "C++ Interface:\n"
  "set_hpr(const LQuaterniond self, const LVecBase3d hpr, int cs)\n"
  "\n"
  "/**\n"
  " * Sets the quaternion as the unit quaternion that is equivalent to these\n"
  " * Euler angles.  (from Real-time Rendering, p.49)\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_hpr_1632_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaterniond_get_hpr_1633(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_hpr", (char **)keyword_list, &param1)) {
    LVecBase3d *return_value = new LVecBase3d((*(const LQuaterniond*)local_this).get_hpr((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(LQuaterniond self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_hpr_1633_comment =
  "C++ Interface:\n"
  "get_hpr(LQuaterniond self, int cs)\n"
  "\n"
  "/**\n"
  " * Extracts the equivalent Euler angles from the unit quaternion.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_hpr_1633_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LQuaterniond::get_axis(void) const
 */
static PyObject *Dtool_LQuaterniond_get_axis_1634(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LQuaterniond::get_axis(void) const
  LVector3d *return_value = new LVector3d((*(const LQuaterniond*)local_this).get_axis());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_axis_1634_comment =
  "C++ Interface:\n"
  "get_axis(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * This, along with get_angle(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the axis; it\n"
  " * is not normalized.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_axis_1634_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LQuaterniond::get_axis_normalized(void) const
 */
static PyObject *Dtool_LQuaterniond_get_axis_normalized_1635(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LQuaterniond::get_axis_normalized(void) const
  LVector3d *return_value = new LVector3d((*(const LQuaterniond*)local_this).get_axis_normalized());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_axis_normalized_1635_comment =
  "C++ Interface:\n"
  "get_axis_normalized(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * This, along with get_angle(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the\n"
  " * normalized axis.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_axis_normalized_1635_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::get_angle_rad(void) const
 */
static PyObject *Dtool_LQuaterniond_get_angle_rad_1636(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::get_angle_rad(void) const
  double return_value = (*(const LQuaterniond*)local_this).get_angle_rad();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_angle_rad_1636_comment =
  "C++ Interface:\n"
  "get_angle_rad(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * This, along with get_axis(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the angle, in\n"
  " * radians counterclockwise about the axis.\n"
  " *\n"
  " * It is necessary to ensure the quaternion has been normalized (for instance,\n"
  " * with a call to normalize()) before calling this method.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_angle_rad_1636_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::get_angle(void) const
 */
static PyObject *Dtool_LQuaterniond_get_angle_1637(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::get_angle(void) const
  double return_value = (*(const LQuaterniond*)local_this).get_angle();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_angle_1637_comment =
  "C++ Interface:\n"
  "get_angle(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * This, along with get_axis(), returns the rotation represented by the\n"
  " * quaternion as an angle about an arbitrary axis.  This returns the angle, in\n"
  " * degrees counterclockwise about the axis.\n"
  " *\n"
  " * It is necessary to ensure the quaternion has been normalized (for instance,\n"
  " * with a call to normalize()) before calling this method.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_angle_1637_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis)
 */
static PyObject *Dtool_LQuaterniond_set_from_axis_angle_rad_1638(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_from_axis_angle_rad")) {
    return NULL;
  }
  // 1-inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis)
  double param1;
  PyObject *param2;
  static const char *keyword_list[] = {"angle_rad", "axis", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:set_from_axis_angle_rad", (char **)keyword_list, &param1, &param2)) {
    LVector3d param2_local;
    LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LQuaterniond.set_from_axis_angle_rad", "LVector3d");
    }
    (*local_this).set_from_axis_angle_rad((double)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_axis_angle_rad(const LQuaterniond self, double angle_rad, const LVector3d axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_from_axis_angle_rad_1638_comment =
  "C++ Interface:\n"
  "set_from_axis_angle_rad(const LQuaterniond self, double angle_rad, const LVector3d axis)\n"
  "\n"
  "/**\n"
  " * angle_rad is the angle about the axis in radians.  axis must be normalized.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_from_axis_angle_rad_1638_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis)
 */
static PyObject *Dtool_LQuaterniond_set_from_axis_angle_1639(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_from_axis_angle")) {
    return NULL;
  }
  // 1-inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis)
  double param1;
  PyObject *param2;
  static const char *keyword_list[] = {"angle_deg", "axis", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:set_from_axis_angle", (char **)keyword_list, &param1, &param2)) {
    LVector3d param2_local;
    LVector3d const *param2_this = Dtool_Coerce_LVector3d(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LQuaterniond.set_from_axis_angle", "LVector3d");
    }
    (*local_this).set_from_axis_angle((double)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_axis_angle(const LQuaterniond self, double angle_deg, const LVector3d axis)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_from_axis_angle_1639_comment =
  "C++ Interface:\n"
  "set_from_axis_angle(const LQuaterniond self, double angle_deg, const LVector3d axis)\n"
  "\n"
  "/**\n"
  " * angle_deg is the angle about the axis in degrees.  axis must be normalized.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_from_axis_angle_1639_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaterniond_get_up_1640(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_up", (char **)keyword_list, &param1)) {
    LVector3d *return_value = new LVector3d((*(const LQuaterniond*)local_this).get_up((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_up(LQuaterniond self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_up_1640_comment =
  "C++ Interface:\n"
  "get_up(LQuaterniond self, int cs)\n"
  "\n"
  "/**\n"
  " * Returns the orientation represented by this quaternion, expressed as an up\n"
  " * vector.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_up_1640_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaterniond_get_right_1641(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_right", (char **)keyword_list, &param1)) {
    LVector3d *return_value = new LVector3d((*(const LQuaterniond*)local_this).get_right((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_right(LQuaterniond self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_right_1641_comment =
  "C++ Interface:\n"
  "get_right(LQuaterniond self, int cs)\n"
  "\n"
  "/**\n"
  " * Returns the orientation represented by this quaternion, expressed as a\n"
  " * right vector.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_right_1641_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const
 */
static PyObject *Dtool_LQuaterniond_get_forward_1642(PyObject *self, PyObject *args, PyObject *kwds) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const
  int param1 = ::CS_default;
  static const char *keyword_list[] = {"cs", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_forward", (char **)keyword_list, &param1)) {
    LVector3d *return_value = new LVector3d((*(const LQuaterniond*)local_this).get_forward((CoordinateSystem)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_forward(LQuaterniond self, int cs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_forward_1642_comment =
  "C++ Interface:\n"
  "get_forward(LQuaterniond self, int cs)\n"
  "\n"
  "/**\n"
  " * Returns the orientation represented by this quaternion, expressed as a\n"
  " * forward vector.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_forward_1642_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::get_r(void) const
 */
static PyObject *Dtool_LQuaterniond_get_r_1643(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::get_r(void) const
  double return_value = (*(const LQuaterniond*)local_this).get_r();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_r_1643_comment =
  "C++ Interface:\n"
  "get_r(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_r_1643_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::get_i(void) const
 */
static PyObject *Dtool_LQuaterniond_get_i_1644(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::get_i(void) const
  double return_value = (*(const LQuaterniond*)local_this).get_i();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_i_1644_comment =
  "C++ Interface:\n"
  "get_i(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_i_1644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::get_j(void) const
 */
static PyObject *Dtool_LQuaterniond_get_j_1645(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::get_j(void) const
  double return_value = (*(const LQuaterniond*)local_this).get_j();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_j_1645_comment =
  "C++ Interface:\n"
  "get_j(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_j_1645_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double LQuaterniond::get_k(void) const
 */
static PyObject *Dtool_LQuaterniond_get_k_1646(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LQuaterniond::get_k(void) const
  double return_value = (*(const LQuaterniond*)local_this).get_k();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_k_1646_comment =
  "C++ Interface:\n"
  "get_k(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_get_k_1646_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::set_r(double r)
 */
static PyObject *Dtool_LQuaterniond_set_r_1647(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_r")) {
    return NULL;
  }
  // 1-inline void LQuaterniond::set_r(double r)
  if (PyNumber_Check(arg)) {
    (*local_this).set_r(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_r(const LQuaterniond self, double r)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_r_1647_comment =
  "C++ Interface:\n"
  "set_r(const LQuaterniond self, double r)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_r_1647_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::set_i(double i)
 */
static PyObject *Dtool_LQuaterniond_set_i_1648(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_i")) {
    return NULL;
  }
  // 1-inline void LQuaterniond::set_i(double i)
  if (PyNumber_Check(arg)) {
    (*local_this).set_i(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_i(const LQuaterniond self, double i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_i_1648_comment =
  "C++ Interface:\n"
  "set_i(const LQuaterniond self, double i)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_i_1648_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::set_j(double j)
 */
static PyObject *Dtool_LQuaterniond_set_j_1649(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_j")) {
    return NULL;
  }
  // 1-inline void LQuaterniond::set_j(double j)
  if (PyNumber_Check(arg)) {
    (*local_this).set_j(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_j(const LQuaterniond self, double j)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_j_1649_comment =
  "C++ Interface:\n"
  "set_j(const LQuaterniond self, double j)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_j_1649_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void LQuaterniond::set_k(double k)
 */
static PyObject *Dtool_LQuaterniond_set_k_1650(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.set_k")) {
    return NULL;
  }
  // 1-inline void LQuaterniond::set_k(double k)
  if (PyNumber_Check(arg)) {
    (*local_this).set_k(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_k(const LQuaterniond self, double k)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_set_k_1650_comment =
  "C++ Interface:\n"
  "set_k(const LQuaterniond self, double k)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_set_k_1650_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::normalize(void)
 */
static PyObject *Dtool_LQuaterniond_normalize_1651(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.normalize")) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::normalize(void)
  bool return_value = (*local_this).normalize();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_normalize_1651_comment =
  "C++ Interface:\n"
  "normalize(const LQuaterniond self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LQuaterniond_normalize_1651_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::conjugate_from(LQuaterniond const &other)
 */
static PyObject *Dtool_LQuaterniond_conjugate_from_1652(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.conjugate_from")) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::conjugate_from(LQuaterniond const &other)
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.conjugate_from", "LQuaterniond");
  }
  bool return_value = (*local_this).conjugate_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "conjugate_from(const LQuaterniond self, const LQuaterniond other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_conjugate_from_1652_comment =
  "C++ Interface:\n"
  "conjugate_from(const LQuaterniond self, const LQuaterniond other)\n"
  "\n"
  "/**\n"
  " * Computes the conjugate of the other quat, and stores the result in this\n"
  " * quat.  This is a fully general operation and makes no assumptions about the\n"
  " * type of transform represented by the quat.\n"
  " *\n"
  " * The other quat must be a different object than this quat.  However, if you\n"
  " * need to get a conjugate of a quat in place, see conjugate_in_place.\n"
  " *\n"
  " * The return value is true if the quat was successfully inverted, false if\n"
  " * there was a singularity.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_conjugate_from_1652_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::conjugate_in_place(void)
 */
static PyObject *Dtool_LQuaterniond_conjugate_in_place_1653(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.conjugate_in_place")) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::conjugate_in_place(void)
  bool return_value = (*local_this).conjugate_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_conjugate_in_place_1653_comment =
  "C++ Interface:\n"
  "conjugate_in_place(const LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * Sets this to be the conjugate of the current quat.  Returns true if the\n"
  " * successful, false if the quat was singular.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_conjugate_in_place_1653_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::invert_from(LQuaterniond const &other)
 */
static PyObject *Dtool_LQuaterniond_invert_from_1654(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.invert_from")) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::invert_from(LQuaterniond const &other)
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.invert_from", "LQuaterniond");
  }
  bool return_value = (*local_this).invert_from(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "invert_from(const LQuaterniond self, const LQuaterniond other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_invert_from_1654_comment =
  "C++ Interface:\n"
  "invert_from(const LQuaterniond self, const LQuaterniond other)\n"
  "\n"
  "/**\n"
  " * Computes the inverse of the other quat, and stores the result in this quat.\n"
  " * This is a fully general operation and makes no assumptions about the type\n"
  " * of transform represented by the quat.\n"
  " *\n"
  " * The other quat must be a different object than this quat.  However, if you\n"
  " * need to invert a quat in place, see invert_in_place.\n"
  " *\n"
  " * The return value is true if the quat was successfully inverted, false if\n"
  " * there was a singularity.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_invert_from_1654_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::invert_in_place(void)
 */
static PyObject *Dtool_LQuaterniond_invert_in_place_1655(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LQuaterniond, (void **)&local_this, "LQuaterniond.invert_in_place")) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::invert_in_place(void)
  bool return_value = (*local_this).invert_in_place();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_invert_in_place_1655_comment =
  "C++ Interface:\n"
  "invert_in_place(const LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * Inverts the current quat.  Returns true if the inverse is successful, false\n"
  " * if the quat was singular.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_invert_in_place_1655_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::is_identity(void) const
 */
static PyObject *Dtool_LQuaterniond_is_identity_1656(PyObject *self, PyObject *) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::is_identity(void) const
  bool return_value = (*(const LQuaterniond*)local_this).is_identity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_is_identity_1656_comment =
  "C++ Interface:\n"
  "is_identity(LQuaterniond self)\n"
  "\n"
  "/**\n"
  " * Returns true if this quaternion represents the identity transformation: no\n"
  " * rotation.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_is_identity_1656_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LQuaterniond::is_almost_identity(double tolerance) const
 */
static PyObject *Dtool_LQuaterniond_is_almost_identity_1657(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LQuaterniond::is_almost_identity(double tolerance) const
  if (PyNumber_Check(arg)) {
    bool return_value = (*(const LQuaterniond*)local_this).is_almost_identity(PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_almost_identity(LQuaterniond self, double tolerance)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_is_almost_identity_1657_comment =
  "C++ Interface:\n"
  "is_almost_identity(LQuaterniond self, double tolerance)\n"
  "\n"
  "/**\n"
  " * Returns true if this quaternion represents the identity transformation\n"
  " * within a given tolerance.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_is_almost_identity_1657_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline LQuaterniond const &LQuaterniond::ident_quat(void)
 */
static PyObject *Dtool_LQuaterniond_ident_quat_1658(PyObject *, PyObject *) {
  // 1-static inline LQuaterniond const &LQuaterniond::ident_quat(void)
  LQuaterniond const *return_value = &(LQuaterniond::ident_quat());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_ident_quat_1658_comment =
  "C++ Interface:\n"
  "ident_quat()\n"
  "\n"
  "/**\n"
  " * Returns an identity quaternion.\n"
  " */";
#else
static const char *Dtool_LQuaterniond_ident_quat_1658_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LQuaterniond::get_class_type(void)
 */
static PyObject *Dtool_LQuaterniond_get_class_type_1659(PyObject *, PyObject *) {
  // 1-static TypeHandle LQuaterniond::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LQuaterniond::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LQuaterniond_get_class_type_1659_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LQuaterniond_get_class_type_1659_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LQuaterniond::LQuaterniond(void)
 * inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default
 * inline LQuaterniond::LQuaterniond(LVecBase4d const &copy)
 * inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy)
 * inline LQuaterniond::LQuaterniond(double r, double i, double j, double k)
 */
static int Dtool_Init_LQuaterniond(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LQuaterniond::LQuaterniond(void)
      LQuaterniond *return_value = new LQuaterniond(LQuaterniond::ident_quat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaterniond", (char **)keyword_list, &param0)) {
          LQuaterniond const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LQuaterniond, (void **)&param0_this);
          if (param0_this != NULL) {
            LQuaterniond *return_value = new LQuaterniond(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LQuaterniond::LQuaterniond(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaterniond", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LQuaterniond *return_value = new LQuaterniond(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaterniond", (char **)keyword_list, &param0)) {
          LQuaterniond param0_local;
          LQuaterniond const *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          if ((param0_this != NULL)) {
            LQuaterniond *return_value = new LQuaterniond(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LQuaterniond::LQuaterniond(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LQuaterniond", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LQuaterniond *return_value = new LQuaterniond(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy)
      double param0;
      PyObject *param1;
      static const char *keyword_list[] = {"r", "copy", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dO:LQuaterniond", (char **)keyword_list, &param0, &param1)) {
        LVecBase3d param1_local;
        LVecBase3d const *param1_this = Dtool_Coerce_LVecBase3d(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "LQuaterniond.LQuaterniond", "LVecBase3d");
          return -1;
        }
        LQuaterniond *return_value = new LQuaterniond((double)param0, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LQuaterniond::LQuaterniond(double r, double i, double j, double k)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"r", "i", "j", "k", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LQuaterniond", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LQuaterniond *return_value = new LQuaterniond((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LQuaterniond, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LQuaterniond() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LQuaterniond()\n"
      "LQuaterniond(const LQuaterniond param0)\n"
      "LQuaterniond(const LVecBase4d copy)\n"
      "LQuaterniond(double r, const LVecBase3d copy)\n"
      "LQuaterniond(double r, double i, double j, double k)\n");
  }
  return -1;
}

LQuaterniond *Dtool_Coerce_LQuaterniond(PyObject *args, LQuaterniond &coerced) {
  LQuaterniond *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LQuaterniond, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LQuaterniond *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline LQuaterniond::LQuaterniond(LVecBase4d const &copy)
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = LQuaterniond(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy)
        double param0;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "dO:LQuaterniond", &param0, &param1)) {
          LVecBase3d const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase3d, (void **)&param1_this);
          if (param1_this != NULL) {
            coerced = LQuaterniond((double)param0, *param1_this);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LQuaterniond::LQuaterniond(double r, double i, double j, double k)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LQuaterniond", &param0, &param1, &param2, &param3)) {
          coerced = LQuaterniond((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LQuaterniond(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LQuaterniond) {
    printf("LQuaterniond ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LQuaterniond *local_this = (LQuaterniond *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LQuaterniond) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LQuaterniond(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LQuaterniond) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LQuaterniond*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LRotationf
 */
/**
 * Python function wrapper for:
 * static TypeHandle LRotationf::get_class_type(void)
 */
static PyObject *Dtool_LRotationf_get_class_type_1665(PyObject *, PyObject *) {
  // 1-static TypeHandle LRotationf::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LRotationf::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LRotationf_get_class_type_1665_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LRotationf_get_class_type_1665_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LRotationf::LRotationf(void)
 * inline LRotationf::LRotationf(LMatrix3f const &m)
 * inline LRotationf::LRotationf(LMatrix4f const &m)
 * inline LRotationf::LRotationf(LQuaternionf const &c)
 * inline LRotationf::LRotationf(LRotationf const &) = default
 * inline LRotationf::LRotationf(LVecBase4f const &copy)
 * inline LRotationf::LRotationf(LVector3f const &axis, float angle)
 * inline LRotationf::LRotationf(float h, float p, float r)
 * inline LRotationf::LRotationf(float r, float i, float j, float k)
 */
static int Dtool_Init_LRotationf(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LRotationf::LRotationf(void)
      LRotationf *return_value = new LRotationf(LQuaternionf::ident_quat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LRotationf::LRotationf(LRotationf const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LRotationf const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LRotationf, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LQuaternionf const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LQuaternionf const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LQuaternionf, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LMatrix3f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LMatrix4f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LVecBase4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LRotationf const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LRotationf param0_local;
          LRotationf const *param0_this = Dtool_Coerce_LRotationf(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LQuaternionf const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LQuaternionf param0_local;
          LQuaternionf const *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LMatrix3f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LMatrix4f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationf::LRotationf(LVecBase4f const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationf", (char **)keyword_list, &param0)) {
          LVecBase4f param0_local;
          LVecBase4f const *param0_this = Dtool_Coerce_LVecBase4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationf *return_value = new LRotationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LRotationf::LRotationf(LVector3f const &axis, float angle)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"axis", "angle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LRotationf", (char **)keyword_list, &param0, &param1)) {
        LVector3f param0_local;
        LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LRotationf.LRotationf", "LVector3f");
          return -1;
        }
        LRotationf *return_value = new LRotationf(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LRotationf::LRotationf(float h, float p, float r)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"h", "p", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:LRotationf", (char **)keyword_list, &param0, &param1, &param2)) {
        LRotationf *return_value = new LRotationf((float)param0, (float)param1, (float)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LRotationf::LRotationf(float r, float i, float j, float k)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "i", "j", "k", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LRotationf", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LRotationf *return_value = new LRotationf((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LRotationf() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LRotationf()\n"
      "LRotationf(const LRotationf param0)\n"
      "LRotationf(const LQuaternionf c)\n"
      "LRotationf(const LMatrix3f m)\n"
      "LRotationf(const LMatrix4f m)\n"
      "LRotationf(const LVecBase4f copy)\n"
      "LRotationf(const LVector3f axis, float angle)\n"
      "LRotationf(float h, float p, float r)\n"
      "LRotationf(float r, float i, float j, float k)\n");
  }
  return -1;
}

LRotationf *Dtool_Coerce_LRotationf(PyObject *args, LRotationf &coerced) {
  LRotationf *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LRotationf, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LRotationf *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LRotationf::LRotationf(LQuaternionf const &c)
      LQuaternionf const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LRotationf::LRotationf(LMatrix3f const &m)
      LMatrix3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LRotationf::LRotationf(LMatrix4f const &m)
      LMatrix4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LRotationf::LRotationf(LVecBase4f const &copy)
      LVecBase4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LRotationf::LRotationf(LVector3f const &axis, float angle)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LRotationf", &param0, &param1)) {
          LVector3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LRotationf(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LRotationf::LRotationf(float h, float p, float r)
        float param0;
        float param1;
        float param2;
        if (PyArg_ParseTuple(args, "fff:LRotationf", &param0, &param1, &param2)) {
          coerced = LRotationf((float)param0, (float)param1, (float)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LRotationf::LRotationf(float r, float i, float j, float k)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LRotationf", &param0, &param1, &param2, &param3)) {
          coerced = LRotationf((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LRotationf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LRotationf) {
    printf("LRotationf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LRotationf *local_this = (LRotationf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LRotationf) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LQuaternionf) {
    return (LQuaternionf *) local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *)(LQuaternionf *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LRotationf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LRotationf) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LQuaternionf) {
    LQuaternionf* other_this = (LQuaternionf*)from_this;
    return (LRotationf*)other_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LRotationf*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LRotationd
 */
/**
 * Python function wrapper for:
 * static TypeHandle LRotationd::get_class_type(void)
 */
static PyObject *Dtool_LRotationd_get_class_type_1671(PyObject *, PyObject *) {
  // 1-static TypeHandle LRotationd::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LRotationd::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LRotationd_get_class_type_1671_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LRotationd_get_class_type_1671_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LRotationd::LRotationd(void)
 * inline LRotationd::LRotationd(LMatrix3d const &m)
 * inline LRotationd::LRotationd(LMatrix4d const &m)
 * inline LRotationd::LRotationd(LQuaterniond const &c)
 * inline LRotationd::LRotationd(LRotationd const &) = default
 * inline LRotationd::LRotationd(LVecBase4d const &copy)
 * inline LRotationd::LRotationd(LVector3d const &axis, double angle)
 * inline LRotationd::LRotationd(double h, double p, double r)
 * inline LRotationd::LRotationd(double r, double i, double j, double k)
 */
static int Dtool_Init_LRotationd(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LRotationd::LRotationd(void)
      LRotationd *return_value = new LRotationd(LQuaterniond::ident_quat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LRotationd::LRotationd(LRotationd const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LRotationd const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LRotationd, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LQuaterniond const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LQuaterniond const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LQuaterniond, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LMatrix4d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LMatrix3d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LVecBase4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVecBase4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LRotationd const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LRotationd param0_local;
          LRotationd const *param0_this = Dtool_Coerce_LRotationd(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LQuaterniond const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LQuaterniond param0_local;
          LQuaterniond const *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LMatrix4d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LMatrix3d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LRotationd::LRotationd(LVecBase4d const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LRotationd", (char **)keyword_list, &param0)) {
          LVecBase4d param0_local;
          LVecBase4d const *param0_this = Dtool_Coerce_LVecBase4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LRotationd *return_value = new LRotationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LRotationd::LRotationd(LVector3d const &axis, double angle)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"axis", "angle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LRotationd", (char **)keyword_list, &param0, &param1)) {
        LVector3d param0_local;
        LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LRotationd.LRotationd", "LVector3d");
          return -1;
        }
        LRotationd *return_value = new LRotationd(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LRotationd::LRotationd(double h, double p, double r)
      double param0;
      double param1;
      double param2;
      static const char *keyword_list[] = {"h", "p", "r", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ddd:LRotationd", (char **)keyword_list, &param0, &param1, &param2)) {
        LRotationd *return_value = new LRotationd((double)param0, (double)param1, (double)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LRotationd::LRotationd(double r, double i, double j, double k)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"r", "i", "j", "k", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LRotationd", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LRotationd *return_value = new LRotationd((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LRotationd, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LRotationd() takes 0, 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LRotationd()\n"
      "LRotationd(const LRotationd param0)\n"
      "LRotationd(const LQuaterniond c)\n"
      "LRotationd(const LMatrix4d m)\n"
      "LRotationd(const LMatrix3d m)\n"
      "LRotationd(const LVecBase4d copy)\n"
      "LRotationd(const LVector3d axis, double angle)\n"
      "LRotationd(double h, double p, double r)\n"
      "LRotationd(double r, double i, double j, double k)\n");
  }
  return -1;
}

LRotationd *Dtool_Coerce_LRotationd(PyObject *args, LRotationd &coerced) {
  LRotationd *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LRotationd, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LRotationd *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LRotationd::LRotationd(LQuaterniond const &c)
      LQuaterniond const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaterniond, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LRotationd::LRotationd(LMatrix4d const &m)
      LMatrix4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LRotationd::LRotationd(LMatrix3d const &m)
      LMatrix3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LRotationd::LRotationd(LVecBase4d const &copy)
      LVecBase4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LRotationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LRotationd::LRotationd(LVector3d const &axis, double angle)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LRotationd", &param0, &param1)) {
          LVector3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LRotationd(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline LRotationd::LRotationd(double h, double p, double r)
        double param0;
        double param1;
        double param2;
        if (PyArg_ParseTuple(args, "ddd:LRotationd", &param0, &param1, &param2)) {
          coerced = LRotationd((double)param0, (double)param1, (double)param2);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LRotationd::LRotationd(double r, double i, double j, double k)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LRotationd", &param0, &param1, &param2, &param3)) {
          coerced = LRotationd((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LRotationd(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LRotationd) {
    printf("LRotationd ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LRotationd *local_this = (LRotationd *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LRotationd) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LQuaterniond) {
    return (LQuaterniond *) local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *)(LQuaterniond *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LRotationd(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LRotationd) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LQuaterniond) {
    LQuaterniond* other_this = (LQuaterniond*)from_this;
    return (LRotationd*)other_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LRotationd*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LOrientationf
 */
/**
 * Python function wrapper for:
 * static TypeHandle LOrientationf::get_class_type(void)
 */
static PyObject *Dtool_LOrientationf_get_class_type_1676(PyObject *, PyObject *) {
  // 1-static TypeHandle LOrientationf::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LOrientationf::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LOrientationf_get_class_type_1676_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LOrientationf_get_class_type_1676_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LOrientationf::LOrientationf(void)
 * inline LOrientationf::LOrientationf(LMatrix3f const &m)
 * inline LOrientationf::LOrientationf(LMatrix4f const &m)
 * inline LOrientationf::LOrientationf(LOrientationf const &) = default
 * inline LOrientationf::LOrientationf(LQuaternionf const &c)
 * inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist)
 * inline LOrientationf::LOrientationf(float r, float i, float j, float k)
 */
static int Dtool_Init_LOrientationf(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LOrientationf::LOrientationf(void)
      LOrientationf *return_value = new LOrientationf(LQuaternionf::ident_quat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LOrientationf::LOrientationf(LOrientationf const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LOrientationf const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LOrientationf, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LQuaternionf const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LQuaternionf const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LQuaternionf, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LMatrix3f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LMatrix3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3f, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LMatrix4f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LMatrix4f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4f, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LOrientationf const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LOrientationf param0_local;
          LOrientationf const *param0_this = Dtool_Coerce_LOrientationf(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LQuaternionf const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LQuaternionf param0_local;
          LQuaternionf const *param0_this = Dtool_Coerce_LQuaternionf(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LMatrix3f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LMatrix3f param0_local;
          LMatrix3f const *param0_this = Dtool_Coerce_LMatrix3f(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationf::LOrientationf(LMatrix4f const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationf", (char **)keyword_list, &param0)) {
          LMatrix4f param0_local;
          LMatrix4f const *param0_this = Dtool_Coerce_LMatrix4f(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationf *return_value = new LOrientationf(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"point_at", "twist", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:LOrientationf", (char **)keyword_list, &param0, &param1)) {
        LVector3f param0_local;
        LVector3f const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LOrientationf.LOrientationf", "LVector3f");
          return -1;
        }
        LOrientationf *return_value = new LOrientationf(*param0_this, (float)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LOrientationf::LOrientationf(float r, float i, float j, float k)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "i", "j", "k", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LOrientationf", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LOrientationf *return_value = new LOrientationf((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationf, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LOrientationf() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LOrientationf()\n"
      "LOrientationf(const LOrientationf param0)\n"
      "LOrientationf(const LQuaternionf c)\n"
      "LOrientationf(const LMatrix3f m)\n"
      "LOrientationf(const LMatrix4f m)\n"
      "LOrientationf(const LVector3f point_at, float twist)\n"
      "LOrientationf(float r, float i, float j, float k)\n");
  }
  return -1;
}

LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced) {
  LOrientationf *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LOrientationf, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LOrientationf *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LOrientationf::LOrientationf(LQuaternionf const &c)
      LQuaternionf const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LOrientationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LOrientationf::LOrientationf(LMatrix3f const &m)
      LMatrix3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LOrientationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LOrientationf::LOrientationf(LMatrix4f const &m)
      LMatrix4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LOrientationf(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist)
        PyObject *param0;
        float param1;
        if (PyArg_ParseTuple(args, "Of:LOrientationf", &param0, &param1)) {
          LVector3f const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3f, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LOrientationf(*param0_this, (float)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LOrientationf::LOrientationf(float r, float i, float j, float k)
        float param0;
        float param1;
        float param2;
        float param3;
        if (PyArg_ParseTuple(args, "ffff:LOrientationf", &param0, &param1, &param2, &param3)) {
          coerced = LOrientationf((float)param0, (float)param1, (float)param2, (float)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LOrientationf(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LOrientationf) {
    printf("LOrientationf ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LOrientationf *local_this = (LOrientationf *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LOrientationf) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LQuaternionf) {
    return (LQuaternionf *) local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4f) {
    return (LVecBase4f *)(LQuaternionf *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LOrientationf(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LOrientationf) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LQuaternionf) {
    LQuaternionf* other_this = (LQuaternionf*)from_this;
    return (LOrientationf*)other_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4f) {
    LVecBase4f* other_this = (LVecBase4f*)from_this;
    return (LOrientationf*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LOrientationd
 */
/**
 * Python function wrapper for:
 * static TypeHandle LOrientationd::get_class_type(void)
 */
static PyObject *Dtool_LOrientationd_get_class_type_1681(PyObject *, PyObject *) {
  // 1-static TypeHandle LOrientationd::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(LOrientationd::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LOrientationd_get_class_type_1681_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LOrientationd_get_class_type_1681_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LOrientationd::LOrientationd(void)
 * inline LOrientationd::LOrientationd(LMatrix3d const &m)
 * inline LOrientationd::LOrientationd(LMatrix4d const &m)
 * inline LOrientationd::LOrientationd(LOrientationd const &) = default
 * inline LOrientationd::LOrientationd(LQuaterniond const &c)
 * inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist)
 * inline LOrientationd::LOrientationd(double r, double i, double j, double k)
 */
static int Dtool_Init_LOrientationd(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LOrientationd::LOrientationd(void)
      LOrientationd *return_value = new LOrientationd(LQuaterniond::ident_quat());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LOrientationd::LOrientationd(LOrientationd const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LOrientationd const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LOrientationd, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LQuaterniond const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LQuaterniond const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LQuaterniond, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LMatrix3d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LMatrix3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix3d, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LMatrix4d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LMatrix4d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LMatrix4d, (void **)&param0_this);
          if (param0_this != NULL) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LOrientationd const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LOrientationd param0_local;
          LOrientationd const *param0_this = Dtool_Coerce_LOrientationd(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LQuaterniond const &c)
        PyObject *param0;
        static const char *keyword_list[] = {"c", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LQuaterniond param0_local;
          LQuaterniond const *param0_this = Dtool_Coerce_LQuaterniond(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LMatrix3d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LMatrix3d param0_local;
          LMatrix3d const *param0_this = Dtool_Coerce_LMatrix3d(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline LOrientationd::LOrientationd(LMatrix4d const &m)
        PyObject *param0;
        static const char *keyword_list[] = {"m", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:LOrientationd", (char **)keyword_list, &param0)) {
          LMatrix4d param0_local;
          LMatrix4d const *param0_this = Dtool_Coerce_LMatrix4d(param0, param0_local);
          if ((param0_this != NULL)) {
            LOrientationd *return_value = new LOrientationd(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist)
      PyObject *param0;
      double param1;
      static const char *keyword_list[] = {"point_at", "twist", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:LOrientationd", (char **)keyword_list, &param0, &param1)) {
        LVector3d param0_local;
        LVector3d const *param0_this = Dtool_Coerce_LVector3d(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LOrientationd.LOrientationd", "LVector3d");
          return -1;
        }
        LOrientationd *return_value = new LOrientationd(*param0_this, (double)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LOrientationd::LOrientationd(double r, double i, double j, double k)
      double param0;
      double param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"r", "i", "j", "k", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dddd:LOrientationd", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LOrientationd *return_value = new LOrientationd((double)param0, (double)param1, (double)param2, (double)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LOrientationd, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LOrientationd() takes 0, 1, 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LOrientationd()\n"
      "LOrientationd(const LOrientationd param0)\n"
      "LOrientationd(const LQuaterniond c)\n"
      "LOrientationd(const LMatrix3d m)\n"
      "LOrientationd(const LMatrix4d m)\n"
      "LOrientationd(const LVector3d point_at, double twist)\n"
      "LOrientationd(double r, double i, double j, double k)\n");
  }
  return -1;
}

LOrientationd *Dtool_Coerce_LOrientationd(PyObject *args, LOrientationd &coerced) {
  LOrientationd *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_LOrientationd, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const LOrientationd *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline LOrientationd::LOrientationd(LQuaterniond const &c)
      LQuaterniond const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaterniond, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LOrientationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LOrientationd::LOrientationd(LMatrix3d const &m)
      LMatrix3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LOrientationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline LOrientationd::LOrientationd(LMatrix4d const &m)
      LMatrix4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = LOrientationd(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist)
        PyObject *param0;
        double param1;
        if (PyArg_ParseTuple(args, "Od:LOrientationd", &param0, &param1)) {
          LVector3d const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_LVector3d, (void **)&param0_this);
          if (param0_this != NULL) {
            coerced = LOrientationd(*param0_this, (double)param1);
            if (_PyErr_OCCURRED()) {
              return NULL;
            } else {
              return &coerced;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline LOrientationd::LOrientationd(double r, double i, double j, double k)
        double param0;
        double param1;
        double param2;
        double param3;
        if (PyArg_ParseTuple(args, "dddd:LOrientationd", &param0, &param1, &param2, &param3)) {
          coerced = LOrientationd((double)param0, (double)param1, (double)param2, (double)param3);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_LOrientationd(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LOrientationd) {
    printf("LOrientationd ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LOrientationd *local_this = (LOrientationd *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LOrientationd) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LQuaterniond) {
    return (LQuaterniond *) local_this;
  }
  if (requested_type == Dtool_Ptr_LVecBase4d) {
    return (LVecBase4d *)(LQuaterniond *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LOrientationd(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LOrientationd) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LQuaterniond) {
    LQuaterniond* other_this = (LQuaterniond*)from_this;
    return (LOrientationd*)other_this;
  }
  if (from_type == Dtool_Ptr_LVecBase4d) {
    LVecBase4d* other_this = (LVecBase4d*)from_this;
    return (LOrientationd*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableColor
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableColor::operator =(LColor const &value)
 */
static PyObject *Dtool_ConfigVariableColor_operator_1756(PyObject *self, PyObject *arg) {
  ConfigVariableColor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableColor, (void **)&local_this, "ConfigVariableColor.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableColor::operator =(LColor const &value)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableColor.assign", "LVecBase4f");
  }
  (*local_this).operator =(*arg_this);
  ConfigVariableColor *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableColor, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableColor self, const LVecBase4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableColor_operator_1756_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableColor self, const LVecBase4f value)\n";
#else
static const char *Dtool_ConfigVariableColor_operator_1756_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableColor::set_value(LColor const &value)
 */
static PyObject *Dtool_ConfigVariableColor_set_value_1759(PyObject *self, PyObject *arg) {
  ConfigVariableColor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableColor, (void **)&local_this, "ConfigVariableColor.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableColor::set_value(LColor const &value)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableColor.set_value", "LVecBase4f");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableColor self, const LVecBase4f value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableColor_set_value_1759_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableColor self, const LVecBase4f value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableColor_set_value_1759_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &ConfigVariableColor::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableColor_get_value_1760(PyObject *self, PyObject *) {
  ConfigVariableColor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableColor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &ConfigVariableColor::get_value(void) const
  LColor const *return_value = &((*(const ConfigVariableColor*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableColor_get_value_1760_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableColor self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableColor_get_value_1760_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor ConfigVariableColor::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableColor_get_default_value_1761(PyObject *self, PyObject *) {
  ConfigVariableColor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableColor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor ConfigVariableColor::get_default_value(void) const
  LColor *return_value = new LColor((*(const ConfigVariableColor*)local_this).get_default_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableColor_get_default_value_1761_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableColor self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableColor_get_default_value_1761_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &ConfigVariableColor::operator typecast(void) const
 */
static PyObject *Dtool_ConfigVariableColor_operator_typecast_1757(PyObject *self, PyObject *) {
  ConfigVariableColor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableColor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &ConfigVariableColor::operator typecast(void) const
  LColor const *return_value = &((LColor const &)*(const ConfigVariableColor*)local_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableColor_operator_typecast_1757_comment =
  "C++ Interface:\n"
  "operator_typecast(ConfigVariableColor self)\n";
#else
static const char *Dtool_ConfigVariableColor_operator_typecast_1757_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default
 * inline ConfigVariableColor::ConfigVariableColor(std::string const &name)
 * inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableColor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableColor", (char **)keyword_list, &param0)) {
          ConfigVariableColor const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableColor, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableColor *return_value = new ConfigVariableColor(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableColor, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableColor", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableColor, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableColor", (char **)keyword_list, &param0)) {
          ConfigVariableColor const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableColor(param0, param0_this, param0_manage)) {
            ConfigVariableColor *return_value = new ConfigVariableColor(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableColor, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableColor::ConfigVariableColor(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|s#i:ConfigVariableColor", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          LColor const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param1_this != NULL) {
            ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableColor, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableColor", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableColor, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|s#i:ConfigVariableColor", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          LVecBase4f param1_local;
          LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
          if ((param1_this != NULL)) {
            ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableColor, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableColor() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableColor(const ConfigVariableColor param0)\n"
      "ConfigVariableColor(str name)\n"
      "ConfigVariableColor(str name, const LVecBase4f default_value, str description, int flags)\n"
      "ConfigVariableColor(str name, str default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableColor(PyObject *args, ConfigVariableColor const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableColor, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableColor::ConfigVariableColor(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#O|s#i:ConfigVariableColor", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          LColor const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param1_this != NULL) {
            ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableColor", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableColor(PyObject *args, ConfigVariableColor *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableColor, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableColor::ConfigVariableColor(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#O|s#i:ConfigVariableColor", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          LColor const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_LVecBase4f, (void **)&param1_this);
          if (param1_this != NULL) {
            ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableColor", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableColor *return_value = new ConfigVariableColor(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableColor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableColor) {
    printf("ConfigVariableColor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableColor *local_this = (ConfigVariableColor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableColor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableColor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableColor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableColor*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableColor*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableColor*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for MathNumbers (MathNumbers)
 */
static PyMethodDef Dtool_Methods_MathNumbers[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MathNumbers = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MathNumbers = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MathNumbers",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MathNumbers,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MathNumbers,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MathNumbers,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MathNumbers,
    PyType_GenericAlloc,
    Dtool_new_MathNumbers,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MathNumbers,
  Dtool_UpcastInterface_MathNumbers,
  Dtool_DowncastInterface_MathNumbers,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MathNumbers(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MathNumbers._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MathNumbers._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MathNumbers) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MathNumbers)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MathNumbers);
  }
}

/**
 * Python method tables for LVecBase2f (LVecBase2f)
 */
static PyMethodDef Dtool_Methods_LVecBase2f[] = {
  {"assign", &Dtool_LVecBase2f_operator_12, METH_O, (const char *)Dtool_LVecBase2f_operator_12_comment},
  {"zero", &Dtool_LVecBase2f_zero_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_zero_13_comment},
  {"unit_x", &Dtool_LVecBase2f_unit_x_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_unit_x_14_comment},
  {"unitX", &Dtool_LVecBase2f_unit_x_14, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_unit_x_14_comment},
  {"unit_y", &Dtool_LVecBase2f_unit_y_15, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_unit_y_15_comment},
  {"unitY", &Dtool_LVecBase2f_unit_y_15, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_unit_y_15_comment},
  {"__reduce__", &Dtool_LVecBase2f_reduce_16, METH_NOARGS, (const char *)Dtool_LVecBase2f_reduce_16_comment},
  {"is_nan", &Dtool_LVecBase2f_is_nan_21, METH_NOARGS, (const char *)Dtool_LVecBase2f_is_nan_21_comment},
  {"isNan", &Dtool_LVecBase2f_is_nan_21, METH_NOARGS, (const char *)Dtool_LVecBase2f_is_nan_21_comment},
  {"get_cell", &Dtool_LVecBase2f_get_cell_22, METH_O, (const char *)Dtool_LVecBase2f_get_cell_22_comment},
  {"getCell", &Dtool_LVecBase2f_get_cell_22, METH_O, (const char *)Dtool_LVecBase2f_get_cell_22_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase2f_set_cell_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_set_cell_23_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase2f_set_cell_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_set_cell_23_comment},
  {"get_x", &Dtool_LVecBase2f_get_x_24, METH_NOARGS, (const char *)Dtool_LVecBase2f_get_x_24_comment},
  {"getX", &Dtool_LVecBase2f_get_x_24, METH_NOARGS, (const char *)Dtool_LVecBase2f_get_x_24_comment},
  {"get_y", &Dtool_LVecBase2f_get_y_25, METH_NOARGS, (const char *)Dtool_LVecBase2f_get_y_25_comment},
  {"getY", &Dtool_LVecBase2f_get_y_25, METH_NOARGS, (const char *)Dtool_LVecBase2f_get_y_25_comment},
  {"set_x", &Dtool_LVecBase2f_set_x_26, METH_O, (const char *)Dtool_LVecBase2f_set_x_26_comment},
  {"setX", &Dtool_LVecBase2f_set_x_26, METH_O, (const char *)Dtool_LVecBase2f_set_x_26_comment},
  {"set_y", &Dtool_LVecBase2f_set_y_27, METH_O, (const char *)Dtool_LVecBase2f_set_y_27_comment},
  {"setY", &Dtool_LVecBase2f_set_y_27, METH_O, (const char *)Dtool_LVecBase2f_set_y_27_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase2f_add_to_cell_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_add_to_cell_31_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase2f_add_to_cell_31, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_add_to_cell_31_comment},
  {"add_x", &Dtool_LVecBase2f_add_x_32, METH_O, (const char *)Dtool_LVecBase2f_add_x_32_comment},
  {"addX", &Dtool_LVecBase2f_add_x_32, METH_O, (const char *)Dtool_LVecBase2f_add_x_32_comment},
  {"add_y", &Dtool_LVecBase2f_add_y_33, METH_O, (const char *)Dtool_LVecBase2f_add_y_33_comment},
  {"addY", &Dtool_LVecBase2f_add_y_33, METH_O, (const char *)Dtool_LVecBase2f_add_y_33_comment},
  {"get_num_components", &Dtool_LVecBase2f_get_num_components_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_get_num_components_35_comment},
  {"getNumComponents", &Dtool_LVecBase2f_get_num_components_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_get_num_components_35_comment},
  {"fill", &Dtool_LVecBase2f_fill_36, METH_O, (const char *)Dtool_LVecBase2f_fill_36_comment},
  {"set", (PyCFunction) &Dtool_LVecBase2f_set_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_set_37_comment},
  {"dot", &Dtool_LVecBase2f_dot_38, METH_O, (const char *)Dtool_LVecBase2f_dot_38_comment},
  {"length_squared", &Dtool_LVecBase2f_length_squared_39, METH_NOARGS, (const char *)Dtool_LVecBase2f_length_squared_39_comment},
  {"lengthSquared", &Dtool_LVecBase2f_length_squared_39, METH_NOARGS, (const char *)Dtool_LVecBase2f_length_squared_39_comment},
  {"length", &Dtool_LVecBase2f_length_40, METH_NOARGS, (const char *)Dtool_LVecBase2f_length_40_comment},
  {"normalize", &Dtool_LVecBase2f_normalize_41, METH_NOARGS, (const char *)Dtool_LVecBase2f_normalize_41_comment},
  {"normalized", &Dtool_LVecBase2f_normalized_42, METH_NOARGS, (const char *)Dtool_LVecBase2f_normalized_42_comment},
  {"project", &Dtool_LVecBase2f_project_43, METH_O, (const char *)Dtool_LVecBase2f_project_43_comment},
  {"compare_to", &Dtool_LVecBase2f_compare_to_47, METH_VARARGS, (const char *)Dtool_LVecBase2f_compare_to_47_comment},
  {"compareTo", &Dtool_LVecBase2f_compare_to_47, METH_VARARGS, (const char *)Dtool_LVecBase2f_compare_to_47_comment},
  {"get_hash", &Dtool_LVecBase2f_get_hash_48, METH_VARARGS, (const char *)Dtool_LVecBase2f_get_hash_48_comment},
  {"getHash", &Dtool_LVecBase2f_get_hash_48, METH_VARARGS, (const char *)Dtool_LVecBase2f_get_hash_48_comment},
  {"add_hash", (PyCFunction) &Dtool_LVecBase2f_add_hash_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_add_hash_49_comment},
  {"addHash", (PyCFunction) &Dtool_LVecBase2f_add_hash_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_add_hash_49_comment},
  {"componentwise_mult", &Dtool_LVecBase2f_componentwise_mult_60, METH_O, (const char *)Dtool_LVecBase2f_componentwise_mult_60_comment},
  {"componentwiseMult", &Dtool_LVecBase2f_componentwise_mult_60, METH_O, (const char *)Dtool_LVecBase2f_componentwise_mult_60_comment},
  {"fmax", &Dtool_LVecBase2f_fmax_63, METH_O, (const char *)Dtool_LVecBase2f_fmax_63_comment},
  {"fmin", &Dtool_LVecBase2f_fmin_64, METH_O, (const char *)Dtool_LVecBase2f_fmin_64_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase2f_almost_equal_65, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_almost_equal_65_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase2f_almost_equal_65, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2f_almost_equal_65_comment},
  {"output", &Dtool_LVecBase2f_output_66, METH_O, (const char *)Dtool_LVecBase2f_output_66_comment},
  {"write_datagram_fixed", &Dtool_LVecBase2f_write_datagram_fixed_68, METH_O, (const char *)Dtool_LVecBase2f_write_datagram_fixed_68_comment},
  {"writeDatagramFixed", &Dtool_LVecBase2f_write_datagram_fixed_68, METH_O, (const char *)Dtool_LVecBase2f_write_datagram_fixed_68_comment},
  {"read_datagram_fixed", &Dtool_LVecBase2f_read_datagram_fixed_69, METH_O, (const char *)Dtool_LVecBase2f_read_datagram_fixed_69_comment},
  {"readDatagramFixed", &Dtool_LVecBase2f_read_datagram_fixed_69, METH_O, (const char *)Dtool_LVecBase2f_read_datagram_fixed_69_comment},
  {"write_datagram", &Dtool_LVecBase2f_write_datagram_70, METH_O, (const char *)Dtool_LVecBase2f_write_datagram_70_comment},
  {"writeDatagram", &Dtool_LVecBase2f_write_datagram_70, METH_O, (const char *)Dtool_LVecBase2f_write_datagram_70_comment},
  {"read_datagram", &Dtool_LVecBase2f_read_datagram_71, METH_O, (const char *)Dtool_LVecBase2f_read_datagram_71_comment},
  {"readDatagram", &Dtool_LVecBase2f_read_datagram_71, METH_O, (const char *)Dtool_LVecBase2f_read_datagram_71_comment},
  {"get_class_type", &Dtool_LVecBase2f_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_get_class_type_72_comment},
  {"getClassType", &Dtool_LVecBase2f_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2f_get_class_type_72_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase2f_operator_52_nb_add(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.__add__", "LVecBase2f");
  }
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase2f_operator_55_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2f LVecBase2f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase2f_operator_56_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2f::operator +=(LVecBase2f const &other)
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.__iadd__", "LVecBase2f");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2f.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase2f_operator_59_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase2f_operator_58_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2f::operator *=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2f.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase2f_ipow_62_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent)
      if (PyNumber_Check(arg)) {
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, (float)PyFloat_AsDouble(arg));
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase2f.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase2f self, float exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase2f_operator_57_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2f::operator -=(LVecBase2f const &other)
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.__isub__", "LVecBase2f");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2f.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase2f_operator_59_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase2f_operator_54_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2f LVecBase2f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase2f_operator_51_nb_negative(PyObject *self) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2f LVecBase2f::operator -(void) const
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase2f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase2f_pow_61_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase2f LVecBase2f::__pow__(float exponent) const
    if (PyNumber_Check(arg)) {
      LVecBase2f *return_value = new LVecBase2f(invoke_extension((const LVecBase2f*)local_this).__pow__((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase2f self, float exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase2f_operator_53_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.__sub__", "LVecBase2f");
  }
  LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase2f_operator_55_nb_true_divide(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2f LVecBase2f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase2f *return_value = new LVecBase2f((*(const LVecBase2f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase2f_operator_19_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase2f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float &LVecBase2f::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = (float)PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase2f.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase2f self, index, float assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase2f_operator_19_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase2f index out of range");
    return NULL;
  }
  // 1-inline float LVecBase2f::operator [](int i) const
  float return_value = (*(const LVecBase2f*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase2f self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase2f_size_20_sq_length(PyObject *self) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase2f_compare_to_47_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase2f::compare_to(LVecBase2f const &other) const
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2f.compare_to", "LVecBase2f");
    return -1;
  }
  int return_value = (*(const LVecBase2f*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase2f self, const LVecBase2f other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase2f_getattr_17_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase2f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase2f_get_hash_48_tp_hash(PyObject *self) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase2f_repr_67_tp_repr(PyObject *self) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase2f::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase2f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase2f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase2f_setattr_18_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase2f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase2f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase2f
//////////////////
static PyObject *Dtool_RichCompare_LVecBase2f(PyObject *self, PyObject *arg, int op) {
  LVecBase2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2f, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase2f::operator <(LVecBase2f const &other) const
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2f*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase2f::operator ==(LVecBase2f const &other) const
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2f*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase2f::operator !=(LVecBase2f const &other) const
      LVecBase2f arg_local;
      LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2f*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase2f_compare_to_47_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase2f[] = {
  {(char *)"x", &Dtool_LVecBase2f_x_Getter, &Dtool_LVecBase2f_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase2f_y_Getter, &Dtool_LVecBase2f_y_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase2f = {
  &Dtool_LVecBase2f_operator_52_nb_add,
  &Dtool_LVecBase2f_operator_53_nb_subtract,
  &Dtool_LVecBase2f_operator_54_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase2f_operator_55_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase2f_pow_61_nb_power,
  &Dtool_LVecBase2f_operator_51_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase2f_operator_56_nb_inplace_add,
  &Dtool_LVecBase2f_operator_57_nb_inplace_subtract,
  &Dtool_LVecBase2f_operator_58_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase2f_operator_59_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase2f_ipow_62_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase2f_operator_55_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase2f_operator_59_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase2f = {
  &Dtool_LVecBase2f_size_20_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase2f_operator_19_sq_item,
  0, // sq_slice
  &Dtool_LVecBase2f_operator_19_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase2f_compare_to_47_tp_compare,
#endif
    &Dtool_LVecBase2f_repr_67_tp_repr,
    &Dtool_NumberMethods_LVecBase2f,
    &Dtool_SequenceMethods_LVecBase2f,
    0, // tp_as_mapping
    &Dtool_LVecBase2f_get_hash_48_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase2f_getattr_17_tp_getattro,
    &Dtool_LVecBase2f_setattr_18_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all two-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase2f,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase2f,
    0, // tp_members
    Dtool_Properties_LVecBase2f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_LVecBase2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase2f,
  Dtool_UpcastInterface_LVecBase2f,
  Dtool_DowncastInterface_LVecBase2f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase2f,
};

static void Dtool_PyModuleClassInit_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase2f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase2f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase2f::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase2f::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase2f);
  }
}

/**
 * Python method tables for LVecBase2d (LVecBase2d)
 */
static PyMethodDef Dtool_Methods_LVecBase2d[] = {
  {"assign", &Dtool_LVecBase2d_operator_80, METH_O, (const char *)Dtool_LVecBase2d_operator_80_comment},
  {"zero", &Dtool_LVecBase2d_zero_81, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_zero_81_comment},
  {"unit_x", &Dtool_LVecBase2d_unit_x_82, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_unit_x_82_comment},
  {"unitX", &Dtool_LVecBase2d_unit_x_82, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_unit_x_82_comment},
  {"unit_y", &Dtool_LVecBase2d_unit_y_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_unit_y_83_comment},
  {"unitY", &Dtool_LVecBase2d_unit_y_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_unit_y_83_comment},
  {"__reduce__", &Dtool_LVecBase2d_reduce_84, METH_NOARGS, (const char *)Dtool_LVecBase2d_reduce_84_comment},
  {"is_nan", &Dtool_LVecBase2d_is_nan_89, METH_NOARGS, (const char *)Dtool_LVecBase2d_is_nan_89_comment},
  {"isNan", &Dtool_LVecBase2d_is_nan_89, METH_NOARGS, (const char *)Dtool_LVecBase2d_is_nan_89_comment},
  {"get_cell", &Dtool_LVecBase2d_get_cell_90, METH_O, (const char *)Dtool_LVecBase2d_get_cell_90_comment},
  {"getCell", &Dtool_LVecBase2d_get_cell_90, METH_O, (const char *)Dtool_LVecBase2d_get_cell_90_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase2d_set_cell_91, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_set_cell_91_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase2d_set_cell_91, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_set_cell_91_comment},
  {"get_x", &Dtool_LVecBase2d_get_x_92, METH_NOARGS, (const char *)Dtool_LVecBase2d_get_x_92_comment},
  {"getX", &Dtool_LVecBase2d_get_x_92, METH_NOARGS, (const char *)Dtool_LVecBase2d_get_x_92_comment},
  {"get_y", &Dtool_LVecBase2d_get_y_93, METH_NOARGS, (const char *)Dtool_LVecBase2d_get_y_93_comment},
  {"getY", &Dtool_LVecBase2d_get_y_93, METH_NOARGS, (const char *)Dtool_LVecBase2d_get_y_93_comment},
  {"set_x", &Dtool_LVecBase2d_set_x_94, METH_O, (const char *)Dtool_LVecBase2d_set_x_94_comment},
  {"setX", &Dtool_LVecBase2d_set_x_94, METH_O, (const char *)Dtool_LVecBase2d_set_x_94_comment},
  {"set_y", &Dtool_LVecBase2d_set_y_95, METH_O, (const char *)Dtool_LVecBase2d_set_y_95_comment},
  {"setY", &Dtool_LVecBase2d_set_y_95, METH_O, (const char *)Dtool_LVecBase2d_set_y_95_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase2d_add_to_cell_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_add_to_cell_99_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase2d_add_to_cell_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_add_to_cell_99_comment},
  {"add_x", &Dtool_LVecBase2d_add_x_100, METH_O, (const char *)Dtool_LVecBase2d_add_x_100_comment},
  {"addX", &Dtool_LVecBase2d_add_x_100, METH_O, (const char *)Dtool_LVecBase2d_add_x_100_comment},
  {"add_y", &Dtool_LVecBase2d_add_y_101, METH_O, (const char *)Dtool_LVecBase2d_add_y_101_comment},
  {"addY", &Dtool_LVecBase2d_add_y_101, METH_O, (const char *)Dtool_LVecBase2d_add_y_101_comment},
  {"get_num_components", &Dtool_LVecBase2d_get_num_components_103, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_get_num_components_103_comment},
  {"getNumComponents", &Dtool_LVecBase2d_get_num_components_103, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_get_num_components_103_comment},
  {"fill", &Dtool_LVecBase2d_fill_104, METH_O, (const char *)Dtool_LVecBase2d_fill_104_comment},
  {"set", (PyCFunction) &Dtool_LVecBase2d_set_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_set_105_comment},
  {"dot", &Dtool_LVecBase2d_dot_106, METH_O, (const char *)Dtool_LVecBase2d_dot_106_comment},
  {"length_squared", &Dtool_LVecBase2d_length_squared_107, METH_NOARGS, (const char *)Dtool_LVecBase2d_length_squared_107_comment},
  {"lengthSquared", &Dtool_LVecBase2d_length_squared_107, METH_NOARGS, (const char *)Dtool_LVecBase2d_length_squared_107_comment},
  {"length", &Dtool_LVecBase2d_length_108, METH_NOARGS, (const char *)Dtool_LVecBase2d_length_108_comment},
  {"normalize", &Dtool_LVecBase2d_normalize_109, METH_NOARGS, (const char *)Dtool_LVecBase2d_normalize_109_comment},
  {"normalized", &Dtool_LVecBase2d_normalized_110, METH_NOARGS, (const char *)Dtool_LVecBase2d_normalized_110_comment},
  {"project", &Dtool_LVecBase2d_project_111, METH_O, (const char *)Dtool_LVecBase2d_project_111_comment},
  {"compare_to", &Dtool_LVecBase2d_compare_to_115, METH_VARARGS, (const char *)Dtool_LVecBase2d_compare_to_115_comment},
  {"compareTo", &Dtool_LVecBase2d_compare_to_115, METH_VARARGS, (const char *)Dtool_LVecBase2d_compare_to_115_comment},
  {"get_hash", &Dtool_LVecBase2d_get_hash_116, METH_VARARGS, (const char *)Dtool_LVecBase2d_get_hash_116_comment},
  {"getHash", &Dtool_LVecBase2d_get_hash_116, METH_VARARGS, (const char *)Dtool_LVecBase2d_get_hash_116_comment},
  {"add_hash", (PyCFunction) &Dtool_LVecBase2d_add_hash_117, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_add_hash_117_comment},
  {"addHash", (PyCFunction) &Dtool_LVecBase2d_add_hash_117, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_add_hash_117_comment},
  {"componentwise_mult", &Dtool_LVecBase2d_componentwise_mult_128, METH_O, (const char *)Dtool_LVecBase2d_componentwise_mult_128_comment},
  {"componentwiseMult", &Dtool_LVecBase2d_componentwise_mult_128, METH_O, (const char *)Dtool_LVecBase2d_componentwise_mult_128_comment},
  {"fmax", &Dtool_LVecBase2d_fmax_131, METH_O, (const char *)Dtool_LVecBase2d_fmax_131_comment},
  {"fmin", &Dtool_LVecBase2d_fmin_132, METH_O, (const char *)Dtool_LVecBase2d_fmin_132_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase2d_almost_equal_133, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_almost_equal_133_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase2d_almost_equal_133, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2d_almost_equal_133_comment},
  {"output", &Dtool_LVecBase2d_output_134, METH_O, (const char *)Dtool_LVecBase2d_output_134_comment},
  {"write_datagram_fixed", &Dtool_LVecBase2d_write_datagram_fixed_136, METH_O, (const char *)Dtool_LVecBase2d_write_datagram_fixed_136_comment},
  {"writeDatagramFixed", &Dtool_LVecBase2d_write_datagram_fixed_136, METH_O, (const char *)Dtool_LVecBase2d_write_datagram_fixed_136_comment},
  {"read_datagram_fixed", &Dtool_LVecBase2d_read_datagram_fixed_137, METH_O, (const char *)Dtool_LVecBase2d_read_datagram_fixed_137_comment},
  {"readDatagramFixed", &Dtool_LVecBase2d_read_datagram_fixed_137, METH_O, (const char *)Dtool_LVecBase2d_read_datagram_fixed_137_comment},
  {"write_datagram", &Dtool_LVecBase2d_write_datagram_138, METH_O, (const char *)Dtool_LVecBase2d_write_datagram_138_comment},
  {"writeDatagram", &Dtool_LVecBase2d_write_datagram_138, METH_O, (const char *)Dtool_LVecBase2d_write_datagram_138_comment},
  {"read_datagram", &Dtool_LVecBase2d_read_datagram_139, METH_O, (const char *)Dtool_LVecBase2d_read_datagram_139_comment},
  {"readDatagram", &Dtool_LVecBase2d_read_datagram_139, METH_O, (const char *)Dtool_LVecBase2d_read_datagram_139_comment},
  {"get_class_type", &Dtool_LVecBase2d_get_class_type_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_get_class_type_140_comment},
  {"getClassType", &Dtool_LVecBase2d_get_class_type_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2d_get_class_type_140_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase2d_operator_120_nb_add(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.__add__", "LVecBase2d");
  }
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase2d_operator_123_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2d LVecBase2d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase2d_operator_124_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2d::operator +=(LVecBase2d const &other)
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.__iadd__", "LVecBase2d");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2d.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase2d_operator_127_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase2d_operator_126_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2d::operator *=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2d.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase2d_ipow_130_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent)
      if (PyNumber_Check(arg)) {
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, PyFloat_AsDouble(arg));
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase2d.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase2d self, double exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase2d_operator_125_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2d::operator -=(LVecBase2d const &other)
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.__isub__", "LVecBase2d");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2d.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase2d_operator_127_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase2d_operator_122_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2d LVecBase2d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase2d_operator_119_nb_negative(PyObject *self) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2d LVecBase2d::operator -(void) const
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase2d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase2d_pow_129_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase2d LVecBase2d::__pow__(double exponent) const
    if (PyNumber_Check(arg)) {
      LVecBase2d *return_value = new LVecBase2d(invoke_extension((const LVecBase2d*)local_this).__pow__(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase2d self, double exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase2d_operator_121_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.__sub__", "LVecBase2d");
  }
  LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase2d_operator_123_nb_true_divide(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2d LVecBase2d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase2d *return_value = new LVecBase2d((*(const LVecBase2d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase2d_operator_87_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase2d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double &LVecBase2d::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase2d.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase2d self, index, double assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase2d_operator_87_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase2d index out of range");
    return NULL;
  }
  // 1-inline double LVecBase2d::operator [](int i) const
  double return_value = (*(const LVecBase2d*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase2d self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase2d_size_88_sq_length(PyObject *self) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase2d_compare_to_115_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase2d::compare_to(LVecBase2d const &other) const
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2d.compare_to", "LVecBase2d");
    return -1;
  }
  int return_value = (*(const LVecBase2d*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase2d self, const LVecBase2d other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase2d_getattr_85_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase2d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase2d_get_hash_116_tp_hash(PyObject *self) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase2d_repr_135_tp_repr(PyObject *self) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase2d::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase2d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase2d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase2d_setattr_86_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase2d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase2d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase2d
//////////////////
static PyObject *Dtool_RichCompare_LVecBase2d(PyObject *self, PyObject *arg, int op) {
  LVecBase2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2d, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase2d::operator <(LVecBase2d const &other) const
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2d*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase2d::operator ==(LVecBase2d const &other) const
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2d*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase2d::operator !=(LVecBase2d const &other) const
      LVecBase2d arg_local;
      LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2d*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase2d_compare_to_115_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase2d[] = {
  {(char *)"x", &Dtool_LVecBase2d_x_Getter, &Dtool_LVecBase2d_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase2d_y_Getter, &Dtool_LVecBase2d_y_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase2d = {
  &Dtool_LVecBase2d_operator_120_nb_add,
  &Dtool_LVecBase2d_operator_121_nb_subtract,
  &Dtool_LVecBase2d_operator_122_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase2d_operator_123_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase2d_pow_129_nb_power,
  &Dtool_LVecBase2d_operator_119_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase2d_operator_124_nb_inplace_add,
  &Dtool_LVecBase2d_operator_125_nb_inplace_subtract,
  &Dtool_LVecBase2d_operator_126_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase2d_operator_127_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase2d_ipow_130_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase2d_operator_123_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase2d_operator_127_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase2d = {
  &Dtool_LVecBase2d_size_88_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase2d_operator_87_sq_item,
  0, // sq_slice
  &Dtool_LVecBase2d_operator_87_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase2d_compare_to_115_tp_compare,
#endif
    &Dtool_LVecBase2d_repr_135_tp_repr,
    &Dtool_NumberMethods_LVecBase2d,
    &Dtool_SequenceMethods_LVecBase2d,
    0, // tp_as_mapping
    &Dtool_LVecBase2d_get_hash_116_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase2d_getattr_85_tp_getattro,
    &Dtool_LVecBase2d_setattr_86_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all two-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase2d,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase2d,
    0, // tp_members
    Dtool_Properties_LVecBase2d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_LVecBase2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase2d,
  Dtool_UpcastInterface_LVecBase2d,
  Dtool_DowncastInterface_LVecBase2d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase2d,
};

static void Dtool_PyModuleClassInit_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase2d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase2d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase2d::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase2d::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase2d);
  }
}

/**
 * Python method tables for LVecBase2i (LVecBase2i)
 */
static PyMethodDef Dtool_Methods_LVecBase2i[] = {
  {"assign", &Dtool_LVecBase2i_operator_148, METH_O, (const char *)Dtool_LVecBase2i_operator_148_comment},
  {"zero", &Dtool_LVecBase2i_zero_149, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_zero_149_comment},
  {"unit_x", &Dtool_LVecBase2i_unit_x_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_unit_x_150_comment},
  {"unitX", &Dtool_LVecBase2i_unit_x_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_unit_x_150_comment},
  {"unit_y", &Dtool_LVecBase2i_unit_y_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_unit_y_151_comment},
  {"unitY", &Dtool_LVecBase2i_unit_y_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_unit_y_151_comment},
  {"__reduce__", &Dtool_LVecBase2i_reduce_152, METH_NOARGS, (const char *)Dtool_LVecBase2i_reduce_152_comment},
  {"is_nan", &Dtool_LVecBase2i_is_nan_157, METH_NOARGS, (const char *)Dtool_LVecBase2i_is_nan_157_comment},
  {"isNan", &Dtool_LVecBase2i_is_nan_157, METH_NOARGS, (const char *)Dtool_LVecBase2i_is_nan_157_comment},
  {"get_cell", &Dtool_LVecBase2i_get_cell_158, METH_O, (const char *)Dtool_LVecBase2i_get_cell_158_comment},
  {"getCell", &Dtool_LVecBase2i_get_cell_158, METH_O, (const char *)Dtool_LVecBase2i_get_cell_158_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase2i_set_cell_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_set_cell_159_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase2i_set_cell_159, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_set_cell_159_comment},
  {"get_x", &Dtool_LVecBase2i_get_x_160, METH_NOARGS, (const char *)Dtool_LVecBase2i_get_x_160_comment},
  {"getX", &Dtool_LVecBase2i_get_x_160, METH_NOARGS, (const char *)Dtool_LVecBase2i_get_x_160_comment},
  {"get_y", &Dtool_LVecBase2i_get_y_161, METH_NOARGS, (const char *)Dtool_LVecBase2i_get_y_161_comment},
  {"getY", &Dtool_LVecBase2i_get_y_161, METH_NOARGS, (const char *)Dtool_LVecBase2i_get_y_161_comment},
  {"set_x", &Dtool_LVecBase2i_set_x_162, METH_O, (const char *)Dtool_LVecBase2i_set_x_162_comment},
  {"setX", &Dtool_LVecBase2i_set_x_162, METH_O, (const char *)Dtool_LVecBase2i_set_x_162_comment},
  {"set_y", &Dtool_LVecBase2i_set_y_163, METH_O, (const char *)Dtool_LVecBase2i_set_y_163_comment},
  {"setY", &Dtool_LVecBase2i_set_y_163, METH_O, (const char *)Dtool_LVecBase2i_set_y_163_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase2i_add_to_cell_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_add_to_cell_167_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase2i_add_to_cell_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_add_to_cell_167_comment},
  {"add_x", &Dtool_LVecBase2i_add_x_168, METH_O, (const char *)Dtool_LVecBase2i_add_x_168_comment},
  {"addX", &Dtool_LVecBase2i_add_x_168, METH_O, (const char *)Dtool_LVecBase2i_add_x_168_comment},
  {"add_y", &Dtool_LVecBase2i_add_y_169, METH_O, (const char *)Dtool_LVecBase2i_add_y_169_comment},
  {"addY", &Dtool_LVecBase2i_add_y_169, METH_O, (const char *)Dtool_LVecBase2i_add_y_169_comment},
  {"get_num_components", &Dtool_LVecBase2i_get_num_components_171, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_get_num_components_171_comment},
  {"getNumComponents", &Dtool_LVecBase2i_get_num_components_171, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_get_num_components_171_comment},
  {"fill", &Dtool_LVecBase2i_fill_172, METH_O, (const char *)Dtool_LVecBase2i_fill_172_comment},
  {"set", (PyCFunction) &Dtool_LVecBase2i_set_173, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_set_173_comment},
  {"dot", &Dtool_LVecBase2i_dot_174, METH_O, (const char *)Dtool_LVecBase2i_dot_174_comment},
  {"length_squared", &Dtool_LVecBase2i_length_squared_175, METH_NOARGS, (const char *)Dtool_LVecBase2i_length_squared_175_comment},
  {"lengthSquared", &Dtool_LVecBase2i_length_squared_175, METH_NOARGS, (const char *)Dtool_LVecBase2i_length_squared_175_comment},
  {"compare_to", &Dtool_LVecBase2i_compare_to_179, METH_O, (const char *)Dtool_LVecBase2i_compare_to_179_comment},
  {"compareTo", &Dtool_LVecBase2i_compare_to_179, METH_O, (const char *)Dtool_LVecBase2i_compare_to_179_comment},
  {"get_hash", &Dtool_LVecBase2i_get_hash_180, METH_NOARGS, (const char *)Dtool_LVecBase2i_get_hash_180_comment},
  {"getHash", &Dtool_LVecBase2i_get_hash_180, METH_NOARGS, (const char *)Dtool_LVecBase2i_get_hash_180_comment},
  {"add_hash", &Dtool_LVecBase2i_add_hash_181, METH_O, (const char *)Dtool_LVecBase2i_add_hash_181_comment},
  {"addHash", &Dtool_LVecBase2i_add_hash_181, METH_O, (const char *)Dtool_LVecBase2i_add_hash_181_comment},
  {"componentwise_mult", &Dtool_LVecBase2i_componentwise_mult_192, METH_O, (const char *)Dtool_LVecBase2i_componentwise_mult_192_comment},
  {"componentwiseMult", &Dtool_LVecBase2i_componentwise_mult_192, METH_O, (const char *)Dtool_LVecBase2i_componentwise_mult_192_comment},
  {"fmax", &Dtool_LVecBase2i_fmax_195, METH_O, (const char *)Dtool_LVecBase2i_fmax_195_comment},
  {"fmin", &Dtool_LVecBase2i_fmin_196, METH_O, (const char *)Dtool_LVecBase2i_fmin_196_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase2i_almost_equal_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_almost_equal_197_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase2i_almost_equal_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase2i_almost_equal_197_comment},
  {"output", &Dtool_LVecBase2i_output_198, METH_O, (const char *)Dtool_LVecBase2i_output_198_comment},
  {"write_datagram_fixed", &Dtool_LVecBase2i_write_datagram_fixed_200, METH_O, (const char *)Dtool_LVecBase2i_write_datagram_fixed_200_comment},
  {"writeDatagramFixed", &Dtool_LVecBase2i_write_datagram_fixed_200, METH_O, (const char *)Dtool_LVecBase2i_write_datagram_fixed_200_comment},
  {"read_datagram_fixed", &Dtool_LVecBase2i_read_datagram_fixed_201, METH_O, (const char *)Dtool_LVecBase2i_read_datagram_fixed_201_comment},
  {"readDatagramFixed", &Dtool_LVecBase2i_read_datagram_fixed_201, METH_O, (const char *)Dtool_LVecBase2i_read_datagram_fixed_201_comment},
  {"write_datagram", &Dtool_LVecBase2i_write_datagram_202, METH_O, (const char *)Dtool_LVecBase2i_write_datagram_202_comment},
  {"writeDatagram", &Dtool_LVecBase2i_write_datagram_202, METH_O, (const char *)Dtool_LVecBase2i_write_datagram_202_comment},
  {"read_datagram", &Dtool_LVecBase2i_read_datagram_203, METH_O, (const char *)Dtool_LVecBase2i_read_datagram_203_comment},
  {"readDatagram", &Dtool_LVecBase2i_read_datagram_203, METH_O, (const char *)Dtool_LVecBase2i_read_datagram_203_comment},
  {"get_class_type", &Dtool_LVecBase2i_get_class_type_204, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_get_class_type_204_comment},
  {"getClassType", &Dtool_LVecBase2i_get_class_type_204, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase2i_get_class_type_204_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase2i_operator_184_nb_add(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.__add__", "LVecBase2i");
  }
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase2i_operator_187_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2i LVecBase2i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase2i_operator_188_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2i::operator +=(LVecBase2i const &other)
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.__iadd__", "LVecBase2i");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2i.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase2i_operator_191_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2i::operator /=(int scalar)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator /=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2i.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase2i_operator_190_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2i::operator *=(int scalar)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator *=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2i.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase2i_ipow_194_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, (int)arg_val);
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase2i.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase2i self, int exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase2i_operator_189_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase2i::operator -=(LVecBase2i const &other)
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.__isub__", "LVecBase2i");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase2i.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase2i_operator_186_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2i LVecBase2i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase2i_operator_183_nb_negative(PyObject *self) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase2i LVecBase2i::operator -(void) const
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase2i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase2i_pow_193_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase2i LVecBase2i::__pow__(int exponent) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      LVecBase2i *return_value = new LVecBase2i(invoke_extension((const LVecBase2i*)local_this).__pow__((int)arg_val));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase2i self, int exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase2i_operator_185_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.__sub__", "LVecBase2i");
  }
  LVecBase2i *return_value = new LVecBase2i((*(const LVecBase2i*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase2i_operator_155_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase2i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int &LVecBase2i::operator [](int i)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return -1;
        }
#endif
        (*local_this).operator [](index) = (int)arg_val;
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase2i.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase2i self, index, int assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase2i_operator_155_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase2i index out of range");
    return NULL;
  }
  // 1-inline int LVecBase2i::operator [](int i) const
  int return_value = (*(const LVecBase2i*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase2i self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase2i_size_156_sq_length(PyObject *self) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase2i_compare_to_179_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase2i::compare_to(LVecBase2i const &other) const
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase2i.compare_to", "LVecBase2i");
    return -1;
  }
  int return_value = (*(const LVecBase2i*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase2i self, const LVecBase2i other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase2i_getattr_153_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase2i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase2i_get_hash_180_tp_hash(PyObject *self) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase2i_repr_199_tp_repr(PyObject *self) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase2i::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase2i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase2i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase2i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase2i_setattr_154_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase2i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase2i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase2i
//////////////////
static PyObject *Dtool_RichCompare_LVecBase2i(PyObject *self, PyObject *arg, int op) {
  LVecBase2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase2i, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase2i::operator <(LVecBase2i const &other) const
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2i*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase2i::operator ==(LVecBase2i const &other) const
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2i*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase2i::operator !=(LVecBase2i const &other) const
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase2i*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase2i_compare_to_179_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase2i[] = {
  {(char *)"x", &Dtool_LVecBase2i_x_Getter, &Dtool_LVecBase2i_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase2i_y_Getter, &Dtool_LVecBase2i_y_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase2i = {
  &Dtool_LVecBase2i_operator_184_nb_add,
  &Dtool_LVecBase2i_operator_185_nb_subtract,
  &Dtool_LVecBase2i_operator_186_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase2i_operator_187_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase2i_pow_193_nb_power,
  &Dtool_LVecBase2i_operator_183_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase2i_operator_188_nb_inplace_add,
  &Dtool_LVecBase2i_operator_189_nb_inplace_subtract,
  &Dtool_LVecBase2i_operator_190_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase2i_operator_191_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase2i_ipow_194_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase2i = {
  &Dtool_LVecBase2i_size_156_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase2i_operator_155_sq_item,
  0, // sq_slice
  &Dtool_LVecBase2i_operator_155_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase2i_compare_to_179_tp_compare,
#endif
    &Dtool_LVecBase2i_repr_199_tp_repr,
    &Dtool_NumberMethods_LVecBase2i,
    &Dtool_SequenceMethods_LVecBase2i,
    0, // tp_as_mapping
    &Dtool_LVecBase2i_get_hash_180_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase2i_getattr_153_tp_getattro,
    &Dtool_LVecBase2i_setattr_154_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all two-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase2i,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase2i,
    0, // tp_members
    Dtool_Properties_LVecBase2i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_LVecBase2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase2i,
  Dtool_UpcastInterface_LVecBase2i,
  Dtool_DowncastInterface_LVecBase2i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase2i,
};

static void Dtool_PyModuleClassInit_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase2i._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase2i::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase2i::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase2i::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase2i);
  }
}

/**
 * Python method tables for LVector2f (LVector2f)
 */
static PyMethodDef Dtool_Methods_LVector2f[] = {
  {"zero", &Dtool_LVector2f_zero_210, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_zero_210_comment},
  {"unit_x", &Dtool_LVector2f_unit_x_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_unit_x_211_comment},
  {"unitX", &Dtool_LVector2f_unit_x_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_unit_x_211_comment},
  {"unit_y", &Dtool_LVector2f_unit_y_212, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_unit_y_212_comment},
  {"unitY", &Dtool_LVector2f_unit_y_212, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_unit_y_212_comment},
  {"normalized", &Dtool_LVector2f_normalized_218, METH_NOARGS, (const char *)Dtool_LVector2f_normalized_218_comment},
  {"project", &Dtool_LVector2f_project_219, METH_O, (const char *)Dtool_LVector2f_project_219_comment},
  {"signed_angle_rad", &Dtool_LVector2f_signed_angle_rad_220, METH_O, (const char *)Dtool_LVector2f_signed_angle_rad_220_comment},
  {"signedAngleRad", &Dtool_LVector2f_signed_angle_rad_220, METH_O, (const char *)Dtool_LVector2f_signed_angle_rad_220_comment},
  {"signed_angle_deg", &Dtool_LVector2f_signed_angle_deg_221, METH_O, (const char *)Dtool_LVector2f_signed_angle_deg_221_comment},
  {"signedAngleDeg", &Dtool_LVector2f_signed_angle_deg_221, METH_O, (const char *)Dtool_LVector2f_signed_angle_deg_221_comment},
  {"get_class_type", &Dtool_LVector2f_get_class_type_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_get_class_type_223_comment},
  {"getClassType", &Dtool_LVector2f_get_class_type_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2f_get_class_type_223_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector2f_operator_214_nb_add(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector2f LVector2f::operator +(LVector2f const &other) const
    LVector2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2f *return_value = new LVecBase2f((*(const LVector2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  {
    // -2 inline LVector2f LVector2f::operator +(LVector2f const &other) const
    LVector2f arg_local;
    LVector2f const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2f *return_value = new LVecBase2f((*(const LVector2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector2f_operator_217_nb_divide(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2f LVector2f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector2f_operator_216_nb_multiply(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2f LVector2f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector2f_operator_213_nb_negative(PyObject *self) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2f LVector2f::operator -(void) const
  LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector2f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector2f_operator_215_nb_subtract(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector2f LVector2f::operator -(LVector2f const &other) const
    LVector2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2f *return_value = new LVecBase2f((*(const LVector2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  {
    // -2 inline LVector2f LVector2f::operator -(LVector2f const &other) const
    LVector2f arg_local;
    LVector2f const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2f *return_value = new LVecBase2f((*(const LVector2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVector2f_operator_217_nb_true_divide(PyObject *self, PyObject *arg) {
  LVector2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2f LVector2f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector2f *return_value = new LVector2f((*(const LVector2f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector2f_getattr_208_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector2f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector2f_repr_222_tp_repr(PyObject *self) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector2f::__repr__(void) const
  std::string return_value = invoke_extension((const LVector2f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector2f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector2f_setattr_209_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector2f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector2f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyNumberMethods Dtool_NumberMethods_LVector2f = {
  &Dtool_LVector2f_operator_214_nb_add,
  &Dtool_LVector2f_operator_215_nb_subtract,
  &Dtool_LVector2f_operator_216_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector2f_operator_217_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector2f_operator_213_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVector2f_operator_217_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector2f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector2f_repr_222_tp_repr,
    &Dtool_NumberMethods_LVector2f,
    &Dtool_SequenceMethods_LVector2f,
    &Dtool_MappingMethods_LVector2f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector2f_getattr_208_tp_getattro,
    &Dtool_LVector2f_setattr_209_tp_setattro,
    &Dtool_BufferProcs_LVector2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a two-component vector offset.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector2f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector2f,
    PyType_GenericAlloc,
    Dtool_new_LVector2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector2f,
  Dtool_UpcastInterface_LVector2f,
  Dtool_DowncastInterface_LVector2f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector2f,
};

static void Dtool_PyModuleClassInit_LVector2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase2f(NULL);
    Dtool_LVector2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase2f);
    PyObject *dict = PyDict_New();
    Dtool_LVector2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector2f);
  }
}

/**
 * Python method tables for LVector2d (LVector2d)
 */
static PyMethodDef Dtool_Methods_LVector2d[] = {
  {"zero", &Dtool_LVector2d_zero_229, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_zero_229_comment},
  {"unit_x", &Dtool_LVector2d_unit_x_230, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_unit_x_230_comment},
  {"unitX", &Dtool_LVector2d_unit_x_230, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_unit_x_230_comment},
  {"unit_y", &Dtool_LVector2d_unit_y_231, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_unit_y_231_comment},
  {"unitY", &Dtool_LVector2d_unit_y_231, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_unit_y_231_comment},
  {"normalized", &Dtool_LVector2d_normalized_237, METH_NOARGS, (const char *)Dtool_LVector2d_normalized_237_comment},
  {"project", &Dtool_LVector2d_project_238, METH_O, (const char *)Dtool_LVector2d_project_238_comment},
  {"signed_angle_rad", &Dtool_LVector2d_signed_angle_rad_239, METH_O, (const char *)Dtool_LVector2d_signed_angle_rad_239_comment},
  {"signedAngleRad", &Dtool_LVector2d_signed_angle_rad_239, METH_O, (const char *)Dtool_LVector2d_signed_angle_rad_239_comment},
  {"signed_angle_deg", &Dtool_LVector2d_signed_angle_deg_240, METH_O, (const char *)Dtool_LVector2d_signed_angle_deg_240_comment},
  {"signedAngleDeg", &Dtool_LVector2d_signed_angle_deg_240, METH_O, (const char *)Dtool_LVector2d_signed_angle_deg_240_comment},
  {"get_class_type", &Dtool_LVector2d_get_class_type_242, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_get_class_type_242_comment},
  {"getClassType", &Dtool_LVector2d_get_class_type_242, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2d_get_class_type_242_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector2d_operator_233_nb_add(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector2d LVector2d::operator +(LVector2d const &other) const
    LVector2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2d *return_value = new LVecBase2d((*(const LVector2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  {
    // -2 inline LVector2d LVector2d::operator +(LVector2d const &other) const
    LVector2d arg_local;
    LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2d *return_value = new LVecBase2d((*(const LVector2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector2d_operator_236_nb_divide(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2d LVector2d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector2d_operator_235_nb_multiply(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2d LVector2d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector2d_operator_232_nb_negative(PyObject *self) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2d LVector2d::operator -(void) const
  LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector2d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector2d_operator_234_nb_subtract(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector2d LVector2d::operator -(LVector2d const &other) const
    LVector2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2d *return_value = new LVecBase2d((*(const LVector2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  {
    // -2 inline LVector2d LVector2d::operator -(LVector2d const &other) const
    LVector2d arg_local;
    LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2d *return_value = new LVecBase2d((*(const LVector2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVector2d_operator_236_nb_true_divide(PyObject *self, PyObject *arg) {
  LVector2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2d LVector2d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector2d *return_value = new LVector2d((*(const LVector2d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector2d_getattr_227_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector2d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector2d_repr_241_tp_repr(PyObject *self) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector2d::__repr__(void) const
  std::string return_value = invoke_extension((const LVector2d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector2d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector2d_setattr_228_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector2d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector2d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyNumberMethods Dtool_NumberMethods_LVector2d = {
  &Dtool_LVector2d_operator_233_nb_add,
  &Dtool_LVector2d_operator_234_nb_subtract,
  &Dtool_LVector2d_operator_235_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector2d_operator_236_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector2d_operator_232_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVector2d_operator_236_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector2d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector2d_repr_241_tp_repr,
    &Dtool_NumberMethods_LVector2d,
    &Dtool_SequenceMethods_LVector2d,
    &Dtool_MappingMethods_LVector2d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector2d_getattr_227_tp_getattro,
    &Dtool_LVector2d_setattr_228_tp_setattro,
    &Dtool_BufferProcs_LVector2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a two-component vector offset.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector2d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector2d,
    PyType_GenericAlloc,
    Dtool_new_LVector2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector2d,
  Dtool_UpcastInterface_LVector2d,
  Dtool_DowncastInterface_LVector2d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector2d,
};

static void Dtool_PyModuleClassInit_LVector2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase2d(NULL);
    Dtool_LVector2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase2d);
    PyObject *dict = PyDict_New();
    Dtool_LVector2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector2d);
  }
}

/**
 * Python method tables for LVector2i (LVector2i)
 */
static PyMethodDef Dtool_Methods_LVector2i[] = {
  {"zero", &Dtool_LVector2i_zero_248, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_zero_248_comment},
  {"unit_x", &Dtool_LVector2i_unit_x_249, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_unit_x_249_comment},
  {"unitX", &Dtool_LVector2i_unit_x_249, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_unit_x_249_comment},
  {"unit_y", &Dtool_LVector2i_unit_y_250, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_unit_y_250_comment},
  {"unitY", &Dtool_LVector2i_unit_y_250, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_unit_y_250_comment},
  {"get_class_type", &Dtool_LVector2i_get_class_type_257, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_get_class_type_257_comment},
  {"getClassType", &Dtool_LVector2i_get_class_type_257, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector2i_get_class_type_257_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector2i_operator_252_nb_add(PyObject *self, PyObject *arg) {
  LVector2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector2i LVector2i::operator +(LVector2i const &other) const
    LVector2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2i *return_value = new LVecBase2i((*(const LVector2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  {
    // -2 inline LVector2i LVector2i::operator +(LVector2i const &other) const
    LVector2i arg_local;
    LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2i *return_value = new LVecBase2i((*(const LVector2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector2i_operator_255_nb_divide(PyObject *self, PyObject *arg) {
  LVector2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2i LVector2i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector2i_operator_254_nb_multiply(PyObject *self, PyObject *arg) {
  LVector2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector2i LVector2i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector2i_operator_251_nb_negative(PyObject *self) {
  LVector2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector2i LVector2i::operator -(void) const
  LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector2i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector2i_operator_253_nb_subtract(PyObject *self, PyObject *arg) {
  LVector2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector2i LVector2i::operator -(LVector2i const &other) const
    LVector2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2i *return_value = new LVecBase2i((*(const LVector2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  {
    // -2 inline LVector2i LVector2i::operator -(LVector2i const &other) const
    LVector2i arg_local;
    LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2i *return_value = new LVector2i((*(const LVector2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2i *return_value = new LVecBase2i((*(const LVector2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector2i_getattr_246_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector2i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector2i_repr_256_tp_repr(PyObject *self) {
  LVector2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector2i::__repr__(void) const
  std::string return_value = invoke_extension((const LVector2i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector2i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector2i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector2i_setattr_247_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector2i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector2i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector2i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyNumberMethods Dtool_NumberMethods_LVector2i = {
  &Dtool_LVector2i_operator_252_nb_add,
  &Dtool_LVector2i_operator_253_nb_subtract,
  &Dtool_LVector2i_operator_254_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector2i_operator_255_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector2i_operator_251_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector2i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector2i_repr_256_tp_repr,
    &Dtool_NumberMethods_LVector2i,
    &Dtool_SequenceMethods_LVector2i,
    &Dtool_MappingMethods_LVector2i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector2i_getattr_246_tp_getattro,
    &Dtool_LVector2i_setattr_247_tp_setattro,
    &Dtool_BufferProcs_LVector2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a two-component vector offset.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector2i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector2i,
    PyType_GenericAlloc,
    Dtool_new_LVector2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector2i,
  Dtool_UpcastInterface_LVector2i,
  Dtool_DowncastInterface_LVector2i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector2i,
};

static void Dtool_PyModuleClassInit_LVector2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase2i(NULL);
    Dtool_LVector2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase2i);
    PyObject *dict = PyDict_New();
    Dtool_LVector2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector2i);
  }
}

/**
 * Python method tables for LPoint2f (LPoint2f)
 */
static PyMethodDef Dtool_Methods_LPoint2f[] = {
  {"zero", &Dtool_LPoint2f_zero_263, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_zero_263_comment},
  {"unit_x", &Dtool_LPoint2f_unit_x_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_unit_x_264_comment},
  {"unitX", &Dtool_LPoint2f_unit_x_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_unit_x_264_comment},
  {"unit_y", &Dtool_LPoint2f_unit_y_265, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_unit_y_265_comment},
  {"unitY", &Dtool_LPoint2f_unit_y_265, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_unit_y_265_comment},
  {"normalized", &Dtool_LPoint2f_normalized_271, METH_NOARGS, (const char *)Dtool_LPoint2f_normalized_271_comment},
  {"project", &Dtool_LPoint2f_project_272, METH_O, (const char *)Dtool_LPoint2f_project_272_comment},
  {"get_class_type", &Dtool_LPoint2f_get_class_type_274, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_get_class_type_274_comment},
  {"getClassType", &Dtool_LPoint2f_get_class_type_274, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2f_get_class_type_274_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint2f_operator_267_nb_add(PyObject *self, PyObject *arg) {
  LPoint2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint2f LPoint2f::operator +(LVector2f const &other) const
    LVector2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2f *return_value = new LVecBase2f((*(const LPoint2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  {
    // -2 inline LPoint2f LPoint2f::operator +(LVector2f const &other) const
    LVector2f arg_local;
    LVector2f const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2f *return_value = new LVecBase2f((*(const LPoint2f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint2f_operator_270_nb_divide(PyObject *self, PyObject *arg) {
  LPoint2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2f LPoint2f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint2f_operator_269_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2f LPoint2f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint2f_operator_266_nb_negative(PyObject *self) {
  LPoint2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2f LPoint2f::operator -(void) const
  LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint2f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint2f_operator_268_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint2f LPoint2f::operator -(LVector2f const &other) const
    LVector2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
    }
  }

  {
    // -2 inline LVector2f LPoint2f::operator -(LPoint2f const &other) const
    LPoint2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2f *return_value = new LVector2f((*(const LPoint2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const
    LVecBase2f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2f *return_value = new LVecBase2f((*(const LPoint2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  {
    // -2 inline LPoint2f LPoint2f::operator -(LVector2f const &other) const
    LVector2f arg_local;
    LVector2f const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
    }
  }

  {
    // -2 inline LVector2f LPoint2f::operator -(LPoint2f const &other) const
    LPoint2f arg_local;
    LPoint2f const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2f *return_value = new LVector2f((*(const LPoint2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
    }
  }

  {
    // -2 inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2f *return_value = new LVecBase2f((*(const LPoint2f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint2f_operator_270_nb_true_divide(PyObject *self, PyObject *arg) {
  LPoint2f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2f LPoint2f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint2f *return_value = new LPoint2f((*(const LPoint2f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint2f_getattr_261_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint2f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint2f_repr_273_tp_repr(PyObject *self) {
  LPoint2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint2f::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint2f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint2f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint2f_setattr_262_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint2f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint2f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint2f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyNumberMethods Dtool_NumberMethods_LPoint2f = {
  &Dtool_LPoint2f_operator_267_nb_add,
  &Dtool_LPoint2f_operator_268_nb_subtract,
  &Dtool_LPoint2f_operator_269_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint2f_operator_270_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint2f_operator_266_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LPoint2f_operator_270_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint2f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint2f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint2f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint2f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint2f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint2f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint2f_repr_273_tp_repr,
    &Dtool_NumberMethods_LPoint2f,
    &Dtool_SequenceMethods_LPoint2f,
    &Dtool_MappingMethods_LPoint2f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint2f_getattr_261_tp_getattro,
    &Dtool_LPoint2f_setattr_262_tp_setattro,
    &Dtool_BufferProcs_LPoint2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a two-component point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint2f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint2f,
    PyType_GenericAlloc,
    Dtool_new_LPoint2f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint2f,
  Dtool_UpcastInterface_LPoint2f,
  Dtool_DowncastInterface_LPoint2f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint2f,
};

static void Dtool_PyModuleClassInit_LPoint2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase2f(NULL);
    Dtool_LPoint2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase2f);
    PyObject *dict = PyDict_New();
    Dtool_LPoint2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint2f);
  }
}

/**
 * Python method tables for LPoint2d (LPoint2d)
 */
static PyMethodDef Dtool_Methods_LPoint2d[] = {
  {"zero", &Dtool_LPoint2d_zero_280, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_zero_280_comment},
  {"unit_x", &Dtool_LPoint2d_unit_x_281, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_unit_x_281_comment},
  {"unitX", &Dtool_LPoint2d_unit_x_281, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_unit_x_281_comment},
  {"unit_y", &Dtool_LPoint2d_unit_y_282, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_unit_y_282_comment},
  {"unitY", &Dtool_LPoint2d_unit_y_282, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_unit_y_282_comment},
  {"normalized", &Dtool_LPoint2d_normalized_288, METH_NOARGS, (const char *)Dtool_LPoint2d_normalized_288_comment},
  {"project", &Dtool_LPoint2d_project_289, METH_O, (const char *)Dtool_LPoint2d_project_289_comment},
  {"get_class_type", &Dtool_LPoint2d_get_class_type_291, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_get_class_type_291_comment},
  {"getClassType", &Dtool_LPoint2d_get_class_type_291, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2d_get_class_type_291_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint2d_operator_284_nb_add(PyObject *self, PyObject *arg) {
  LPoint2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint2d LPoint2d::operator +(LVector2d const &other) const
    LVector2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2d *return_value = new LVecBase2d((*(const LPoint2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  {
    // -2 inline LPoint2d LPoint2d::operator +(LVector2d const &other) const
    LVector2d arg_local;
    LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2d *return_value = new LVecBase2d((*(const LPoint2d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint2d_operator_287_nb_divide(PyObject *self, PyObject *arg) {
  LPoint2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2d LPoint2d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint2d_operator_286_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2d LPoint2d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint2d_operator_283_nb_negative(PyObject *self) {
  LPoint2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2d LPoint2d::operator -(void) const
  LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint2d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint2d_operator_285_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint2d LPoint2d::operator -(LVector2d const &other) const
    LVector2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
    }
  }

  {
    // -2 inline LVector2d LPoint2d::operator -(LPoint2d const &other) const
    LPoint2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2d *return_value = new LVector2d((*(const LPoint2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const
    LVecBase2d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2d *return_value = new LVecBase2d((*(const LPoint2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  {
    // -2 inline LPoint2d LPoint2d::operator -(LVector2d const &other) const
    LVector2d arg_local;
    LVector2d const *arg_this = Dtool_Coerce_LVector2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
    }
  }

  {
    // -2 inline LVector2d LPoint2d::operator -(LPoint2d const &other) const
    LPoint2d arg_local;
    LPoint2d const *arg_this = Dtool_Coerce_LPoint2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2d *return_value = new LVector2d((*(const LPoint2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2d, true, false);
    }
  }

  {
    // -2 inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2d *return_value = new LVecBase2d((*(const LPoint2d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint2d_operator_287_nb_true_divide(PyObject *self, PyObject *arg) {
  LPoint2d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2d LPoint2d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint2d *return_value = new LPoint2d((*(const LPoint2d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint2d_getattr_278_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint2d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint2d_repr_290_tp_repr(PyObject *self) {
  LPoint2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint2d::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint2d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint2d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint2d_setattr_279_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint2d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint2d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint2d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyNumberMethods Dtool_NumberMethods_LPoint2d = {
  &Dtool_LPoint2d_operator_284_nb_add,
  &Dtool_LPoint2d_operator_285_nb_subtract,
  &Dtool_LPoint2d_operator_286_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint2d_operator_287_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint2d_operator_283_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LPoint2d_operator_287_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint2d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint2d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint2d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint2d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint2d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint2d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint2d_repr_290_tp_repr,
    &Dtool_NumberMethods_LPoint2d,
    &Dtool_SequenceMethods_LPoint2d,
    &Dtool_MappingMethods_LPoint2d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint2d_getattr_278_tp_getattro,
    &Dtool_LPoint2d_setattr_279_tp_setattro,
    &Dtool_BufferProcs_LPoint2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a two-component point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint2d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint2d,
    PyType_GenericAlloc,
    Dtool_new_LPoint2d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint2d,
  Dtool_UpcastInterface_LPoint2d,
  Dtool_DowncastInterface_LPoint2d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint2d,
};

static void Dtool_PyModuleClassInit_LPoint2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase2d(NULL);
    Dtool_LPoint2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase2d);
    PyObject *dict = PyDict_New();
    Dtool_LPoint2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint2d);
  }
}

/**
 * Python method tables for LPoint2i (LPoint2i)
 */
static PyMethodDef Dtool_Methods_LPoint2i[] = {
  {"zero", &Dtool_LPoint2i_zero_297, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_zero_297_comment},
  {"unit_x", &Dtool_LPoint2i_unit_x_298, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_unit_x_298_comment},
  {"unitX", &Dtool_LPoint2i_unit_x_298, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_unit_x_298_comment},
  {"unit_y", &Dtool_LPoint2i_unit_y_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_unit_y_299_comment},
  {"unitY", &Dtool_LPoint2i_unit_y_299, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_unit_y_299_comment},
  {"get_class_type", &Dtool_LPoint2i_get_class_type_306, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_get_class_type_306_comment},
  {"getClassType", &Dtool_LPoint2i_get_class_type_306, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint2i_get_class_type_306_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint2i_operator_301_nb_add(PyObject *self, PyObject *arg) {
  LPoint2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint2i LPoint2i::operator +(LVector2i const &other) const
    LVector2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2i *return_value = new LVecBase2i((*(const LPoint2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  {
    // -2 inline LPoint2i LPoint2i::operator +(LVector2i const &other) const
    LVector2i arg_local;
    LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2i *return_value = new LVecBase2i((*(const LPoint2i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint2i_operator_304_nb_divide(PyObject *self, PyObject *arg) {
  LPoint2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2i LPoint2i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint2i_operator_303_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint2i LPoint2i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint2i_operator_300_nb_negative(PyObject *self) {
  LPoint2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint2i LPoint2i::operator -(void) const
  LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint2i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint2i_operator_302_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint2i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint2i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint2i LPoint2i::operator -(LVector2i const &other) const
    LVector2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
    }
  }

  {
    // -2 inline LVector2i LPoint2i::operator -(LPoint2i const &other) const
    LPoint2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector2i *return_value = new LVector2i((*(const LPoint2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const
    LVecBase2i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase2i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase2i *return_value = new LVecBase2i((*(const LPoint2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  {
    // -2 inline LPoint2i LPoint2i::operator -(LVector2i const &other) const
    LVector2i arg_local;
    LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint2i *return_value = new LPoint2i((*(const LPoint2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, true, false);
    }
  }

  {
    // -2 inline LVector2i LPoint2i::operator -(LPoint2i const &other) const
    LPoint2i arg_local;
    LPoint2i const *arg_this = Dtool_Coerce_LPoint2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector2i *return_value = new LVector2i((*(const LPoint2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, true, false);
    }
  }

  {
    // -2 inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase2i *return_value = new LVecBase2i((*(const LPoint2i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint2i_getattr_295_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint2i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint2i_repr_305_tp_repr(PyObject *self) {
  LPoint2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint2i::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint2i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint2i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint2i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint2i_setattr_296_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint2i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint2i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint2i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint2i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyNumberMethods Dtool_NumberMethods_LPoint2i = {
  &Dtool_LPoint2i_operator_301_nb_add,
  &Dtool_LPoint2i_operator_302_nb_subtract,
  &Dtool_LPoint2i_operator_303_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint2i_operator_304_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint2i_operator_300_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint2i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint2i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint2i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint2i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint2i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint2i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint2i_repr_305_tp_repr,
    &Dtool_NumberMethods_LPoint2i,
    &Dtool_SequenceMethods_LPoint2i,
    &Dtool_MappingMethods_LPoint2i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint2i_getattr_295_tp_getattro,
    &Dtool_LPoint2i_setattr_296_tp_setattro,
    &Dtool_BufferProcs_LPoint2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a two-component point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint2i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint2i,
    PyType_GenericAlloc,
    Dtool_new_LPoint2i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint2i,
  Dtool_UpcastInterface_LPoint2i,
  Dtool_DowncastInterface_LPoint2i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint2i,
};

static void Dtool_PyModuleClassInit_LPoint2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase2i(NULL);
    Dtool_LPoint2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase2i);
    PyObject *dict = PyDict_New();
    Dtool_LPoint2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint2i);
  }
}

/**
 * Python method tables for LVecBase3f (LVecBase3f)
 */
static PyMethodDef Dtool_Methods_LVecBase3f[] = {
  {"assign", &Dtool_LVecBase3f_operator_314, METH_O, (const char *)Dtool_LVecBase3f_operator_314_comment},
  {"zero", &Dtool_LVecBase3f_zero_315, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_zero_315_comment},
  {"unit_x", &Dtool_LVecBase3f_unit_x_316, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_unit_x_316_comment},
  {"unitX", &Dtool_LVecBase3f_unit_x_316, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_unit_x_316_comment},
  {"unit_y", &Dtool_LVecBase3f_unit_y_317, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_unit_y_317_comment},
  {"unitY", &Dtool_LVecBase3f_unit_y_317, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_unit_y_317_comment},
  {"unit_z", &Dtool_LVecBase3f_unit_z_318, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_unit_z_318_comment},
  {"unitZ", &Dtool_LVecBase3f_unit_z_318, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_unit_z_318_comment},
  {"__reduce__", &Dtool_LVecBase3f_reduce_319, METH_NOARGS, (const char *)Dtool_LVecBase3f_reduce_319_comment},
  {"is_nan", &Dtool_LVecBase3f_is_nan_324, METH_NOARGS, (const char *)Dtool_LVecBase3f_is_nan_324_comment},
  {"isNan", &Dtool_LVecBase3f_is_nan_324, METH_NOARGS, (const char *)Dtool_LVecBase3f_is_nan_324_comment},
  {"get_cell", &Dtool_LVecBase3f_get_cell_325, METH_O, (const char *)Dtool_LVecBase3f_get_cell_325_comment},
  {"getCell", &Dtool_LVecBase3f_get_cell_325, METH_O, (const char *)Dtool_LVecBase3f_get_cell_325_comment},
  {"get_x", &Dtool_LVecBase3f_get_x_326, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_x_326_comment},
  {"getX", &Dtool_LVecBase3f_get_x_326, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_x_326_comment},
  {"get_y", &Dtool_LVecBase3f_get_y_327, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_y_327_comment},
  {"getY", &Dtool_LVecBase3f_get_y_327, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_y_327_comment},
  {"get_z", &Dtool_LVecBase3f_get_z_328, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_z_328_comment},
  {"getZ", &Dtool_LVecBase3f_get_z_328, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_z_328_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase3f_set_cell_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_set_cell_329_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase3f_set_cell_329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_set_cell_329_comment},
  {"set_x", &Dtool_LVecBase3f_set_x_330, METH_O, (const char *)Dtool_LVecBase3f_set_x_330_comment},
  {"setX", &Dtool_LVecBase3f_set_x_330, METH_O, (const char *)Dtool_LVecBase3f_set_x_330_comment},
  {"set_y", &Dtool_LVecBase3f_set_y_331, METH_O, (const char *)Dtool_LVecBase3f_set_y_331_comment},
  {"setY", &Dtool_LVecBase3f_set_y_331, METH_O, (const char *)Dtool_LVecBase3f_set_y_331_comment},
  {"set_z", &Dtool_LVecBase3f_set_z_332, METH_O, (const char *)Dtool_LVecBase3f_set_z_332_comment},
  {"setZ", &Dtool_LVecBase3f_set_z_332, METH_O, (const char *)Dtool_LVecBase3f_set_z_332_comment},
  {"get_xy", &Dtool_LVecBase3f_get_xy_333, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_xy_333_comment},
  {"getXy", &Dtool_LVecBase3f_get_xy_333, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_xy_333_comment},
  {"get_xz", &Dtool_LVecBase3f_get_xz_334, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_xz_334_comment},
  {"getXz", &Dtool_LVecBase3f_get_xz_334, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_xz_334_comment},
  {"get_yz", &Dtool_LVecBase3f_get_yz_335, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_yz_335_comment},
  {"getYz", &Dtool_LVecBase3f_get_yz_335, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_yz_335_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase3f_add_to_cell_342, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_add_to_cell_342_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase3f_add_to_cell_342, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_add_to_cell_342_comment},
  {"add_x", &Dtool_LVecBase3f_add_x_343, METH_O, (const char *)Dtool_LVecBase3f_add_x_343_comment},
  {"addX", &Dtool_LVecBase3f_add_x_343, METH_O, (const char *)Dtool_LVecBase3f_add_x_343_comment},
  {"add_y", &Dtool_LVecBase3f_add_y_344, METH_O, (const char *)Dtool_LVecBase3f_add_y_344_comment},
  {"addY", &Dtool_LVecBase3f_add_y_344, METH_O, (const char *)Dtool_LVecBase3f_add_y_344_comment},
  {"add_z", &Dtool_LVecBase3f_add_z_345, METH_O, (const char *)Dtool_LVecBase3f_add_z_345_comment},
  {"addZ", &Dtool_LVecBase3f_add_z_345, METH_O, (const char *)Dtool_LVecBase3f_add_z_345_comment},
  {"get_num_components", &Dtool_LVecBase3f_get_num_components_347, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_get_num_components_347_comment},
  {"getNumComponents", &Dtool_LVecBase3f_get_num_components_347, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_get_num_components_347_comment},
  {"fill", &Dtool_LVecBase3f_fill_348, METH_O, (const char *)Dtool_LVecBase3f_fill_348_comment},
  {"set", (PyCFunction) &Dtool_LVecBase3f_set_349, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_set_349_comment},
  {"dot", &Dtool_LVecBase3f_dot_350, METH_O, (const char *)Dtool_LVecBase3f_dot_350_comment},
  {"length_squared", &Dtool_LVecBase3f_length_squared_351, METH_NOARGS, (const char *)Dtool_LVecBase3f_length_squared_351_comment},
  {"lengthSquared", &Dtool_LVecBase3f_length_squared_351, METH_NOARGS, (const char *)Dtool_LVecBase3f_length_squared_351_comment},
  {"length", &Dtool_LVecBase3f_length_352, METH_NOARGS, (const char *)Dtool_LVecBase3f_length_352_comment},
  {"normalize", &Dtool_LVecBase3f_normalize_353, METH_NOARGS, (const char *)Dtool_LVecBase3f_normalize_353_comment},
  {"normalized", &Dtool_LVecBase3f_normalized_354, METH_NOARGS, (const char *)Dtool_LVecBase3f_normalized_354_comment},
  {"project", &Dtool_LVecBase3f_project_355, METH_O, (const char *)Dtool_LVecBase3f_project_355_comment},
  {"cross", &Dtool_LVecBase3f_cross_356, METH_O, (const char *)Dtool_LVecBase3f_cross_356_comment},
  {"get_standardized_hpr", &Dtool_LVecBase3f_get_standardized_hpr_360, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_standardized_hpr_360_comment},
  {"getStandardizedHpr", &Dtool_LVecBase3f_get_standardized_hpr_360, METH_NOARGS, (const char *)Dtool_LVecBase3f_get_standardized_hpr_360_comment},
  {"compare_to", &Dtool_LVecBase3f_compare_to_361, METH_VARARGS, (const char *)Dtool_LVecBase3f_compare_to_361_comment},
  {"compareTo", &Dtool_LVecBase3f_compare_to_361, METH_VARARGS, (const char *)Dtool_LVecBase3f_compare_to_361_comment},
  {"get_hash", &Dtool_LVecBase3f_get_hash_362, METH_VARARGS, (const char *)Dtool_LVecBase3f_get_hash_362_comment},
  {"getHash", &Dtool_LVecBase3f_get_hash_362, METH_VARARGS, (const char *)Dtool_LVecBase3f_get_hash_362_comment},
  {"add_hash", (PyCFunction) &Dtool_LVecBase3f_add_hash_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_add_hash_363_comment},
  {"addHash", (PyCFunction) &Dtool_LVecBase3f_add_hash_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_add_hash_363_comment},
  {"componentwise_mult", &Dtool_LVecBase3f_componentwise_mult_374, METH_O, (const char *)Dtool_LVecBase3f_componentwise_mult_374_comment},
  {"componentwiseMult", &Dtool_LVecBase3f_componentwise_mult_374, METH_O, (const char *)Dtool_LVecBase3f_componentwise_mult_374_comment},
  {"fmax", &Dtool_LVecBase3f_fmax_377, METH_O, (const char *)Dtool_LVecBase3f_fmax_377_comment},
  {"fmin", &Dtool_LVecBase3f_fmin_378, METH_O, (const char *)Dtool_LVecBase3f_fmin_378_comment},
  {"cross_into", &Dtool_LVecBase3f_cross_into_379, METH_O, (const char *)Dtool_LVecBase3f_cross_into_379_comment},
  {"crossInto", &Dtool_LVecBase3f_cross_into_379, METH_O, (const char *)Dtool_LVecBase3f_cross_into_379_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase3f_almost_equal_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_almost_equal_380_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase3f_almost_equal_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3f_almost_equal_380_comment},
  {"output", &Dtool_LVecBase3f_output_381, METH_O, (const char *)Dtool_LVecBase3f_output_381_comment},
  {"write_datagram_fixed", &Dtool_LVecBase3f_write_datagram_fixed_383, METH_O, (const char *)Dtool_LVecBase3f_write_datagram_fixed_383_comment},
  {"writeDatagramFixed", &Dtool_LVecBase3f_write_datagram_fixed_383, METH_O, (const char *)Dtool_LVecBase3f_write_datagram_fixed_383_comment},
  {"read_datagram_fixed", &Dtool_LVecBase3f_read_datagram_fixed_384, METH_O, (const char *)Dtool_LVecBase3f_read_datagram_fixed_384_comment},
  {"readDatagramFixed", &Dtool_LVecBase3f_read_datagram_fixed_384, METH_O, (const char *)Dtool_LVecBase3f_read_datagram_fixed_384_comment},
  {"write_datagram", &Dtool_LVecBase3f_write_datagram_385, METH_O, (const char *)Dtool_LVecBase3f_write_datagram_385_comment},
  {"writeDatagram", &Dtool_LVecBase3f_write_datagram_385, METH_O, (const char *)Dtool_LVecBase3f_write_datagram_385_comment},
  {"read_datagram", &Dtool_LVecBase3f_read_datagram_386, METH_O, (const char *)Dtool_LVecBase3f_read_datagram_386_comment},
  {"readDatagram", &Dtool_LVecBase3f_read_datagram_386, METH_O, (const char *)Dtool_LVecBase3f_read_datagram_386_comment},
  {"get_class_type", &Dtool_LVecBase3f_get_class_type_387, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_get_class_type_387_comment},
  {"getClassType", &Dtool_LVecBase3f_get_class_type_387, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3f_get_class_type_387_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase3f_operator_366_nb_add(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.__add__", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase3f_operator_369_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3f LVecBase3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase3f_operator_370_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3f::operator +=(LVecBase3f const &other)
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.__iadd__", "LVecBase3f");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3f.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase3f_operator_373_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase3f_operator_372_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3f::operator *=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3f.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase3f_ipow_376_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent)
      if (PyNumber_Check(arg)) {
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, (float)PyFloat_AsDouble(arg));
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase3f.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase3f self, float exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase3f_operator_371_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3f::operator -=(LVecBase3f const &other)
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.__isub__", "LVecBase3f");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3f.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase3f_operator_373_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase3f_operator_368_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3f LVecBase3f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase3f_operator_365_nb_negative(PyObject *self) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3f LVecBase3f::operator -(void) const
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase3f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase3f_pow_375_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase3f LVecBase3f::__pow__(float exponent) const
    if (PyNumber_Check(arg)) {
      LVecBase3f *return_value = new LVecBase3f(invoke_extension((const LVecBase3f*)local_this).__pow__((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase3f self, float exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase3f_operator_367_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.__sub__", "LVecBase3f");
  }
  LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase3f_operator_369_nb_true_divide(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3f LVecBase3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase3f *return_value = new LVecBase3f((*(const LVecBase3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase3f_operator_322_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase3f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float &LVecBase3f::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = (float)PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase3f.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase3f self, index, float assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase3f_operator_322_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase3f index out of range");
    return NULL;
  }
  // 1-inline float LVecBase3f::operator [](int i) const
  float return_value = (*(const LVecBase3f*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase3f self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase3f_size_323_sq_length(PyObject *self) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase3f_compare_to_361_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase3f::compare_to(LVecBase3f const &other) const
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3f.compare_to", "LVecBase3f");
    return -1;
  }
  int return_value = (*(const LVecBase3f*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase3f self, const LVecBase3f other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase3f_getattr_320_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase3f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase3f_get_hash_362_tp_hash(PyObject *self) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase3f_repr_382_tp_repr(PyObject *self) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase3f::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase3f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase3f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase3f_setattr_321_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase3f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase3f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase3f
//////////////////
static PyObject *Dtool_RichCompare_LVecBase3f(PyObject *self, PyObject *arg, int op) {
  LVecBase3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3f, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase3f::operator <(LVecBase3f const &other) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3f*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase3f::operator ==(LVecBase3f const &other) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3f*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase3f::operator !=(LVecBase3f const &other) const
      LVecBase3f arg_local;
      LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3f*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase3f_compare_to_361_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase3f[] = {
  {(char *)"x", &Dtool_LVecBase3f_x_Getter, &Dtool_LVecBase3f_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase3f_y_Getter, &Dtool_LVecBase3f_y_Setter, NULL, NULL},
  {(char *)"z", &Dtool_LVecBase3f_z_Getter, &Dtool_LVecBase3f_z_Setter, NULL, NULL},
  {(char *)"xy", &Dtool_LVecBase3f_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LVecBase3f_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LVecBase3f_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase3f = {
  &Dtool_LVecBase3f_operator_366_nb_add,
  &Dtool_LVecBase3f_operator_367_nb_subtract,
  &Dtool_LVecBase3f_operator_368_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase3f_operator_369_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase3f_pow_375_nb_power,
  &Dtool_LVecBase3f_operator_365_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase3f_operator_370_nb_inplace_add,
  &Dtool_LVecBase3f_operator_371_nb_inplace_subtract,
  &Dtool_LVecBase3f_operator_372_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase3f_operator_373_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase3f_ipow_376_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase3f_operator_369_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase3f_operator_373_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase3f = {
  &Dtool_LVecBase3f_size_323_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase3f_operator_322_sq_item,
  0, // sq_slice
  &Dtool_LVecBase3f_operator_322_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase3f_compare_to_361_tp_compare,
#endif
    &Dtool_LVecBase3f_repr_382_tp_repr,
    &Dtool_NumberMethods_LVecBase3f,
    &Dtool_SequenceMethods_LVecBase3f,
    0, // tp_as_mapping
    &Dtool_LVecBase3f_get_hash_362_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase3f_getattr_320_tp_getattro,
    &Dtool_LVecBase3f_setattr_321_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all three-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase3f,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase3f,
    0, // tp_members
    Dtool_Properties_LVecBase3f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_LVecBase3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase3f,
  Dtool_UpcastInterface_LVecBase3f,
  Dtool_DowncastInterface_LVecBase3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase3f,
};

static void Dtool_PyModuleClassInit_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase3f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase3f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase3f::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase3f::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase3f);
  }
}

/**
 * Python method tables for LVecBase3d (LVecBase3d)
 */
static PyMethodDef Dtool_Methods_LVecBase3d[] = {
  {"assign", &Dtool_LVecBase3d_operator_395, METH_O, (const char *)Dtool_LVecBase3d_operator_395_comment},
  {"zero", &Dtool_LVecBase3d_zero_396, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_zero_396_comment},
  {"unit_x", &Dtool_LVecBase3d_unit_x_397, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_unit_x_397_comment},
  {"unitX", &Dtool_LVecBase3d_unit_x_397, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_unit_x_397_comment},
  {"unit_y", &Dtool_LVecBase3d_unit_y_398, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_unit_y_398_comment},
  {"unitY", &Dtool_LVecBase3d_unit_y_398, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_unit_y_398_comment},
  {"unit_z", &Dtool_LVecBase3d_unit_z_399, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_unit_z_399_comment},
  {"unitZ", &Dtool_LVecBase3d_unit_z_399, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_unit_z_399_comment},
  {"__reduce__", &Dtool_LVecBase3d_reduce_400, METH_NOARGS, (const char *)Dtool_LVecBase3d_reduce_400_comment},
  {"is_nan", &Dtool_LVecBase3d_is_nan_405, METH_NOARGS, (const char *)Dtool_LVecBase3d_is_nan_405_comment},
  {"isNan", &Dtool_LVecBase3d_is_nan_405, METH_NOARGS, (const char *)Dtool_LVecBase3d_is_nan_405_comment},
  {"get_cell", &Dtool_LVecBase3d_get_cell_406, METH_O, (const char *)Dtool_LVecBase3d_get_cell_406_comment},
  {"getCell", &Dtool_LVecBase3d_get_cell_406, METH_O, (const char *)Dtool_LVecBase3d_get_cell_406_comment},
  {"get_x", &Dtool_LVecBase3d_get_x_407, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_x_407_comment},
  {"getX", &Dtool_LVecBase3d_get_x_407, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_x_407_comment},
  {"get_y", &Dtool_LVecBase3d_get_y_408, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_y_408_comment},
  {"getY", &Dtool_LVecBase3d_get_y_408, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_y_408_comment},
  {"get_z", &Dtool_LVecBase3d_get_z_409, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_z_409_comment},
  {"getZ", &Dtool_LVecBase3d_get_z_409, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_z_409_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase3d_set_cell_410, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_set_cell_410_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase3d_set_cell_410, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_set_cell_410_comment},
  {"set_x", &Dtool_LVecBase3d_set_x_411, METH_O, (const char *)Dtool_LVecBase3d_set_x_411_comment},
  {"setX", &Dtool_LVecBase3d_set_x_411, METH_O, (const char *)Dtool_LVecBase3d_set_x_411_comment},
  {"set_y", &Dtool_LVecBase3d_set_y_412, METH_O, (const char *)Dtool_LVecBase3d_set_y_412_comment},
  {"setY", &Dtool_LVecBase3d_set_y_412, METH_O, (const char *)Dtool_LVecBase3d_set_y_412_comment},
  {"set_z", &Dtool_LVecBase3d_set_z_413, METH_O, (const char *)Dtool_LVecBase3d_set_z_413_comment},
  {"setZ", &Dtool_LVecBase3d_set_z_413, METH_O, (const char *)Dtool_LVecBase3d_set_z_413_comment},
  {"get_xy", &Dtool_LVecBase3d_get_xy_414, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_xy_414_comment},
  {"getXy", &Dtool_LVecBase3d_get_xy_414, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_xy_414_comment},
  {"get_xz", &Dtool_LVecBase3d_get_xz_415, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_xz_415_comment},
  {"getXz", &Dtool_LVecBase3d_get_xz_415, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_xz_415_comment},
  {"get_yz", &Dtool_LVecBase3d_get_yz_416, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_yz_416_comment},
  {"getYz", &Dtool_LVecBase3d_get_yz_416, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_yz_416_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase3d_add_to_cell_423, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_add_to_cell_423_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase3d_add_to_cell_423, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_add_to_cell_423_comment},
  {"add_x", &Dtool_LVecBase3d_add_x_424, METH_O, (const char *)Dtool_LVecBase3d_add_x_424_comment},
  {"addX", &Dtool_LVecBase3d_add_x_424, METH_O, (const char *)Dtool_LVecBase3d_add_x_424_comment},
  {"add_y", &Dtool_LVecBase3d_add_y_425, METH_O, (const char *)Dtool_LVecBase3d_add_y_425_comment},
  {"addY", &Dtool_LVecBase3d_add_y_425, METH_O, (const char *)Dtool_LVecBase3d_add_y_425_comment},
  {"add_z", &Dtool_LVecBase3d_add_z_426, METH_O, (const char *)Dtool_LVecBase3d_add_z_426_comment},
  {"addZ", &Dtool_LVecBase3d_add_z_426, METH_O, (const char *)Dtool_LVecBase3d_add_z_426_comment},
  {"get_num_components", &Dtool_LVecBase3d_get_num_components_428, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_get_num_components_428_comment},
  {"getNumComponents", &Dtool_LVecBase3d_get_num_components_428, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_get_num_components_428_comment},
  {"fill", &Dtool_LVecBase3d_fill_429, METH_O, (const char *)Dtool_LVecBase3d_fill_429_comment},
  {"set", (PyCFunction) &Dtool_LVecBase3d_set_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_set_430_comment},
  {"dot", &Dtool_LVecBase3d_dot_431, METH_O, (const char *)Dtool_LVecBase3d_dot_431_comment},
  {"length_squared", &Dtool_LVecBase3d_length_squared_432, METH_NOARGS, (const char *)Dtool_LVecBase3d_length_squared_432_comment},
  {"lengthSquared", &Dtool_LVecBase3d_length_squared_432, METH_NOARGS, (const char *)Dtool_LVecBase3d_length_squared_432_comment},
  {"length", &Dtool_LVecBase3d_length_433, METH_NOARGS, (const char *)Dtool_LVecBase3d_length_433_comment},
  {"normalize", &Dtool_LVecBase3d_normalize_434, METH_NOARGS, (const char *)Dtool_LVecBase3d_normalize_434_comment},
  {"normalized", &Dtool_LVecBase3d_normalized_435, METH_NOARGS, (const char *)Dtool_LVecBase3d_normalized_435_comment},
  {"project", &Dtool_LVecBase3d_project_436, METH_O, (const char *)Dtool_LVecBase3d_project_436_comment},
  {"cross", &Dtool_LVecBase3d_cross_437, METH_O, (const char *)Dtool_LVecBase3d_cross_437_comment},
  {"get_standardized_hpr", &Dtool_LVecBase3d_get_standardized_hpr_441, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_standardized_hpr_441_comment},
  {"getStandardizedHpr", &Dtool_LVecBase3d_get_standardized_hpr_441, METH_NOARGS, (const char *)Dtool_LVecBase3d_get_standardized_hpr_441_comment},
  {"compare_to", &Dtool_LVecBase3d_compare_to_442, METH_VARARGS, (const char *)Dtool_LVecBase3d_compare_to_442_comment},
  {"compareTo", &Dtool_LVecBase3d_compare_to_442, METH_VARARGS, (const char *)Dtool_LVecBase3d_compare_to_442_comment},
  {"get_hash", &Dtool_LVecBase3d_get_hash_443, METH_VARARGS, (const char *)Dtool_LVecBase3d_get_hash_443_comment},
  {"getHash", &Dtool_LVecBase3d_get_hash_443, METH_VARARGS, (const char *)Dtool_LVecBase3d_get_hash_443_comment},
  {"add_hash", (PyCFunction) &Dtool_LVecBase3d_add_hash_444, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_add_hash_444_comment},
  {"addHash", (PyCFunction) &Dtool_LVecBase3d_add_hash_444, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_add_hash_444_comment},
  {"componentwise_mult", &Dtool_LVecBase3d_componentwise_mult_455, METH_O, (const char *)Dtool_LVecBase3d_componentwise_mult_455_comment},
  {"componentwiseMult", &Dtool_LVecBase3d_componentwise_mult_455, METH_O, (const char *)Dtool_LVecBase3d_componentwise_mult_455_comment},
  {"fmax", &Dtool_LVecBase3d_fmax_458, METH_O, (const char *)Dtool_LVecBase3d_fmax_458_comment},
  {"fmin", &Dtool_LVecBase3d_fmin_459, METH_O, (const char *)Dtool_LVecBase3d_fmin_459_comment},
  {"cross_into", &Dtool_LVecBase3d_cross_into_460, METH_O, (const char *)Dtool_LVecBase3d_cross_into_460_comment},
  {"crossInto", &Dtool_LVecBase3d_cross_into_460, METH_O, (const char *)Dtool_LVecBase3d_cross_into_460_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase3d_almost_equal_461, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_almost_equal_461_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase3d_almost_equal_461, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3d_almost_equal_461_comment},
  {"output", &Dtool_LVecBase3d_output_462, METH_O, (const char *)Dtool_LVecBase3d_output_462_comment},
  {"write_datagram_fixed", &Dtool_LVecBase3d_write_datagram_fixed_464, METH_O, (const char *)Dtool_LVecBase3d_write_datagram_fixed_464_comment},
  {"writeDatagramFixed", &Dtool_LVecBase3d_write_datagram_fixed_464, METH_O, (const char *)Dtool_LVecBase3d_write_datagram_fixed_464_comment},
  {"read_datagram_fixed", &Dtool_LVecBase3d_read_datagram_fixed_465, METH_O, (const char *)Dtool_LVecBase3d_read_datagram_fixed_465_comment},
  {"readDatagramFixed", &Dtool_LVecBase3d_read_datagram_fixed_465, METH_O, (const char *)Dtool_LVecBase3d_read_datagram_fixed_465_comment},
  {"write_datagram", &Dtool_LVecBase3d_write_datagram_466, METH_O, (const char *)Dtool_LVecBase3d_write_datagram_466_comment},
  {"writeDatagram", &Dtool_LVecBase3d_write_datagram_466, METH_O, (const char *)Dtool_LVecBase3d_write_datagram_466_comment},
  {"read_datagram", &Dtool_LVecBase3d_read_datagram_467, METH_O, (const char *)Dtool_LVecBase3d_read_datagram_467_comment},
  {"readDatagram", &Dtool_LVecBase3d_read_datagram_467, METH_O, (const char *)Dtool_LVecBase3d_read_datagram_467_comment},
  {"get_class_type", &Dtool_LVecBase3d_get_class_type_468, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_get_class_type_468_comment},
  {"getClassType", &Dtool_LVecBase3d_get_class_type_468, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3d_get_class_type_468_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase3d_operator_447_nb_add(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.__add__", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase3d_operator_450_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3d LVecBase3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase3d_operator_451_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3d::operator +=(LVecBase3d const &other)
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.__iadd__", "LVecBase3d");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3d.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase3d_operator_454_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase3d_operator_453_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3d::operator *=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3d.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase3d_ipow_457_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent)
      if (PyNumber_Check(arg)) {
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, PyFloat_AsDouble(arg));
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase3d.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase3d self, double exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase3d_operator_452_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3d::operator -=(LVecBase3d const &other)
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.__isub__", "LVecBase3d");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3d.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase3d_operator_454_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase3d_operator_449_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3d LVecBase3d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase3d_operator_446_nb_negative(PyObject *self) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3d LVecBase3d::operator -(void) const
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase3d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase3d_pow_456_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase3d LVecBase3d::__pow__(double exponent) const
    if (PyNumber_Check(arg)) {
      LVecBase3d *return_value = new LVecBase3d(invoke_extension((const LVecBase3d*)local_this).__pow__(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase3d self, double exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase3d_operator_448_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.__sub__", "LVecBase3d");
  }
  LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase3d_operator_450_nb_true_divide(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3d LVecBase3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase3d *return_value = new LVecBase3d((*(const LVecBase3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase3d_operator_403_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase3d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double &LVecBase3d::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase3d.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase3d self, index, double assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase3d_operator_403_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase3d index out of range");
    return NULL;
  }
  // 1-inline double LVecBase3d::operator [](int i) const
  double return_value = (*(const LVecBase3d*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase3d self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase3d_size_404_sq_length(PyObject *self) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase3d_compare_to_442_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase3d::compare_to(LVecBase3d const &other) const
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3d.compare_to", "LVecBase3d");
    return -1;
  }
  int return_value = (*(const LVecBase3d*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase3d self, const LVecBase3d other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase3d_getattr_401_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase3d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase3d_get_hash_443_tp_hash(PyObject *self) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase3d_repr_463_tp_repr(PyObject *self) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase3d::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase3d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase3d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase3d_setattr_402_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase3d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase3d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase3d
//////////////////
static PyObject *Dtool_RichCompare_LVecBase3d(PyObject *self, PyObject *arg, int op) {
  LVecBase3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3d, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase3d::operator <(LVecBase3d const &other) const
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3d*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase3d::operator ==(LVecBase3d const &other) const
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3d*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase3d::operator !=(LVecBase3d const &other) const
      LVecBase3d arg_local;
      LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3d*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase3d_compare_to_442_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase3d[] = {
  {(char *)"x", &Dtool_LVecBase3d_x_Getter, &Dtool_LVecBase3d_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase3d_y_Getter, &Dtool_LVecBase3d_y_Setter, NULL, NULL},
  {(char *)"z", &Dtool_LVecBase3d_z_Getter, &Dtool_LVecBase3d_z_Setter, NULL, NULL},
  {(char *)"xy", &Dtool_LVecBase3d_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LVecBase3d_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LVecBase3d_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase3d = {
  &Dtool_LVecBase3d_operator_447_nb_add,
  &Dtool_LVecBase3d_operator_448_nb_subtract,
  &Dtool_LVecBase3d_operator_449_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase3d_operator_450_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase3d_pow_456_nb_power,
  &Dtool_LVecBase3d_operator_446_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase3d_operator_451_nb_inplace_add,
  &Dtool_LVecBase3d_operator_452_nb_inplace_subtract,
  &Dtool_LVecBase3d_operator_453_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase3d_operator_454_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase3d_ipow_457_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase3d_operator_450_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase3d_operator_454_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase3d = {
  &Dtool_LVecBase3d_size_404_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase3d_operator_403_sq_item,
  0, // sq_slice
  &Dtool_LVecBase3d_operator_403_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase3d_compare_to_442_tp_compare,
#endif
    &Dtool_LVecBase3d_repr_463_tp_repr,
    &Dtool_NumberMethods_LVecBase3d,
    &Dtool_SequenceMethods_LVecBase3d,
    0, // tp_as_mapping
    &Dtool_LVecBase3d_get_hash_443_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase3d_getattr_401_tp_getattro,
    &Dtool_LVecBase3d_setattr_402_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all three-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase3d,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase3d,
    0, // tp_members
    Dtool_Properties_LVecBase3d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_LVecBase3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase3d,
  Dtool_UpcastInterface_LVecBase3d,
  Dtool_DowncastInterface_LVecBase3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase3d,
};

static void Dtool_PyModuleClassInit_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase3d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase3d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase3d::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase3d::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase3d);
  }
}

/**
 * Python method tables for LVecBase3i (LVecBase3i)
 */
static PyMethodDef Dtool_Methods_LVecBase3i[] = {
  {"assign", &Dtool_LVecBase3i_operator_476, METH_O, (const char *)Dtool_LVecBase3i_operator_476_comment},
  {"zero", &Dtool_LVecBase3i_zero_477, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_zero_477_comment},
  {"unit_x", &Dtool_LVecBase3i_unit_x_478, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_unit_x_478_comment},
  {"unitX", &Dtool_LVecBase3i_unit_x_478, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_unit_x_478_comment},
  {"unit_y", &Dtool_LVecBase3i_unit_y_479, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_unit_y_479_comment},
  {"unitY", &Dtool_LVecBase3i_unit_y_479, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_unit_y_479_comment},
  {"unit_z", &Dtool_LVecBase3i_unit_z_480, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_unit_z_480_comment},
  {"unitZ", &Dtool_LVecBase3i_unit_z_480, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_unit_z_480_comment},
  {"__reduce__", &Dtool_LVecBase3i_reduce_481, METH_NOARGS, (const char *)Dtool_LVecBase3i_reduce_481_comment},
  {"is_nan", &Dtool_LVecBase3i_is_nan_486, METH_NOARGS, (const char *)Dtool_LVecBase3i_is_nan_486_comment},
  {"isNan", &Dtool_LVecBase3i_is_nan_486, METH_NOARGS, (const char *)Dtool_LVecBase3i_is_nan_486_comment},
  {"get_cell", &Dtool_LVecBase3i_get_cell_487, METH_O, (const char *)Dtool_LVecBase3i_get_cell_487_comment},
  {"getCell", &Dtool_LVecBase3i_get_cell_487, METH_O, (const char *)Dtool_LVecBase3i_get_cell_487_comment},
  {"get_x", &Dtool_LVecBase3i_get_x_488, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_x_488_comment},
  {"getX", &Dtool_LVecBase3i_get_x_488, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_x_488_comment},
  {"get_y", &Dtool_LVecBase3i_get_y_489, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_y_489_comment},
  {"getY", &Dtool_LVecBase3i_get_y_489, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_y_489_comment},
  {"get_z", &Dtool_LVecBase3i_get_z_490, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_z_490_comment},
  {"getZ", &Dtool_LVecBase3i_get_z_490, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_z_490_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase3i_set_cell_491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_set_cell_491_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase3i_set_cell_491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_set_cell_491_comment},
  {"set_x", &Dtool_LVecBase3i_set_x_492, METH_O, (const char *)Dtool_LVecBase3i_set_x_492_comment},
  {"setX", &Dtool_LVecBase3i_set_x_492, METH_O, (const char *)Dtool_LVecBase3i_set_x_492_comment},
  {"set_y", &Dtool_LVecBase3i_set_y_493, METH_O, (const char *)Dtool_LVecBase3i_set_y_493_comment},
  {"setY", &Dtool_LVecBase3i_set_y_493, METH_O, (const char *)Dtool_LVecBase3i_set_y_493_comment},
  {"set_z", &Dtool_LVecBase3i_set_z_494, METH_O, (const char *)Dtool_LVecBase3i_set_z_494_comment},
  {"setZ", &Dtool_LVecBase3i_set_z_494, METH_O, (const char *)Dtool_LVecBase3i_set_z_494_comment},
  {"get_xy", &Dtool_LVecBase3i_get_xy_495, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_xy_495_comment},
  {"getXy", &Dtool_LVecBase3i_get_xy_495, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_xy_495_comment},
  {"get_xz", &Dtool_LVecBase3i_get_xz_496, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_xz_496_comment},
  {"getXz", &Dtool_LVecBase3i_get_xz_496, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_xz_496_comment},
  {"get_yz", &Dtool_LVecBase3i_get_yz_497, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_yz_497_comment},
  {"getYz", &Dtool_LVecBase3i_get_yz_497, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_yz_497_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase3i_add_to_cell_504, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_add_to_cell_504_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase3i_add_to_cell_504, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_add_to_cell_504_comment},
  {"add_x", &Dtool_LVecBase3i_add_x_505, METH_O, (const char *)Dtool_LVecBase3i_add_x_505_comment},
  {"addX", &Dtool_LVecBase3i_add_x_505, METH_O, (const char *)Dtool_LVecBase3i_add_x_505_comment},
  {"add_y", &Dtool_LVecBase3i_add_y_506, METH_O, (const char *)Dtool_LVecBase3i_add_y_506_comment},
  {"addY", &Dtool_LVecBase3i_add_y_506, METH_O, (const char *)Dtool_LVecBase3i_add_y_506_comment},
  {"add_z", &Dtool_LVecBase3i_add_z_507, METH_O, (const char *)Dtool_LVecBase3i_add_z_507_comment},
  {"addZ", &Dtool_LVecBase3i_add_z_507, METH_O, (const char *)Dtool_LVecBase3i_add_z_507_comment},
  {"get_num_components", &Dtool_LVecBase3i_get_num_components_509, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_get_num_components_509_comment},
  {"getNumComponents", &Dtool_LVecBase3i_get_num_components_509, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_get_num_components_509_comment},
  {"fill", &Dtool_LVecBase3i_fill_510, METH_O, (const char *)Dtool_LVecBase3i_fill_510_comment},
  {"set", (PyCFunction) &Dtool_LVecBase3i_set_511, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_set_511_comment},
  {"dot", &Dtool_LVecBase3i_dot_512, METH_O, (const char *)Dtool_LVecBase3i_dot_512_comment},
  {"length_squared", &Dtool_LVecBase3i_length_squared_513, METH_NOARGS, (const char *)Dtool_LVecBase3i_length_squared_513_comment},
  {"lengthSquared", &Dtool_LVecBase3i_length_squared_513, METH_NOARGS, (const char *)Dtool_LVecBase3i_length_squared_513_comment},
  {"cross", &Dtool_LVecBase3i_cross_514, METH_O, (const char *)Dtool_LVecBase3i_cross_514_comment},
  {"compare_to", &Dtool_LVecBase3i_compare_to_518, METH_O, (const char *)Dtool_LVecBase3i_compare_to_518_comment},
  {"compareTo", &Dtool_LVecBase3i_compare_to_518, METH_O, (const char *)Dtool_LVecBase3i_compare_to_518_comment},
  {"get_hash", &Dtool_LVecBase3i_get_hash_519, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_hash_519_comment},
  {"getHash", &Dtool_LVecBase3i_get_hash_519, METH_NOARGS, (const char *)Dtool_LVecBase3i_get_hash_519_comment},
  {"add_hash", &Dtool_LVecBase3i_add_hash_520, METH_O, (const char *)Dtool_LVecBase3i_add_hash_520_comment},
  {"addHash", &Dtool_LVecBase3i_add_hash_520, METH_O, (const char *)Dtool_LVecBase3i_add_hash_520_comment},
  {"componentwise_mult", &Dtool_LVecBase3i_componentwise_mult_531, METH_O, (const char *)Dtool_LVecBase3i_componentwise_mult_531_comment},
  {"componentwiseMult", &Dtool_LVecBase3i_componentwise_mult_531, METH_O, (const char *)Dtool_LVecBase3i_componentwise_mult_531_comment},
  {"fmax", &Dtool_LVecBase3i_fmax_534, METH_O, (const char *)Dtool_LVecBase3i_fmax_534_comment},
  {"fmin", &Dtool_LVecBase3i_fmin_535, METH_O, (const char *)Dtool_LVecBase3i_fmin_535_comment},
  {"cross_into", &Dtool_LVecBase3i_cross_into_536, METH_O, (const char *)Dtool_LVecBase3i_cross_into_536_comment},
  {"crossInto", &Dtool_LVecBase3i_cross_into_536, METH_O, (const char *)Dtool_LVecBase3i_cross_into_536_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase3i_almost_equal_537, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_almost_equal_537_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase3i_almost_equal_537, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase3i_almost_equal_537_comment},
  {"output", &Dtool_LVecBase3i_output_538, METH_O, (const char *)Dtool_LVecBase3i_output_538_comment},
  {"write_datagram_fixed", &Dtool_LVecBase3i_write_datagram_fixed_540, METH_O, (const char *)Dtool_LVecBase3i_write_datagram_fixed_540_comment},
  {"writeDatagramFixed", &Dtool_LVecBase3i_write_datagram_fixed_540, METH_O, (const char *)Dtool_LVecBase3i_write_datagram_fixed_540_comment},
  {"read_datagram_fixed", &Dtool_LVecBase3i_read_datagram_fixed_541, METH_O, (const char *)Dtool_LVecBase3i_read_datagram_fixed_541_comment},
  {"readDatagramFixed", &Dtool_LVecBase3i_read_datagram_fixed_541, METH_O, (const char *)Dtool_LVecBase3i_read_datagram_fixed_541_comment},
  {"write_datagram", &Dtool_LVecBase3i_write_datagram_542, METH_O, (const char *)Dtool_LVecBase3i_write_datagram_542_comment},
  {"writeDatagram", &Dtool_LVecBase3i_write_datagram_542, METH_O, (const char *)Dtool_LVecBase3i_write_datagram_542_comment},
  {"read_datagram", &Dtool_LVecBase3i_read_datagram_543, METH_O, (const char *)Dtool_LVecBase3i_read_datagram_543_comment},
  {"readDatagram", &Dtool_LVecBase3i_read_datagram_543, METH_O, (const char *)Dtool_LVecBase3i_read_datagram_543_comment},
  {"get_class_type", &Dtool_LVecBase3i_get_class_type_544, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_get_class_type_544_comment},
  {"getClassType", &Dtool_LVecBase3i_get_class_type_544, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase3i_get_class_type_544_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase3i_operator_523_nb_add(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.__add__", "LVecBase3i");
  }
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase3i_operator_526_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3i LVecBase3i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase3i_operator_527_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3i::operator +=(LVecBase3i const &other)
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.__iadd__", "LVecBase3i");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3i.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase3i_operator_530_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3i::operator /=(int scalar)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator /=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3i.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase3i_operator_529_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3i::operator *=(int scalar)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator *=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3i.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase3i_ipow_533_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, (int)arg_val);
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase3i.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase3i self, int exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase3i_operator_528_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase3i::operator -=(LVecBase3i const &other)
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.__isub__", "LVecBase3i");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase3i.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase3i_operator_525_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3i LVecBase3i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase3i_operator_522_nb_negative(PyObject *self) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase3i LVecBase3i::operator -(void) const
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase3i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase3i_pow_532_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase3i LVecBase3i::__pow__(int exponent) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      LVecBase3i *return_value = new LVecBase3i(invoke_extension((const LVecBase3i*)local_this).__pow__((int)arg_val));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase3i self, int exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase3i_operator_524_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.__sub__", "LVecBase3i");
  }
  LVecBase3i *return_value = new LVecBase3i((*(const LVecBase3i*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase3i_operator_484_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase3i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int &LVecBase3i::operator [](int i)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return -1;
        }
#endif
        (*local_this).operator [](index) = (int)arg_val;
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase3i.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase3i self, index, int assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase3i_operator_484_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase3i index out of range");
    return NULL;
  }
  // 1-inline int LVecBase3i::operator [](int i) const
  int return_value = (*(const LVecBase3i*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase3i self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase3i_size_485_sq_length(PyObject *self) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase3i_compare_to_518_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase3i::compare_to(LVecBase3i const &other) const
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase3i.compare_to", "LVecBase3i");
    return -1;
  }
  int return_value = (*(const LVecBase3i*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase3i self, const LVecBase3i other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase3i_getattr_482_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase3i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase3i_get_hash_519_tp_hash(PyObject *self) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase3i_repr_539_tp_repr(PyObject *self) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase3i::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase3i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase3i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase3i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase3i_setattr_483_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase3i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase3i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase3i
//////////////////
static PyObject *Dtool_RichCompare_LVecBase3i(PyObject *self, PyObject *arg, int op) {
  LVecBase3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase3i, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase3i::operator <(LVecBase3i const &other) const
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3i*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase3i::operator ==(LVecBase3i const &other) const
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3i*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase3i::operator !=(LVecBase3i const &other) const
      LVecBase3i arg_local;
      LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase3i*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase3i_compare_to_518_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase3i[] = {
  {(char *)"x", &Dtool_LVecBase3i_x_Getter, &Dtool_LVecBase3i_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase3i_y_Getter, &Dtool_LVecBase3i_y_Setter, NULL, NULL},
  {(char *)"z", &Dtool_LVecBase3i_z_Getter, &Dtool_LVecBase3i_z_Setter, NULL, NULL},
  {(char *)"xy", &Dtool_LVecBase3i_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LVecBase3i_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LVecBase3i_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase3i = {
  &Dtool_LVecBase3i_operator_523_nb_add,
  &Dtool_LVecBase3i_operator_524_nb_subtract,
  &Dtool_LVecBase3i_operator_525_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase3i_operator_526_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase3i_pow_532_nb_power,
  &Dtool_LVecBase3i_operator_522_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase3i_operator_527_nb_inplace_add,
  &Dtool_LVecBase3i_operator_528_nb_inplace_subtract,
  &Dtool_LVecBase3i_operator_529_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase3i_operator_530_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase3i_ipow_533_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase3i = {
  &Dtool_LVecBase3i_size_485_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase3i_operator_484_sq_item,
  0, // sq_slice
  &Dtool_LVecBase3i_operator_484_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase3i_compare_to_518_tp_compare,
#endif
    &Dtool_LVecBase3i_repr_539_tp_repr,
    &Dtool_NumberMethods_LVecBase3i,
    &Dtool_SequenceMethods_LVecBase3i,
    0, // tp_as_mapping
    &Dtool_LVecBase3i_get_hash_519_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase3i_getattr_482_tp_getattro,
    &Dtool_LVecBase3i_setattr_483_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all three-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase3i,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase3i,
    0, // tp_members
    Dtool_Properties_LVecBase3i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_LVecBase3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase3i,
  Dtool_UpcastInterface_LVecBase3i,
  Dtool_DowncastInterface_LVecBase3i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase3i,
};

static void Dtool_PyModuleClassInit_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase3i._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase3i::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase3i::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase3i::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase3i);
  }
}

/**
 * Python method tables for LVector3f (LVector3f)
 */
static PyMethodDef Dtool_Methods_LVector3f[] = {
  {"zero", &Dtool_LVector3f_zero_555, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_zero_555_comment},
  {"unit_x", &Dtool_LVector3f_unit_x_556, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_unit_x_556_comment},
  {"unitX", &Dtool_LVector3f_unit_x_556, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_unit_x_556_comment},
  {"unit_y", &Dtool_LVector3f_unit_y_557, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_unit_y_557_comment},
  {"unitY", &Dtool_LVector3f_unit_y_557, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_unit_y_557_comment},
  {"unit_z", &Dtool_LVector3f_unit_z_558, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_unit_z_558_comment},
  {"unitZ", &Dtool_LVector3f_unit_z_558, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_unit_z_558_comment},
  {"get_xy", &Dtool_LVector3f_get_xy_559, METH_NOARGS, (const char *)Dtool_LVector3f_get_xy_559_comment},
  {"getXy", &Dtool_LVector3f_get_xy_559, METH_NOARGS, (const char *)Dtool_LVector3f_get_xy_559_comment},
  {"get_xz", &Dtool_LVector3f_get_xz_560, METH_NOARGS, (const char *)Dtool_LVector3f_get_xz_560_comment},
  {"getXz", &Dtool_LVector3f_get_xz_560, METH_NOARGS, (const char *)Dtool_LVector3f_get_xz_560_comment},
  {"get_yz", &Dtool_LVector3f_get_yz_561, METH_NOARGS, (const char *)Dtool_LVector3f_get_yz_561_comment},
  {"getYz", &Dtool_LVector3f_get_yz_561, METH_NOARGS, (const char *)Dtool_LVector3f_get_yz_561_comment},
  {"cross", &Dtool_LVector3f_cross_568, METH_O, (const char *)Dtool_LVector3f_cross_568_comment},
  {"normalized", &Dtool_LVector3f_normalized_569, METH_NOARGS, (const char *)Dtool_LVector3f_normalized_569_comment},
  {"project", &Dtool_LVector3f_project_570, METH_O, (const char *)Dtool_LVector3f_project_570_comment},
  {"angle_rad", &Dtool_LVector3f_angle_rad_571, METH_O, (const char *)Dtool_LVector3f_angle_rad_571_comment},
  {"angleRad", &Dtool_LVector3f_angle_rad_571, METH_O, (const char *)Dtool_LVector3f_angle_rad_571_comment},
  {"angle_deg", &Dtool_LVector3f_angle_deg_572, METH_O, (const char *)Dtool_LVector3f_angle_deg_572_comment},
  {"angleDeg", &Dtool_LVector3f_angle_deg_572, METH_O, (const char *)Dtool_LVector3f_angle_deg_572_comment},
  {"signed_angle_rad", (PyCFunction) &Dtool_LVector3f_signed_angle_rad_573, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3f_signed_angle_rad_573_comment},
  {"signedAngleRad", (PyCFunction) &Dtool_LVector3f_signed_angle_rad_573, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3f_signed_angle_rad_573_comment},
  {"signed_angle_deg", (PyCFunction) &Dtool_LVector3f_signed_angle_deg_574, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3f_signed_angle_deg_574_comment},
  {"signedAngleDeg", (PyCFunction) &Dtool_LVector3f_signed_angle_deg_574, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3f_signed_angle_deg_574_comment},
  {"relative_angle_rad", &Dtool_LVector3f_relative_angle_rad_575, METH_O, (const char *)Dtool_LVector3f_relative_angle_rad_575_comment},
  {"relativeAngleRad", &Dtool_LVector3f_relative_angle_rad_575, METH_O, (const char *)Dtool_LVector3f_relative_angle_rad_575_comment},
  {"relative_angle_deg", &Dtool_LVector3f_relative_angle_deg_576, METH_O, (const char *)Dtool_LVector3f_relative_angle_deg_576_comment},
  {"relativeAngleDeg", &Dtool_LVector3f_relative_angle_deg_576, METH_O, (const char *)Dtool_LVector3f_relative_angle_deg_576_comment},
  {"up", (PyCFunction) &Dtool_LVector3f_up_579, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_up_579_comment},
  {"right", (PyCFunction) &Dtool_LVector3f_right_580, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_right_580_comment},
  {"forward", (PyCFunction) &Dtool_LVector3f_forward_581, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_forward_581_comment},
  {"down", (PyCFunction) &Dtool_LVector3f_down_582, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_down_582_comment},
  {"left", (PyCFunction) &Dtool_LVector3f_left_583, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_left_583_comment},
  {"back", (PyCFunction) &Dtool_LVector3f_back_584, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_back_584_comment},
  {"rfu", (PyCFunction) &Dtool_LVector3f_rfu_585, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3f_rfu_585_comment},
  {"get_class_type", &Dtool_LVector3f_get_class_type_587, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_get_class_type_587_comment},
  {"getClassType", &Dtool_LVector3f_get_class_type_587, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3f_get_class_type_587_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector3f_operator_566_nb_add(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3f LVector3f::operator +(LVector3f const &other) const
    LVector3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f((*(const LVector3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LVector3f LVector3f::operator +(LVector3f const &other) const
    LVector3f arg_local;
    LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f((*(const LVector3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector3f_operator_578_nb_divide(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3f LVector3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector3f_operator_577_nb_multiply(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3f LVector3f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector3f_operator_565_nb_negative(PyObject *self) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3f LVector3f::operator -(void) const
  LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector3f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector3f_operator_567_nb_subtract(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3f LVector3f::operator -(LVector3f const &other) const
    LVector3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f((*(const LVector3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LVector3f LVector3f::operator -(LVector3f const &other) const
    LVector3f arg_local;
    LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f((*(const LVector3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVector3f_operator_578_nb_true_divide(PyObject *self, PyObject *arg) {
  LVector3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3f LVector3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector3f *return_value = new LVector3f((*(const LVector3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector3f_getattr_553_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector3f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector3f_repr_586_tp_repr(PyObject *self) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector3f::__repr__(void) const
  std::string return_value = invoke_extension((const LVector3f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector3f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector3f_setattr_554_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector3f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector3f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LVector3f[] = {
  {(char *)"xy", &Dtool_LVector3f_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LVector3f_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LVector3f_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVector3f = {
  &Dtool_LVector3f_operator_566_nb_add,
  &Dtool_LVector3f_operator_567_nb_subtract,
  &Dtool_LVector3f_operator_577_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector3f_operator_578_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector3f_operator_565_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVector3f_operator_578_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector3f_repr_586_tp_repr,
    &Dtool_NumberMethods_LVector3f,
    &Dtool_SequenceMethods_LVector3f,
    &Dtool_MappingMethods_LVector3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector3f_getattr_553_tp_getattro,
    &Dtool_LVector3f_setattr_554_tp_setattro,
    &Dtool_BufferProcs_LVector3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a three-component vector distance (as opposed to a three-component\n"
    " * point, which represents a particular point in space).  Some of the methods\n"
    " * are slightly different between LPoint3 and LVector3; in particular,\n"
    " * subtraction of two points yields a vector, while addition of a vector and a\n"
    " * point yields a point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector3f,
    0, // tp_members
    Dtool_Properties_LVector3f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector3f,
    PyType_GenericAlloc,
    Dtool_new_LVector3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector3f,
  Dtool_UpcastInterface_LVector3f,
  Dtool_DowncastInterface_LVector3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector3f,
};

static void Dtool_PyModuleClassInit_LVector3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase3f(NULL);
    Dtool_LVector3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase3f);
    PyObject *dict = PyDict_New();
    Dtool_LVector3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector3f);
  }
}

/**
 * Python method tables for LVector3d (LVector3d)
 */
static PyMethodDef Dtool_Methods_LVector3d[] = {
  {"zero", &Dtool_LVector3d_zero_593, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_zero_593_comment},
  {"unit_x", &Dtool_LVector3d_unit_x_594, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_unit_x_594_comment},
  {"unitX", &Dtool_LVector3d_unit_x_594, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_unit_x_594_comment},
  {"unit_y", &Dtool_LVector3d_unit_y_595, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_unit_y_595_comment},
  {"unitY", &Dtool_LVector3d_unit_y_595, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_unit_y_595_comment},
  {"unit_z", &Dtool_LVector3d_unit_z_596, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_unit_z_596_comment},
  {"unitZ", &Dtool_LVector3d_unit_z_596, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_unit_z_596_comment},
  {"get_xy", &Dtool_LVector3d_get_xy_597, METH_NOARGS, (const char *)Dtool_LVector3d_get_xy_597_comment},
  {"getXy", &Dtool_LVector3d_get_xy_597, METH_NOARGS, (const char *)Dtool_LVector3d_get_xy_597_comment},
  {"get_xz", &Dtool_LVector3d_get_xz_598, METH_NOARGS, (const char *)Dtool_LVector3d_get_xz_598_comment},
  {"getXz", &Dtool_LVector3d_get_xz_598, METH_NOARGS, (const char *)Dtool_LVector3d_get_xz_598_comment},
  {"get_yz", &Dtool_LVector3d_get_yz_599, METH_NOARGS, (const char *)Dtool_LVector3d_get_yz_599_comment},
  {"getYz", &Dtool_LVector3d_get_yz_599, METH_NOARGS, (const char *)Dtool_LVector3d_get_yz_599_comment},
  {"cross", &Dtool_LVector3d_cross_606, METH_O, (const char *)Dtool_LVector3d_cross_606_comment},
  {"normalized", &Dtool_LVector3d_normalized_607, METH_NOARGS, (const char *)Dtool_LVector3d_normalized_607_comment},
  {"project", &Dtool_LVector3d_project_608, METH_O, (const char *)Dtool_LVector3d_project_608_comment},
  {"angle_rad", &Dtool_LVector3d_angle_rad_609, METH_O, (const char *)Dtool_LVector3d_angle_rad_609_comment},
  {"angleRad", &Dtool_LVector3d_angle_rad_609, METH_O, (const char *)Dtool_LVector3d_angle_rad_609_comment},
  {"angle_deg", &Dtool_LVector3d_angle_deg_610, METH_O, (const char *)Dtool_LVector3d_angle_deg_610_comment},
  {"angleDeg", &Dtool_LVector3d_angle_deg_610, METH_O, (const char *)Dtool_LVector3d_angle_deg_610_comment},
  {"signed_angle_rad", (PyCFunction) &Dtool_LVector3d_signed_angle_rad_611, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3d_signed_angle_rad_611_comment},
  {"signedAngleRad", (PyCFunction) &Dtool_LVector3d_signed_angle_rad_611, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3d_signed_angle_rad_611_comment},
  {"signed_angle_deg", (PyCFunction) &Dtool_LVector3d_signed_angle_deg_612, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3d_signed_angle_deg_612_comment},
  {"signedAngleDeg", (PyCFunction) &Dtool_LVector3d_signed_angle_deg_612, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVector3d_signed_angle_deg_612_comment},
  {"relative_angle_rad", &Dtool_LVector3d_relative_angle_rad_613, METH_O, (const char *)Dtool_LVector3d_relative_angle_rad_613_comment},
  {"relativeAngleRad", &Dtool_LVector3d_relative_angle_rad_613, METH_O, (const char *)Dtool_LVector3d_relative_angle_rad_613_comment},
  {"relative_angle_deg", &Dtool_LVector3d_relative_angle_deg_614, METH_O, (const char *)Dtool_LVector3d_relative_angle_deg_614_comment},
  {"relativeAngleDeg", &Dtool_LVector3d_relative_angle_deg_614, METH_O, (const char *)Dtool_LVector3d_relative_angle_deg_614_comment},
  {"up", (PyCFunction) &Dtool_LVector3d_up_617, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_up_617_comment},
  {"right", (PyCFunction) &Dtool_LVector3d_right_618, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_right_618_comment},
  {"forward", (PyCFunction) &Dtool_LVector3d_forward_619, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_forward_619_comment},
  {"down", (PyCFunction) &Dtool_LVector3d_down_620, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_down_620_comment},
  {"left", (PyCFunction) &Dtool_LVector3d_left_621, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_left_621_comment},
  {"back", (PyCFunction) &Dtool_LVector3d_back_622, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_back_622_comment},
  {"rfu", (PyCFunction) &Dtool_LVector3d_rfu_623, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3d_rfu_623_comment},
  {"get_class_type", &Dtool_LVector3d_get_class_type_625, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_get_class_type_625_comment},
  {"getClassType", &Dtool_LVector3d_get_class_type_625, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3d_get_class_type_625_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector3d_operator_604_nb_add(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3d LVector3d::operator +(LVector3d const &other) const
    LVector3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d((*(const LVector3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LVector3d LVector3d::operator +(LVector3d const &other) const
    LVector3d arg_local;
    LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d((*(const LVector3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector3d_operator_616_nb_divide(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3d LVector3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector3d_operator_615_nb_multiply(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3d LVector3d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector3d_operator_603_nb_negative(PyObject *self) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3d LVector3d::operator -(void) const
  LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector3d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector3d_operator_605_nb_subtract(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3d LVector3d::operator -(LVector3d const &other) const
    LVector3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d((*(const LVector3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LVector3d LVector3d::operator -(LVector3d const &other) const
    LVector3d arg_local;
    LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d((*(const LVector3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVector3d_operator_616_nb_true_divide(PyObject *self, PyObject *arg) {
  LVector3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3d LVector3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector3d *return_value = new LVector3d((*(const LVector3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector3d_getattr_591_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector3d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector3d_repr_624_tp_repr(PyObject *self) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector3d::__repr__(void) const
  std::string return_value = invoke_extension((const LVector3d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector3d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector3d_setattr_592_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector3d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector3d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LVector3d[] = {
  {(char *)"xy", &Dtool_LVector3d_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LVector3d_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LVector3d_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVector3d = {
  &Dtool_LVector3d_operator_604_nb_add,
  &Dtool_LVector3d_operator_605_nb_subtract,
  &Dtool_LVector3d_operator_615_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector3d_operator_616_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector3d_operator_603_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVector3d_operator_616_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector3d_repr_624_tp_repr,
    &Dtool_NumberMethods_LVector3d,
    &Dtool_SequenceMethods_LVector3d,
    &Dtool_MappingMethods_LVector3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector3d_getattr_591_tp_getattro,
    &Dtool_LVector3d_setattr_592_tp_setattro,
    &Dtool_BufferProcs_LVector3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a three-component vector distance (as opposed to a three-component\n"
    " * point, which represents a particular point in space).  Some of the methods\n"
    " * are slightly different between LPoint3 and LVector3; in particular,\n"
    " * subtraction of two points yields a vector, while addition of a vector and a\n"
    " * point yields a point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector3d,
    0, // tp_members
    Dtool_Properties_LVector3d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector3d,
    PyType_GenericAlloc,
    Dtool_new_LVector3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector3d,
  Dtool_UpcastInterface_LVector3d,
  Dtool_DowncastInterface_LVector3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector3d,
};

static void Dtool_PyModuleClassInit_LVector3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase3d(NULL);
    Dtool_LVector3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase3d);
    PyObject *dict = PyDict_New();
    Dtool_LVector3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector3d);
  }
}

/**
 * Python method tables for LVector3i (LVector3i)
 */
static PyMethodDef Dtool_Methods_LVector3i[] = {
  {"zero", &Dtool_LVector3i_zero_631, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_zero_631_comment},
  {"unit_x", &Dtool_LVector3i_unit_x_632, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_unit_x_632_comment},
  {"unitX", &Dtool_LVector3i_unit_x_632, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_unit_x_632_comment},
  {"unit_y", &Dtool_LVector3i_unit_y_633, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_unit_y_633_comment},
  {"unitY", &Dtool_LVector3i_unit_y_633, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_unit_y_633_comment},
  {"unit_z", &Dtool_LVector3i_unit_z_634, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_unit_z_634_comment},
  {"unitZ", &Dtool_LVector3i_unit_z_634, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_unit_z_634_comment},
  {"get_xy", &Dtool_LVector3i_get_xy_635, METH_NOARGS, (const char *)Dtool_LVector3i_get_xy_635_comment},
  {"getXy", &Dtool_LVector3i_get_xy_635, METH_NOARGS, (const char *)Dtool_LVector3i_get_xy_635_comment},
  {"get_xz", &Dtool_LVector3i_get_xz_636, METH_NOARGS, (const char *)Dtool_LVector3i_get_xz_636_comment},
  {"getXz", &Dtool_LVector3i_get_xz_636, METH_NOARGS, (const char *)Dtool_LVector3i_get_xz_636_comment},
  {"get_yz", &Dtool_LVector3i_get_yz_637, METH_NOARGS, (const char *)Dtool_LVector3i_get_yz_637_comment},
  {"getYz", &Dtool_LVector3i_get_yz_637, METH_NOARGS, (const char *)Dtool_LVector3i_get_yz_637_comment},
  {"cross", &Dtool_LVector3i_cross_644, METH_O, (const char *)Dtool_LVector3i_cross_644_comment},
  {"up", (PyCFunction) &Dtool_LVector3i_up_647, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_up_647_comment},
  {"right", (PyCFunction) &Dtool_LVector3i_right_648, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_right_648_comment},
  {"forward", (PyCFunction) &Dtool_LVector3i_forward_649, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_forward_649_comment},
  {"down", (PyCFunction) &Dtool_LVector3i_down_650, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_down_650_comment},
  {"left", (PyCFunction) &Dtool_LVector3i_left_651, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_left_651_comment},
  {"back", (PyCFunction) &Dtool_LVector3i_back_652, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_back_652_comment},
  {"rfu", (PyCFunction) &Dtool_LVector3i_rfu_653, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LVector3i_rfu_653_comment},
  {"get_class_type", &Dtool_LVector3i_get_class_type_655, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_get_class_type_655_comment},
  {"getClassType", &Dtool_LVector3i_get_class_type_655, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector3i_get_class_type_655_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector3i_operator_642_nb_add(PyObject *self, PyObject *arg) {
  LVector3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3i LVector3i::operator +(LVector3i const &other) const
    LVector3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3i *return_value = new LVecBase3i((*(const LVector3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  {
    // -2 inline LVector3i LVector3i::operator +(LVector3i const &other) const
    LVector3i arg_local;
    LVector3i const *arg_this = Dtool_Coerce_LVector3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3i *return_value = new LVecBase3i((*(const LVector3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector3i_operator_646_nb_divide(PyObject *self, PyObject *arg) {
  LVector3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3i LVector3i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector3i_operator_645_nb_multiply(PyObject *self, PyObject *arg) {
  LVector3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector3i LVector3i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector3i_operator_641_nb_negative(PyObject *self) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector3i LVector3i::operator -(void) const
  LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector3i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector3i_operator_643_nb_subtract(PyObject *self, PyObject *arg) {
  LVector3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3i LVector3i::operator -(LVector3i const &other) const
    LVector3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3i *return_value = new LVecBase3i((*(const LVector3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  {
    // -2 inline LVector3i LVector3i::operator -(LVector3i const &other) const
    LVector3i arg_local;
    LVector3i const *arg_this = Dtool_Coerce_LVector3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3i *return_value = new LVector3i((*(const LVector3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3i *return_value = new LVecBase3i((*(const LVector3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector3i_getattr_629_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector3i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector3i_repr_654_tp_repr(PyObject *self) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector3i::__repr__(void) const
  std::string return_value = invoke_extension((const LVector3i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector3i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector3i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector3i_setattr_630_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector3i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector3i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector3i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LVector3i[] = {
  {(char *)"xy", &Dtool_LVector3i_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LVector3i_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LVector3i_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVector3i = {
  &Dtool_LVector3i_operator_642_nb_add,
  &Dtool_LVector3i_operator_643_nb_subtract,
  &Dtool_LVector3i_operator_645_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector3i_operator_646_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector3i_operator_641_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector3i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector3i_repr_654_tp_repr,
    &Dtool_NumberMethods_LVector3i,
    &Dtool_SequenceMethods_LVector3i,
    &Dtool_MappingMethods_LVector3i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector3i_getattr_629_tp_getattro,
    &Dtool_LVector3i_setattr_630_tp_setattro,
    &Dtool_BufferProcs_LVector3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a three-component vector distance (as opposed to a three-component\n"
    " * point, which represents a particular point in space).  Some of the methods\n"
    " * are slightly different between LPoint3 and LVector3; in particular,\n"
    " * subtraction of two points yields a vector, while addition of a vector and a\n"
    " * point yields a point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector3i,
    0, // tp_members
    Dtool_Properties_LVector3i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector3i,
    PyType_GenericAlloc,
    Dtool_new_LVector3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector3i,
  Dtool_UpcastInterface_LVector3i,
  Dtool_DowncastInterface_LVector3i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector3i,
};

static void Dtool_PyModuleClassInit_LVector3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase3i(NULL);
    Dtool_LVector3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase3i);
    PyObject *dict = PyDict_New();
    Dtool_LVector3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector3i);
  }
}

/**
 * Python method tables for LPoint3f (LPoint3f)
 */
static PyMethodDef Dtool_Methods_LPoint3f[] = {
  {"zero", &Dtool_LPoint3f_zero_661, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_zero_661_comment},
  {"unit_x", &Dtool_LPoint3f_unit_x_662, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_unit_x_662_comment},
  {"unitX", &Dtool_LPoint3f_unit_x_662, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_unit_x_662_comment},
  {"unit_y", &Dtool_LPoint3f_unit_y_663, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_unit_y_663_comment},
  {"unitY", &Dtool_LPoint3f_unit_y_663, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_unit_y_663_comment},
  {"unit_z", &Dtool_LPoint3f_unit_z_664, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_unit_z_664_comment},
  {"unitZ", &Dtool_LPoint3f_unit_z_664, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_unit_z_664_comment},
  {"get_xy", &Dtool_LPoint3f_get_xy_665, METH_NOARGS, (const char *)Dtool_LPoint3f_get_xy_665_comment},
  {"getXy", &Dtool_LPoint3f_get_xy_665, METH_NOARGS, (const char *)Dtool_LPoint3f_get_xy_665_comment},
  {"get_xz", &Dtool_LPoint3f_get_xz_666, METH_NOARGS, (const char *)Dtool_LPoint3f_get_xz_666_comment},
  {"getXz", &Dtool_LPoint3f_get_xz_666, METH_NOARGS, (const char *)Dtool_LPoint3f_get_xz_666_comment},
  {"get_yz", &Dtool_LPoint3f_get_yz_667, METH_NOARGS, (const char *)Dtool_LPoint3f_get_yz_667_comment},
  {"getYz", &Dtool_LPoint3f_get_yz_667, METH_NOARGS, (const char *)Dtool_LPoint3f_get_yz_667_comment},
  {"cross", &Dtool_LPoint3f_cross_674, METH_O, (const char *)Dtool_LPoint3f_cross_674_comment},
  {"normalized", &Dtool_LPoint3f_normalized_675, METH_NOARGS, (const char *)Dtool_LPoint3f_normalized_675_comment},
  {"project", &Dtool_LPoint3f_project_676, METH_O, (const char *)Dtool_LPoint3f_project_676_comment},
  {"origin", (PyCFunction) &Dtool_LPoint3f_origin_679, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LPoint3f_origin_679_comment},
  {"rfu", (PyCFunction) &Dtool_LPoint3f_rfu_680, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LPoint3f_rfu_680_comment},
  {"get_class_type", &Dtool_LPoint3f_get_class_type_682, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_get_class_type_682_comment},
  {"getClassType", &Dtool_LPoint3f_get_class_type_682, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3f_get_class_type_682_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint3f_operator_672_nb_add(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint3f LPoint3f::operator +(LVector3f const &other) const
    LVector3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f((*(const LPoint3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LPoint3f LPoint3f::operator +(LVector3f const &other) const
    LVector3f arg_local;
    LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f((*(const LPoint3f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint3f_operator_678_nb_divide(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3f LPoint3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint3f_operator_677_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3f LPoint3f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint3f_operator_671_nb_negative(PyObject *self) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3f LPoint3f::operator -(void) const
  LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint3f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint3f_operator_673_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint3f LPoint3f::operator -(LVector3f const &other) const
    LVector3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
  }

  {
    // -2 inline LVector3f LPoint3f::operator -(LPoint3f const &other) const
    LPoint3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3f *return_value = new LVector3f((*(const LPoint3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const
    LVecBase3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3f *return_value = new LVecBase3f((*(const LPoint3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  {
    // -2 inline LPoint3f LPoint3f::operator -(LVector3f const &other) const
    LVector3f arg_local;
    LVector3f const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
    }
  }

  {
    // -2 inline LVector3f LPoint3f::operator -(LPoint3f const &other) const
    LPoint3f arg_local;
    LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3f *return_value = new LVector3f((*(const LPoint3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
    }
  }

  {
    // -2 inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3f *return_value = new LVecBase3f((*(const LPoint3f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint3f_operator_678_nb_true_divide(PyObject *self, PyObject *arg) {
  LPoint3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3f LPoint3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint3f *return_value = new LPoint3f((*(const LPoint3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint3f_getattr_659_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint3f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint3f_repr_681_tp_repr(PyObject *self) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint3f::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint3f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint3f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint3f_setattr_660_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint3f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint3f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LPoint3f[] = {
  {(char *)"xy", &Dtool_LPoint3f_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LPoint3f_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LPoint3f_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LPoint3f = {
  &Dtool_LPoint3f_operator_672_nb_add,
  &Dtool_LPoint3f_operator_673_nb_subtract,
  &Dtool_LPoint3f_operator_677_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint3f_operator_678_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint3f_operator_671_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LPoint3f_operator_678_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint3f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint3f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint3f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint3f_repr_681_tp_repr,
    &Dtool_NumberMethods_LPoint3f,
    &Dtool_SequenceMethods_LPoint3f,
    &Dtool_MappingMethods_LPoint3f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint3f_getattr_659_tp_getattro,
    &Dtool_LPoint3f_setattr_660_tp_setattro,
    &Dtool_BufferProcs_LPoint3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a three-component point in space (as opposed to a three-component\n"
    " * vector, which represents a direction and a distance).  Some of the methods\n"
    " * are slightly different between LPoint3 and LVector3; in particular,\n"
    " * subtraction of two points yields a vector, while addition of a vector and a\n"
    " * point yields a point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint3f,
    0, // tp_members
    Dtool_Properties_LPoint3f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint3f,
    PyType_GenericAlloc,
    Dtool_new_LPoint3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint3f,
  Dtool_UpcastInterface_LPoint3f,
  Dtool_DowncastInterface_LPoint3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint3f,
};

static void Dtool_PyModuleClassInit_LPoint3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase3f(NULL);
    Dtool_LPoint3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase3f);
    PyObject *dict = PyDict_New();
    Dtool_LPoint3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint3f);
  }
}

/**
 * Python method tables for LPoint3d (LPoint3d)
 */
static PyMethodDef Dtool_Methods_LPoint3d[] = {
  {"zero", &Dtool_LPoint3d_zero_688, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_zero_688_comment},
  {"unit_x", &Dtool_LPoint3d_unit_x_689, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_unit_x_689_comment},
  {"unitX", &Dtool_LPoint3d_unit_x_689, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_unit_x_689_comment},
  {"unit_y", &Dtool_LPoint3d_unit_y_690, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_unit_y_690_comment},
  {"unitY", &Dtool_LPoint3d_unit_y_690, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_unit_y_690_comment},
  {"unit_z", &Dtool_LPoint3d_unit_z_691, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_unit_z_691_comment},
  {"unitZ", &Dtool_LPoint3d_unit_z_691, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_unit_z_691_comment},
  {"get_xy", &Dtool_LPoint3d_get_xy_692, METH_NOARGS, (const char *)Dtool_LPoint3d_get_xy_692_comment},
  {"getXy", &Dtool_LPoint3d_get_xy_692, METH_NOARGS, (const char *)Dtool_LPoint3d_get_xy_692_comment},
  {"get_xz", &Dtool_LPoint3d_get_xz_693, METH_NOARGS, (const char *)Dtool_LPoint3d_get_xz_693_comment},
  {"getXz", &Dtool_LPoint3d_get_xz_693, METH_NOARGS, (const char *)Dtool_LPoint3d_get_xz_693_comment},
  {"get_yz", &Dtool_LPoint3d_get_yz_694, METH_NOARGS, (const char *)Dtool_LPoint3d_get_yz_694_comment},
  {"getYz", &Dtool_LPoint3d_get_yz_694, METH_NOARGS, (const char *)Dtool_LPoint3d_get_yz_694_comment},
  {"cross", &Dtool_LPoint3d_cross_701, METH_O, (const char *)Dtool_LPoint3d_cross_701_comment},
  {"normalized", &Dtool_LPoint3d_normalized_702, METH_NOARGS, (const char *)Dtool_LPoint3d_normalized_702_comment},
  {"project", &Dtool_LPoint3d_project_703, METH_O, (const char *)Dtool_LPoint3d_project_703_comment},
  {"origin", (PyCFunction) &Dtool_LPoint3d_origin_706, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LPoint3d_origin_706_comment},
  {"rfu", (PyCFunction) &Dtool_LPoint3d_rfu_707, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LPoint3d_rfu_707_comment},
  {"get_class_type", &Dtool_LPoint3d_get_class_type_709, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_get_class_type_709_comment},
  {"getClassType", &Dtool_LPoint3d_get_class_type_709, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3d_get_class_type_709_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint3d_operator_699_nb_add(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint3d LPoint3d::operator +(LVector3d const &other) const
    LVector3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d((*(const LPoint3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LPoint3d LPoint3d::operator +(LVector3d const &other) const
    LVector3d arg_local;
    LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d((*(const LPoint3d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint3d_operator_705_nb_divide(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3d LPoint3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint3d_operator_704_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3d LPoint3d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint3d_operator_698_nb_negative(PyObject *self) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3d LPoint3d::operator -(void) const
  LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint3d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint3d_operator_700_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3d LPoint3d::operator -(LPoint3d const &other) const
    LPoint3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3d *return_value = new LVector3d((*(const LPoint3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
    }
  }

  {
    // -2 inline LPoint3d LPoint3d::operator -(LVector3d const &other) const
    LVector3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const
    LVecBase3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3d *return_value = new LVecBase3d((*(const LPoint3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  {
    // -2 inline LVector3d LPoint3d::operator -(LPoint3d const &other) const
    LPoint3d arg_local;
    LPoint3d const *arg_this = Dtool_Coerce_LPoint3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3d *return_value = new LVector3d((*(const LPoint3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3d, true, false);
    }
  }

  {
    // -2 inline LPoint3d LPoint3d::operator -(LVector3d const &other) const
    LVector3d arg_local;
    LVector3d const *arg_this = Dtool_Coerce_LVector3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
    }
  }

  {
    // -2 inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3d *return_value = new LVecBase3d((*(const LPoint3d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint3d_operator_705_nb_true_divide(PyObject *self, PyObject *arg) {
  LPoint3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3d LPoint3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint3d *return_value = new LPoint3d((*(const LPoint3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint3d_getattr_686_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint3d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint3d_repr_708_tp_repr(PyObject *self) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint3d::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint3d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint3d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint3d_setattr_687_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint3d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint3d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LPoint3d[] = {
  {(char *)"xy", &Dtool_LPoint3d_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LPoint3d_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LPoint3d_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LPoint3d = {
  &Dtool_LPoint3d_operator_699_nb_add,
  &Dtool_LPoint3d_operator_700_nb_subtract,
  &Dtool_LPoint3d_operator_704_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint3d_operator_705_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint3d_operator_698_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LPoint3d_operator_705_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint3d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint3d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint3d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint3d_repr_708_tp_repr,
    &Dtool_NumberMethods_LPoint3d,
    &Dtool_SequenceMethods_LPoint3d,
    &Dtool_MappingMethods_LPoint3d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint3d_getattr_686_tp_getattro,
    &Dtool_LPoint3d_setattr_687_tp_setattro,
    &Dtool_BufferProcs_LPoint3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a three-component point in space (as opposed to a three-component\n"
    " * vector, which represents a direction and a distance).  Some of the methods\n"
    " * are slightly different between LPoint3 and LVector3; in particular,\n"
    " * subtraction of two points yields a vector, while addition of a vector and a\n"
    " * point yields a point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint3d,
    0, // tp_members
    Dtool_Properties_LPoint3d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint3d,
    PyType_GenericAlloc,
    Dtool_new_LPoint3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint3d,
  Dtool_UpcastInterface_LPoint3d,
  Dtool_DowncastInterface_LPoint3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint3d,
};

static void Dtool_PyModuleClassInit_LPoint3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase3d(NULL);
    Dtool_LPoint3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase3d);
    PyObject *dict = PyDict_New();
    Dtool_LPoint3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint3d);
  }
}

/**
 * Python method tables for LPoint3i (LPoint3i)
 */
static PyMethodDef Dtool_Methods_LPoint3i[] = {
  {"zero", &Dtool_LPoint3i_zero_715, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_zero_715_comment},
  {"unit_x", &Dtool_LPoint3i_unit_x_716, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_unit_x_716_comment},
  {"unitX", &Dtool_LPoint3i_unit_x_716, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_unit_x_716_comment},
  {"unit_y", &Dtool_LPoint3i_unit_y_717, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_unit_y_717_comment},
  {"unitY", &Dtool_LPoint3i_unit_y_717, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_unit_y_717_comment},
  {"unit_z", &Dtool_LPoint3i_unit_z_718, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_unit_z_718_comment},
  {"unitZ", &Dtool_LPoint3i_unit_z_718, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_unit_z_718_comment},
  {"get_xy", &Dtool_LPoint3i_get_xy_719, METH_NOARGS, (const char *)Dtool_LPoint3i_get_xy_719_comment},
  {"getXy", &Dtool_LPoint3i_get_xy_719, METH_NOARGS, (const char *)Dtool_LPoint3i_get_xy_719_comment},
  {"get_xz", &Dtool_LPoint3i_get_xz_720, METH_NOARGS, (const char *)Dtool_LPoint3i_get_xz_720_comment},
  {"getXz", &Dtool_LPoint3i_get_xz_720, METH_NOARGS, (const char *)Dtool_LPoint3i_get_xz_720_comment},
  {"get_yz", &Dtool_LPoint3i_get_yz_721, METH_NOARGS, (const char *)Dtool_LPoint3i_get_yz_721_comment},
  {"getYz", &Dtool_LPoint3i_get_yz_721, METH_NOARGS, (const char *)Dtool_LPoint3i_get_yz_721_comment},
  {"cross", &Dtool_LPoint3i_cross_728, METH_O, (const char *)Dtool_LPoint3i_cross_728_comment},
  {"origin", (PyCFunction) &Dtool_LPoint3i_origin_731, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LPoint3i_origin_731_comment},
  {"rfu", (PyCFunction) &Dtool_LPoint3i_rfu_732, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LPoint3i_rfu_732_comment},
  {"get_class_type", &Dtool_LPoint3i_get_class_type_734, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_get_class_type_734_comment},
  {"getClassType", &Dtool_LPoint3i_get_class_type_734, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint3i_get_class_type_734_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint3i_operator_726_nb_add(PyObject *self, PyObject *arg) {
  LPoint3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint3i LPoint3i::operator +(LVector3i const &other) const
    LVector3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3i *return_value = new LVecBase3i((*(const LPoint3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  {
    // -2 inline LPoint3i LPoint3i::operator +(LVector3i const &other) const
    LVector3i arg_local;
    LVector3i const *arg_this = Dtool_Coerce_LVector3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3i *return_value = new LVecBase3i((*(const LPoint3i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint3i_operator_730_nb_divide(PyObject *self, PyObject *arg) {
  LPoint3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3i LPoint3i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint3i_operator_729_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint3i LPoint3i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint3i_operator_725_nb_negative(PyObject *self) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint3i LPoint3i::operator -(void) const
  LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint3i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint3i_operator_727_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint3i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint3i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector3i LPoint3i::operator -(LPoint3i const &other) const
    LPoint3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector3i *return_value = new LVector3i((*(const LPoint3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
    }
  }

  {
    // -2 inline LPoint3i LPoint3i::operator -(LVector3i const &other) const
    LVector3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const
    LVecBase3i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase3i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase3i *return_value = new LVecBase3i((*(const LPoint3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  {
    // -2 inline LVector3i LPoint3i::operator -(LPoint3i const &other) const
    LPoint3i arg_local;
    LPoint3i const *arg_this = Dtool_Coerce_LPoint3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector3i *return_value = new LVector3i((*(const LPoint3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3i, true, false);
    }
  }

  {
    // -2 inline LPoint3i LPoint3i::operator -(LVector3i const &other) const
    LVector3i arg_local;
    LVector3i const *arg_this = Dtool_Coerce_LVector3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint3i *return_value = new LPoint3i((*(const LPoint3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
    }
  }

  {
    // -2 inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase3i *return_value = new LVecBase3i((*(const LPoint3i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint3i_getattr_713_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint3i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint3i_repr_733_tp_repr(PyObject *self) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint3i::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint3i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint3i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint3i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint3i_setattr_714_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint3i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint3i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint3i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint3i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LPoint3i[] = {
  {(char *)"xy", &Dtool_LPoint3i_xy_Getter, NULL, NULL, NULL},
  {(char *)"xz", &Dtool_LPoint3i_xz_Getter, NULL, NULL, NULL},
  {(char *)"yz", &Dtool_LPoint3i_yz_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LPoint3i = {
  &Dtool_LPoint3i_operator_726_nb_add,
  &Dtool_LPoint3i_operator_727_nb_subtract,
  &Dtool_LPoint3i_operator_729_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint3i_operator_730_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint3i_operator_725_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint3i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint3i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint3i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint3i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint3i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint3i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint3i_repr_733_tp_repr,
    &Dtool_NumberMethods_LPoint3i,
    &Dtool_SequenceMethods_LPoint3i,
    &Dtool_MappingMethods_LPoint3i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint3i_getattr_713_tp_getattro,
    &Dtool_LPoint3i_setattr_714_tp_setattro,
    &Dtool_BufferProcs_LPoint3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a three-component point in space (as opposed to a three-component\n"
    " * vector, which represents a direction and a distance).  Some of the methods\n"
    " * are slightly different between LPoint3 and LVector3; in particular,\n"
    " * subtraction of two points yields a vector, while addition of a vector and a\n"
    " * point yields a point.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint3i,
    0, // tp_members
    Dtool_Properties_LPoint3i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint3i,
    PyType_GenericAlloc,
    Dtool_new_LPoint3i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint3i,
  Dtool_UpcastInterface_LPoint3i,
  Dtool_DowncastInterface_LPoint3i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint3i,
};

static void Dtool_PyModuleClassInit_LPoint3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase3i(NULL);
    Dtool_LPoint3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase3i);
    PyObject *dict = PyDict_New();
    Dtool_LPoint3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint3i);
  }
}

/**
 * Python method tables for LVecBase4f (LVecBase4f)
 */
static PyMethodDef Dtool_Methods_LVecBase4f[] = {
  {"assign", &Dtool_LVecBase4f_operator_742, METH_O, (const char *)Dtool_LVecBase4f_operator_742_comment},
  {"zero", &Dtool_LVecBase4f_zero_743, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_zero_743_comment},
  {"unit_x", &Dtool_LVecBase4f_unit_x_744, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_x_744_comment},
  {"unitX", &Dtool_LVecBase4f_unit_x_744, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_x_744_comment},
  {"unit_y", &Dtool_LVecBase4f_unit_y_745, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_y_745_comment},
  {"unitY", &Dtool_LVecBase4f_unit_y_745, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_y_745_comment},
  {"unit_z", &Dtool_LVecBase4f_unit_z_746, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_z_746_comment},
  {"unitZ", &Dtool_LVecBase4f_unit_z_746, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_z_746_comment},
  {"unit_w", &Dtool_LVecBase4f_unit_w_747, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_w_747_comment},
  {"unitW", &Dtool_LVecBase4f_unit_w_747, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_unit_w_747_comment},
  {"__reduce__", &Dtool_LVecBase4f_reduce_748, METH_NOARGS, (const char *)Dtool_LVecBase4f_reduce_748_comment},
  {"is_nan", &Dtool_LVecBase4f_is_nan_753, METH_NOARGS, (const char *)Dtool_LVecBase4f_is_nan_753_comment},
  {"isNan", &Dtool_LVecBase4f_is_nan_753, METH_NOARGS, (const char *)Dtool_LVecBase4f_is_nan_753_comment},
  {"get_cell", &Dtool_LVecBase4f_get_cell_754, METH_O, (const char *)Dtool_LVecBase4f_get_cell_754_comment},
  {"getCell", &Dtool_LVecBase4f_get_cell_754, METH_O, (const char *)Dtool_LVecBase4f_get_cell_754_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase4f_set_cell_755, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_set_cell_755_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase4f_set_cell_755, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_set_cell_755_comment},
  {"get_x", &Dtool_LVecBase4f_get_x_756, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_x_756_comment},
  {"getX", &Dtool_LVecBase4f_get_x_756, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_x_756_comment},
  {"get_y", &Dtool_LVecBase4f_get_y_757, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_y_757_comment},
  {"getY", &Dtool_LVecBase4f_get_y_757, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_y_757_comment},
  {"get_z", &Dtool_LVecBase4f_get_z_758, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_z_758_comment},
  {"getZ", &Dtool_LVecBase4f_get_z_758, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_z_758_comment},
  {"get_w", &Dtool_LVecBase4f_get_w_759, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_w_759_comment},
  {"getW", &Dtool_LVecBase4f_get_w_759, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_w_759_comment},
  {"get_xyz", &Dtool_LVecBase4f_get_xyz_760, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_xyz_760_comment},
  {"getXyz", &Dtool_LVecBase4f_get_xyz_760, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_xyz_760_comment},
  {"get_xy", &Dtool_LVecBase4f_get_xy_761, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_xy_761_comment},
  {"getXy", &Dtool_LVecBase4f_get_xy_761, METH_NOARGS, (const char *)Dtool_LVecBase4f_get_xy_761_comment},
  {"set_x", &Dtool_LVecBase4f_set_x_762, METH_O, (const char *)Dtool_LVecBase4f_set_x_762_comment},
  {"setX", &Dtool_LVecBase4f_set_x_762, METH_O, (const char *)Dtool_LVecBase4f_set_x_762_comment},
  {"set_y", &Dtool_LVecBase4f_set_y_763, METH_O, (const char *)Dtool_LVecBase4f_set_y_763_comment},
  {"setY", &Dtool_LVecBase4f_set_y_763, METH_O, (const char *)Dtool_LVecBase4f_set_y_763_comment},
  {"set_z", &Dtool_LVecBase4f_set_z_764, METH_O, (const char *)Dtool_LVecBase4f_set_z_764_comment},
  {"setZ", &Dtool_LVecBase4f_set_z_764, METH_O, (const char *)Dtool_LVecBase4f_set_z_764_comment},
  {"set_w", &Dtool_LVecBase4f_set_w_765, METH_O, (const char *)Dtool_LVecBase4f_set_w_765_comment},
  {"setW", &Dtool_LVecBase4f_set_w_765, METH_O, (const char *)Dtool_LVecBase4f_set_w_765_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase4f_add_to_cell_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_add_to_cell_771_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase4f_add_to_cell_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_add_to_cell_771_comment},
  {"add_x", &Dtool_LVecBase4f_add_x_772, METH_O, (const char *)Dtool_LVecBase4f_add_x_772_comment},
  {"addX", &Dtool_LVecBase4f_add_x_772, METH_O, (const char *)Dtool_LVecBase4f_add_x_772_comment},
  {"add_y", &Dtool_LVecBase4f_add_y_773, METH_O, (const char *)Dtool_LVecBase4f_add_y_773_comment},
  {"addY", &Dtool_LVecBase4f_add_y_773, METH_O, (const char *)Dtool_LVecBase4f_add_y_773_comment},
  {"add_z", &Dtool_LVecBase4f_add_z_774, METH_O, (const char *)Dtool_LVecBase4f_add_z_774_comment},
  {"addZ", &Dtool_LVecBase4f_add_z_774, METH_O, (const char *)Dtool_LVecBase4f_add_z_774_comment},
  {"add_w", &Dtool_LVecBase4f_add_w_775, METH_O, (const char *)Dtool_LVecBase4f_add_w_775_comment},
  {"addW", &Dtool_LVecBase4f_add_w_775, METH_O, (const char *)Dtool_LVecBase4f_add_w_775_comment},
  {"get_num_components", &Dtool_LVecBase4f_get_num_components_777, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_get_num_components_777_comment},
  {"getNumComponents", &Dtool_LVecBase4f_get_num_components_777, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_get_num_components_777_comment},
  {"fill", &Dtool_LVecBase4f_fill_779, METH_O, (const char *)Dtool_LVecBase4f_fill_779_comment},
  {"set", (PyCFunction) &Dtool_LVecBase4f_set_780, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_set_780_comment},
  {"dot", &Dtool_LVecBase4f_dot_781, METH_O, (const char *)Dtool_LVecBase4f_dot_781_comment},
  {"length_squared", &Dtool_LVecBase4f_length_squared_782, METH_NOARGS, (const char *)Dtool_LVecBase4f_length_squared_782_comment},
  {"lengthSquared", &Dtool_LVecBase4f_length_squared_782, METH_NOARGS, (const char *)Dtool_LVecBase4f_length_squared_782_comment},
  {"length", &Dtool_LVecBase4f_length_783, METH_NOARGS, (const char *)Dtool_LVecBase4f_length_783_comment},
  {"normalize", &Dtool_LVecBase4f_normalize_784, METH_NOARGS, (const char *)Dtool_LVecBase4f_normalize_784_comment},
  {"normalized", &Dtool_LVecBase4f_normalized_785, METH_NOARGS, (const char *)Dtool_LVecBase4f_normalized_785_comment},
  {"project", &Dtool_LVecBase4f_project_786, METH_O, (const char *)Dtool_LVecBase4f_project_786_comment},
  {"compare_to", &Dtool_LVecBase4f_compare_to_790, METH_VARARGS, (const char *)Dtool_LVecBase4f_compare_to_790_comment},
  {"compareTo", &Dtool_LVecBase4f_compare_to_790, METH_VARARGS, (const char *)Dtool_LVecBase4f_compare_to_790_comment},
  {"get_hash", &Dtool_LVecBase4f_get_hash_791, METH_VARARGS, (const char *)Dtool_LVecBase4f_get_hash_791_comment},
  {"getHash", &Dtool_LVecBase4f_get_hash_791, METH_VARARGS, (const char *)Dtool_LVecBase4f_get_hash_791_comment},
  {"add_hash", (PyCFunction) &Dtool_LVecBase4f_add_hash_792, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_add_hash_792_comment},
  {"addHash", (PyCFunction) &Dtool_LVecBase4f_add_hash_792, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_add_hash_792_comment},
  {"componentwise_mult", &Dtool_LVecBase4f_componentwise_mult_803, METH_O, (const char *)Dtool_LVecBase4f_componentwise_mult_803_comment},
  {"componentwiseMult", &Dtool_LVecBase4f_componentwise_mult_803, METH_O, (const char *)Dtool_LVecBase4f_componentwise_mult_803_comment},
  {"fmax", &Dtool_LVecBase4f_fmax_806, METH_O, (const char *)Dtool_LVecBase4f_fmax_806_comment},
  {"fmin", &Dtool_LVecBase4f_fmin_807, METH_O, (const char *)Dtool_LVecBase4f_fmin_807_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase4f_almost_equal_808, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_almost_equal_808_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase4f_almost_equal_808, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4f_almost_equal_808_comment},
  {"output", &Dtool_LVecBase4f_output_809, METH_O, (const char *)Dtool_LVecBase4f_output_809_comment},
  {"write_datagram_fixed", &Dtool_LVecBase4f_write_datagram_fixed_811, METH_O, (const char *)Dtool_LVecBase4f_write_datagram_fixed_811_comment},
  {"writeDatagramFixed", &Dtool_LVecBase4f_write_datagram_fixed_811, METH_O, (const char *)Dtool_LVecBase4f_write_datagram_fixed_811_comment},
  {"read_datagram_fixed", &Dtool_LVecBase4f_read_datagram_fixed_812, METH_O, (const char *)Dtool_LVecBase4f_read_datagram_fixed_812_comment},
  {"readDatagramFixed", &Dtool_LVecBase4f_read_datagram_fixed_812, METH_O, (const char *)Dtool_LVecBase4f_read_datagram_fixed_812_comment},
  {"write_datagram", &Dtool_LVecBase4f_write_datagram_813, METH_O, (const char *)Dtool_LVecBase4f_write_datagram_813_comment},
  {"writeDatagram", &Dtool_LVecBase4f_write_datagram_813, METH_O, (const char *)Dtool_LVecBase4f_write_datagram_813_comment},
  {"read_datagram", &Dtool_LVecBase4f_read_datagram_814, METH_O, (const char *)Dtool_LVecBase4f_read_datagram_814_comment},
  {"readDatagram", &Dtool_LVecBase4f_read_datagram_814, METH_O, (const char *)Dtool_LVecBase4f_read_datagram_814_comment},
  {"get_class_type", &Dtool_LVecBase4f_get_class_type_815, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_get_class_type_815_comment},
  {"getClassType", &Dtool_LVecBase4f_get_class_type_815, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4f_get_class_type_815_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase4f_operator_795_nb_add(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.__add__", "LVecBase4f");
  }
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase4f_operator_798_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4f LVecBase4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase4f_operator_799_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4f::operator +=(LVecBase4f const &other)
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.__iadd__", "LVecBase4f");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4f.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase4f_operator_802_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase4f_operator_801_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4f::operator *=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4f.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase4f_ipow_805_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent)
      if (PyNumber_Check(arg)) {
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, (float)PyFloat_AsDouble(arg));
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase4f.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase4f self, float exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase4f_operator_800_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4f::operator -=(LVecBase4f const &other)
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.__isub__", "LVecBase4f");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4f.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase4f_operator_802_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase4f_operator_797_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4f LVecBase4f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase4f_operator_794_nb_negative(PyObject *self) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4f LVecBase4f::operator -(void) const
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase4f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase4f_pow_804_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase4f LVecBase4f::__pow__(float exponent) const
    if (PyNumber_Check(arg)) {
      LVecBase4f *return_value = new LVecBase4f(invoke_extension((const LVecBase4f*)local_this).__pow__((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase4f self, float exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase4f_operator_796_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.__sub__", "LVecBase4f");
  }
  LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase4f_operator_798_nb_true_divide(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4f LVecBase4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase4f *return_value = new LVecBase4f((*(const LVecBase4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase4f_operator_751_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase4f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float &LVecBase4f::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = (float)PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase4f.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase4f self, index, float assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase4f_operator_751_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase4f index out of range");
    return NULL;
  }
  // 1-inline float LVecBase4f::operator [](int i) const
  float return_value = (*(const LVecBase4f*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase4f self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase4f_size_752_sq_length(PyObject *self) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase4f_compare_to_790_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase4f::compare_to(LVecBase4f const &other) const
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4f.compare_to", "LVecBase4f");
    return -1;
  }
  int return_value = (*(const LVecBase4f*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase4f self, const LVecBase4f other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase4f_getattr_749_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase4f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase4f_get_hash_791_tp_hash(PyObject *self) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase4f_repr_810_tp_repr(PyObject *self) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase4f::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase4f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase4f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase4f_setattr_750_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase4f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase4f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase4f
//////////////////
static PyObject *Dtool_RichCompare_LVecBase4f(PyObject *self, PyObject *arg, int op) {
  LVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase4f::operator <(LVecBase4f const &other) const
      LVecBase4f arg_local;
      LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4f*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase4f::operator ==(LVecBase4f const &other) const
      LVecBase4f arg_local;
      LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4f*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase4f::operator !=(LVecBase4f const &other) const
      LVecBase4f arg_local;
      LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4f*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase4f_compare_to_790_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase4f[] = {
  {(char *)"x", &Dtool_LVecBase4f_x_Getter, &Dtool_LVecBase4f_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase4f_y_Getter, &Dtool_LVecBase4f_y_Setter, NULL, NULL},
  {(char *)"z", &Dtool_LVecBase4f_z_Getter, &Dtool_LVecBase4f_z_Setter, NULL, NULL},
  {(char *)"xyz", &Dtool_LVecBase4f_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LVecBase4f_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase4f = {
  &Dtool_LVecBase4f_operator_795_nb_add,
  &Dtool_LVecBase4f_operator_796_nb_subtract,
  &Dtool_LVecBase4f_operator_797_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase4f_operator_798_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase4f_pow_804_nb_power,
  &Dtool_LVecBase4f_operator_794_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase4f_operator_799_nb_inplace_add,
  &Dtool_LVecBase4f_operator_800_nb_inplace_subtract,
  &Dtool_LVecBase4f_operator_801_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase4f_operator_802_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase4f_ipow_805_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase4f_operator_798_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase4f_operator_802_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase4f = {
  &Dtool_LVecBase4f_size_752_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase4f_operator_751_sq_item,
  0, // sq_slice
  &Dtool_LVecBase4f_operator_751_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase4f_compare_to_790_tp_compare,
#endif
    &Dtool_LVecBase4f_repr_810_tp_repr,
    &Dtool_NumberMethods_LVecBase4f,
    &Dtool_SequenceMethods_LVecBase4f,
    0, // tp_as_mapping
    &Dtool_LVecBase4f_get_hash_791_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase4f_getattr_749_tp_getattro,
    &Dtool_LVecBase4f_setattr_750_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all three-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase4f,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase4f,
    0, // tp_members
    Dtool_Properties_LVecBase4f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_LVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase4f,
  Dtool_UpcastInterface_LVecBase4f,
  Dtool_DowncastInterface_LVecBase4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase4f,
};

static void Dtool_PyModuleClassInit_LVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase4f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase4f::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase4f::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase4f);
  }
}

/**
 * Python method tables for UnalignedLVecBase4f (UnalignedLVecBase4f)
 */
static PyMethodDef Dtool_Methods_UnalignedLVecBase4f[] = {
  {"set", (PyCFunction) &Dtool_UnalignedLVecBase4f_set_820, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_UnalignedLVecBase4f_set_820_comment},
  {"get_num_components", &Dtool_UnalignedLVecBase4f_get_num_components_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4f_get_num_components_824_comment},
  {"getNumComponents", &Dtool_UnalignedLVecBase4f_get_num_components_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4f_get_num_components_824_comment},
  {"get_class_type", &Dtool_UnalignedLVecBase4f_get_class_type_825, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4f_get_class_type_825_comment},
  {"getClassType", &Dtool_UnalignedLVecBase4f_get_class_type_825, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4f_get_class_type_825_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4f slot sq_ass_item -> operator []
//////////////////
static int Dtool_UnalignedLVecBase4f_operator_821_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  UnalignedLVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "UnalignedLVecBase4f index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float &UnalignedLVecBase4f::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = (float)PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call UnalignedLVecBase4f.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const UnalignedLVecBase4f self, index, float assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4f slot sq_item -> operator []
//////////////////
static PyObject *Dtool_UnalignedLVecBase4f_operator_821_sq_item(PyObject *self, Py_ssize_t index) {
  UnalignedLVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "UnalignedLVecBase4f index out of range");
    return NULL;
  }
  // 1-inline float UnalignedLVecBase4f::operator [](int i) const
  float return_value = (*(const UnalignedLVecBase4f*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(UnalignedLVecBase4f self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_UnalignedLVecBase4f_size_822_sq_length(PyObject *self) {
  UnalignedLVecBase4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_UnalignedLVecBase4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnalignedLVecBase4f = {
  &Dtool_UnalignedLVecBase4f_size_822_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_UnalignedLVecBase4f_operator_821_sq_item,
  0, // sq_slice
  &Dtool_UnalignedLVecBase4f_operator_821_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UnalignedLVecBase4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnalignedLVecBase4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UnalignedLVecBase4f,
    &Dtool_SequenceMethods_UnalignedLVecBase4f,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an \"unaligned\" LVecBase4.  It has no functionality other than to\n"
    " * store numbers, and it will pack them in as tightly as possible, avoiding\n"
    " * any SSE2 alignment requirements shared by the primary LVecBase4 class.\n"
    " *\n"
    " * Use it only when you need to pack numbers tightly without respect to\n"
    " * alignment, and then copy it to a proper LVecBase4 to get actual use from\n"
    " * it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UnalignedLVecBase4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UnalignedLVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_UnalignedLVecBase4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnalignedLVecBase4f,
  Dtool_UpcastInterface_UnalignedLVecBase4f,
  Dtool_DowncastInterface_UnalignedLVecBase4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_UnalignedLVecBase4f,
};

static void Dtool_PyModuleClassInit_UnalignedLVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UnalignedLVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UnalignedLVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum UnalignedLVecBase4f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(UnalignedLVecBase4f::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(UnalignedLVecBase4f::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_UnalignedLVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnalignedLVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnalignedLVecBase4f);
  }
}

/**
 * Python method tables for LVecBase4d (LVecBase4d)
 */
static PyMethodDef Dtool_Methods_LVecBase4d[] = {
  {"assign", &Dtool_LVecBase4d_operator_833, METH_O, (const char *)Dtool_LVecBase4d_operator_833_comment},
  {"zero", &Dtool_LVecBase4d_zero_834, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_zero_834_comment},
  {"unit_x", &Dtool_LVecBase4d_unit_x_835, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_x_835_comment},
  {"unitX", &Dtool_LVecBase4d_unit_x_835, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_x_835_comment},
  {"unit_y", &Dtool_LVecBase4d_unit_y_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_y_836_comment},
  {"unitY", &Dtool_LVecBase4d_unit_y_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_y_836_comment},
  {"unit_z", &Dtool_LVecBase4d_unit_z_837, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_z_837_comment},
  {"unitZ", &Dtool_LVecBase4d_unit_z_837, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_z_837_comment},
  {"unit_w", &Dtool_LVecBase4d_unit_w_838, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_w_838_comment},
  {"unitW", &Dtool_LVecBase4d_unit_w_838, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_unit_w_838_comment},
  {"__reduce__", &Dtool_LVecBase4d_reduce_839, METH_NOARGS, (const char *)Dtool_LVecBase4d_reduce_839_comment},
  {"is_nan", &Dtool_LVecBase4d_is_nan_844, METH_NOARGS, (const char *)Dtool_LVecBase4d_is_nan_844_comment},
  {"isNan", &Dtool_LVecBase4d_is_nan_844, METH_NOARGS, (const char *)Dtool_LVecBase4d_is_nan_844_comment},
  {"get_cell", &Dtool_LVecBase4d_get_cell_845, METH_O, (const char *)Dtool_LVecBase4d_get_cell_845_comment},
  {"getCell", &Dtool_LVecBase4d_get_cell_845, METH_O, (const char *)Dtool_LVecBase4d_get_cell_845_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase4d_set_cell_846, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_set_cell_846_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase4d_set_cell_846, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_set_cell_846_comment},
  {"get_x", &Dtool_LVecBase4d_get_x_847, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_x_847_comment},
  {"getX", &Dtool_LVecBase4d_get_x_847, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_x_847_comment},
  {"get_y", &Dtool_LVecBase4d_get_y_848, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_y_848_comment},
  {"getY", &Dtool_LVecBase4d_get_y_848, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_y_848_comment},
  {"get_z", &Dtool_LVecBase4d_get_z_849, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_z_849_comment},
  {"getZ", &Dtool_LVecBase4d_get_z_849, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_z_849_comment},
  {"get_w", &Dtool_LVecBase4d_get_w_850, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_w_850_comment},
  {"getW", &Dtool_LVecBase4d_get_w_850, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_w_850_comment},
  {"get_xyz", &Dtool_LVecBase4d_get_xyz_851, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_xyz_851_comment},
  {"getXyz", &Dtool_LVecBase4d_get_xyz_851, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_xyz_851_comment},
  {"get_xy", &Dtool_LVecBase4d_get_xy_852, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_xy_852_comment},
  {"getXy", &Dtool_LVecBase4d_get_xy_852, METH_NOARGS, (const char *)Dtool_LVecBase4d_get_xy_852_comment},
  {"set_x", &Dtool_LVecBase4d_set_x_853, METH_O, (const char *)Dtool_LVecBase4d_set_x_853_comment},
  {"setX", &Dtool_LVecBase4d_set_x_853, METH_O, (const char *)Dtool_LVecBase4d_set_x_853_comment},
  {"set_y", &Dtool_LVecBase4d_set_y_854, METH_O, (const char *)Dtool_LVecBase4d_set_y_854_comment},
  {"setY", &Dtool_LVecBase4d_set_y_854, METH_O, (const char *)Dtool_LVecBase4d_set_y_854_comment},
  {"set_z", &Dtool_LVecBase4d_set_z_855, METH_O, (const char *)Dtool_LVecBase4d_set_z_855_comment},
  {"setZ", &Dtool_LVecBase4d_set_z_855, METH_O, (const char *)Dtool_LVecBase4d_set_z_855_comment},
  {"set_w", &Dtool_LVecBase4d_set_w_856, METH_O, (const char *)Dtool_LVecBase4d_set_w_856_comment},
  {"setW", &Dtool_LVecBase4d_set_w_856, METH_O, (const char *)Dtool_LVecBase4d_set_w_856_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase4d_add_to_cell_862, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_add_to_cell_862_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase4d_add_to_cell_862, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_add_to_cell_862_comment},
  {"add_x", &Dtool_LVecBase4d_add_x_863, METH_O, (const char *)Dtool_LVecBase4d_add_x_863_comment},
  {"addX", &Dtool_LVecBase4d_add_x_863, METH_O, (const char *)Dtool_LVecBase4d_add_x_863_comment},
  {"add_y", &Dtool_LVecBase4d_add_y_864, METH_O, (const char *)Dtool_LVecBase4d_add_y_864_comment},
  {"addY", &Dtool_LVecBase4d_add_y_864, METH_O, (const char *)Dtool_LVecBase4d_add_y_864_comment},
  {"add_z", &Dtool_LVecBase4d_add_z_865, METH_O, (const char *)Dtool_LVecBase4d_add_z_865_comment},
  {"addZ", &Dtool_LVecBase4d_add_z_865, METH_O, (const char *)Dtool_LVecBase4d_add_z_865_comment},
  {"add_w", &Dtool_LVecBase4d_add_w_866, METH_O, (const char *)Dtool_LVecBase4d_add_w_866_comment},
  {"addW", &Dtool_LVecBase4d_add_w_866, METH_O, (const char *)Dtool_LVecBase4d_add_w_866_comment},
  {"get_num_components", &Dtool_LVecBase4d_get_num_components_868, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_get_num_components_868_comment},
  {"getNumComponents", &Dtool_LVecBase4d_get_num_components_868, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_get_num_components_868_comment},
  {"fill", &Dtool_LVecBase4d_fill_870, METH_O, (const char *)Dtool_LVecBase4d_fill_870_comment},
  {"set", (PyCFunction) &Dtool_LVecBase4d_set_871, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_set_871_comment},
  {"dot", &Dtool_LVecBase4d_dot_872, METH_O, (const char *)Dtool_LVecBase4d_dot_872_comment},
  {"length_squared", &Dtool_LVecBase4d_length_squared_873, METH_NOARGS, (const char *)Dtool_LVecBase4d_length_squared_873_comment},
  {"lengthSquared", &Dtool_LVecBase4d_length_squared_873, METH_NOARGS, (const char *)Dtool_LVecBase4d_length_squared_873_comment},
  {"length", &Dtool_LVecBase4d_length_874, METH_NOARGS, (const char *)Dtool_LVecBase4d_length_874_comment},
  {"normalize", &Dtool_LVecBase4d_normalize_875, METH_NOARGS, (const char *)Dtool_LVecBase4d_normalize_875_comment},
  {"normalized", &Dtool_LVecBase4d_normalized_876, METH_NOARGS, (const char *)Dtool_LVecBase4d_normalized_876_comment},
  {"project", &Dtool_LVecBase4d_project_877, METH_O, (const char *)Dtool_LVecBase4d_project_877_comment},
  {"compare_to", &Dtool_LVecBase4d_compare_to_881, METH_VARARGS, (const char *)Dtool_LVecBase4d_compare_to_881_comment},
  {"compareTo", &Dtool_LVecBase4d_compare_to_881, METH_VARARGS, (const char *)Dtool_LVecBase4d_compare_to_881_comment},
  {"get_hash", &Dtool_LVecBase4d_get_hash_882, METH_VARARGS, (const char *)Dtool_LVecBase4d_get_hash_882_comment},
  {"getHash", &Dtool_LVecBase4d_get_hash_882, METH_VARARGS, (const char *)Dtool_LVecBase4d_get_hash_882_comment},
  {"add_hash", (PyCFunction) &Dtool_LVecBase4d_add_hash_883, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_add_hash_883_comment},
  {"addHash", (PyCFunction) &Dtool_LVecBase4d_add_hash_883, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_add_hash_883_comment},
  {"componentwise_mult", &Dtool_LVecBase4d_componentwise_mult_894, METH_O, (const char *)Dtool_LVecBase4d_componentwise_mult_894_comment},
  {"componentwiseMult", &Dtool_LVecBase4d_componentwise_mult_894, METH_O, (const char *)Dtool_LVecBase4d_componentwise_mult_894_comment},
  {"fmax", &Dtool_LVecBase4d_fmax_897, METH_O, (const char *)Dtool_LVecBase4d_fmax_897_comment},
  {"fmin", &Dtool_LVecBase4d_fmin_898, METH_O, (const char *)Dtool_LVecBase4d_fmin_898_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase4d_almost_equal_899, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_almost_equal_899_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase4d_almost_equal_899, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4d_almost_equal_899_comment},
  {"output", &Dtool_LVecBase4d_output_900, METH_O, (const char *)Dtool_LVecBase4d_output_900_comment},
  {"write_datagram_fixed", &Dtool_LVecBase4d_write_datagram_fixed_902, METH_O, (const char *)Dtool_LVecBase4d_write_datagram_fixed_902_comment},
  {"writeDatagramFixed", &Dtool_LVecBase4d_write_datagram_fixed_902, METH_O, (const char *)Dtool_LVecBase4d_write_datagram_fixed_902_comment},
  {"read_datagram_fixed", &Dtool_LVecBase4d_read_datagram_fixed_903, METH_O, (const char *)Dtool_LVecBase4d_read_datagram_fixed_903_comment},
  {"readDatagramFixed", &Dtool_LVecBase4d_read_datagram_fixed_903, METH_O, (const char *)Dtool_LVecBase4d_read_datagram_fixed_903_comment},
  {"write_datagram", &Dtool_LVecBase4d_write_datagram_904, METH_O, (const char *)Dtool_LVecBase4d_write_datagram_904_comment},
  {"writeDatagram", &Dtool_LVecBase4d_write_datagram_904, METH_O, (const char *)Dtool_LVecBase4d_write_datagram_904_comment},
  {"read_datagram", &Dtool_LVecBase4d_read_datagram_905, METH_O, (const char *)Dtool_LVecBase4d_read_datagram_905_comment},
  {"readDatagram", &Dtool_LVecBase4d_read_datagram_905, METH_O, (const char *)Dtool_LVecBase4d_read_datagram_905_comment},
  {"get_class_type", &Dtool_LVecBase4d_get_class_type_906, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_get_class_type_906_comment},
  {"getClassType", &Dtool_LVecBase4d_get_class_type_906, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4d_get_class_type_906_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase4d_operator_886_nb_add(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.__add__", "LVecBase4d");
  }
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase4d_operator_889_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4d LVecBase4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase4d_operator_890_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4d::operator +=(LVecBase4d const &other)
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.__iadd__", "LVecBase4d");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4d.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase4d_operator_893_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase4d_operator_892_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4d::operator *=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator *=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4d.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase4d_ipow_896_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent)
      if (PyNumber_Check(arg)) {
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, PyFloat_AsDouble(arg));
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase4d.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase4d self, double exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase4d_operator_891_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4d::operator -=(LVecBase4d const &other)
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.__isub__", "LVecBase4d");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4d.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase4d_operator_893_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase4d_operator_888_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4d LVecBase4d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase4d_operator_885_nb_negative(PyObject *self) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4d LVecBase4d::operator -(void) const
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase4d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase4d_pow_895_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase4d LVecBase4d::__pow__(double exponent) const
    if (PyNumber_Check(arg)) {
      LVecBase4d *return_value = new LVecBase4d(invoke_extension((const LVecBase4d*)local_this).__pow__(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase4d self, double exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase4d_operator_887_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.__sub__", "LVecBase4d");
  }
  LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase4d_operator_889_nb_true_divide(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4d LVecBase4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVecBase4d *return_value = new LVecBase4d((*(const LVecBase4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase4d_operator_842_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase4d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double &LVecBase4d::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase4d.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase4d self, index, double assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase4d_operator_842_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase4d index out of range");
    return NULL;
  }
  // 1-inline double LVecBase4d::operator [](int i) const
  double return_value = (*(const LVecBase4d*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase4d self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase4d_size_843_sq_length(PyObject *self) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase4d_compare_to_881_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase4d::compare_to(LVecBase4d const &other) const
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4d.compare_to", "LVecBase4d");
    return -1;
  }
  int return_value = (*(const LVecBase4d*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase4d self, const LVecBase4d other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase4d_getattr_840_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase4d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase4d_get_hash_882_tp_hash(PyObject *self) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase4d_repr_901_tp_repr(PyObject *self) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase4d::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase4d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase4d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase4d_setattr_841_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase4d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase4d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase4d
//////////////////
static PyObject *Dtool_RichCompare_LVecBase4d(PyObject *self, PyObject *arg, int op) {
  LVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase4d::operator <(LVecBase4d const &other) const
      LVecBase4d arg_local;
      LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4d*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase4d::operator ==(LVecBase4d const &other) const
      LVecBase4d arg_local;
      LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4d*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase4d::operator !=(LVecBase4d const &other) const
      LVecBase4d arg_local;
      LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4d*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase4d_compare_to_881_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase4d[] = {
  {(char *)"x", &Dtool_LVecBase4d_x_Getter, &Dtool_LVecBase4d_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase4d_y_Getter, &Dtool_LVecBase4d_y_Setter, NULL, NULL},
  {(char *)"z", &Dtool_LVecBase4d_z_Getter, &Dtool_LVecBase4d_z_Setter, NULL, NULL},
  {(char *)"xyz", &Dtool_LVecBase4d_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LVecBase4d_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase4d = {
  &Dtool_LVecBase4d_operator_886_nb_add,
  &Dtool_LVecBase4d_operator_887_nb_subtract,
  &Dtool_LVecBase4d_operator_888_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase4d_operator_889_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase4d_pow_895_nb_power,
  &Dtool_LVecBase4d_operator_885_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase4d_operator_890_nb_inplace_add,
  &Dtool_LVecBase4d_operator_891_nb_inplace_subtract,
  &Dtool_LVecBase4d_operator_892_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase4d_operator_893_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase4d_ipow_896_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase4d_operator_889_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVecBase4d_operator_893_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase4d = {
  &Dtool_LVecBase4d_size_843_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase4d_operator_842_sq_item,
  0, // sq_slice
  &Dtool_LVecBase4d_operator_842_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase4d_compare_to_881_tp_compare,
#endif
    &Dtool_LVecBase4d_repr_901_tp_repr,
    &Dtool_NumberMethods_LVecBase4d,
    &Dtool_SequenceMethods_LVecBase4d,
    0, // tp_as_mapping
    &Dtool_LVecBase4d_get_hash_882_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase4d_getattr_840_tp_getattro,
    &Dtool_LVecBase4d_setattr_841_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all three-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase4d,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase4d,
    0, // tp_members
    Dtool_Properties_LVecBase4d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_LVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase4d,
  Dtool_UpcastInterface_LVecBase4d,
  Dtool_DowncastInterface_LVecBase4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase4d,
};

static void Dtool_PyModuleClassInit_LVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase4d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase4d::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase4d::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase4d);
  }
}

/**
 * Python method tables for UnalignedLVecBase4d (UnalignedLVecBase4d)
 */
static PyMethodDef Dtool_Methods_UnalignedLVecBase4d[] = {
  {"set", (PyCFunction) &Dtool_UnalignedLVecBase4d_set_911, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_UnalignedLVecBase4d_set_911_comment},
  {"get_num_components", &Dtool_UnalignedLVecBase4d_get_num_components_915, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4d_get_num_components_915_comment},
  {"getNumComponents", &Dtool_UnalignedLVecBase4d_get_num_components_915, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4d_get_num_components_915_comment},
  {"get_class_type", &Dtool_UnalignedLVecBase4d_get_class_type_916, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4d_get_class_type_916_comment},
  {"getClassType", &Dtool_UnalignedLVecBase4d_get_class_type_916, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4d_get_class_type_916_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4d slot sq_ass_item -> operator []
//////////////////
static int Dtool_UnalignedLVecBase4d_operator_912_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  UnalignedLVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "UnalignedLVecBase4d index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double &UnalignedLVecBase4d::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call UnalignedLVecBase4d.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const UnalignedLVecBase4d self, index, double assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4d slot sq_item -> operator []
//////////////////
static PyObject *Dtool_UnalignedLVecBase4d_operator_912_sq_item(PyObject *self, Py_ssize_t index) {
  UnalignedLVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "UnalignedLVecBase4d index out of range");
    return NULL;
  }
  // 1-inline double UnalignedLVecBase4d::operator [](int i) const
  double return_value = (*(const UnalignedLVecBase4d*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(UnalignedLVecBase4d self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_UnalignedLVecBase4d_size_913_sq_length(PyObject *self) {
  UnalignedLVecBase4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_UnalignedLVecBase4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnalignedLVecBase4d = {
  &Dtool_UnalignedLVecBase4d_size_913_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_UnalignedLVecBase4d_operator_912_sq_item,
  0, // sq_slice
  &Dtool_UnalignedLVecBase4d_operator_912_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UnalignedLVecBase4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnalignedLVecBase4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UnalignedLVecBase4d,
    &Dtool_SequenceMethods_UnalignedLVecBase4d,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an \"unaligned\" LVecBase4.  It has no functionality other than to\n"
    " * store numbers, and it will pack them in as tightly as possible, avoiding\n"
    " * any SSE2 alignment requirements shared by the primary LVecBase4 class.\n"
    " *\n"
    " * Use it only when you need to pack numbers tightly without respect to\n"
    " * alignment, and then copy it to a proper LVecBase4 to get actual use from\n"
    " * it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UnalignedLVecBase4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UnalignedLVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_UnalignedLVecBase4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnalignedLVecBase4d,
  Dtool_UpcastInterface_UnalignedLVecBase4d,
  Dtool_DowncastInterface_UnalignedLVecBase4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_UnalignedLVecBase4d,
};

static void Dtool_PyModuleClassInit_UnalignedLVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UnalignedLVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UnalignedLVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum UnalignedLVecBase4d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(UnalignedLVecBase4d::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(UnalignedLVecBase4d::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_UnalignedLVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnalignedLVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnalignedLVecBase4d);
  }
}

/**
 * Python method tables for LVecBase4i (LVecBase4i)
 */
static PyMethodDef Dtool_Methods_LVecBase4i[] = {
  {"assign", &Dtool_LVecBase4i_operator_924, METH_O, (const char *)Dtool_LVecBase4i_operator_924_comment},
  {"zero", &Dtool_LVecBase4i_zero_925, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_zero_925_comment},
  {"unit_x", &Dtool_LVecBase4i_unit_x_926, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_x_926_comment},
  {"unitX", &Dtool_LVecBase4i_unit_x_926, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_x_926_comment},
  {"unit_y", &Dtool_LVecBase4i_unit_y_927, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_y_927_comment},
  {"unitY", &Dtool_LVecBase4i_unit_y_927, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_y_927_comment},
  {"unit_z", &Dtool_LVecBase4i_unit_z_928, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_z_928_comment},
  {"unitZ", &Dtool_LVecBase4i_unit_z_928, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_z_928_comment},
  {"unit_w", &Dtool_LVecBase4i_unit_w_929, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_w_929_comment},
  {"unitW", &Dtool_LVecBase4i_unit_w_929, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_unit_w_929_comment},
  {"__reduce__", &Dtool_LVecBase4i_reduce_930, METH_NOARGS, (const char *)Dtool_LVecBase4i_reduce_930_comment},
  {"is_nan", &Dtool_LVecBase4i_is_nan_935, METH_NOARGS, (const char *)Dtool_LVecBase4i_is_nan_935_comment},
  {"isNan", &Dtool_LVecBase4i_is_nan_935, METH_NOARGS, (const char *)Dtool_LVecBase4i_is_nan_935_comment},
  {"get_cell", &Dtool_LVecBase4i_get_cell_936, METH_O, (const char *)Dtool_LVecBase4i_get_cell_936_comment},
  {"getCell", &Dtool_LVecBase4i_get_cell_936, METH_O, (const char *)Dtool_LVecBase4i_get_cell_936_comment},
  {"set_cell", (PyCFunction) &Dtool_LVecBase4i_set_cell_937, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_set_cell_937_comment},
  {"setCell", (PyCFunction) &Dtool_LVecBase4i_set_cell_937, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_set_cell_937_comment},
  {"get_x", &Dtool_LVecBase4i_get_x_938, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_x_938_comment},
  {"getX", &Dtool_LVecBase4i_get_x_938, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_x_938_comment},
  {"get_y", &Dtool_LVecBase4i_get_y_939, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_y_939_comment},
  {"getY", &Dtool_LVecBase4i_get_y_939, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_y_939_comment},
  {"get_z", &Dtool_LVecBase4i_get_z_940, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_z_940_comment},
  {"getZ", &Dtool_LVecBase4i_get_z_940, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_z_940_comment},
  {"get_w", &Dtool_LVecBase4i_get_w_941, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_w_941_comment},
  {"getW", &Dtool_LVecBase4i_get_w_941, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_w_941_comment},
  {"get_xyz", &Dtool_LVecBase4i_get_xyz_942, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_xyz_942_comment},
  {"getXyz", &Dtool_LVecBase4i_get_xyz_942, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_xyz_942_comment},
  {"get_xy", &Dtool_LVecBase4i_get_xy_943, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_xy_943_comment},
  {"getXy", &Dtool_LVecBase4i_get_xy_943, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_xy_943_comment},
  {"set_x", &Dtool_LVecBase4i_set_x_944, METH_O, (const char *)Dtool_LVecBase4i_set_x_944_comment},
  {"setX", &Dtool_LVecBase4i_set_x_944, METH_O, (const char *)Dtool_LVecBase4i_set_x_944_comment},
  {"set_y", &Dtool_LVecBase4i_set_y_945, METH_O, (const char *)Dtool_LVecBase4i_set_y_945_comment},
  {"setY", &Dtool_LVecBase4i_set_y_945, METH_O, (const char *)Dtool_LVecBase4i_set_y_945_comment},
  {"set_z", &Dtool_LVecBase4i_set_z_946, METH_O, (const char *)Dtool_LVecBase4i_set_z_946_comment},
  {"setZ", &Dtool_LVecBase4i_set_z_946, METH_O, (const char *)Dtool_LVecBase4i_set_z_946_comment},
  {"set_w", &Dtool_LVecBase4i_set_w_947, METH_O, (const char *)Dtool_LVecBase4i_set_w_947_comment},
  {"setW", &Dtool_LVecBase4i_set_w_947, METH_O, (const char *)Dtool_LVecBase4i_set_w_947_comment},
  {"add_to_cell", (PyCFunction) &Dtool_LVecBase4i_add_to_cell_953, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_add_to_cell_953_comment},
  {"addToCell", (PyCFunction) &Dtool_LVecBase4i_add_to_cell_953, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_add_to_cell_953_comment},
  {"add_x", &Dtool_LVecBase4i_add_x_954, METH_O, (const char *)Dtool_LVecBase4i_add_x_954_comment},
  {"addX", &Dtool_LVecBase4i_add_x_954, METH_O, (const char *)Dtool_LVecBase4i_add_x_954_comment},
  {"add_y", &Dtool_LVecBase4i_add_y_955, METH_O, (const char *)Dtool_LVecBase4i_add_y_955_comment},
  {"addY", &Dtool_LVecBase4i_add_y_955, METH_O, (const char *)Dtool_LVecBase4i_add_y_955_comment},
  {"add_z", &Dtool_LVecBase4i_add_z_956, METH_O, (const char *)Dtool_LVecBase4i_add_z_956_comment},
  {"addZ", &Dtool_LVecBase4i_add_z_956, METH_O, (const char *)Dtool_LVecBase4i_add_z_956_comment},
  {"add_w", &Dtool_LVecBase4i_add_w_957, METH_O, (const char *)Dtool_LVecBase4i_add_w_957_comment},
  {"addW", &Dtool_LVecBase4i_add_w_957, METH_O, (const char *)Dtool_LVecBase4i_add_w_957_comment},
  {"get_num_components", &Dtool_LVecBase4i_get_num_components_959, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_get_num_components_959_comment},
  {"getNumComponents", &Dtool_LVecBase4i_get_num_components_959, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_get_num_components_959_comment},
  {"fill", &Dtool_LVecBase4i_fill_961, METH_O, (const char *)Dtool_LVecBase4i_fill_961_comment},
  {"set", (PyCFunction) &Dtool_LVecBase4i_set_962, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_set_962_comment},
  {"dot", &Dtool_LVecBase4i_dot_963, METH_O, (const char *)Dtool_LVecBase4i_dot_963_comment},
  {"length_squared", &Dtool_LVecBase4i_length_squared_964, METH_NOARGS, (const char *)Dtool_LVecBase4i_length_squared_964_comment},
  {"lengthSquared", &Dtool_LVecBase4i_length_squared_964, METH_NOARGS, (const char *)Dtool_LVecBase4i_length_squared_964_comment},
  {"compare_to", &Dtool_LVecBase4i_compare_to_968, METH_O, (const char *)Dtool_LVecBase4i_compare_to_968_comment},
  {"compareTo", &Dtool_LVecBase4i_compare_to_968, METH_O, (const char *)Dtool_LVecBase4i_compare_to_968_comment},
  {"get_hash", &Dtool_LVecBase4i_get_hash_969, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_hash_969_comment},
  {"getHash", &Dtool_LVecBase4i_get_hash_969, METH_NOARGS, (const char *)Dtool_LVecBase4i_get_hash_969_comment},
  {"add_hash", &Dtool_LVecBase4i_add_hash_970, METH_O, (const char *)Dtool_LVecBase4i_add_hash_970_comment},
  {"addHash", &Dtool_LVecBase4i_add_hash_970, METH_O, (const char *)Dtool_LVecBase4i_add_hash_970_comment},
  {"componentwise_mult", &Dtool_LVecBase4i_componentwise_mult_981, METH_O, (const char *)Dtool_LVecBase4i_componentwise_mult_981_comment},
  {"componentwiseMult", &Dtool_LVecBase4i_componentwise_mult_981, METH_O, (const char *)Dtool_LVecBase4i_componentwise_mult_981_comment},
  {"fmax", &Dtool_LVecBase4i_fmax_984, METH_O, (const char *)Dtool_LVecBase4i_fmax_984_comment},
  {"fmin", &Dtool_LVecBase4i_fmin_985, METH_O, (const char *)Dtool_LVecBase4i_fmin_985_comment},
  {"almost_equal", (PyCFunction) &Dtool_LVecBase4i_almost_equal_986, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_almost_equal_986_comment},
  {"almostEqual", (PyCFunction) &Dtool_LVecBase4i_almost_equal_986, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LVecBase4i_almost_equal_986_comment},
  {"output", &Dtool_LVecBase4i_output_987, METH_O, (const char *)Dtool_LVecBase4i_output_987_comment},
  {"write_datagram_fixed", &Dtool_LVecBase4i_write_datagram_fixed_989, METH_O, (const char *)Dtool_LVecBase4i_write_datagram_fixed_989_comment},
  {"writeDatagramFixed", &Dtool_LVecBase4i_write_datagram_fixed_989, METH_O, (const char *)Dtool_LVecBase4i_write_datagram_fixed_989_comment},
  {"read_datagram_fixed", &Dtool_LVecBase4i_read_datagram_fixed_990, METH_O, (const char *)Dtool_LVecBase4i_read_datagram_fixed_990_comment},
  {"readDatagramFixed", &Dtool_LVecBase4i_read_datagram_fixed_990, METH_O, (const char *)Dtool_LVecBase4i_read_datagram_fixed_990_comment},
  {"write_datagram", &Dtool_LVecBase4i_write_datagram_991, METH_O, (const char *)Dtool_LVecBase4i_write_datagram_991_comment},
  {"writeDatagram", &Dtool_LVecBase4i_write_datagram_991, METH_O, (const char *)Dtool_LVecBase4i_write_datagram_991_comment},
  {"read_datagram", &Dtool_LVecBase4i_read_datagram_992, METH_O, (const char *)Dtool_LVecBase4i_read_datagram_992_comment},
  {"readDatagram", &Dtool_LVecBase4i_read_datagram_992, METH_O, (const char *)Dtool_LVecBase4i_read_datagram_992_comment},
  {"get_class_type", &Dtool_LVecBase4i_get_class_type_993, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_get_class_type_993_comment},
  {"getClassType", &Dtool_LVecBase4i_get_class_type_993, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVecBase4i_get_class_type_993_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVecBase4i_operator_973_nb_add(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.__add__", "LVecBase4i");
  }
  LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVecBase4i_operator_976_nb_divide(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4i LVecBase4i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LVecBase4i_operator_977_nb_inplace_add(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4i::operator +=(LVecBase4i const &other)
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.__iadd__", "LVecBase4i");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4i.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LVecBase4i_operator_980_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4i::operator /=(int scalar)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator /=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4i.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LVecBase4i_operator_979_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4i::operator *=(int scalar)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator *=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4i.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_inplace_power -> __ipow__
//////////////////
static PyObject *Dtool_LVecBase4i_ipow_983_nb_inplace_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        PyObject *return_value = invoke_extension(local_this).__ipow__(self, (int)arg_val);
        return Dtool_Return(return_value);
      }
    } else {
#ifdef NDEBUG
      return Dtool_Raise_TypeError("non-const method called on const object");
#else
      return Dtool_Raise_TypeError("Cannot call LVecBase4i.__ipow__() on a const object.");
#endif
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__ipow__(const LVecBase4i self, int exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LVecBase4i_operator_978_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void LVecBase4i::operator -=(LVecBase4i const &other)
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.__isub__", "LVecBase4i");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LVecBase4i.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVecBase4i_operator_975_nb_multiply(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4i LVecBase4i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVecBase4i_operator_972_nb_negative(PyObject *self) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVecBase4i LVecBase4i::operator -(void) const
  LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVecBase4i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_power -> __pow__
//////////////////
static PyObject *Dtool_LVecBase4i_pow_982_nb_power(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (arg2 != (PyObject *)NULL) {
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    Py_DECREF(args);
  } else {
    // 1-inline LVecBase4i LVecBase4i::__pow__(int exponent) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      LVecBase4i *return_value = new LVecBase4i(invoke_extension((const LVecBase4i*)local_this).__pow__((int)arg_val));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__pow__(LVecBase4i self, int exponent)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVecBase4i_operator_974_nb_subtract(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVecBase4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.__sub__", "LVecBase4i");
  }
  LVecBase4i *return_value = new LVecBase4i((*(const LVecBase4i*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot sq_ass_item -> operator []
//////////////////
static int Dtool_LVecBase4i_operator_933_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase4i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int &LVecBase4i::operator [](int i)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return -1;
        }
#endif
        (*local_this).operator [](index) = (int)arg_val;
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call LVecBase4i.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const LVecBase4i self, index, int assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LVecBase4i_operator_933_sq_item(PyObject *self, Py_ssize_t index) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LVecBase4i index out of range");
    return NULL;
  }
  // 1-inline int LVecBase4i::operator [](int i) const
  int return_value = (*(const LVecBase4i*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(LVecBase4i self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LVecBase4i_size_934_sq_length(PyObject *self) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot tp_compare -> compare_to
//////////////////
static int Dtool_LVecBase4i_compare_to_968_tp_compare(PyObject *self, PyObject *arg) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LVecBase4i::compare_to(LVecBase4i const &other) const
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LVecBase4i.compare_to", "LVecBase4i");
    return -1;
  }
  int return_value = (*(const LVecBase4i*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LVecBase4i self, const LVecBase4i other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVecBase4i_getattr_931_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVecBase4i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LVecBase4i_get_hash_969_tp_hash(PyObject *self) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVecBase4i_repr_988_tp_repr(PyObject *self) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVecBase4i::__repr__(void) const
  std::string return_value = invoke_extension((const LVecBase4i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVecBase4i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVecBase4i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVecBase4i_setattr_932_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVecBase4i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVecBase4i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

//////////////////
//  A rich comparison function
//     LVecBase4i
//////////////////
static PyObject *Dtool_RichCompare_LVecBase4i(PyObject *self, PyObject *arg, int op) {
  LVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LVecBase4i::operator <(LVecBase4i const &other) const
      LVecBase4i arg_local;
      LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4i*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LVecBase4i::operator ==(LVecBase4i const &other) const
      LVecBase4i arg_local;
      LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4i*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LVecBase4i::operator !=(LVecBase4i const &other) const
      LVecBase4i arg_local;
      LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LVecBase4i*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LVecBase4i_compare_to_968_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LVecBase4i[] = {
  {(char *)"x", &Dtool_LVecBase4i_x_Getter, &Dtool_LVecBase4i_x_Setter, NULL, NULL},
  {(char *)"y", &Dtool_LVecBase4i_y_Getter, &Dtool_LVecBase4i_y_Setter, NULL, NULL},
  {(char *)"z", &Dtool_LVecBase4i_z_Getter, &Dtool_LVecBase4i_z_Setter, NULL, NULL},
  {(char *)"xyz", &Dtool_LVecBase4i_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LVecBase4i_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVecBase4i = {
  &Dtool_LVecBase4i_operator_973_nb_add,
  &Dtool_LVecBase4i_operator_974_nb_subtract,
  &Dtool_LVecBase4i_operator_975_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase4i_operator_976_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  &Dtool_LVecBase4i_pow_982_nb_power,
  &Dtool_LVecBase4i_operator_972_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LVecBase4i_operator_977_nb_inplace_add,
  &Dtool_LVecBase4i_operator_978_nb_inplace_subtract,
  &Dtool_LVecBase4i_operator_979_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVecBase4i_operator_980_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  &Dtool_LVecBase4i_ipow_983_nb_inplace_power,
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVecBase4i = {
  &Dtool_LVecBase4i_size_934_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LVecBase4i_operator_933_sq_item,
  0, // sq_slice
  &Dtool_LVecBase4i_operator_933_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LVecBase4i_compare_to_968_tp_compare,
#endif
    &Dtool_LVecBase4i_repr_988_tp_repr,
    &Dtool_NumberMethods_LVecBase4i,
    &Dtool_SequenceMethods_LVecBase4i,
    0, // tp_as_mapping
    &Dtool_LVecBase4i_get_hash_969_tp_hash,
    0, // tp_call
    0, // tp_str
    &Dtool_LVecBase4i_getattr_931_tp_getattro,
    &Dtool_LVecBase4i_setattr_932_tp_setattro,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for all three-component vectors and points.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LVecBase4i,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVecBase4i,
    0, // tp_members
    Dtool_Properties_LVecBase4i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_LVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVecBase4i,
  Dtool_UpcastInterface_LVecBase4i,
  Dtool_DowncastInterface_LVecBase4i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVecBase4i,
};

static void Dtool_PyModuleClassInit_LVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LVecBase4i::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LVecBase4i::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LVecBase4i::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_LVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVecBase4i);
  }
}

/**
 * Python method tables for UnalignedLVecBase4i (UnalignedLVecBase4i)
 */
static PyMethodDef Dtool_Methods_UnalignedLVecBase4i[] = {
  {"set", (PyCFunction) &Dtool_UnalignedLVecBase4i_set_998, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_UnalignedLVecBase4i_set_998_comment},
  {"get_num_components", &Dtool_UnalignedLVecBase4i_get_num_components_1002, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4i_get_num_components_1002_comment},
  {"getNumComponents", &Dtool_UnalignedLVecBase4i_get_num_components_1002, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4i_get_num_components_1002_comment},
  {"get_class_type", &Dtool_UnalignedLVecBase4i_get_class_type_1003, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4i_get_class_type_1003_comment},
  {"getClassType", &Dtool_UnalignedLVecBase4i_get_class_type_1003, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLVecBase4i_get_class_type_1003_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4i slot sq_ass_item -> operator []
//////////////////
static int Dtool_UnalignedLVecBase4i_operator_999_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  UnalignedLVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "UnalignedLVecBase4i index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int &UnalignedLVecBase4i::operator [](int i)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return -1;
        }
#endif
        (*local_this).operator [](index) = (int)arg_val;
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call UnalignedLVecBase4i.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const UnalignedLVecBase4i self, index, int assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4i slot sq_item -> operator []
//////////////////
static PyObject *Dtool_UnalignedLVecBase4i_operator_999_sq_item(PyObject *self, Py_ssize_t index) {
  UnalignedLVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4i, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "UnalignedLVecBase4i index out of range");
    return NULL;
  }
  // 1-inline int UnalignedLVecBase4i::operator [](int i) const
  int return_value = (*(const UnalignedLVecBase4i*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(UnalignedLVecBase4i self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// UnalignedLVecBase4i slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_UnalignedLVecBase4i_size_1000_sq_length(PyObject *self) {
  UnalignedLVecBase4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLVecBase4i, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_UnalignedLVecBase4i = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_UnalignedLVecBase4i = {
  &Dtool_UnalignedLVecBase4i_size_1000_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_UnalignedLVecBase4i_operator_999_sq_item,
  0, // sq_slice
  &Dtool_UnalignedLVecBase4i_operator_999_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_UnalignedLVecBase4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UnalignedLVecBase4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnalignedLVecBase4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UnalignedLVecBase4i,
    &Dtool_SequenceMethods_UnalignedLVecBase4i,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an \"unaligned\" LVecBase4.  It has no functionality other than to\n"
    " * store numbers, and it will pack them in as tightly as possible, avoiding\n"
    " * any SSE2 alignment requirements shared by the primary LVecBase4 class.\n"
    " *\n"
    " * Use it only when you need to pack numbers tightly without respect to\n"
    " * alignment, and then copy it to a proper LVecBase4 to get actual use from\n"
    " * it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UnalignedLVecBase4i,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UnalignedLVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_UnalignedLVecBase4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnalignedLVecBase4i,
  Dtool_UpcastInterface_UnalignedLVecBase4i,
  Dtool_DowncastInterface_UnalignedLVecBase4i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_UnalignedLVecBase4i,
};

static void Dtool_PyModuleClassInit_UnalignedLVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UnalignedLVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UnalignedLVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum UnalignedLVecBase4i::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(UnalignedLVecBase4i::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(UnalignedLVecBase4i::is_int));
    if (PyType_Ready((PyTypeObject *)&Dtool_UnalignedLVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnalignedLVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnalignedLVecBase4i);
  }
}

/**
 * Python method tables for LVector4f (LVector4f)
 */
static PyMethodDef Dtool_Methods_LVector4f[] = {
  {"zero", &Dtool_LVector4f_zero_1009, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_zero_1009_comment},
  {"unit_x", &Dtool_LVector4f_unit_x_1010, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_x_1010_comment},
  {"unitX", &Dtool_LVector4f_unit_x_1010, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_x_1010_comment},
  {"unit_y", &Dtool_LVector4f_unit_y_1011, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_y_1011_comment},
  {"unitY", &Dtool_LVector4f_unit_y_1011, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_y_1011_comment},
  {"unit_z", &Dtool_LVector4f_unit_z_1012, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_z_1012_comment},
  {"unitZ", &Dtool_LVector4f_unit_z_1012, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_z_1012_comment},
  {"unit_w", &Dtool_LVector4f_unit_w_1013, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_w_1013_comment},
  {"unitW", &Dtool_LVector4f_unit_w_1013, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_unit_w_1013_comment},
  {"get_xyz", &Dtool_LVector4f_get_xyz_1014, METH_NOARGS, (const char *)Dtool_LVector4f_get_xyz_1014_comment},
  {"getXyz", &Dtool_LVector4f_get_xyz_1014, METH_NOARGS, (const char *)Dtool_LVector4f_get_xyz_1014_comment},
  {"get_xy", &Dtool_LVector4f_get_xy_1015, METH_NOARGS, (const char *)Dtool_LVector4f_get_xy_1015_comment},
  {"getXy", &Dtool_LVector4f_get_xy_1015, METH_NOARGS, (const char *)Dtool_LVector4f_get_xy_1015_comment},
  {"normalized", &Dtool_LVector4f_normalized_1023, METH_NOARGS, (const char *)Dtool_LVector4f_normalized_1023_comment},
  {"project", &Dtool_LVector4f_project_1024, METH_O, (const char *)Dtool_LVector4f_project_1024_comment},
  {"get_class_type", &Dtool_LVector4f_get_class_type_1026, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_get_class_type_1026_comment},
  {"getClassType", &Dtool_LVector4f_get_class_type_1026, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4f_get_class_type_1026_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector4f_operator_1019_nb_add(PyObject *self, PyObject *arg) {
  LVector4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4f LVector4f::operator +(LVector4f const &other) const
    LVector4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4f *return_value = new LVecBase4f((*(const LVector4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  {
    // -2 inline LVector4f LVector4f::operator +(LVector4f const &other) const
    LVector4f arg_local;
    LVector4f const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4f *return_value = new LVecBase4f((*(const LVector4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector4f_operator_1022_nb_divide(PyObject *self, PyObject *arg) {
  LVector4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4f LVector4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector4f_operator_1021_nb_multiply(PyObject *self, PyObject *arg) {
  LVector4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4f LVector4f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector4f_operator_1018_nb_negative(PyObject *self) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector4f LVector4f::operator -(void) const
  LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector4f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector4f_operator_1020_nb_subtract(PyObject *self, PyObject *arg) {
  LVector4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4f LVector4f::operator -(LVector4f const &other) const
    LVector4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4f *return_value = new LVecBase4f((*(const LVector4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  {
    // -2 inline LVector4f LVector4f::operator -(LVector4f const &other) const
    LVector4f arg_local;
    LVector4f const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4f *return_value = new LVecBase4f((*(const LVector4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVector4f_operator_1022_nb_true_divide(PyObject *self, PyObject *arg) {
  LVector4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4f LVector4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LVector4f *return_value = new LVector4f((*(const LVector4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector4f_getattr_1007_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector4f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector4f_repr_1025_tp_repr(PyObject *self) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector4f::__repr__(void) const
  std::string return_value = invoke_extension((const LVector4f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector4f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector4f_setattr_1008_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector4f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector4f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LVector4f[] = {
  {(char *)"xyz", &Dtool_LVector4f_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LVector4f_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVector4f = {
  &Dtool_LVector4f_operator_1019_nb_add,
  &Dtool_LVector4f_operator_1020_nb_subtract,
  &Dtool_LVector4f_operator_1021_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector4f_operator_1022_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector4f_operator_1018_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVector4f_operator_1022_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector4f_repr_1025_tp_repr,
    &Dtool_NumberMethods_LVector4f,
    &Dtool_SequenceMethods_LVector4f,
    &Dtool_MappingMethods_LVector4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector4f_getattr_1007_tp_getattro,
    &Dtool_LVector4f_setattr_1008_tp_setattro,
    &Dtool_BufferProcs_LVector4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a four-component vector distance.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector4f,
    0, // tp_members
    Dtool_Properties_LVector4f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector4f,
    PyType_GenericAlloc,
    Dtool_new_LVector4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector4f,
  Dtool_UpcastInterface_LVector4f,
  Dtool_DowncastInterface_LVector4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector4f,
};

static void Dtool_PyModuleClassInit_LVector4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4f(NULL);
    Dtool_LVector4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_LVector4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector4f);
  }
}

/**
 * Python method tables for LVector4d (LVector4d)
 */
static PyMethodDef Dtool_Methods_LVector4d[] = {
  {"zero", &Dtool_LVector4d_zero_1032, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_zero_1032_comment},
  {"unit_x", &Dtool_LVector4d_unit_x_1033, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_x_1033_comment},
  {"unitX", &Dtool_LVector4d_unit_x_1033, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_x_1033_comment},
  {"unit_y", &Dtool_LVector4d_unit_y_1034, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_y_1034_comment},
  {"unitY", &Dtool_LVector4d_unit_y_1034, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_y_1034_comment},
  {"unit_z", &Dtool_LVector4d_unit_z_1035, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_z_1035_comment},
  {"unitZ", &Dtool_LVector4d_unit_z_1035, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_z_1035_comment},
  {"unit_w", &Dtool_LVector4d_unit_w_1036, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_w_1036_comment},
  {"unitW", &Dtool_LVector4d_unit_w_1036, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_unit_w_1036_comment},
  {"get_xyz", &Dtool_LVector4d_get_xyz_1037, METH_NOARGS, (const char *)Dtool_LVector4d_get_xyz_1037_comment},
  {"getXyz", &Dtool_LVector4d_get_xyz_1037, METH_NOARGS, (const char *)Dtool_LVector4d_get_xyz_1037_comment},
  {"get_xy", &Dtool_LVector4d_get_xy_1038, METH_NOARGS, (const char *)Dtool_LVector4d_get_xy_1038_comment},
  {"getXy", &Dtool_LVector4d_get_xy_1038, METH_NOARGS, (const char *)Dtool_LVector4d_get_xy_1038_comment},
  {"normalized", &Dtool_LVector4d_normalized_1046, METH_NOARGS, (const char *)Dtool_LVector4d_normalized_1046_comment},
  {"project", &Dtool_LVector4d_project_1047, METH_O, (const char *)Dtool_LVector4d_project_1047_comment},
  {"get_class_type", &Dtool_LVector4d_get_class_type_1049, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_get_class_type_1049_comment},
  {"getClassType", &Dtool_LVector4d_get_class_type_1049, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4d_get_class_type_1049_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector4d_operator_1042_nb_add(PyObject *self, PyObject *arg) {
  LVector4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4d LVector4d::operator +(LVector4d const &other) const
    LVector4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4d *return_value = new LVecBase4d((*(const LVector4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  {
    // -2 inline LVector4d LVector4d::operator +(LVector4d const &other) const
    LVector4d arg_local;
    LVector4d const *arg_this = Dtool_Coerce_LVector4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4d *return_value = new LVecBase4d((*(const LVector4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector4d_operator_1045_nb_divide(PyObject *self, PyObject *arg) {
  LVector4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4d LVector4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector4d_operator_1044_nb_multiply(PyObject *self, PyObject *arg) {
  LVector4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4d LVector4d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector4d_operator_1041_nb_negative(PyObject *self) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector4d LVector4d::operator -(void) const
  LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector4d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector4d_operator_1043_nb_subtract(PyObject *self, PyObject *arg) {
  LVector4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4d LVector4d::operator -(LVector4d const &other) const
    LVector4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4d *return_value = new LVecBase4d((*(const LVector4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  {
    // -2 inline LVector4d LVector4d::operator -(LVector4d const &other) const
    LVector4d arg_local;
    LVector4d const *arg_this = Dtool_Coerce_LVector4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4d *return_value = new LVecBase4d((*(const LVector4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LVector4d_operator_1045_nb_true_divide(PyObject *self, PyObject *arg) {
  LVector4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4d LVector4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LVector4d *return_value = new LVector4d((*(const LVector4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector4d_getattr_1030_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector4d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector4d_repr_1048_tp_repr(PyObject *self) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector4d::__repr__(void) const
  std::string return_value = invoke_extension((const LVector4d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector4d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector4d_setattr_1031_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector4d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector4d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LVector4d[] = {
  {(char *)"xyz", &Dtool_LVector4d_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LVector4d_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVector4d = {
  &Dtool_LVector4d_operator_1042_nb_add,
  &Dtool_LVector4d_operator_1043_nb_subtract,
  &Dtool_LVector4d_operator_1044_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector4d_operator_1045_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector4d_operator_1041_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LVector4d_operator_1045_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector4d_repr_1048_tp_repr,
    &Dtool_NumberMethods_LVector4d,
    &Dtool_SequenceMethods_LVector4d,
    &Dtool_MappingMethods_LVector4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector4d_getattr_1030_tp_getattro,
    &Dtool_LVector4d_setattr_1031_tp_setattro,
    &Dtool_BufferProcs_LVector4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a four-component vector distance.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector4d,
    0, // tp_members
    Dtool_Properties_LVector4d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector4d,
    PyType_GenericAlloc,
    Dtool_new_LVector4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector4d,
  Dtool_UpcastInterface_LVector4d,
  Dtool_DowncastInterface_LVector4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector4d,
};

static void Dtool_PyModuleClassInit_LVector4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4d(NULL);
    Dtool_LVector4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_LVector4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector4d);
  }
}

/**
 * Python method tables for LVector4i (LVector4i)
 */
static PyMethodDef Dtool_Methods_LVector4i[] = {
  {"zero", &Dtool_LVector4i_zero_1055, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_zero_1055_comment},
  {"unit_x", &Dtool_LVector4i_unit_x_1056, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_x_1056_comment},
  {"unitX", &Dtool_LVector4i_unit_x_1056, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_x_1056_comment},
  {"unit_y", &Dtool_LVector4i_unit_y_1057, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_y_1057_comment},
  {"unitY", &Dtool_LVector4i_unit_y_1057, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_y_1057_comment},
  {"unit_z", &Dtool_LVector4i_unit_z_1058, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_z_1058_comment},
  {"unitZ", &Dtool_LVector4i_unit_z_1058, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_z_1058_comment},
  {"unit_w", &Dtool_LVector4i_unit_w_1059, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_w_1059_comment},
  {"unitW", &Dtool_LVector4i_unit_w_1059, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_unit_w_1059_comment},
  {"get_xyz", &Dtool_LVector4i_get_xyz_1060, METH_NOARGS, (const char *)Dtool_LVector4i_get_xyz_1060_comment},
  {"getXyz", &Dtool_LVector4i_get_xyz_1060, METH_NOARGS, (const char *)Dtool_LVector4i_get_xyz_1060_comment},
  {"get_xy", &Dtool_LVector4i_get_xy_1061, METH_NOARGS, (const char *)Dtool_LVector4i_get_xy_1061_comment},
  {"getXy", &Dtool_LVector4i_get_xy_1061, METH_NOARGS, (const char *)Dtool_LVector4i_get_xy_1061_comment},
  {"get_class_type", &Dtool_LVector4i_get_class_type_1070, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_get_class_type_1070_comment},
  {"getClassType", &Dtool_LVector4i_get_class_type_1070, METH_NOARGS | METH_STATIC, (const char *)Dtool_LVector4i_get_class_type_1070_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LVector4i_operator_1065_nb_add(PyObject *self, PyObject *arg) {
  LVector4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4i LVector4i::operator +(LVector4i const &other) const
    LVector4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4i *return_value = new LVecBase4i((*(const LVector4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  {
    // -2 inline LVector4i LVector4i::operator +(LVector4i const &other) const
    LVector4i arg_local;
    LVector4i const *arg_this = Dtool_Coerce_LVector4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4i *return_value = new LVecBase4i((*(const LVector4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LVector4i_operator_1068_nb_divide(PyObject *self, PyObject *arg) {
  LVector4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4i LVector4i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LVector4i_operator_1067_nb_multiply(PyObject *self, PyObject *arg) {
  LVector4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LVector4i LVector4i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LVector4i_operator_1064_nb_negative(PyObject *self) {
  LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LVector4i LVector4i::operator -(void) const
  LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LVector4i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LVector4i_operator_1066_nb_subtract(PyObject *self, PyObject *arg) {
  LVector4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LVector4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4i LVector4i::operator -(LVector4i const &other) const
    LVector4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4i *return_value = new LVecBase4i((*(const LVector4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  {
    // -2 inline LVector4i LVector4i::operator -(LVector4i const &other) const
    LVector4i arg_local;
    LVector4i const *arg_this = Dtool_Coerce_LVector4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4i *return_value = new LVector4i((*(const LVector4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4i *return_value = new LVecBase4i((*(const LVector4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LVector4i_getattr_1053_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LVector4i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LVector4i_repr_1069_tp_repr(PyObject *self) {
  LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LVector4i::__repr__(void) const
  std::string return_value = invoke_extension((const LVector4i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LVector4i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LVector4i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LVector4i_setattr_1054_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LVector4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LVector4i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LVector4i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LVector4i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LVector4i[] = {
  {(char *)"xyz", &Dtool_LVector4i_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LVector4i_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LVector4i = {
  &Dtool_LVector4i_operator_1065_nb_add,
  &Dtool_LVector4i_operator_1066_nb_subtract,
  &Dtool_LVector4i_operator_1067_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LVector4i_operator_1068_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LVector4i_operator_1064_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LVector4i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LVector4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LVector4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LVector4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LVector4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LVector4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LVector4i_repr_1069_tp_repr,
    &Dtool_NumberMethods_LVector4i,
    &Dtool_SequenceMethods_LVector4i,
    &Dtool_MappingMethods_LVector4i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LVector4i_getattr_1053_tp_getattro,
    &Dtool_LVector4i_setattr_1054_tp_setattro,
    &Dtool_BufferProcs_LVector4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a four-component vector distance.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LVector4i,
    0, // tp_members
    Dtool_Properties_LVector4i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LVector4i,
    PyType_GenericAlloc,
    Dtool_new_LVector4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LVector4i,
  Dtool_UpcastInterface_LVector4i,
  Dtool_DowncastInterface_LVector4i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LVector4i,
};

static void Dtool_PyModuleClassInit_LVector4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4i(NULL);
    Dtool_LVector4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4i);
    PyObject *dict = PyDict_New();
    Dtool_LVector4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LVector4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LVector4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LVector4i);
  }
}

/**
 * Python method tables for LPoint4f (LPoint4f)
 */
static PyMethodDef Dtool_Methods_LPoint4f[] = {
  {"zero", &Dtool_LPoint4f_zero_1076, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_zero_1076_comment},
  {"unit_x", &Dtool_LPoint4f_unit_x_1077, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_x_1077_comment},
  {"unitX", &Dtool_LPoint4f_unit_x_1077, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_x_1077_comment},
  {"unit_y", &Dtool_LPoint4f_unit_y_1078, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_y_1078_comment},
  {"unitY", &Dtool_LPoint4f_unit_y_1078, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_y_1078_comment},
  {"unit_z", &Dtool_LPoint4f_unit_z_1079, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_z_1079_comment},
  {"unitZ", &Dtool_LPoint4f_unit_z_1079, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_z_1079_comment},
  {"unit_w", &Dtool_LPoint4f_unit_w_1080, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_w_1080_comment},
  {"unitW", &Dtool_LPoint4f_unit_w_1080, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_unit_w_1080_comment},
  {"get_xyz", &Dtool_LPoint4f_get_xyz_1081, METH_NOARGS, (const char *)Dtool_LPoint4f_get_xyz_1081_comment},
  {"getXyz", &Dtool_LPoint4f_get_xyz_1081, METH_NOARGS, (const char *)Dtool_LPoint4f_get_xyz_1081_comment},
  {"get_xy", &Dtool_LPoint4f_get_xy_1082, METH_NOARGS, (const char *)Dtool_LPoint4f_get_xy_1082_comment},
  {"getXy", &Dtool_LPoint4f_get_xy_1082, METH_NOARGS, (const char *)Dtool_LPoint4f_get_xy_1082_comment},
  {"normalized", &Dtool_LPoint4f_normalized_1090, METH_NOARGS, (const char *)Dtool_LPoint4f_normalized_1090_comment},
  {"project", &Dtool_LPoint4f_project_1091, METH_O, (const char *)Dtool_LPoint4f_project_1091_comment},
  {"get_class_type", &Dtool_LPoint4f_get_class_type_1093, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_get_class_type_1093_comment},
  {"getClassType", &Dtool_LPoint4f_get_class_type_1093, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4f_get_class_type_1093_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint4f_operator_1086_nb_add(PyObject *self, PyObject *arg) {
  LPoint4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint4f LPoint4f::operator +(LVector4f const &other) const
    LVector4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4f *return_value = new LVecBase4f((*(const LPoint4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  {
    // -2 inline LPoint4f LPoint4f::operator +(LVector4f const &other) const
    LVector4f arg_local;
    LVector4f const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4f *return_value = new LVecBase4f((*(const LPoint4f*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint4f_operator_1089_nb_divide(PyObject *self, PyObject *arg) {
  LPoint4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4f LPoint4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint4f_operator_1088_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4f LPoint4f::operator *(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint4f_operator_1085_nb_negative(PyObject *self) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint4f LPoint4f::operator -(void) const
  LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint4f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint4f_operator_1087_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4f LPoint4f::operator -(LPoint4f const &other) const
    LPoint4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4f *return_value = new LVector4f((*(const LPoint4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
    }
  }

  {
    // -2 inline LPoint4f LPoint4f::operator -(LVector4f const &other) const
    LVector4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const
    LVecBase4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4f *return_value = new LVecBase4f((*(const LPoint4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  {
    // -2 inline LVector4f LPoint4f::operator -(LPoint4f const &other) const
    LPoint4f arg_local;
    LPoint4f const *arg_this = Dtool_Coerce_LPoint4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4f *return_value = new LVector4f((*(const LPoint4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, true, false);
    }
  }

  {
    // -2 inline LPoint4f LPoint4f::operator -(LVector4f const &other) const
    LVector4f arg_local;
    LVector4f const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
    }
  }

  {
    // -2 inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4f *return_value = new LVecBase4f((*(const LPoint4f*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint4f_operator_1089_nb_true_divide(PyObject *self, PyObject *arg) {
  LPoint4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4f LPoint4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LPoint4f *return_value = new LPoint4f((*(const LPoint4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint4f_getattr_1074_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint4f*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint4f_repr_1092_tp_repr(PyObject *self) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint4f::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint4f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint4f self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4f slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint4f_setattr_1075_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4f, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint4f.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint4f self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LPoint4f[] = {
  {(char *)"xyz", &Dtool_LPoint4f_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LPoint4f_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LPoint4f = {
  &Dtool_LPoint4f_operator_1086_nb_add,
  &Dtool_LPoint4f_operator_1087_nb_subtract,
  &Dtool_LPoint4f_operator_1088_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint4f_operator_1089_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint4f_operator_1085_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LPoint4f_operator_1089_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint4f = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint4f = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint4f = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint4f_repr_1092_tp_repr,
    &Dtool_NumberMethods_LPoint4f,
    &Dtool_SequenceMethods_LPoint4f,
    &Dtool_MappingMethods_LPoint4f,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint4f_getattr_1074_tp_getattro,
    &Dtool_LPoint4f_setattr_1075_tp_setattro,
    &Dtool_BufferProcs_LPoint4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a four-component point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint4f,
    0, // tp_members
    Dtool_Properties_LPoint4f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint4f,
    PyType_GenericAlloc,
    Dtool_new_LPoint4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint4f,
  Dtool_UpcastInterface_LPoint4f,
  Dtool_DowncastInterface_LPoint4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint4f,
};

static void Dtool_PyModuleClassInit_LPoint4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4f(NULL);
    Dtool_LPoint4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_LPoint4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint4f);
  }
}

/**
 * Python method tables for LPoint4d (LPoint4d)
 */
static PyMethodDef Dtool_Methods_LPoint4d[] = {
  {"zero", &Dtool_LPoint4d_zero_1099, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_zero_1099_comment},
  {"unit_x", &Dtool_LPoint4d_unit_x_1100, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_x_1100_comment},
  {"unitX", &Dtool_LPoint4d_unit_x_1100, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_x_1100_comment},
  {"unit_y", &Dtool_LPoint4d_unit_y_1101, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_y_1101_comment},
  {"unitY", &Dtool_LPoint4d_unit_y_1101, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_y_1101_comment},
  {"unit_z", &Dtool_LPoint4d_unit_z_1102, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_z_1102_comment},
  {"unitZ", &Dtool_LPoint4d_unit_z_1102, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_z_1102_comment},
  {"unit_w", &Dtool_LPoint4d_unit_w_1103, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_w_1103_comment},
  {"unitW", &Dtool_LPoint4d_unit_w_1103, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_unit_w_1103_comment},
  {"get_xyz", &Dtool_LPoint4d_get_xyz_1104, METH_NOARGS, (const char *)Dtool_LPoint4d_get_xyz_1104_comment},
  {"getXyz", &Dtool_LPoint4d_get_xyz_1104, METH_NOARGS, (const char *)Dtool_LPoint4d_get_xyz_1104_comment},
  {"get_xy", &Dtool_LPoint4d_get_xy_1105, METH_NOARGS, (const char *)Dtool_LPoint4d_get_xy_1105_comment},
  {"getXy", &Dtool_LPoint4d_get_xy_1105, METH_NOARGS, (const char *)Dtool_LPoint4d_get_xy_1105_comment},
  {"normalized", &Dtool_LPoint4d_normalized_1113, METH_NOARGS, (const char *)Dtool_LPoint4d_normalized_1113_comment},
  {"project", &Dtool_LPoint4d_project_1114, METH_O, (const char *)Dtool_LPoint4d_project_1114_comment},
  {"get_class_type", &Dtool_LPoint4d_get_class_type_1116, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_get_class_type_1116_comment},
  {"getClassType", &Dtool_LPoint4d_get_class_type_1116, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4d_get_class_type_1116_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint4d_operator_1109_nb_add(PyObject *self, PyObject *arg) {
  LPoint4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint4d LPoint4d::operator +(LVector4d const &other) const
    LVector4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4d *return_value = new LVecBase4d((*(const LPoint4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  {
    // -2 inline LPoint4d LPoint4d::operator +(LVector4d const &other) const
    LVector4d arg_local;
    LVector4d const *arg_this = Dtool_Coerce_LVector4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4d *return_value = new LVecBase4d((*(const LPoint4d*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint4d_operator_1112_nb_divide(PyObject *self, PyObject *arg) {
  LPoint4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4d LPoint4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint4d_operator_1111_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4d LPoint4d::operator *(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator *(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint4d_operator_1108_nb_negative(PyObject *self) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint4d LPoint4d::operator -(void) const
  LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint4d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint4d_operator_1110_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LVector4d LPoint4d::operator -(LPoint4d const &other) const
    LPoint4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4d *return_value = new LVector4d((*(const LPoint4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
    }
  }

  {
    // -2 inline LPoint4d LPoint4d::operator -(LVector4d const &other) const
    LVector4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const
    LVecBase4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4d *return_value = new LVecBase4d((*(const LPoint4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  {
    // -2 inline LVector4d LPoint4d::operator -(LPoint4d const &other) const
    LPoint4d arg_local;
    LPoint4d const *arg_this = Dtool_Coerce_LPoint4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4d *return_value = new LVector4d((*(const LPoint4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4d, true, false);
    }
  }

  {
    // -2 inline LPoint4d LPoint4d::operator -(LVector4d const &other) const
    LVector4d arg_local;
    LVector4d const *arg_this = Dtool_Coerce_LVector4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
    }
  }

  {
    // -2 inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4d *return_value = new LVecBase4d((*(const LPoint4d*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint4d_operator_1112_nb_true_divide(PyObject *self, PyObject *arg) {
  LPoint4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4d LPoint4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LPoint4d *return_value = new LPoint4d((*(const LPoint4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint4d_getattr_1097_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint4d*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint4d_repr_1115_tp_repr(PyObject *self) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint4d::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint4d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint4d self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4d slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint4d_setattr_1098_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4d, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint4d.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint4d self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LPoint4d[] = {
  {(char *)"xyz", &Dtool_LPoint4d_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LPoint4d_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LPoint4d = {
  &Dtool_LPoint4d_operator_1109_nb_add,
  &Dtool_LPoint4d_operator_1110_nb_subtract,
  &Dtool_LPoint4d_operator_1111_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint4d_operator_1112_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint4d_operator_1108_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LPoint4d_operator_1112_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint4d = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint4d = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint4d = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint4d_repr_1115_tp_repr,
    &Dtool_NumberMethods_LPoint4d,
    &Dtool_SequenceMethods_LPoint4d,
    &Dtool_MappingMethods_LPoint4d,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint4d_getattr_1097_tp_getattro,
    &Dtool_LPoint4d_setattr_1098_tp_setattro,
    &Dtool_BufferProcs_LPoint4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a four-component point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint4d,
    0, // tp_members
    Dtool_Properties_LPoint4d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint4d,
    PyType_GenericAlloc,
    Dtool_new_LPoint4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint4d,
  Dtool_UpcastInterface_LPoint4d,
  Dtool_DowncastInterface_LPoint4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint4d,
};

static void Dtool_PyModuleClassInit_LPoint4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4d(NULL);
    Dtool_LPoint4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_LPoint4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint4d);
  }
}

/**
 * Python method tables for LPoint4i (LPoint4i)
 */
static PyMethodDef Dtool_Methods_LPoint4i[] = {
  {"zero", &Dtool_LPoint4i_zero_1122, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_zero_1122_comment},
  {"unit_x", &Dtool_LPoint4i_unit_x_1123, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_x_1123_comment},
  {"unitX", &Dtool_LPoint4i_unit_x_1123, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_x_1123_comment},
  {"unit_y", &Dtool_LPoint4i_unit_y_1124, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_y_1124_comment},
  {"unitY", &Dtool_LPoint4i_unit_y_1124, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_y_1124_comment},
  {"unit_z", &Dtool_LPoint4i_unit_z_1125, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_z_1125_comment},
  {"unitZ", &Dtool_LPoint4i_unit_z_1125, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_z_1125_comment},
  {"unit_w", &Dtool_LPoint4i_unit_w_1126, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_w_1126_comment},
  {"unitW", &Dtool_LPoint4i_unit_w_1126, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_unit_w_1126_comment},
  {"get_xyz", &Dtool_LPoint4i_get_xyz_1127, METH_NOARGS, (const char *)Dtool_LPoint4i_get_xyz_1127_comment},
  {"getXyz", &Dtool_LPoint4i_get_xyz_1127, METH_NOARGS, (const char *)Dtool_LPoint4i_get_xyz_1127_comment},
  {"get_xy", &Dtool_LPoint4i_get_xy_1128, METH_NOARGS, (const char *)Dtool_LPoint4i_get_xy_1128_comment},
  {"getXy", &Dtool_LPoint4i_get_xy_1128, METH_NOARGS, (const char *)Dtool_LPoint4i_get_xy_1128_comment},
  {"get_class_type", &Dtool_LPoint4i_get_class_type_1137, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_get_class_type_1137_comment},
  {"getClassType", &Dtool_LPoint4i_get_class_type_1137, METH_NOARGS | METH_STATIC, (const char *)Dtool_LPoint4i_get_class_type_1137_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LPoint4i_operator_1132_nb_add(PyObject *self, PyObject *arg) {
  LPoint4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint4i LPoint4i::operator +(LVector4i const &other) const
    LVector4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4i *return_value = new LVecBase4i((*(const LPoint4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  {
    // -2 inline LPoint4i LPoint4i::operator +(LVector4i const &other) const
    LVector4i arg_local;
    LVector4i const *arg_this = Dtool_Coerce_LVector4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4i *return_value = new LVecBase4i((*(const LPoint4i*)local_this).operator +(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LPoint4i_operator_1135_nb_divide(PyObject *self, PyObject *arg) {
  LPoint4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4i LPoint4i::operator /(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator /((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LPoint4i_operator_1134_nb_multiply(PyObject *self, PyObject *arg) {
  LPoint4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LPoint4i LPoint4i::operator *(int scalar) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator *((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LPoint4i_operator_1131_nb_negative(PyObject *self) {
  LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LPoint4i LPoint4i::operator -(void) const
  LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LPoint4i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LPoint4i_operator_1133_nb_subtract(PyObject *self, PyObject *arg) {
  LPoint4i *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LPoint4i, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LPoint4i LPoint4i::operator -(LVector4i const &other) const
    LVector4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVector4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
    }
  }

  {
    // -2 inline LVector4i LPoint4i::operator -(LPoint4i const &other) const
    LPoint4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LPoint4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVector4i *return_value = new LVector4i((*(const LPoint4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const
    LVecBase4i const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LVecBase4i, (void **)&arg_this);
    if (arg_this != NULL) {
      LVecBase4i *return_value = new LVecBase4i((*(const LPoint4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  {
    // -2 inline LPoint4i LPoint4i::operator -(LVector4i const &other) const
    LVector4i arg_local;
    LVector4i const *arg_this = Dtool_Coerce_LVector4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LPoint4i *return_value = new LPoint4i((*(const LPoint4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint4i, true, false);
    }
  }

  {
    // -2 inline LVector4i LPoint4i::operator -(LPoint4i const &other) const
    LPoint4i arg_local;
    LPoint4i const *arg_this = Dtool_Coerce_LPoint4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVector4i *return_value = new LVector4i((*(const LPoint4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4i, true, false);
    }
  }

  {
    // -2 inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != NULL)) {
      LVecBase4i *return_value = new LVecBase4i((*(const LPoint4i*)local_this).operator -(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_LPoint4i_getattr_1120_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    PyObject *return_value = invoke_extension((const LPoint4i*)local_this).__getattr__(self, std::string(param1_str, param1_len));
    return Dtool_Return(return_value);
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LPoint4i_repr_1136_tp_repr(PyObject *self) {
  LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LPoint4i::__repr__(void) const
  std::string return_value = invoke_extension((const LPoint4i*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LPoint4i self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LPoint4i slot tp_setattro -> __setattr__
//////////////////
static int Dtool_LPoint4i_setattr_1121_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  LPoint4i *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LPoint4i, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "s#O:__setattr__", &param1_str, &param1_len, &param2)) {
        int return_value = invoke_extension(local_this).__setattr__(self, std::string(param1_str, param1_len), param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call LPoint4i.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const LPoint4i self, str attr_name, object assign)\n");
    }
    return -1;

  } else { // __delattr__
    PyErr_Format(PyExc_TypeError,
      "can't delete attributes of built-in/extension type '%s'",
      Py_TYPE(self)->tp_name);
    return -1;
  }
}

static PyGetSetDef Dtool_Properties_LPoint4i[] = {
  {(char *)"xyz", &Dtool_LPoint4i_xyz_Getter, NULL, NULL, NULL},
  {(char *)"xy", &Dtool_LPoint4i_xy_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LPoint4i = {
  &Dtool_LPoint4i_operator_1132_nb_add,
  &Dtool_LPoint4i_operator_1133_nb_subtract,
  &Dtool_LPoint4i_operator_1134_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LPoint4i_operator_1135_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LPoint4i_operator_1131_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LPoint4i = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LPoint4i = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LPoint4i = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LPoint4i = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LPoint4i",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LPoint4i,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_LPoint4i_repr_1136_tp_repr,
    &Dtool_NumberMethods_LPoint4i,
    &Dtool_SequenceMethods_LPoint4i,
    &Dtool_MappingMethods_LPoint4i,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_LPoint4i_getattr_1120_tp_getattro,
    &Dtool_LPoint4i_setattr_1121_tp_setattro,
    &Dtool_BufferProcs_LPoint4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a four-component point in space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LPoint4i,
    0, // tp_members
    Dtool_Properties_LPoint4i,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LPoint4i,
    PyType_GenericAlloc,
    Dtool_new_LPoint4i,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LPoint4i,
  Dtool_UpcastInterface_LPoint4i,
  Dtool_DowncastInterface_LPoint4i,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LPoint4i,
};

static void Dtool_PyModuleClassInit_LPoint4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4i(NULL);
    Dtool_LPoint4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4i);
    PyObject *dict = PyDict_New();
    Dtool_LPoint4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LPoint4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LPoint4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LPoint4i);
  }
}

/**
 * Python method tables for LMatrix3f_Row (Row)
 */
static PyMethodDef Dtool_Methods_LMatrix3f_Row[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f_Row slot sq_ass_item -> operator []
//////////////////
static int Dtool_LMatrix3f_Row_operator_1142_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LMatrix3f::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f_Row, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3f_Row index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float &LMatrix3f::Row::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = (float)PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call Row.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const Row self, index, float assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f_Row slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix3f_Row_operator_1142_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix3f::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f_Row, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3f_Row index out of range");
    return NULL;
  }
  // 1-inline float LMatrix3f::Row::operator [](int i) const
  float return_value = (*(const LMatrix3f::Row*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Row self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f_Row slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix3f_Row_size_1143_sq_length(PyObject *self) {
  LMatrix3f::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f_Row, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix3f_Row = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix3f_Row = {
  &Dtool_LMatrix3f_Row_size_1143_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix3f_Row_operator_1142_sq_item,
  0, // sq_slice
  &Dtool_LMatrix3f_Row_operator_1142_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix3f_Row = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Row",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix3f_Row,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix3f_Row,
    &Dtool_SequenceMethods_LMatrix3f_Row,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// These helper classes are used to support two-level operator [].",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix3f_Row,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix3f_Row,
    PyType_GenericAlloc,
    Dtool_new_LMatrix3f_Row,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix3f_Row,
  Dtool_UpcastInterface_LMatrix3f_Row,
  Dtool_DowncastInterface_LMatrix3f_Row,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix3f_Row(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix3f_Row._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix3f_Row._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix3f_Row) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix3f_Row)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix3f_Row);
  }
}

/**
 * Python method tables for LMatrix3f_CRow (CRow)
 */
static PyMethodDef Dtool_Methods_LMatrix3f_CRow[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f_CRow slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix3f_CRow_operator_1147_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix3f::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f_CRow, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3f_CRow index out of range");
    return NULL;
  }
  // 1-inline float LMatrix3f::CRow::operator [](int i) const
  float return_value = (*(const LMatrix3f::CRow*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(CRow self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f_CRow slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix3f_CRow_size_1148_sq_length(PyObject *self) {
  LMatrix3f::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f_CRow, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix3f_CRow = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix3f_CRow = {
  &Dtool_LMatrix3f_CRow_size_1148_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix3f_CRow_operator_1147_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix3f_CRow = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CRow",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix3f_CRow,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix3f_CRow,
    &Dtool_SequenceMethods_LMatrix3f_CRow,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix3f_CRow,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix3f_CRow,
    PyType_GenericAlloc,
    Dtool_new_LMatrix3f_CRow,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix3f_CRow,
  Dtool_UpcastInterface_LMatrix3f_CRow,
  Dtool_DowncastInterface_LMatrix3f_CRow,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix3f_CRow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix3f_CRow._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix3f_CRow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix3f_CRow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix3f_CRow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix3f_CRow);
  }
}

/**
 * Python method tables for LMatrix3f (LMatrix3f)
 */
static PyMethodDef Dtool_Methods_LMatrix3f[] = {
  {"assign", &Dtool_LMatrix3f_operator_1152, METH_O, (const char *)Dtool_LMatrix3f_operator_1152_comment},
  {"__reduce__", &Dtool_LMatrix3f_reduce_1156, METH_NOARGS, (const char *)Dtool_LMatrix3f_reduce_1156_comment},
  {"fill", &Dtool_LMatrix3f_fill_1157, METH_O, (const char *)Dtool_LMatrix3f_fill_1157_comment},
  {"set", (PyCFunction) &Dtool_LMatrix3f_set_1158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_1158_comment},
  {"set_row", (PyCFunction) &Dtool_LMatrix3f_set_row_1161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_row_1161_comment},
  {"setRow", (PyCFunction) &Dtool_LMatrix3f_set_row_1161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_row_1161_comment},
  {"set_col", (PyCFunction) &Dtool_LMatrix3f_set_col_1162, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_col_1162_comment},
  {"setCol", (PyCFunction) &Dtool_LMatrix3f_set_col_1162, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_col_1162_comment},
  {"get_row", (PyCFunction) &Dtool_LMatrix3f_get_row_1163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_get_row_1163_comment},
  {"getRow", (PyCFunction) &Dtool_LMatrix3f_get_row_1163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_get_row_1163_comment},
  {"get_col", &Dtool_LMatrix3f_get_col_1164, METH_O, (const char *)Dtool_LMatrix3f_get_col_1164_comment},
  {"getCol", &Dtool_LMatrix3f_get_col_1164, METH_O, (const char *)Dtool_LMatrix3f_get_col_1164_comment},
  {"get_row2", &Dtool_LMatrix3f_get_row2_1169, METH_O, (const char *)Dtool_LMatrix3f_get_row2_1169_comment},
  {"getRow2", &Dtool_LMatrix3f_get_row2_1169, METH_O, (const char *)Dtool_LMatrix3f_get_row2_1169_comment},
  {"get_col2", &Dtool_LMatrix3f_get_col2_1170, METH_O, (const char *)Dtool_LMatrix3f_get_col2_1170_comment},
  {"getCol2", &Dtool_LMatrix3f_get_col2_1170, METH_O, (const char *)Dtool_LMatrix3f_get_col2_1170_comment},
  {"is_nan", &Dtool_LMatrix3f_is_nan_1174, METH_NOARGS, (const char *)Dtool_LMatrix3f_is_nan_1174_comment},
  {"isNan", &Dtool_LMatrix3f_is_nan_1174, METH_NOARGS, (const char *)Dtool_LMatrix3f_is_nan_1174_comment},
  {"is_identity", &Dtool_LMatrix3f_is_identity_1175, METH_NOARGS, (const char *)Dtool_LMatrix3f_is_identity_1175_comment},
  {"isIdentity", &Dtool_LMatrix3f_is_identity_1175, METH_NOARGS, (const char *)Dtool_LMatrix3f_is_identity_1175_comment},
  {"get_cell", (PyCFunction) &Dtool_LMatrix3f_get_cell_1176, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_get_cell_1176_comment},
  {"getCell", (PyCFunction) &Dtool_LMatrix3f_get_cell_1176, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_get_cell_1176_comment},
  {"set_cell", (PyCFunction) &Dtool_LMatrix3f_set_cell_1177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_cell_1177_comment},
  {"setCell", (PyCFunction) &Dtool_LMatrix3f_set_cell_1177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_cell_1177_comment},
  {"get_num_components", &Dtool_LMatrix3f_get_num_components_1179, METH_NOARGS, (const char *)Dtool_LMatrix3f_get_num_components_1179_comment},
  {"getNumComponents", &Dtool_LMatrix3f_get_num_components_1179, METH_NOARGS, (const char *)Dtool_LMatrix3f_get_num_components_1179_comment},
  {"compare_to", &Dtool_LMatrix3f_compare_to_1183, METH_VARARGS, (const char *)Dtool_LMatrix3f_compare_to_1183_comment},
  {"compareTo", &Dtool_LMatrix3f_compare_to_1183, METH_VARARGS, (const char *)Dtool_LMatrix3f_compare_to_1183_comment},
  {"get_hash", &Dtool_LMatrix3f_get_hash_1184, METH_VARARGS, (const char *)Dtool_LMatrix3f_get_hash_1184_comment},
  {"getHash", &Dtool_LMatrix3f_get_hash_1184, METH_VARARGS, (const char *)Dtool_LMatrix3f_get_hash_1184_comment},
  {"add_hash", (PyCFunction) &Dtool_LMatrix3f_add_hash_1185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_add_hash_1185_comment},
  {"addHash", (PyCFunction) &Dtool_LMatrix3f_add_hash_1185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_add_hash_1185_comment},
  {"xform", &Dtool_LMatrix3f_xform_1186, METH_O, (const char *)Dtool_LMatrix3f_xform_1186_comment},
  {"xform_point", &Dtool_LMatrix3f_xform_point_1187, METH_O, (const char *)Dtool_LMatrix3f_xform_point_1187_comment},
  {"xformPoint", &Dtool_LMatrix3f_xform_point_1187, METH_O, (const char *)Dtool_LMatrix3f_xform_point_1187_comment},
  {"xform_vec", &Dtool_LMatrix3f_xform_vec_1188, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_1188_comment},
  {"xformVec", &Dtool_LMatrix3f_xform_vec_1188, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_1188_comment},
  {"xform_vec_general", &Dtool_LMatrix3f_xform_vec_general_1189, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_general_1189_comment},
  {"xformVecGeneral", &Dtool_LMatrix3f_xform_vec_general_1189, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_general_1189_comment},
  {"xform_in_place", &Dtool_LMatrix3f_xform_in_place_1190, METH_O, (const char *)Dtool_LMatrix3f_xform_in_place_1190_comment},
  {"xformInPlace", &Dtool_LMatrix3f_xform_in_place_1190, METH_O, (const char *)Dtool_LMatrix3f_xform_in_place_1190_comment},
  {"xform_point_in_place", &Dtool_LMatrix3f_xform_point_in_place_1191, METH_O, (const char *)Dtool_LMatrix3f_xform_point_in_place_1191_comment},
  {"xformPointInPlace", &Dtool_LMatrix3f_xform_point_in_place_1191, METH_O, (const char *)Dtool_LMatrix3f_xform_point_in_place_1191_comment},
  {"xform_vec_in_place", &Dtool_LMatrix3f_xform_vec_in_place_1192, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_in_place_1192_comment},
  {"xformVecInPlace", &Dtool_LMatrix3f_xform_vec_in_place_1192, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_in_place_1192_comment},
  {"xform_vec_general_in_place", &Dtool_LMatrix3f_xform_vec_general_in_place_1193, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_general_in_place_1193_comment},
  {"xformVecGeneralInPlace", &Dtool_LMatrix3f_xform_vec_general_in_place_1193, METH_O, (const char *)Dtool_LMatrix3f_xform_vec_general_in_place_1193_comment},
  {"multiply", (PyCFunction) &Dtool_LMatrix3f_multiply_1194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_multiply_1194_comment},
  {"componentwise_mult", &Dtool_LMatrix3f_componentwise_mult_1201, METH_O, (const char *)Dtool_LMatrix3f_componentwise_mult_1201_comment},
  {"componentwiseMult", &Dtool_LMatrix3f_componentwise_mult_1201, METH_O, (const char *)Dtool_LMatrix3f_componentwise_mult_1201_comment},
  {"determinant", &Dtool_LMatrix3f_determinant_1202, METH_NOARGS, (const char *)Dtool_LMatrix3f_determinant_1202_comment},
  {"transpose_from", &Dtool_LMatrix3f_transpose_from_1203, METH_O, (const char *)Dtool_LMatrix3f_transpose_from_1203_comment},
  {"transposeFrom", &Dtool_LMatrix3f_transpose_from_1203, METH_O, (const char *)Dtool_LMatrix3f_transpose_from_1203_comment},
  {"transpose_in_place", &Dtool_LMatrix3f_transpose_in_place_1204, METH_NOARGS, (const char *)Dtool_LMatrix3f_transpose_in_place_1204_comment},
  {"transposeInPlace", &Dtool_LMatrix3f_transpose_in_place_1204, METH_NOARGS, (const char *)Dtool_LMatrix3f_transpose_in_place_1204_comment},
  {"invert_from", &Dtool_LMatrix3f_invert_from_1205, METH_O, (const char *)Dtool_LMatrix3f_invert_from_1205_comment},
  {"invertFrom", &Dtool_LMatrix3f_invert_from_1205, METH_O, (const char *)Dtool_LMatrix3f_invert_from_1205_comment},
  {"invert_in_place", &Dtool_LMatrix3f_invert_in_place_1206, METH_NOARGS, (const char *)Dtool_LMatrix3f_invert_in_place_1206_comment},
  {"invertInPlace", &Dtool_LMatrix3f_invert_in_place_1206, METH_NOARGS, (const char *)Dtool_LMatrix3f_invert_in_place_1206_comment},
  {"invert_transpose_from", &Dtool_LMatrix3f_invert_transpose_from_1207, METH_O, (const char *)Dtool_LMatrix3f_invert_transpose_from_1207_comment},
  {"invertTransposeFrom", &Dtool_LMatrix3f_invert_transpose_from_1207, METH_O, (const char *)Dtool_LMatrix3f_invert_transpose_from_1207_comment},
  {"ident_mat", &Dtool_LMatrix3f_ident_mat_1208, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3f_ident_mat_1208_comment},
  {"identMat", &Dtool_LMatrix3f_ident_mat_1208, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3f_ident_mat_1208_comment},
  {"set_translate_mat", &Dtool_LMatrix3f_set_translate_mat_1209, METH_O, (const char *)Dtool_LMatrix3f_set_translate_mat_1209_comment},
  {"setTranslateMat", &Dtool_LMatrix3f_set_translate_mat_1209, METH_O, (const char *)Dtool_LMatrix3f_set_translate_mat_1209_comment},
  {"set_rotate_mat", (PyCFunction) &Dtool_LMatrix3f_set_rotate_mat_1210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_rotate_mat_1210_comment},
  {"setRotateMat", (PyCFunction) &Dtool_LMatrix3f_set_rotate_mat_1210, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_rotate_mat_1210_comment},
  {"set_scale_mat", &Dtool_LMatrix3f_set_scale_mat_1211, METH_O, (const char *)Dtool_LMatrix3f_set_scale_mat_1211_comment},
  {"setScaleMat", &Dtool_LMatrix3f_set_scale_mat_1211, METH_O, (const char *)Dtool_LMatrix3f_set_scale_mat_1211_comment},
  {"translate_mat", (PyCFunction) &Dtool_LMatrix3f_translate_mat_1212, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_translate_mat_1212_comment},
  {"translateMat", (PyCFunction) &Dtool_LMatrix3f_translate_mat_1212, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_translate_mat_1212_comment},
  {"rotate_mat", (PyCFunction) &Dtool_LMatrix3f_rotate_mat_1213, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_rotate_mat_1213_comment},
  {"rotateMat", (PyCFunction) &Dtool_LMatrix3f_rotate_mat_1213, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_rotate_mat_1213_comment},
  {"scale_mat", (PyCFunction) &Dtool_LMatrix3f_scale_mat_1214, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_scale_mat_1214_comment},
  {"scaleMat", (PyCFunction) &Dtool_LMatrix3f_scale_mat_1214, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_scale_mat_1214_comment},
  {"set_rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix3f_set_rotate_mat_normaxis_1215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_rotate_mat_normaxis_1215_comment},
  {"setRotateMatNormaxis", (PyCFunction) &Dtool_LMatrix3f_set_rotate_mat_normaxis_1215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_rotate_mat_normaxis_1215_comment},
  {"rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix3f_rotate_mat_normaxis_1216, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_rotate_mat_normaxis_1216_comment},
  {"rotateMatNormaxis", (PyCFunction) &Dtool_LMatrix3f_rotate_mat_normaxis_1216, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_rotate_mat_normaxis_1216_comment},
  {"set_shear_mat", (PyCFunction) &Dtool_LMatrix3f_set_shear_mat_1217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_shear_mat_1217_comment},
  {"setShearMat", (PyCFunction) &Dtool_LMatrix3f_set_shear_mat_1217, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_shear_mat_1217_comment},
  {"shear_mat", (PyCFunction) &Dtool_LMatrix3f_shear_mat_1218, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_shear_mat_1218_comment},
  {"shearMat", (PyCFunction) &Dtool_LMatrix3f_shear_mat_1218, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_shear_mat_1218_comment},
  {"set_scale_shear_mat", (PyCFunction) &Dtool_LMatrix3f_set_scale_shear_mat_1219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_scale_shear_mat_1219_comment},
  {"setScaleShearMat", (PyCFunction) &Dtool_LMatrix3f_set_scale_shear_mat_1219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_set_scale_shear_mat_1219_comment},
  {"scale_shear_mat", (PyCFunction) &Dtool_LMatrix3f_scale_shear_mat_1220, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_scale_shear_mat_1220_comment},
  {"scaleShearMat", (PyCFunction) &Dtool_LMatrix3f_scale_shear_mat_1220, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_scale_shear_mat_1220_comment},
  {"convert_mat", (PyCFunction) &Dtool_LMatrix3f_convert_mat_1221, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_convert_mat_1221_comment},
  {"convertMat", (PyCFunction) &Dtool_LMatrix3f_convert_mat_1221, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3f_convert_mat_1221_comment},
  {"almost_equal", (PyCFunction) &Dtool_LMatrix3f_almost_equal_1222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_almost_equal_1222_comment},
  {"almostEqual", (PyCFunction) &Dtool_LMatrix3f_almost_equal_1222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_almost_equal_1222_comment},
  {"output", &Dtool_LMatrix3f_output_1223, METH_O, (const char *)Dtool_LMatrix3f_output_1223_comment},
  {"write", (PyCFunction) &Dtool_LMatrix3f_write_1224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3f_write_1224_comment},
  {"write_datagram_fixed", &Dtool_LMatrix3f_write_datagram_fixed_1227, METH_O, (const char *)Dtool_LMatrix3f_write_datagram_fixed_1227_comment},
  {"writeDatagramFixed", &Dtool_LMatrix3f_write_datagram_fixed_1227, METH_O, (const char *)Dtool_LMatrix3f_write_datagram_fixed_1227_comment},
  {"read_datagram_fixed", &Dtool_LMatrix3f_read_datagram_fixed_1228, METH_O, (const char *)Dtool_LMatrix3f_read_datagram_fixed_1228_comment},
  {"readDatagramFixed", &Dtool_LMatrix3f_read_datagram_fixed_1228, METH_O, (const char *)Dtool_LMatrix3f_read_datagram_fixed_1228_comment},
  {"write_datagram", &Dtool_LMatrix3f_write_datagram_1229, METH_O, (const char *)Dtool_LMatrix3f_write_datagram_1229_comment},
  {"writeDatagram", &Dtool_LMatrix3f_write_datagram_1229, METH_O, (const char *)Dtool_LMatrix3f_write_datagram_1229_comment},
  {"read_datagram", &Dtool_LMatrix3f_read_datagram_1230, METH_O, (const char *)Dtool_LMatrix3f_read_datagram_1230_comment},
  {"readDatagram", &Dtool_LMatrix3f_read_datagram_1230, METH_O, (const char *)Dtool_LMatrix3f_read_datagram_1230_comment},
  {"get_class_type", &Dtool_LMatrix3f_get_class_type_1231, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3f_get_class_type_1231_comment},
  {"getClassType", &Dtool_LMatrix3f_get_class_type_1231, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3f_get_class_type_1231_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_rows", (PyCFunction) &MakeSeq_LMatrix3f_get_rows, METH_NOARGS, NULL},
  { "getRows", (PyCFunction) &MakeSeq_LMatrix3f_get_rows, METH_NOARGS, NULL},
  {"get_cols", (PyCFunction) &MakeSeq_LMatrix3f_get_cols, METH_NOARGS, NULL},
  { "getCols", (PyCFunction) &MakeSeq_LMatrix3f_get_cols, METH_NOARGS, NULL},
  {"get_col2s", (PyCFunction) &MakeSeq_LMatrix3f_get_col2s, METH_NOARGS, NULL},
  { "getCol2s", (PyCFunction) &MakeSeq_LMatrix3f_get_col2s, METH_NOARGS, NULL},
  {"get_row2s", (PyCFunction) &MakeSeq_LMatrix3f_get_row2s, METH_NOARGS, NULL},
  { "getRow2s", (PyCFunction) &MakeSeq_LMatrix3f_get_row2s, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1196_nb_divide(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix3f LMatrix3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix3f *return_value = new LMatrix3f((*(const LMatrix3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1197_nb_inplace_add(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.__iadd__", "LMatrix3f");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3f.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1200_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3f &LMatrix3f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1199_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other)
      LMatrix3f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix3f &LMatrix3f::operator *=(float scalar)
      if (PyNumber_Check(arg)) {
        (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other)
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: inline LMatrix3f &LMatrix3f::operator *=(float scalar)
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3f.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1198_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.__isub__", "LMatrix3f");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3f.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1200_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3f &LMatrix3f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1195_nb_multiply(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3f *return_value = new LMatrix3f((*(const LMatrix3f*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LMatrix3f LMatrix3f::operator *(float scalar) const
    if (PyNumber_Check(arg)) {
      LMatrix3f *return_value = new LMatrix3f((*(const LMatrix3f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3f *return_value = new LMatrix3f((*(const LMatrix3f*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  // No coercion possible: inline LMatrix3f LMatrix3f::operator *(float scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1196_nb_true_divide(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix3f LMatrix3f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix3f *return_value = new LMatrix3f((*(const LMatrix3f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix3f_operator_1159_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3f index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix3f::Row LMatrix3f::operator [](int i)
    LMatrix3f::Row *return_value = new LMatrix3f::Row((*local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f_Row, true, false);
  }

  {
    // -2 inline LMatrix3f::CRow LMatrix3f::operator [](int i) const
    LMatrix3f::CRow *return_value = new LMatrix3f::CRow((*(const LMatrix3f*)local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f_CRow, true, false);
  }

  // No coercion possible: inline LMatrix3f::Row LMatrix3f::operator [](int i)
  // No coercion possible: inline LMatrix3f::CRow LMatrix3f::operator [](int i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(const LMatrix3f self, index)\n"
      "__getitem__(LMatrix3f self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix3f_size_1160_sq_length(PyObject *self) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

/**
 * Python function wrapper for:
 * inline float LMatrix3f::operator ()(int row, int col) const
 */
static PyObject *Dtool_LMatrix3f_operator_1173(PyObject *self, PyObject *args, PyObject *kwds)
 {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LMatrix3f::operator ()(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:__call__", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const LMatrix3f*)local_this).operator ()((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(LMatrix3f self, int row, int col)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot tp_compare -> compare_to
//////////////////
static int Dtool_LMatrix3f_compare_to_1183_tp_compare(PyObject *self, PyObject *arg) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LMatrix3f::compare_to(LMatrix3f const &other) const
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3f.compare_to", "LMatrix3f");
    return -1;
  }
  int return_value = (*(const LMatrix3f*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix3f self, const LMatrix3f other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LMatrix3f_get_hash_1184_tp_hash(PyObject *self) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LMatrix3f_repr_1225_tp_repr(PyObject *self) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LMatrix3f::__repr__(void) const
  std::string return_value = invoke_extension((const LMatrix3f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LMatrix3f self)\n");
  }
  return NULL;
}

//////////////////
//  A __str__ function
//     LMatrix3f
//////////////////
static PyObject *Dtool_Str_LMatrix3f(PyObject *self) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     LMatrix3f
//////////////////
static PyObject *Dtool_RichCompare_LMatrix3f(PyObject *self, PyObject *arg, int op) {
  LMatrix3f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3f, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LMatrix3f::operator <(LMatrix3f const &other) const
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix3f*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LMatrix3f::operator ==(LMatrix3f const &other) const
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix3f*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LMatrix3f::operator !=(LMatrix3f const &other) const
      LMatrix3f arg_local;
      LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix3f*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LMatrix3f_compare_to_1183_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LMatrix3f[] = {
  {(char *)"rows", &Dtool_LMatrix3f_rows_Getter, NULL, NULL, NULL},
  {(char *)"cols", &Dtool_LMatrix3f_cols_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LMatrix3f = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LMatrix3f_operator_1195_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix3f_operator_1196_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LMatrix3f_operator_1197_nb_inplace_add,
  &Dtool_LMatrix3f_operator_1198_nb_inplace_subtract,
  &Dtool_LMatrix3f_operator_1199_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix3f_operator_1200_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix3f_operator_1196_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix3f_operator_1200_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix3f = {
  &Dtool_LMatrix3f_size_1160_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix3f_operator_1159_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LMatrix3f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix3f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LMatrix3f_compare_to_1183_tp_compare,
#endif
    &Dtool_LMatrix3f_repr_1225_tp_repr,
    &Dtool_NumberMethods_LMatrix3f,
    &Dtool_SequenceMethods_LMatrix3f,
    0, // tp_as_mapping
    &Dtool_LMatrix3f_get_hash_1184_tp_hash,
    &Dtool_LMatrix3f_operator_1173,
    &Dtool_Str_LMatrix3f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a 3-by-3 transform matrix.  It typically will represent either a\n"
    " * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix\n"
    " * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LMatrix3f,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix3f,
    0, // tp_members
    Dtool_Properties_LMatrix3f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_LMatrix3f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix3f,
  Dtool_UpcastInterface_LMatrix3f,
  Dtool_DowncastInterface_LMatrix3f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LMatrix3f,
};

static void Dtool_PyModuleClassInit_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix3f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LMatrix3f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LMatrix3f::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LMatrix3f::is_int));
    // Nested Object   LMatrix3f_Row;
    Dtool_PyModuleClassInit_LMatrix3f_Row(NULL);
    PyDict_SetItemString(dict, "Row", (PyObject *)&Dtool_LMatrix3f_Row);
    // Nested Object   LMatrix3f_CRow;
    Dtool_PyModuleClassInit_LMatrix3f_CRow(NULL);
    PyDict_SetItemString(dict, "CRow", (PyObject *)&Dtool_LMatrix3f_CRow);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix3f);
  }
}

/**
 * Python method tables for LMatrix4f_Row (Row)
 */
static PyMethodDef Dtool_Methods_LMatrix4f_Row[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f_Row slot sq_ass_item -> operator []
//////////////////
static int Dtool_LMatrix4f_Row_operator_1238_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LMatrix4f::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f_Row, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4f_Row index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float &LMatrix4f::Row::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = (float)PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call Row.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const Row self, index, float assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f_Row slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix4f_Row_operator_1238_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix4f::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f_Row, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4f_Row index out of range");
    return NULL;
  }
  // 1-inline float LMatrix4f::Row::operator [](int i) const
  float return_value = (*(const LMatrix4f::Row*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Row self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f_Row slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix4f_Row_size_1239_sq_length(PyObject *self) {
  LMatrix4f::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f_Row, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix4f_Row = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix4f_Row = {
  &Dtool_LMatrix4f_Row_size_1239_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix4f_Row_operator_1238_sq_item,
  0, // sq_slice
  &Dtool_LMatrix4f_Row_operator_1238_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix4f_Row = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Row",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix4f_Row,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix4f_Row,
    &Dtool_SequenceMethods_LMatrix4f_Row,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// These helper classes are used to support two-level operator [].",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix4f_Row,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix4f_Row,
    PyType_GenericAlloc,
    Dtool_new_LMatrix4f_Row,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix4f_Row,
  Dtool_UpcastInterface_LMatrix4f_Row,
  Dtool_DowncastInterface_LMatrix4f_Row,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix4f_Row(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix4f_Row._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix4f_Row._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix4f_Row) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix4f_Row)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix4f_Row);
  }
}

/**
 * Python method tables for LMatrix4f_CRow (CRow)
 */
static PyMethodDef Dtool_Methods_LMatrix4f_CRow[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f_CRow slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix4f_CRow_operator_1243_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix4f::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f_CRow, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4f_CRow index out of range");
    return NULL;
  }
  // 1-inline float LMatrix4f::CRow::operator [](int i) const
  float return_value = (*(const LMatrix4f::CRow*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(CRow self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f_CRow slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix4f_CRow_size_1244_sq_length(PyObject *self) {
  LMatrix4f::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f_CRow, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix4f_CRow = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix4f_CRow = {
  &Dtool_LMatrix4f_CRow_size_1244_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix4f_CRow_operator_1243_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix4f_CRow = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CRow",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix4f_CRow,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix4f_CRow,
    &Dtool_SequenceMethods_LMatrix4f_CRow,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix4f_CRow,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix4f_CRow,
    PyType_GenericAlloc,
    Dtool_new_LMatrix4f_CRow,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix4f_CRow,
  Dtool_UpcastInterface_LMatrix4f_CRow,
  Dtool_DowncastInterface_LMatrix4f_CRow,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix4f_CRow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix4f_CRow._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix4f_CRow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix4f_CRow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix4f_CRow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix4f_CRow);
  }
}

/**
 * Python method tables for LMatrix4f (LMatrix4f)
 */
static PyMethodDef Dtool_Methods_LMatrix4f[] = {
  {"assign", &Dtool_LMatrix4f_operator_1248, METH_O, (const char *)Dtool_LMatrix4f_operator_1248_comment},
  {"__reduce__", &Dtool_LMatrix4f_reduce_1252, METH_NOARGS, (const char *)Dtool_LMatrix4f_reduce_1252_comment},
  {"fill", &Dtool_LMatrix4f_fill_1253, METH_O, (const char *)Dtool_LMatrix4f_fill_1253_comment},
  {"set", (PyCFunction) &Dtool_LMatrix4f_set_1254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_1254_comment},
  {"set_upper_3", &Dtool_LMatrix4f_set_upper_3_1255, METH_O, (const char *)Dtool_LMatrix4f_set_upper_3_1255_comment},
  {"setUpper3", &Dtool_LMatrix4f_set_upper_3_1255, METH_O, (const char *)Dtool_LMatrix4f_set_upper_3_1255_comment},
  {"get_upper_3", &Dtool_LMatrix4f_get_upper_3_1256, METH_NOARGS, (const char *)Dtool_LMatrix4f_get_upper_3_1256_comment},
  {"getUpper3", &Dtool_LMatrix4f_get_upper_3_1256, METH_NOARGS, (const char *)Dtool_LMatrix4f_get_upper_3_1256_comment},
  {"set_row", (PyCFunction) &Dtool_LMatrix4f_set_row_1259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_row_1259_comment},
  {"setRow", (PyCFunction) &Dtool_LMatrix4f_set_row_1259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_row_1259_comment},
  {"set_col", (PyCFunction) &Dtool_LMatrix4f_set_col_1260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_col_1260_comment},
  {"setCol", (PyCFunction) &Dtool_LMatrix4f_set_col_1260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_col_1260_comment},
  {"get_row", (PyCFunction) &Dtool_LMatrix4f_get_row_1261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_get_row_1261_comment},
  {"getRow", (PyCFunction) &Dtool_LMatrix4f_get_row_1261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_get_row_1261_comment},
  {"get_col", &Dtool_LMatrix4f_get_col_1262, METH_O, (const char *)Dtool_LMatrix4f_get_col_1262_comment},
  {"getCol", &Dtool_LMatrix4f_get_col_1262, METH_O, (const char *)Dtool_LMatrix4f_get_col_1262_comment},
  {"get_row3", (PyCFunction) &Dtool_LMatrix4f_get_row3_1263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_get_row3_1263_comment},
  {"getRow3", (PyCFunction) &Dtool_LMatrix4f_get_row3_1263, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_get_row3_1263_comment},
  {"get_col3", &Dtool_LMatrix4f_get_col3_1269, METH_O, (const char *)Dtool_LMatrix4f_get_col3_1269_comment},
  {"getCol3", &Dtool_LMatrix4f_get_col3_1269, METH_O, (const char *)Dtool_LMatrix4f_get_col3_1269_comment},
  {"is_nan", &Dtool_LMatrix4f_is_nan_1271, METH_NOARGS, (const char *)Dtool_LMatrix4f_is_nan_1271_comment},
  {"isNan", &Dtool_LMatrix4f_is_nan_1271, METH_NOARGS, (const char *)Dtool_LMatrix4f_is_nan_1271_comment},
  {"is_identity", &Dtool_LMatrix4f_is_identity_1272, METH_NOARGS, (const char *)Dtool_LMatrix4f_is_identity_1272_comment},
  {"isIdentity", &Dtool_LMatrix4f_is_identity_1272, METH_NOARGS, (const char *)Dtool_LMatrix4f_is_identity_1272_comment},
  {"get_cell", (PyCFunction) &Dtool_LMatrix4f_get_cell_1273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_get_cell_1273_comment},
  {"getCell", (PyCFunction) &Dtool_LMatrix4f_get_cell_1273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_get_cell_1273_comment},
  {"set_cell", (PyCFunction) &Dtool_LMatrix4f_set_cell_1274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_cell_1274_comment},
  {"setCell", (PyCFunction) &Dtool_LMatrix4f_set_cell_1274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_cell_1274_comment},
  {"get_num_components", &Dtool_LMatrix4f_get_num_components_1276, METH_NOARGS, (const char *)Dtool_LMatrix4f_get_num_components_1276_comment},
  {"getNumComponents", &Dtool_LMatrix4f_get_num_components_1276, METH_NOARGS, (const char *)Dtool_LMatrix4f_get_num_components_1276_comment},
  {"compare_to", &Dtool_LMatrix4f_compare_to_1282, METH_VARARGS, (const char *)Dtool_LMatrix4f_compare_to_1282_comment},
  {"compareTo", &Dtool_LMatrix4f_compare_to_1282, METH_VARARGS, (const char *)Dtool_LMatrix4f_compare_to_1282_comment},
  {"get_hash", &Dtool_LMatrix4f_get_hash_1283, METH_VARARGS, (const char *)Dtool_LMatrix4f_get_hash_1283_comment},
  {"getHash", &Dtool_LMatrix4f_get_hash_1283, METH_VARARGS, (const char *)Dtool_LMatrix4f_get_hash_1283_comment},
  {"add_hash", (PyCFunction) &Dtool_LMatrix4f_add_hash_1284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_add_hash_1284_comment},
  {"addHash", (PyCFunction) &Dtool_LMatrix4f_add_hash_1284, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_add_hash_1284_comment},
  {"xform", &Dtool_LMatrix4f_xform_1285, METH_O, (const char *)Dtool_LMatrix4f_xform_1285_comment},
  {"xform_point", &Dtool_LMatrix4f_xform_point_1286, METH_O, (const char *)Dtool_LMatrix4f_xform_point_1286_comment},
  {"xformPoint", &Dtool_LMatrix4f_xform_point_1286, METH_O, (const char *)Dtool_LMatrix4f_xform_point_1286_comment},
  {"xform_point_general", &Dtool_LMatrix4f_xform_point_general_1287, METH_O, (const char *)Dtool_LMatrix4f_xform_point_general_1287_comment},
  {"xformPointGeneral", &Dtool_LMatrix4f_xform_point_general_1287, METH_O, (const char *)Dtool_LMatrix4f_xform_point_general_1287_comment},
  {"xform_vec", &Dtool_LMatrix4f_xform_vec_1288, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_1288_comment},
  {"xformVec", &Dtool_LMatrix4f_xform_vec_1288, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_1288_comment},
  {"xform_vec_general", &Dtool_LMatrix4f_xform_vec_general_1289, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_general_1289_comment},
  {"xformVecGeneral", &Dtool_LMatrix4f_xform_vec_general_1289, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_general_1289_comment},
  {"xform_in_place", &Dtool_LMatrix4f_xform_in_place_1290, METH_O, (const char *)Dtool_LMatrix4f_xform_in_place_1290_comment},
  {"xformInPlace", &Dtool_LMatrix4f_xform_in_place_1290, METH_O, (const char *)Dtool_LMatrix4f_xform_in_place_1290_comment},
  {"xform_point_in_place", &Dtool_LMatrix4f_xform_point_in_place_1291, METH_O, (const char *)Dtool_LMatrix4f_xform_point_in_place_1291_comment},
  {"xformPointInPlace", &Dtool_LMatrix4f_xform_point_in_place_1291, METH_O, (const char *)Dtool_LMatrix4f_xform_point_in_place_1291_comment},
  {"xform_point_general_in_place", &Dtool_LMatrix4f_xform_point_general_in_place_1292, METH_O, (const char *)Dtool_LMatrix4f_xform_point_general_in_place_1292_comment},
  {"xformPointGeneralInPlace", &Dtool_LMatrix4f_xform_point_general_in_place_1292, METH_O, (const char *)Dtool_LMatrix4f_xform_point_general_in_place_1292_comment},
  {"xform_vec_in_place", &Dtool_LMatrix4f_xform_vec_in_place_1293, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_in_place_1293_comment},
  {"xformVecInPlace", &Dtool_LMatrix4f_xform_vec_in_place_1293, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_in_place_1293_comment},
  {"xform_vec_general_in_place", &Dtool_LMatrix4f_xform_vec_general_in_place_1294, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_general_in_place_1294_comment},
  {"xformVecGeneralInPlace", &Dtool_LMatrix4f_xform_vec_general_in_place_1294, METH_O, (const char *)Dtool_LMatrix4f_xform_vec_general_in_place_1294_comment},
  {"multiply", (PyCFunction) &Dtool_LMatrix4f_multiply_1295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_multiply_1295_comment},
  {"componentwise_mult", &Dtool_LMatrix4f_componentwise_mult_1302, METH_O, (const char *)Dtool_LMatrix4f_componentwise_mult_1302_comment},
  {"componentwiseMult", &Dtool_LMatrix4f_componentwise_mult_1302, METH_O, (const char *)Dtool_LMatrix4f_componentwise_mult_1302_comment},
  {"transpose_from", &Dtool_LMatrix4f_transpose_from_1303, METH_O, (const char *)Dtool_LMatrix4f_transpose_from_1303_comment},
  {"transposeFrom", &Dtool_LMatrix4f_transpose_from_1303, METH_O, (const char *)Dtool_LMatrix4f_transpose_from_1303_comment},
  {"transpose_in_place", &Dtool_LMatrix4f_transpose_in_place_1304, METH_NOARGS, (const char *)Dtool_LMatrix4f_transpose_in_place_1304_comment},
  {"transposeInPlace", &Dtool_LMatrix4f_transpose_in_place_1304, METH_NOARGS, (const char *)Dtool_LMatrix4f_transpose_in_place_1304_comment},
  {"invert_from", &Dtool_LMatrix4f_invert_from_1305, METH_O, (const char *)Dtool_LMatrix4f_invert_from_1305_comment},
  {"invertFrom", &Dtool_LMatrix4f_invert_from_1305, METH_O, (const char *)Dtool_LMatrix4f_invert_from_1305_comment},
  {"invert_affine_from", &Dtool_LMatrix4f_invert_affine_from_1306, METH_O, (const char *)Dtool_LMatrix4f_invert_affine_from_1306_comment},
  {"invertAffineFrom", &Dtool_LMatrix4f_invert_affine_from_1306, METH_O, (const char *)Dtool_LMatrix4f_invert_affine_from_1306_comment},
  {"invert_in_place", &Dtool_LMatrix4f_invert_in_place_1307, METH_NOARGS, (const char *)Dtool_LMatrix4f_invert_in_place_1307_comment},
  {"invertInPlace", &Dtool_LMatrix4f_invert_in_place_1307, METH_NOARGS, (const char *)Dtool_LMatrix4f_invert_in_place_1307_comment},
  {"accumulate", (PyCFunction) &Dtool_LMatrix4f_accumulate_1308, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_accumulate_1308_comment},
  {"ident_mat", &Dtool_LMatrix4f_ident_mat_1309, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_ident_mat_1309_comment},
  {"identMat", &Dtool_LMatrix4f_ident_mat_1309, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_ident_mat_1309_comment},
  {"ones_mat", &Dtool_LMatrix4f_ones_mat_1310, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_ones_mat_1310_comment},
  {"onesMat", &Dtool_LMatrix4f_ones_mat_1310, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_ones_mat_1310_comment},
  {"zeros_mat", &Dtool_LMatrix4f_zeros_mat_1311, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_zeros_mat_1311_comment},
  {"zerosMat", &Dtool_LMatrix4f_zeros_mat_1311, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_zeros_mat_1311_comment},
  {"set_translate_mat", &Dtool_LMatrix4f_set_translate_mat_1312, METH_O, (const char *)Dtool_LMatrix4f_set_translate_mat_1312_comment},
  {"setTranslateMat", &Dtool_LMatrix4f_set_translate_mat_1312, METH_O, (const char *)Dtool_LMatrix4f_set_translate_mat_1312_comment},
  {"set_rotate_mat", (PyCFunction) &Dtool_LMatrix4f_set_rotate_mat_1313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_rotate_mat_1313_comment},
  {"setRotateMat", (PyCFunction) &Dtool_LMatrix4f_set_rotate_mat_1313, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_rotate_mat_1313_comment},
  {"set_rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix4f_set_rotate_mat_normaxis_1314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_rotate_mat_normaxis_1314_comment},
  {"setRotateMatNormaxis", (PyCFunction) &Dtool_LMatrix4f_set_rotate_mat_normaxis_1314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_rotate_mat_normaxis_1314_comment},
  {"set_scale_mat", &Dtool_LMatrix4f_set_scale_mat_1315, METH_O, (const char *)Dtool_LMatrix4f_set_scale_mat_1315_comment},
  {"setScaleMat", &Dtool_LMatrix4f_set_scale_mat_1315, METH_O, (const char *)Dtool_LMatrix4f_set_scale_mat_1315_comment},
  {"set_shear_mat", (PyCFunction) &Dtool_LMatrix4f_set_shear_mat_1316, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_shear_mat_1316_comment},
  {"setShearMat", (PyCFunction) &Dtool_LMatrix4f_set_shear_mat_1316, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_shear_mat_1316_comment},
  {"set_scale_shear_mat", (PyCFunction) &Dtool_LMatrix4f_set_scale_shear_mat_1317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_scale_shear_mat_1317_comment},
  {"setScaleShearMat", (PyCFunction) &Dtool_LMatrix4f_set_scale_shear_mat_1317, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_set_scale_shear_mat_1317_comment},
  {"translate_mat", (PyCFunction) &Dtool_LMatrix4f_translate_mat_1318, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_translate_mat_1318_comment},
  {"translateMat", (PyCFunction) &Dtool_LMatrix4f_translate_mat_1318, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_translate_mat_1318_comment},
  {"rotate_mat", (PyCFunction) &Dtool_LMatrix4f_rotate_mat_1319, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_rotate_mat_1319_comment},
  {"rotateMat", (PyCFunction) &Dtool_LMatrix4f_rotate_mat_1319, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_rotate_mat_1319_comment},
  {"rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix4f_rotate_mat_normaxis_1320, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_rotate_mat_normaxis_1320_comment},
  {"rotateMatNormaxis", (PyCFunction) &Dtool_LMatrix4f_rotate_mat_normaxis_1320, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_rotate_mat_normaxis_1320_comment},
  {"scale_mat", (PyCFunction) &Dtool_LMatrix4f_scale_mat_1321, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_scale_mat_1321_comment},
  {"scaleMat", (PyCFunction) &Dtool_LMatrix4f_scale_mat_1321, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_scale_mat_1321_comment},
  {"shear_mat", (PyCFunction) &Dtool_LMatrix4f_shear_mat_1322, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_shear_mat_1322_comment},
  {"shearMat", (PyCFunction) &Dtool_LMatrix4f_shear_mat_1322, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_shear_mat_1322_comment},
  {"scale_shear_mat", (PyCFunction) &Dtool_LMatrix4f_scale_shear_mat_1323, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_scale_shear_mat_1323_comment},
  {"scaleShearMat", (PyCFunction) &Dtool_LMatrix4f_scale_shear_mat_1323, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_scale_shear_mat_1323_comment},
  {"y_to_z_up_mat", &Dtool_LMatrix4f_y_to_z_up_mat_1324, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_y_to_z_up_mat_1324_comment},
  {"yToZUpMat", &Dtool_LMatrix4f_y_to_z_up_mat_1324, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_y_to_z_up_mat_1324_comment},
  {"z_to_y_up_mat", &Dtool_LMatrix4f_z_to_y_up_mat_1325, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_z_to_y_up_mat_1325_comment},
  {"zToYUpMat", &Dtool_LMatrix4f_z_to_y_up_mat_1325, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_z_to_y_up_mat_1325_comment},
  {"convert_mat", (PyCFunction) &Dtool_LMatrix4f_convert_mat_1326, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_convert_mat_1326_comment},
  {"convertMat", (PyCFunction) &Dtool_LMatrix4f_convert_mat_1326, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4f_convert_mat_1326_comment},
  {"almost_equal", (PyCFunction) &Dtool_LMatrix4f_almost_equal_1327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_almost_equal_1327_comment},
  {"almostEqual", (PyCFunction) &Dtool_LMatrix4f_almost_equal_1327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_almost_equal_1327_comment},
  {"output", &Dtool_LMatrix4f_output_1328, METH_O, (const char *)Dtool_LMatrix4f_output_1328_comment},
  {"write", (PyCFunction) &Dtool_LMatrix4f_write_1329, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4f_write_1329_comment},
  {"write_datagram_fixed", &Dtool_LMatrix4f_write_datagram_fixed_1332, METH_O, (const char *)Dtool_LMatrix4f_write_datagram_fixed_1332_comment},
  {"writeDatagramFixed", &Dtool_LMatrix4f_write_datagram_fixed_1332, METH_O, (const char *)Dtool_LMatrix4f_write_datagram_fixed_1332_comment},
  {"read_datagram_fixed", &Dtool_LMatrix4f_read_datagram_fixed_1333, METH_O, (const char *)Dtool_LMatrix4f_read_datagram_fixed_1333_comment},
  {"readDatagramFixed", &Dtool_LMatrix4f_read_datagram_fixed_1333, METH_O, (const char *)Dtool_LMatrix4f_read_datagram_fixed_1333_comment},
  {"write_datagram", &Dtool_LMatrix4f_write_datagram_1334, METH_O, (const char *)Dtool_LMatrix4f_write_datagram_1334_comment},
  {"writeDatagram", &Dtool_LMatrix4f_write_datagram_1334, METH_O, (const char *)Dtool_LMatrix4f_write_datagram_1334_comment},
  {"read_datagram", &Dtool_LMatrix4f_read_datagram_1335, METH_O, (const char *)Dtool_LMatrix4f_read_datagram_1335_comment},
  {"readDatagram", &Dtool_LMatrix4f_read_datagram_1335, METH_O, (const char *)Dtool_LMatrix4f_read_datagram_1335_comment},
  {"get_class_type", &Dtool_LMatrix4f_get_class_type_1336, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_get_class_type_1336_comment},
  {"getClassType", &Dtool_LMatrix4f_get_class_type_1336, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4f_get_class_type_1336_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_rows", (PyCFunction) &MakeSeq_LMatrix4f_get_rows, METH_NOARGS, NULL},
  { "getRows", (PyCFunction) &MakeSeq_LMatrix4f_get_rows, METH_NOARGS, NULL},
  {"get_cols", (PyCFunction) &MakeSeq_LMatrix4f_get_cols, METH_NOARGS, NULL},
  { "getCols", (PyCFunction) &MakeSeq_LMatrix4f_get_cols, METH_NOARGS, NULL},
  {"get_row3s", (PyCFunction) &MakeSeq_LMatrix4f_get_row3s, METH_NOARGS, NULL},
  { "getRow3s", (PyCFunction) &MakeSeq_LMatrix4f_get_row3s, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1297_nb_divide(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix4f LMatrix4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix4f *return_value = new LMatrix4f((*(const LMatrix4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1298_nb_inplace_add(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.__iadd__", "LMatrix4f");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4f.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1301_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4f &LMatrix4f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1300_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other)
      LMatrix4f const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix4f &LMatrix4f::operator *=(float scalar)
      if (PyNumber_Check(arg)) {
        (*local_this).operator *=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other)
      LMatrix4f arg_local;
      LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: inline LMatrix4f &LMatrix4f::operator *=(float scalar)
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4f.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1299_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.__isub__", "LMatrix4f");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4f.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1301_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4f &LMatrix4f::operator /=(float scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4f.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1296_nb_multiply(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4f *return_value = new LMatrix4f((*(const LMatrix4f*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  {
    // -2 inline LMatrix4f LMatrix4f::operator *(float scalar) const
    if (PyNumber_Check(arg)) {
      LMatrix4f *return_value = new LMatrix4f((*(const LMatrix4f*)local_this).operator *((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  {
    // -2 inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4f *return_value = new LMatrix4f((*(const LMatrix4f*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  // No coercion possible: inline LMatrix4f LMatrix4f::operator *(float scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1297_nb_true_divide(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4f, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix4f LMatrix4f::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix4f *return_value = new LMatrix4f((*(const LMatrix4f*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix4f_operator_1257_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4f index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix4f::Row LMatrix4f::operator [](int i)
    LMatrix4f::Row *return_value = new LMatrix4f::Row((*local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f_Row, true, false);
  }

  {
    // -2 inline LMatrix4f::CRow LMatrix4f::operator [](int i) const
    LMatrix4f::CRow *return_value = new LMatrix4f::CRow((*(const LMatrix4f*)local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f_CRow, true, false);
  }

  // No coercion possible: inline LMatrix4f::Row LMatrix4f::operator [](int i)
  // No coercion possible: inline LMatrix4f::CRow LMatrix4f::operator [](int i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(const LMatrix4f self, index)\n"
      "__getitem__(LMatrix4f self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix4f_size_1258_sq_length(PyObject *self) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

/**
 * Python function wrapper for:
 * inline float LMatrix4f::operator ()(int row, int col) const
 */
static PyObject *Dtool_LMatrix4f_operator_1270(PyObject *self, PyObject *args, PyObject *kwds)
 {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float LMatrix4f::operator ()(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:__call__", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const LMatrix4f*)local_this).operator ()((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(LMatrix4f self, int row, int col)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot tp_compare -> compare_to
//////////////////
static int Dtool_LMatrix4f_compare_to_1282_tp_compare(PyObject *self, PyObject *arg) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LMatrix4f::compare_to(LMatrix4f const &other) const
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4f.compare_to", "LMatrix4f");
    return -1;
  }
  int return_value = (*(const LMatrix4f*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix4f self, const LMatrix4f other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LMatrix4f_get_hash_1283_tp_hash(PyObject *self) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4f slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LMatrix4f_repr_1330_tp_repr(PyObject *self) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LMatrix4f::__repr__(void) const
  std::string return_value = invoke_extension((const LMatrix4f*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LMatrix4f self)\n");
  }
  return NULL;
}

//////////////////
//  A __str__ function
//     LMatrix4f
//////////////////
static PyObject *Dtool_Str_LMatrix4f(PyObject *self) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     LMatrix4f
//////////////////
static PyObject *Dtool_RichCompare_LMatrix4f(PyObject *self, PyObject *arg, int op) {
  LMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4f, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LMatrix4f::operator <(LMatrix4f const &other) const
      LMatrix4f arg_local;
      LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix4f*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LMatrix4f::operator ==(LMatrix4f const &other) const
      LMatrix4f arg_local;
      LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix4f*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LMatrix4f::operator !=(LMatrix4f const &other) const
      LMatrix4f arg_local;
      LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix4f*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LMatrix4f_compare_to_1282_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LMatrix4f[] = {
  {(char *)"rows", &Dtool_LMatrix4f_rows_Getter, NULL, NULL, NULL},
  {(char *)"cols", &Dtool_LMatrix4f_cols_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LMatrix4f_operator_1296_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix4f_operator_1297_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LMatrix4f_operator_1298_nb_inplace_add,
  &Dtool_LMatrix4f_operator_1299_nb_inplace_subtract,
  &Dtool_LMatrix4f_operator_1300_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix4f_operator_1301_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix4f_operator_1297_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix4f_operator_1301_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix4f = {
  &Dtool_LMatrix4f_size_1258_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix4f_operator_1257_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LMatrix4f_compare_to_1282_tp_compare,
#endif
    &Dtool_LMatrix4f_repr_1330_tp_repr,
    &Dtool_NumberMethods_LMatrix4f,
    &Dtool_SequenceMethods_LMatrix4f,
    0, // tp_as_mapping
    &Dtool_LMatrix4f_get_hash_1283_tp_hash,
    &Dtool_LMatrix4f_operator_1270,
    &Dtool_Str_LMatrix4f,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a 4-by-4 transform matrix.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LMatrix4f,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix4f,
    0, // tp_members
    Dtool_Properties_LMatrix4f,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_LMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix4f,
  Dtool_UpcastInterface_LMatrix4f,
  Dtool_DowncastInterface_LMatrix4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LMatrix4f,
};

static void Dtool_PyModuleClassInit_LMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_LMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LMatrix4f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LMatrix4f::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LMatrix4f::is_int));
    // Nested Object   LMatrix4f_Row;
    Dtool_PyModuleClassInit_LMatrix4f_Row(NULL);
    PyDict_SetItemString(dict, "Row", (PyObject *)&Dtool_LMatrix4f_Row);
    // Nested Object   LMatrix4f_CRow;
    Dtool_PyModuleClassInit_LMatrix4f_CRow(NULL);
    PyDict_SetItemString(dict, "CRow", (PyObject *)&Dtool_LMatrix4f_CRow);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix4f);
  }
}

/**
 * Python method tables for UnalignedLMatrix4f (UnalignedLMatrix4f)
 */
static PyMethodDef Dtool_Methods_UnalignedLMatrix4f[] = {
  {"assign", &Dtool_UnalignedLMatrix4f_operator_1341, METH_O, (const char *)Dtool_UnalignedLMatrix4f_operator_1341_comment},
  {"set", (PyCFunction) &Dtool_UnalignedLMatrix4f_set_1342, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_UnalignedLMatrix4f_set_1342_comment},
  {"get_num_components", &Dtool_UnalignedLMatrix4f_get_num_components_1345, METH_NOARGS, (const char *)Dtool_UnalignedLMatrix4f_get_num_components_1345_comment},
  {"getNumComponents", &Dtool_UnalignedLMatrix4f_get_num_components_1345, METH_NOARGS, (const char *)Dtool_UnalignedLMatrix4f_get_num_components_1345_comment},
  {"get_class_type", &Dtool_UnalignedLMatrix4f_get_class_type_1346, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLMatrix4f_get_class_type_1346_comment},
  {"getClassType", &Dtool_UnalignedLMatrix4f_get_class_type_1346, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLMatrix4f_get_class_type_1346_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * inline float UnalignedLMatrix4f::operator ()(int row, int col) const
 */
static PyObject *Dtool_UnalignedLMatrix4f_operator_1343(PyObject *self, PyObject *args, PyObject *kwds)
 {
  UnalignedLMatrix4f *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLMatrix4f, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float UnalignedLMatrix4f::operator ()(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:__call__", (char **)keyword_list, &param1, &param2)) {
    float return_value = (*(const UnalignedLMatrix4f*)local_this).operator ()((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(UnalignedLMatrix4f self, int row, int col)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_UnalignedLMatrix4f = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_UnalignedLMatrix4f = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UnalignedLMatrix4f",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnalignedLMatrix4f,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UnalignedLMatrix4f,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    &Dtool_UnalignedLMatrix4f_operator_1343,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an \"unaligned\" LMatrix4.  It has no functionality other than to\n"
    " * store numbers, and it will pack them in as tightly as possible, avoiding\n"
    " * any SSE2 alignment requirements shared by the primary LMatrix4 class.\n"
    " *\n"
    " * Use it only when you need to pack numbers tightly without respect to\n"
    " * alignment, and then copy it to a proper LMatrix4 to get actual use from it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UnalignedLMatrix4f,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UnalignedLMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_UnalignedLMatrix4f,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnalignedLMatrix4f,
  Dtool_UpcastInterface_UnalignedLMatrix4f,
  Dtool_DowncastInterface_UnalignedLMatrix4f,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_UnalignedLMatrix4f,
};

static void Dtool_PyModuleClassInit_UnalignedLMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UnalignedLMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UnalignedLMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum UnalignedLMatrix4f::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(UnalignedLMatrix4f::num_components));
    if (PyType_Ready((PyTypeObject *)&Dtool_UnalignedLMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnalignedLMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnalignedLMatrix4f);
  }
}

/**
 * Python method tables for LMatrix3d_Row (Row)
 */
static PyMethodDef Dtool_Methods_LMatrix3d_Row[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d_Row slot sq_ass_item -> operator []
//////////////////
static int Dtool_LMatrix3d_Row_operator_1351_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LMatrix3d::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d_Row, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3d_Row index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double &LMatrix3d::Row::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call Row.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const Row self, index, double assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d_Row slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix3d_Row_operator_1351_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix3d::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d_Row, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3d_Row index out of range");
    return NULL;
  }
  // 1-inline double LMatrix3d::Row::operator [](int i) const
  double return_value = (*(const LMatrix3d::Row*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Row self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d_Row slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix3d_Row_size_1352_sq_length(PyObject *self) {
  LMatrix3d::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d_Row, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix3d_Row = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix3d_Row = {
  &Dtool_LMatrix3d_Row_size_1352_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix3d_Row_operator_1351_sq_item,
  0, // sq_slice
  &Dtool_LMatrix3d_Row_operator_1351_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix3d_Row = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Row",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix3d_Row,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix3d_Row,
    &Dtool_SequenceMethods_LMatrix3d_Row,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// These helper classes are used to support two-level operator [].",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix3d_Row,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix3d_Row,
    PyType_GenericAlloc,
    Dtool_new_LMatrix3d_Row,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix3d_Row,
  Dtool_UpcastInterface_LMatrix3d_Row,
  Dtool_DowncastInterface_LMatrix3d_Row,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix3d_Row(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix3d_Row._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix3d_Row._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix3d_Row) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix3d_Row)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix3d_Row);
  }
}

/**
 * Python method tables for LMatrix3d_CRow (CRow)
 */
static PyMethodDef Dtool_Methods_LMatrix3d_CRow[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d_CRow slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix3d_CRow_operator_1356_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix3d::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d_CRow, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3d_CRow index out of range");
    return NULL;
  }
  // 1-inline double LMatrix3d::CRow::operator [](int i) const
  double return_value = (*(const LMatrix3d::CRow*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(CRow self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d_CRow slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix3d_CRow_size_1357_sq_length(PyObject *self) {
  LMatrix3d::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d_CRow, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix3d_CRow = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix3d_CRow = {
  &Dtool_LMatrix3d_CRow_size_1357_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix3d_CRow_operator_1356_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix3d_CRow = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CRow",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix3d_CRow,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix3d_CRow,
    &Dtool_SequenceMethods_LMatrix3d_CRow,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix3d_CRow,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix3d_CRow,
    PyType_GenericAlloc,
    Dtool_new_LMatrix3d_CRow,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix3d_CRow,
  Dtool_UpcastInterface_LMatrix3d_CRow,
  Dtool_DowncastInterface_LMatrix3d_CRow,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix3d_CRow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix3d_CRow._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix3d_CRow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix3d_CRow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix3d_CRow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix3d_CRow);
  }
}

/**
 * Python method tables for LMatrix3d (LMatrix3d)
 */
static PyMethodDef Dtool_Methods_LMatrix3d[] = {
  {"assign", &Dtool_LMatrix3d_operator_1361, METH_O, (const char *)Dtool_LMatrix3d_operator_1361_comment},
  {"__reduce__", &Dtool_LMatrix3d_reduce_1365, METH_NOARGS, (const char *)Dtool_LMatrix3d_reduce_1365_comment},
  {"fill", &Dtool_LMatrix3d_fill_1366, METH_O, (const char *)Dtool_LMatrix3d_fill_1366_comment},
  {"set", (PyCFunction) &Dtool_LMatrix3d_set_1367, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_1367_comment},
  {"set_row", (PyCFunction) &Dtool_LMatrix3d_set_row_1370, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_row_1370_comment},
  {"setRow", (PyCFunction) &Dtool_LMatrix3d_set_row_1370, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_row_1370_comment},
  {"set_col", (PyCFunction) &Dtool_LMatrix3d_set_col_1371, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_col_1371_comment},
  {"setCol", (PyCFunction) &Dtool_LMatrix3d_set_col_1371, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_col_1371_comment},
  {"get_row", (PyCFunction) &Dtool_LMatrix3d_get_row_1372, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_get_row_1372_comment},
  {"getRow", (PyCFunction) &Dtool_LMatrix3d_get_row_1372, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_get_row_1372_comment},
  {"get_col", &Dtool_LMatrix3d_get_col_1373, METH_O, (const char *)Dtool_LMatrix3d_get_col_1373_comment},
  {"getCol", &Dtool_LMatrix3d_get_col_1373, METH_O, (const char *)Dtool_LMatrix3d_get_col_1373_comment},
  {"get_row2", &Dtool_LMatrix3d_get_row2_1378, METH_O, (const char *)Dtool_LMatrix3d_get_row2_1378_comment},
  {"getRow2", &Dtool_LMatrix3d_get_row2_1378, METH_O, (const char *)Dtool_LMatrix3d_get_row2_1378_comment},
  {"get_col2", &Dtool_LMatrix3d_get_col2_1379, METH_O, (const char *)Dtool_LMatrix3d_get_col2_1379_comment},
  {"getCol2", &Dtool_LMatrix3d_get_col2_1379, METH_O, (const char *)Dtool_LMatrix3d_get_col2_1379_comment},
  {"is_nan", &Dtool_LMatrix3d_is_nan_1383, METH_NOARGS, (const char *)Dtool_LMatrix3d_is_nan_1383_comment},
  {"isNan", &Dtool_LMatrix3d_is_nan_1383, METH_NOARGS, (const char *)Dtool_LMatrix3d_is_nan_1383_comment},
  {"is_identity", &Dtool_LMatrix3d_is_identity_1384, METH_NOARGS, (const char *)Dtool_LMatrix3d_is_identity_1384_comment},
  {"isIdentity", &Dtool_LMatrix3d_is_identity_1384, METH_NOARGS, (const char *)Dtool_LMatrix3d_is_identity_1384_comment},
  {"get_cell", (PyCFunction) &Dtool_LMatrix3d_get_cell_1385, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_get_cell_1385_comment},
  {"getCell", (PyCFunction) &Dtool_LMatrix3d_get_cell_1385, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_get_cell_1385_comment},
  {"set_cell", (PyCFunction) &Dtool_LMatrix3d_set_cell_1386, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_cell_1386_comment},
  {"setCell", (PyCFunction) &Dtool_LMatrix3d_set_cell_1386, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_cell_1386_comment},
  {"get_num_components", &Dtool_LMatrix3d_get_num_components_1388, METH_NOARGS, (const char *)Dtool_LMatrix3d_get_num_components_1388_comment},
  {"getNumComponents", &Dtool_LMatrix3d_get_num_components_1388, METH_NOARGS, (const char *)Dtool_LMatrix3d_get_num_components_1388_comment},
  {"compare_to", &Dtool_LMatrix3d_compare_to_1392, METH_VARARGS, (const char *)Dtool_LMatrix3d_compare_to_1392_comment},
  {"compareTo", &Dtool_LMatrix3d_compare_to_1392, METH_VARARGS, (const char *)Dtool_LMatrix3d_compare_to_1392_comment},
  {"get_hash", &Dtool_LMatrix3d_get_hash_1393, METH_VARARGS, (const char *)Dtool_LMatrix3d_get_hash_1393_comment},
  {"getHash", &Dtool_LMatrix3d_get_hash_1393, METH_VARARGS, (const char *)Dtool_LMatrix3d_get_hash_1393_comment},
  {"add_hash", (PyCFunction) &Dtool_LMatrix3d_add_hash_1394, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_add_hash_1394_comment},
  {"addHash", (PyCFunction) &Dtool_LMatrix3d_add_hash_1394, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_add_hash_1394_comment},
  {"xform", &Dtool_LMatrix3d_xform_1395, METH_O, (const char *)Dtool_LMatrix3d_xform_1395_comment},
  {"xform_point", &Dtool_LMatrix3d_xform_point_1396, METH_O, (const char *)Dtool_LMatrix3d_xform_point_1396_comment},
  {"xformPoint", &Dtool_LMatrix3d_xform_point_1396, METH_O, (const char *)Dtool_LMatrix3d_xform_point_1396_comment},
  {"xform_vec", &Dtool_LMatrix3d_xform_vec_1397, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_1397_comment},
  {"xformVec", &Dtool_LMatrix3d_xform_vec_1397, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_1397_comment},
  {"xform_vec_general", &Dtool_LMatrix3d_xform_vec_general_1398, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_general_1398_comment},
  {"xformVecGeneral", &Dtool_LMatrix3d_xform_vec_general_1398, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_general_1398_comment},
  {"xform_in_place", &Dtool_LMatrix3d_xform_in_place_1399, METH_O, (const char *)Dtool_LMatrix3d_xform_in_place_1399_comment},
  {"xformInPlace", &Dtool_LMatrix3d_xform_in_place_1399, METH_O, (const char *)Dtool_LMatrix3d_xform_in_place_1399_comment},
  {"xform_point_in_place", &Dtool_LMatrix3d_xform_point_in_place_1400, METH_O, (const char *)Dtool_LMatrix3d_xform_point_in_place_1400_comment},
  {"xformPointInPlace", &Dtool_LMatrix3d_xform_point_in_place_1400, METH_O, (const char *)Dtool_LMatrix3d_xform_point_in_place_1400_comment},
  {"xform_vec_in_place", &Dtool_LMatrix3d_xform_vec_in_place_1401, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_in_place_1401_comment},
  {"xformVecInPlace", &Dtool_LMatrix3d_xform_vec_in_place_1401, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_in_place_1401_comment},
  {"xform_vec_general_in_place", &Dtool_LMatrix3d_xform_vec_general_in_place_1402, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_general_in_place_1402_comment},
  {"xformVecGeneralInPlace", &Dtool_LMatrix3d_xform_vec_general_in_place_1402, METH_O, (const char *)Dtool_LMatrix3d_xform_vec_general_in_place_1402_comment},
  {"multiply", (PyCFunction) &Dtool_LMatrix3d_multiply_1403, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_multiply_1403_comment},
  {"componentwise_mult", &Dtool_LMatrix3d_componentwise_mult_1410, METH_O, (const char *)Dtool_LMatrix3d_componentwise_mult_1410_comment},
  {"componentwiseMult", &Dtool_LMatrix3d_componentwise_mult_1410, METH_O, (const char *)Dtool_LMatrix3d_componentwise_mult_1410_comment},
  {"determinant", &Dtool_LMatrix3d_determinant_1411, METH_NOARGS, (const char *)Dtool_LMatrix3d_determinant_1411_comment},
  {"transpose_from", &Dtool_LMatrix3d_transpose_from_1412, METH_O, (const char *)Dtool_LMatrix3d_transpose_from_1412_comment},
  {"transposeFrom", &Dtool_LMatrix3d_transpose_from_1412, METH_O, (const char *)Dtool_LMatrix3d_transpose_from_1412_comment},
  {"transpose_in_place", &Dtool_LMatrix3d_transpose_in_place_1413, METH_NOARGS, (const char *)Dtool_LMatrix3d_transpose_in_place_1413_comment},
  {"transposeInPlace", &Dtool_LMatrix3d_transpose_in_place_1413, METH_NOARGS, (const char *)Dtool_LMatrix3d_transpose_in_place_1413_comment},
  {"invert_from", &Dtool_LMatrix3d_invert_from_1414, METH_O, (const char *)Dtool_LMatrix3d_invert_from_1414_comment},
  {"invertFrom", &Dtool_LMatrix3d_invert_from_1414, METH_O, (const char *)Dtool_LMatrix3d_invert_from_1414_comment},
  {"invert_in_place", &Dtool_LMatrix3d_invert_in_place_1415, METH_NOARGS, (const char *)Dtool_LMatrix3d_invert_in_place_1415_comment},
  {"invertInPlace", &Dtool_LMatrix3d_invert_in_place_1415, METH_NOARGS, (const char *)Dtool_LMatrix3d_invert_in_place_1415_comment},
  {"invert_transpose_from", &Dtool_LMatrix3d_invert_transpose_from_1416, METH_O, (const char *)Dtool_LMatrix3d_invert_transpose_from_1416_comment},
  {"invertTransposeFrom", &Dtool_LMatrix3d_invert_transpose_from_1416, METH_O, (const char *)Dtool_LMatrix3d_invert_transpose_from_1416_comment},
  {"ident_mat", &Dtool_LMatrix3d_ident_mat_1417, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3d_ident_mat_1417_comment},
  {"identMat", &Dtool_LMatrix3d_ident_mat_1417, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3d_ident_mat_1417_comment},
  {"set_translate_mat", &Dtool_LMatrix3d_set_translate_mat_1418, METH_O, (const char *)Dtool_LMatrix3d_set_translate_mat_1418_comment},
  {"setTranslateMat", &Dtool_LMatrix3d_set_translate_mat_1418, METH_O, (const char *)Dtool_LMatrix3d_set_translate_mat_1418_comment},
  {"set_rotate_mat", (PyCFunction) &Dtool_LMatrix3d_set_rotate_mat_1419, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_rotate_mat_1419_comment},
  {"setRotateMat", (PyCFunction) &Dtool_LMatrix3d_set_rotate_mat_1419, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_rotate_mat_1419_comment},
  {"set_scale_mat", &Dtool_LMatrix3d_set_scale_mat_1420, METH_O, (const char *)Dtool_LMatrix3d_set_scale_mat_1420_comment},
  {"setScaleMat", &Dtool_LMatrix3d_set_scale_mat_1420, METH_O, (const char *)Dtool_LMatrix3d_set_scale_mat_1420_comment},
  {"translate_mat", (PyCFunction) &Dtool_LMatrix3d_translate_mat_1421, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_translate_mat_1421_comment},
  {"translateMat", (PyCFunction) &Dtool_LMatrix3d_translate_mat_1421, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_translate_mat_1421_comment},
  {"rotate_mat", (PyCFunction) &Dtool_LMatrix3d_rotate_mat_1422, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_rotate_mat_1422_comment},
  {"rotateMat", (PyCFunction) &Dtool_LMatrix3d_rotate_mat_1422, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_rotate_mat_1422_comment},
  {"scale_mat", (PyCFunction) &Dtool_LMatrix3d_scale_mat_1423, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_scale_mat_1423_comment},
  {"scaleMat", (PyCFunction) &Dtool_LMatrix3d_scale_mat_1423, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_scale_mat_1423_comment},
  {"set_rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix3d_set_rotate_mat_normaxis_1424, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_rotate_mat_normaxis_1424_comment},
  {"setRotateMatNormaxis", (PyCFunction) &Dtool_LMatrix3d_set_rotate_mat_normaxis_1424, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_rotate_mat_normaxis_1424_comment},
  {"rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix3d_rotate_mat_normaxis_1425, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_rotate_mat_normaxis_1425_comment},
  {"rotateMatNormaxis", (PyCFunction) &Dtool_LMatrix3d_rotate_mat_normaxis_1425, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_rotate_mat_normaxis_1425_comment},
  {"set_shear_mat", (PyCFunction) &Dtool_LMatrix3d_set_shear_mat_1426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_shear_mat_1426_comment},
  {"setShearMat", (PyCFunction) &Dtool_LMatrix3d_set_shear_mat_1426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_shear_mat_1426_comment},
  {"shear_mat", (PyCFunction) &Dtool_LMatrix3d_shear_mat_1427, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_shear_mat_1427_comment},
  {"shearMat", (PyCFunction) &Dtool_LMatrix3d_shear_mat_1427, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_shear_mat_1427_comment},
  {"set_scale_shear_mat", (PyCFunction) &Dtool_LMatrix3d_set_scale_shear_mat_1428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_scale_shear_mat_1428_comment},
  {"setScaleShearMat", (PyCFunction) &Dtool_LMatrix3d_set_scale_shear_mat_1428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_set_scale_shear_mat_1428_comment},
  {"scale_shear_mat", (PyCFunction) &Dtool_LMatrix3d_scale_shear_mat_1429, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_scale_shear_mat_1429_comment},
  {"scaleShearMat", (PyCFunction) &Dtool_LMatrix3d_scale_shear_mat_1429, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_scale_shear_mat_1429_comment},
  {"convert_mat", (PyCFunction) &Dtool_LMatrix3d_convert_mat_1430, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_convert_mat_1430_comment},
  {"convertMat", (PyCFunction) &Dtool_LMatrix3d_convert_mat_1430, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix3d_convert_mat_1430_comment},
  {"almost_equal", (PyCFunction) &Dtool_LMatrix3d_almost_equal_1431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_almost_equal_1431_comment},
  {"almostEqual", (PyCFunction) &Dtool_LMatrix3d_almost_equal_1431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_almost_equal_1431_comment},
  {"output", &Dtool_LMatrix3d_output_1432, METH_O, (const char *)Dtool_LMatrix3d_output_1432_comment},
  {"write", (PyCFunction) &Dtool_LMatrix3d_write_1433, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix3d_write_1433_comment},
  {"write_datagram_fixed", &Dtool_LMatrix3d_write_datagram_fixed_1436, METH_O, (const char *)Dtool_LMatrix3d_write_datagram_fixed_1436_comment},
  {"writeDatagramFixed", &Dtool_LMatrix3d_write_datagram_fixed_1436, METH_O, (const char *)Dtool_LMatrix3d_write_datagram_fixed_1436_comment},
  {"read_datagram_fixed", &Dtool_LMatrix3d_read_datagram_fixed_1437, METH_O, (const char *)Dtool_LMatrix3d_read_datagram_fixed_1437_comment},
  {"readDatagramFixed", &Dtool_LMatrix3d_read_datagram_fixed_1437, METH_O, (const char *)Dtool_LMatrix3d_read_datagram_fixed_1437_comment},
  {"write_datagram", &Dtool_LMatrix3d_write_datagram_1438, METH_O, (const char *)Dtool_LMatrix3d_write_datagram_1438_comment},
  {"writeDatagram", &Dtool_LMatrix3d_write_datagram_1438, METH_O, (const char *)Dtool_LMatrix3d_write_datagram_1438_comment},
  {"read_datagram", &Dtool_LMatrix3d_read_datagram_1439, METH_O, (const char *)Dtool_LMatrix3d_read_datagram_1439_comment},
  {"readDatagram", &Dtool_LMatrix3d_read_datagram_1439, METH_O, (const char *)Dtool_LMatrix3d_read_datagram_1439_comment},
  {"get_class_type", &Dtool_LMatrix3d_get_class_type_1440, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3d_get_class_type_1440_comment},
  {"getClassType", &Dtool_LMatrix3d_get_class_type_1440, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix3d_get_class_type_1440_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_rows", (PyCFunction) &MakeSeq_LMatrix3d_get_rows, METH_NOARGS, NULL},
  { "getRows", (PyCFunction) &MakeSeq_LMatrix3d_get_rows, METH_NOARGS, NULL},
  {"get_cols", (PyCFunction) &MakeSeq_LMatrix3d_get_cols, METH_NOARGS, NULL},
  { "getCols", (PyCFunction) &MakeSeq_LMatrix3d_get_cols, METH_NOARGS, NULL},
  {"get_col2s", (PyCFunction) &MakeSeq_LMatrix3d_get_col2s, METH_NOARGS, NULL},
  { "getCol2s", (PyCFunction) &MakeSeq_LMatrix3d_get_col2s, METH_NOARGS, NULL},
  {"get_row2s", (PyCFunction) &MakeSeq_LMatrix3d_get_row2s, METH_NOARGS, NULL},
  { "getRow2s", (PyCFunction) &MakeSeq_LMatrix3d_get_row2s, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1405_nb_divide(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix3d LMatrix3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix3d *return_value = new LMatrix3d((*(const LMatrix3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1406_nb_inplace_add(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.__iadd__", "LMatrix3d");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3d.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1409_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3d &LMatrix3d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1408_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other)
      LMatrix3d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix3d &LMatrix3d::operator *=(double scalar)
      if (PyNumber_Check(arg)) {
        (*local_this).operator *=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other)
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: inline LMatrix3d &LMatrix3d::operator *=(double scalar)
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3d.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1407_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.__isub__", "LMatrix3d");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3d.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1409_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix3d &LMatrix3d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix3d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1404_nb_multiply(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3d *return_value = new LMatrix3d((*(const LMatrix3d*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  {
    // -2 inline LMatrix3d LMatrix3d::operator *(double scalar) const
    if (PyNumber_Check(arg)) {
      LMatrix3d *return_value = new LMatrix3d((*(const LMatrix3d*)local_this).operator *(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  {
    // -2 inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3d *return_value = new LMatrix3d((*(const LMatrix3d*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  // No coercion possible: inline LMatrix3d LMatrix3d::operator *(double scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1405_nb_true_divide(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix3d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix3d LMatrix3d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix3d *return_value = new LMatrix3d((*(const LMatrix3d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix3d_operator_1368_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix3d index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix3d::Row LMatrix3d::operator [](int i)
    LMatrix3d::Row *return_value = new LMatrix3d::Row((*local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d_Row, true, false);
  }

  {
    // -2 inline LMatrix3d::CRow LMatrix3d::operator [](int i) const
    LMatrix3d::CRow *return_value = new LMatrix3d::CRow((*(const LMatrix3d*)local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d_CRow, true, false);
  }

  // No coercion possible: inline LMatrix3d::Row LMatrix3d::operator [](int i)
  // No coercion possible: inline LMatrix3d::CRow LMatrix3d::operator [](int i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(const LMatrix3d self, index)\n"
      "__getitem__(LMatrix3d self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix3d_size_1369_sq_length(PyObject *self) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

/**
 * Python function wrapper for:
 * inline double LMatrix3d::operator ()(int row, int col) const
 */
static PyObject *Dtool_LMatrix3d_operator_1382(PyObject *self, PyObject *args, PyObject *kwds)
 {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LMatrix3d::operator ()(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:__call__", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*(const LMatrix3d*)local_this).operator ()((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(LMatrix3d self, int row, int col)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot tp_compare -> compare_to
//////////////////
static int Dtool_LMatrix3d_compare_to_1392_tp_compare(PyObject *self, PyObject *arg) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LMatrix3d::compare_to(LMatrix3d const &other) const
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LMatrix3d.compare_to", "LMatrix3d");
    return -1;
  }
  int return_value = (*(const LMatrix3d*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix3d self, const LMatrix3d other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LMatrix3d_get_hash_1393_tp_hash(PyObject *self) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix3d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LMatrix3d_repr_1434_tp_repr(PyObject *self) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LMatrix3d::__repr__(void) const
  std::string return_value = invoke_extension((const LMatrix3d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LMatrix3d self)\n");
  }
  return NULL;
}

//////////////////
//  A __str__ function
//     LMatrix3d
//////////////////
static PyObject *Dtool_Str_LMatrix3d(PyObject *self) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     LMatrix3d
//////////////////
static PyObject *Dtool_RichCompare_LMatrix3d(PyObject *self, PyObject *arg, int op) {
  LMatrix3d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix3d, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LMatrix3d::operator <(LMatrix3d const &other) const
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix3d*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LMatrix3d::operator ==(LMatrix3d const &other) const
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix3d*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LMatrix3d::operator !=(LMatrix3d const &other) const
      LMatrix3d arg_local;
      LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix3d*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LMatrix3d_compare_to_1392_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LMatrix3d[] = {
  {(char *)"rows", &Dtool_LMatrix3d_rows_Getter, NULL, NULL, NULL},
  {(char *)"cols", &Dtool_LMatrix3d_cols_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LMatrix3d = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LMatrix3d_operator_1404_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix3d_operator_1405_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LMatrix3d_operator_1406_nb_inplace_add,
  &Dtool_LMatrix3d_operator_1407_nb_inplace_subtract,
  &Dtool_LMatrix3d_operator_1408_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix3d_operator_1409_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix3d_operator_1405_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix3d_operator_1409_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix3d = {
  &Dtool_LMatrix3d_size_1369_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix3d_operator_1368_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LMatrix3d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix3d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LMatrix3d_compare_to_1392_tp_compare,
#endif
    &Dtool_LMatrix3d_repr_1434_tp_repr,
    &Dtool_NumberMethods_LMatrix3d,
    &Dtool_SequenceMethods_LMatrix3d,
    0, // tp_as_mapping
    &Dtool_LMatrix3d_get_hash_1393_tp_hash,
    &Dtool_LMatrix3d_operator_1382,
    &Dtool_Str_LMatrix3d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a 3-by-3 transform matrix.  It typically will represent either a\n"
    " * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix\n"
    " * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LMatrix3d,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix3d,
    0, // tp_members
    Dtool_Properties_LMatrix3d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_LMatrix3d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix3d,
  Dtool_UpcastInterface_LMatrix3d,
  Dtool_DowncastInterface_LMatrix3d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LMatrix3d,
};

static void Dtool_PyModuleClassInit_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix3d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LMatrix3d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LMatrix3d::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LMatrix3d::is_int));
    // Nested Object   LMatrix3d_Row;
    Dtool_PyModuleClassInit_LMatrix3d_Row(NULL);
    PyDict_SetItemString(dict, "Row", (PyObject *)&Dtool_LMatrix3d_Row);
    // Nested Object   LMatrix3d_CRow;
    Dtool_PyModuleClassInit_LMatrix3d_CRow(NULL);
    PyDict_SetItemString(dict, "CRow", (PyObject *)&Dtool_LMatrix3d_CRow);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix3d);
  }
}

/**
 * Python method tables for LMatrix4d_Row (Row)
 */
static PyMethodDef Dtool_Methods_LMatrix4d_Row[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d_Row slot sq_ass_item -> operator []
//////////////////
static int Dtool_LMatrix4d_Row_operator_1445_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  LMatrix4d::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d_Row, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4d_Row index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double &LMatrix4d::Row::operator [](int i)
      if (PyNumber_Check(arg)) {
        (*local_this).operator [](index) = PyFloat_AsDouble(arg);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call Row.__getitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__getitem__(const Row self, index, double assign_val)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d_Row slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix4d_Row_operator_1445_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix4d::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d_Row, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4d_Row index out of range");
    return NULL;
  }
  // 1-inline double LMatrix4d::Row::operator [](int i) const
  double return_value = (*(const LMatrix4d::Row*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Row self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d_Row slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix4d_Row_size_1446_sq_length(PyObject *self) {
  LMatrix4d::Row *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d_Row, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix4d_Row = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix4d_Row = {
  &Dtool_LMatrix4d_Row_size_1446_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix4d_Row_operator_1445_sq_item,
  0, // sq_slice
  &Dtool_LMatrix4d_Row_operator_1445_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix4d_Row = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Row",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix4d_Row,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix4d_Row,
    &Dtool_SequenceMethods_LMatrix4d_Row,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// These helper classes are used to support two-level operator [].",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix4d_Row,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix4d_Row,
    PyType_GenericAlloc,
    Dtool_new_LMatrix4d_Row,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix4d_Row,
  Dtool_UpcastInterface_LMatrix4d_Row,
  Dtool_DowncastInterface_LMatrix4d_Row,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix4d_Row(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix4d_Row._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix4d_Row._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix4d_Row) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix4d_Row)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix4d_Row);
  }
}

/**
 * Python method tables for LMatrix4d_CRow (CRow)
 */
static PyMethodDef Dtool_Methods_LMatrix4d_CRow[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d_CRow slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix4d_CRow_operator_1450_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix4d::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d_CRow, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4d_CRow index out of range");
    return NULL;
  }
  // 1-inline double LMatrix4d::CRow::operator [](int i) const
  double return_value = (*(const LMatrix4d::CRow*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(CRow self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d_CRow slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix4d_CRow_size_1451_sq_length(PyObject *self) {
  LMatrix4d::CRow *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d_CRow, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_LMatrix4d_CRow = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix4d_CRow = {
  &Dtool_LMatrix4d_CRow_size_1451_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix4d_CRow_operator_1450_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix4d_CRow = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.CRow",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix4d_CRow,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LMatrix4d_CRow,
    &Dtool_SequenceMethods_LMatrix4d_CRow,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix4d_CRow,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix4d_CRow,
    PyType_GenericAlloc,
    Dtool_new_LMatrix4d_CRow,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix4d_CRow,
  Dtool_UpcastInterface_LMatrix4d_CRow,
  Dtool_DowncastInterface_LMatrix4d_CRow,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LMatrix4d_CRow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix4d_CRow._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_LMatrix4d_CRow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix4d_CRow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix4d_CRow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix4d_CRow);
  }
}

/**
 * Python method tables for LMatrix4d (LMatrix4d)
 */
static PyMethodDef Dtool_Methods_LMatrix4d[] = {
  {"assign", &Dtool_LMatrix4d_operator_1455, METH_O, (const char *)Dtool_LMatrix4d_operator_1455_comment},
  {"__reduce__", &Dtool_LMatrix4d_reduce_1459, METH_NOARGS, (const char *)Dtool_LMatrix4d_reduce_1459_comment},
  {"fill", &Dtool_LMatrix4d_fill_1460, METH_O, (const char *)Dtool_LMatrix4d_fill_1460_comment},
  {"set", (PyCFunction) &Dtool_LMatrix4d_set_1461, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_1461_comment},
  {"set_upper_3", &Dtool_LMatrix4d_set_upper_3_1462, METH_O, (const char *)Dtool_LMatrix4d_set_upper_3_1462_comment},
  {"setUpper3", &Dtool_LMatrix4d_set_upper_3_1462, METH_O, (const char *)Dtool_LMatrix4d_set_upper_3_1462_comment},
  {"get_upper_3", &Dtool_LMatrix4d_get_upper_3_1463, METH_NOARGS, (const char *)Dtool_LMatrix4d_get_upper_3_1463_comment},
  {"getUpper3", &Dtool_LMatrix4d_get_upper_3_1463, METH_NOARGS, (const char *)Dtool_LMatrix4d_get_upper_3_1463_comment},
  {"set_row", (PyCFunction) &Dtool_LMatrix4d_set_row_1466, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_row_1466_comment},
  {"setRow", (PyCFunction) &Dtool_LMatrix4d_set_row_1466, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_row_1466_comment},
  {"set_col", (PyCFunction) &Dtool_LMatrix4d_set_col_1467, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_col_1467_comment},
  {"setCol", (PyCFunction) &Dtool_LMatrix4d_set_col_1467, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_col_1467_comment},
  {"get_row", (PyCFunction) &Dtool_LMatrix4d_get_row_1468, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_get_row_1468_comment},
  {"getRow", (PyCFunction) &Dtool_LMatrix4d_get_row_1468, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_get_row_1468_comment},
  {"get_col", &Dtool_LMatrix4d_get_col_1469, METH_O, (const char *)Dtool_LMatrix4d_get_col_1469_comment},
  {"getCol", &Dtool_LMatrix4d_get_col_1469, METH_O, (const char *)Dtool_LMatrix4d_get_col_1469_comment},
  {"get_row3", (PyCFunction) &Dtool_LMatrix4d_get_row3_1470, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_get_row3_1470_comment},
  {"getRow3", (PyCFunction) &Dtool_LMatrix4d_get_row3_1470, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_get_row3_1470_comment},
  {"get_col3", &Dtool_LMatrix4d_get_col3_1476, METH_O, (const char *)Dtool_LMatrix4d_get_col3_1476_comment},
  {"getCol3", &Dtool_LMatrix4d_get_col3_1476, METH_O, (const char *)Dtool_LMatrix4d_get_col3_1476_comment},
  {"is_nan", &Dtool_LMatrix4d_is_nan_1478, METH_NOARGS, (const char *)Dtool_LMatrix4d_is_nan_1478_comment},
  {"isNan", &Dtool_LMatrix4d_is_nan_1478, METH_NOARGS, (const char *)Dtool_LMatrix4d_is_nan_1478_comment},
  {"is_identity", &Dtool_LMatrix4d_is_identity_1479, METH_NOARGS, (const char *)Dtool_LMatrix4d_is_identity_1479_comment},
  {"isIdentity", &Dtool_LMatrix4d_is_identity_1479, METH_NOARGS, (const char *)Dtool_LMatrix4d_is_identity_1479_comment},
  {"get_cell", (PyCFunction) &Dtool_LMatrix4d_get_cell_1480, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_get_cell_1480_comment},
  {"getCell", (PyCFunction) &Dtool_LMatrix4d_get_cell_1480, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_get_cell_1480_comment},
  {"set_cell", (PyCFunction) &Dtool_LMatrix4d_set_cell_1481, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_cell_1481_comment},
  {"setCell", (PyCFunction) &Dtool_LMatrix4d_set_cell_1481, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_cell_1481_comment},
  {"get_num_components", &Dtool_LMatrix4d_get_num_components_1483, METH_NOARGS, (const char *)Dtool_LMatrix4d_get_num_components_1483_comment},
  {"getNumComponents", &Dtool_LMatrix4d_get_num_components_1483, METH_NOARGS, (const char *)Dtool_LMatrix4d_get_num_components_1483_comment},
  {"compare_to", &Dtool_LMatrix4d_compare_to_1489, METH_VARARGS, (const char *)Dtool_LMatrix4d_compare_to_1489_comment},
  {"compareTo", &Dtool_LMatrix4d_compare_to_1489, METH_VARARGS, (const char *)Dtool_LMatrix4d_compare_to_1489_comment},
  {"get_hash", &Dtool_LMatrix4d_get_hash_1490, METH_VARARGS, (const char *)Dtool_LMatrix4d_get_hash_1490_comment},
  {"getHash", &Dtool_LMatrix4d_get_hash_1490, METH_VARARGS, (const char *)Dtool_LMatrix4d_get_hash_1490_comment},
  {"add_hash", (PyCFunction) &Dtool_LMatrix4d_add_hash_1491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_add_hash_1491_comment},
  {"addHash", (PyCFunction) &Dtool_LMatrix4d_add_hash_1491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_add_hash_1491_comment},
  {"xform", &Dtool_LMatrix4d_xform_1492, METH_O, (const char *)Dtool_LMatrix4d_xform_1492_comment},
  {"xform_point", &Dtool_LMatrix4d_xform_point_1493, METH_O, (const char *)Dtool_LMatrix4d_xform_point_1493_comment},
  {"xformPoint", &Dtool_LMatrix4d_xform_point_1493, METH_O, (const char *)Dtool_LMatrix4d_xform_point_1493_comment},
  {"xform_point_general", &Dtool_LMatrix4d_xform_point_general_1494, METH_O, (const char *)Dtool_LMatrix4d_xform_point_general_1494_comment},
  {"xformPointGeneral", &Dtool_LMatrix4d_xform_point_general_1494, METH_O, (const char *)Dtool_LMatrix4d_xform_point_general_1494_comment},
  {"xform_vec", &Dtool_LMatrix4d_xform_vec_1495, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_1495_comment},
  {"xformVec", &Dtool_LMatrix4d_xform_vec_1495, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_1495_comment},
  {"xform_vec_general", &Dtool_LMatrix4d_xform_vec_general_1496, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_general_1496_comment},
  {"xformVecGeneral", &Dtool_LMatrix4d_xform_vec_general_1496, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_general_1496_comment},
  {"xform_in_place", &Dtool_LMatrix4d_xform_in_place_1497, METH_O, (const char *)Dtool_LMatrix4d_xform_in_place_1497_comment},
  {"xformInPlace", &Dtool_LMatrix4d_xform_in_place_1497, METH_O, (const char *)Dtool_LMatrix4d_xform_in_place_1497_comment},
  {"xform_point_in_place", &Dtool_LMatrix4d_xform_point_in_place_1498, METH_O, (const char *)Dtool_LMatrix4d_xform_point_in_place_1498_comment},
  {"xformPointInPlace", &Dtool_LMatrix4d_xform_point_in_place_1498, METH_O, (const char *)Dtool_LMatrix4d_xform_point_in_place_1498_comment},
  {"xform_point_general_in_place", &Dtool_LMatrix4d_xform_point_general_in_place_1499, METH_O, (const char *)Dtool_LMatrix4d_xform_point_general_in_place_1499_comment},
  {"xformPointGeneralInPlace", &Dtool_LMatrix4d_xform_point_general_in_place_1499, METH_O, (const char *)Dtool_LMatrix4d_xform_point_general_in_place_1499_comment},
  {"xform_vec_in_place", &Dtool_LMatrix4d_xform_vec_in_place_1500, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_in_place_1500_comment},
  {"xformVecInPlace", &Dtool_LMatrix4d_xform_vec_in_place_1500, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_in_place_1500_comment},
  {"xform_vec_general_in_place", &Dtool_LMatrix4d_xform_vec_general_in_place_1501, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_general_in_place_1501_comment},
  {"xformVecGeneralInPlace", &Dtool_LMatrix4d_xform_vec_general_in_place_1501, METH_O, (const char *)Dtool_LMatrix4d_xform_vec_general_in_place_1501_comment},
  {"multiply", (PyCFunction) &Dtool_LMatrix4d_multiply_1502, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_multiply_1502_comment},
  {"componentwise_mult", &Dtool_LMatrix4d_componentwise_mult_1509, METH_O, (const char *)Dtool_LMatrix4d_componentwise_mult_1509_comment},
  {"componentwiseMult", &Dtool_LMatrix4d_componentwise_mult_1509, METH_O, (const char *)Dtool_LMatrix4d_componentwise_mult_1509_comment},
  {"transpose_from", &Dtool_LMatrix4d_transpose_from_1510, METH_O, (const char *)Dtool_LMatrix4d_transpose_from_1510_comment},
  {"transposeFrom", &Dtool_LMatrix4d_transpose_from_1510, METH_O, (const char *)Dtool_LMatrix4d_transpose_from_1510_comment},
  {"transpose_in_place", &Dtool_LMatrix4d_transpose_in_place_1511, METH_NOARGS, (const char *)Dtool_LMatrix4d_transpose_in_place_1511_comment},
  {"transposeInPlace", &Dtool_LMatrix4d_transpose_in_place_1511, METH_NOARGS, (const char *)Dtool_LMatrix4d_transpose_in_place_1511_comment},
  {"invert_from", &Dtool_LMatrix4d_invert_from_1512, METH_O, (const char *)Dtool_LMatrix4d_invert_from_1512_comment},
  {"invertFrom", &Dtool_LMatrix4d_invert_from_1512, METH_O, (const char *)Dtool_LMatrix4d_invert_from_1512_comment},
  {"invert_affine_from", &Dtool_LMatrix4d_invert_affine_from_1513, METH_O, (const char *)Dtool_LMatrix4d_invert_affine_from_1513_comment},
  {"invertAffineFrom", &Dtool_LMatrix4d_invert_affine_from_1513, METH_O, (const char *)Dtool_LMatrix4d_invert_affine_from_1513_comment},
  {"invert_in_place", &Dtool_LMatrix4d_invert_in_place_1514, METH_NOARGS, (const char *)Dtool_LMatrix4d_invert_in_place_1514_comment},
  {"invertInPlace", &Dtool_LMatrix4d_invert_in_place_1514, METH_NOARGS, (const char *)Dtool_LMatrix4d_invert_in_place_1514_comment},
  {"accumulate", (PyCFunction) &Dtool_LMatrix4d_accumulate_1515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_accumulate_1515_comment},
  {"ident_mat", &Dtool_LMatrix4d_ident_mat_1516, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_ident_mat_1516_comment},
  {"identMat", &Dtool_LMatrix4d_ident_mat_1516, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_ident_mat_1516_comment},
  {"ones_mat", &Dtool_LMatrix4d_ones_mat_1517, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_ones_mat_1517_comment},
  {"onesMat", &Dtool_LMatrix4d_ones_mat_1517, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_ones_mat_1517_comment},
  {"zeros_mat", &Dtool_LMatrix4d_zeros_mat_1518, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_zeros_mat_1518_comment},
  {"zerosMat", &Dtool_LMatrix4d_zeros_mat_1518, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_zeros_mat_1518_comment},
  {"set_translate_mat", &Dtool_LMatrix4d_set_translate_mat_1519, METH_O, (const char *)Dtool_LMatrix4d_set_translate_mat_1519_comment},
  {"setTranslateMat", &Dtool_LMatrix4d_set_translate_mat_1519, METH_O, (const char *)Dtool_LMatrix4d_set_translate_mat_1519_comment},
  {"set_rotate_mat", (PyCFunction) &Dtool_LMatrix4d_set_rotate_mat_1520, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_rotate_mat_1520_comment},
  {"setRotateMat", (PyCFunction) &Dtool_LMatrix4d_set_rotate_mat_1520, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_rotate_mat_1520_comment},
  {"set_rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix4d_set_rotate_mat_normaxis_1521, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_rotate_mat_normaxis_1521_comment},
  {"setRotateMatNormaxis", (PyCFunction) &Dtool_LMatrix4d_set_rotate_mat_normaxis_1521, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_rotate_mat_normaxis_1521_comment},
  {"set_scale_mat", &Dtool_LMatrix4d_set_scale_mat_1522, METH_O, (const char *)Dtool_LMatrix4d_set_scale_mat_1522_comment},
  {"setScaleMat", &Dtool_LMatrix4d_set_scale_mat_1522, METH_O, (const char *)Dtool_LMatrix4d_set_scale_mat_1522_comment},
  {"set_shear_mat", (PyCFunction) &Dtool_LMatrix4d_set_shear_mat_1523, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_shear_mat_1523_comment},
  {"setShearMat", (PyCFunction) &Dtool_LMatrix4d_set_shear_mat_1523, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_shear_mat_1523_comment},
  {"set_scale_shear_mat", (PyCFunction) &Dtool_LMatrix4d_set_scale_shear_mat_1524, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_scale_shear_mat_1524_comment},
  {"setScaleShearMat", (PyCFunction) &Dtool_LMatrix4d_set_scale_shear_mat_1524, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_set_scale_shear_mat_1524_comment},
  {"translate_mat", (PyCFunction) &Dtool_LMatrix4d_translate_mat_1525, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_translate_mat_1525_comment},
  {"translateMat", (PyCFunction) &Dtool_LMatrix4d_translate_mat_1525, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_translate_mat_1525_comment},
  {"rotate_mat", (PyCFunction) &Dtool_LMatrix4d_rotate_mat_1526, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_rotate_mat_1526_comment},
  {"rotateMat", (PyCFunction) &Dtool_LMatrix4d_rotate_mat_1526, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_rotate_mat_1526_comment},
  {"rotate_mat_normaxis", (PyCFunction) &Dtool_LMatrix4d_rotate_mat_normaxis_1527, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_rotate_mat_normaxis_1527_comment},
  {"rotateMatNormaxis", (PyCFunction) &Dtool_LMatrix4d_rotate_mat_normaxis_1527, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_rotate_mat_normaxis_1527_comment},
  {"scale_mat", (PyCFunction) &Dtool_LMatrix4d_scale_mat_1528, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_scale_mat_1528_comment},
  {"scaleMat", (PyCFunction) &Dtool_LMatrix4d_scale_mat_1528, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_scale_mat_1528_comment},
  {"shear_mat", (PyCFunction) &Dtool_LMatrix4d_shear_mat_1529, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_shear_mat_1529_comment},
  {"shearMat", (PyCFunction) &Dtool_LMatrix4d_shear_mat_1529, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_shear_mat_1529_comment},
  {"scale_shear_mat", (PyCFunction) &Dtool_LMatrix4d_scale_shear_mat_1530, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_scale_shear_mat_1530_comment},
  {"scaleShearMat", (PyCFunction) &Dtool_LMatrix4d_scale_shear_mat_1530, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_scale_shear_mat_1530_comment},
  {"y_to_z_up_mat", &Dtool_LMatrix4d_y_to_z_up_mat_1531, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_y_to_z_up_mat_1531_comment},
  {"yToZUpMat", &Dtool_LMatrix4d_y_to_z_up_mat_1531, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_y_to_z_up_mat_1531_comment},
  {"z_to_y_up_mat", &Dtool_LMatrix4d_z_to_y_up_mat_1532, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_z_to_y_up_mat_1532_comment},
  {"zToYUpMat", &Dtool_LMatrix4d_z_to_y_up_mat_1532, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_z_to_y_up_mat_1532_comment},
  {"convert_mat", (PyCFunction) &Dtool_LMatrix4d_convert_mat_1533, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_convert_mat_1533_comment},
  {"convertMat", (PyCFunction) &Dtool_LMatrix4d_convert_mat_1533, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LMatrix4d_convert_mat_1533_comment},
  {"almost_equal", (PyCFunction) &Dtool_LMatrix4d_almost_equal_1534, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_almost_equal_1534_comment},
  {"almostEqual", (PyCFunction) &Dtool_LMatrix4d_almost_equal_1534, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_almost_equal_1534_comment},
  {"output", &Dtool_LMatrix4d_output_1535, METH_O, (const char *)Dtool_LMatrix4d_output_1535_comment},
  {"write", (PyCFunction) &Dtool_LMatrix4d_write_1536, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LMatrix4d_write_1536_comment},
  {"write_datagram_fixed", &Dtool_LMatrix4d_write_datagram_fixed_1539, METH_O, (const char *)Dtool_LMatrix4d_write_datagram_fixed_1539_comment},
  {"writeDatagramFixed", &Dtool_LMatrix4d_write_datagram_fixed_1539, METH_O, (const char *)Dtool_LMatrix4d_write_datagram_fixed_1539_comment},
  {"read_datagram_fixed", &Dtool_LMatrix4d_read_datagram_fixed_1540, METH_O, (const char *)Dtool_LMatrix4d_read_datagram_fixed_1540_comment},
  {"readDatagramFixed", &Dtool_LMatrix4d_read_datagram_fixed_1540, METH_O, (const char *)Dtool_LMatrix4d_read_datagram_fixed_1540_comment},
  {"write_datagram", &Dtool_LMatrix4d_write_datagram_1541, METH_O, (const char *)Dtool_LMatrix4d_write_datagram_1541_comment},
  {"writeDatagram", &Dtool_LMatrix4d_write_datagram_1541, METH_O, (const char *)Dtool_LMatrix4d_write_datagram_1541_comment},
  {"read_datagram", &Dtool_LMatrix4d_read_datagram_1542, METH_O, (const char *)Dtool_LMatrix4d_read_datagram_1542_comment},
  {"readDatagram", &Dtool_LMatrix4d_read_datagram_1542, METH_O, (const char *)Dtool_LMatrix4d_read_datagram_1542_comment},
  {"get_class_type", &Dtool_LMatrix4d_get_class_type_1543, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_get_class_type_1543_comment},
  {"getClassType", &Dtool_LMatrix4d_get_class_type_1543, METH_NOARGS | METH_STATIC, (const char *)Dtool_LMatrix4d_get_class_type_1543_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_rows", (PyCFunction) &MakeSeq_LMatrix4d_get_rows, METH_NOARGS, NULL},
  { "getRows", (PyCFunction) &MakeSeq_LMatrix4d_get_rows, METH_NOARGS, NULL},
  {"get_cols", (PyCFunction) &MakeSeq_LMatrix4d_get_cols, METH_NOARGS, NULL},
  { "getCols", (PyCFunction) &MakeSeq_LMatrix4d_get_cols, METH_NOARGS, NULL},
  {"get_row3s", (PyCFunction) &MakeSeq_LMatrix4d_get_row3s, METH_NOARGS, NULL},
  { "getRow3s", (PyCFunction) &MakeSeq_LMatrix4d_get_row3s, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1504_nb_divide(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix4d LMatrix4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix4d *return_value = new LMatrix4d((*(const LMatrix4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1505_nb_inplace_add(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.__iadd__", "LMatrix4d");
      return NULL;
    }
    (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4d.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_inplace_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1508_nb_inplace_divide(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4d &LMatrix4d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1507_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    {
      // -2 inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other)
      LMatrix4d const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
      if (arg_this != NULL) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix4d &LMatrix4d::operator *=(double scalar)
      if (PyNumber_Check(arg)) {
        (*local_this).operator *=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    {
      // -2 inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other)
      LMatrix4d arg_local;
      LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
      if ((arg_this != NULL)) {
        (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        Py_INCREF(self);
        return self;
      }
    }

    // No coercion possible: inline LMatrix4d &LMatrix4d::operator *=(double scalar)
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4d.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1506_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.__isub__", "LMatrix4d");
      return NULL;
    }
    (*local_this).operator -=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4d.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_inplace_true_divide -> operator /=
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1508_nb_inplace_true_divide(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LMatrix4d &LMatrix4d::operator /=(double scalar)
    if (PyNumber_Check(arg)) {
      (*local_this).operator /=(PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LMatrix4d.__idiv__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1503_nb_multiply(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4d *return_value = new LMatrix4d((*(const LMatrix4d*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LMatrix4d LMatrix4d::operator *(double scalar) const
    if (PyNumber_Check(arg)) {
      LMatrix4d *return_value = new LMatrix4d((*(const LMatrix4d*)local_this).operator *(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4d *return_value = new LMatrix4d((*(const LMatrix4d*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  // No coercion possible: inline LMatrix4d LMatrix4d::operator *(double scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1504_nb_true_divide(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LMatrix4d, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LMatrix4d LMatrix4d::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LMatrix4d *return_value = new LMatrix4d((*(const LMatrix4d*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot sq_item -> operator []
//////////////////
static PyObject *Dtool_LMatrix4d_operator_1464_sq_item(PyObject *self, Py_ssize_t index) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "LMatrix4d index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix4d::Row LMatrix4d::operator [](int i)
    LMatrix4d::Row *return_value = new LMatrix4d::Row((*local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d_Row, true, false);
  }

  {
    // -2 inline LMatrix4d::CRow LMatrix4d::operator [](int i) const
    LMatrix4d::CRow *return_value = new LMatrix4d::CRow((*(const LMatrix4d*)local_this).operator [](index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d_CRow, true, false);
  }

  // No coercion possible: inline LMatrix4d::Row LMatrix4d::operator [](int i)
  // No coercion possible: inline LMatrix4d::CRow LMatrix4d::operator [](int i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(const LMatrix4d self, index)\n"
      "__getitem__(LMatrix4d self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_LMatrix4d_size_1465_sq_length(PyObject *self) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

/**
 * Python function wrapper for:
 * inline double LMatrix4d::operator ()(int row, int col) const
 */
static PyObject *Dtool_LMatrix4d_operator_1477(PyObject *self, PyObject *args, PyObject *kwds)
 {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double LMatrix4d::operator ()(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:__call__", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*(const LMatrix4d*)local_this).operator ()((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(LMatrix4d self, int row, int col)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot tp_compare -> compare_to
//////////////////
static int Dtool_LMatrix4d_compare_to_1489_tp_compare(PyObject *self, PyObject *arg) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int LMatrix4d::compare_to(LMatrix4d const &other) const
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LMatrix4d.compare_to", "LMatrix4d");
    return -1;
  }
  int return_value = (*(const LMatrix4d*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(LMatrix4d self, const LMatrix4d other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_LMatrix4d_get_hash_1490_tp_hash(PyObject *self) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LMatrix4d slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_LMatrix4d_repr_1537_tp_repr(PyObject *self) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string LMatrix4d::__repr__(void) const
  std::string return_value = invoke_extension((const LMatrix4d*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(LMatrix4d self)\n");
  }
  return NULL;
}

//////////////////
//  A __str__ function
//     LMatrix4d
//////////////////
static PyObject *Dtool_Str_LMatrix4d(PyObject *self) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     LMatrix4d
//////////////////
static PyObject *Dtool_RichCompare_LMatrix4d(PyObject *self, PyObject *arg, int op) {
  LMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LMatrix4d, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-inline bool LMatrix4d::operator <(LMatrix4d const &other) const
      LMatrix4d arg_local;
      LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix4d*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_EQ:
    {
      // 1-inline bool LMatrix4d::operator ==(LMatrix4d const &other) const
      LMatrix4d arg_local;
      LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix4d*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool LMatrix4d::operator !=(LMatrix4d const &other) const
      LMatrix4d arg_local;
      LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const LMatrix4d*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_LMatrix4d_compare_to_1489_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_LMatrix4d[] = {
  {(char *)"rows", &Dtool_LMatrix4d_rows_Getter, NULL, NULL, NULL},
  {(char *)"cols", &Dtool_LMatrix4d_cols_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_LMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LMatrix4d_operator_1503_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix4d_operator_1504_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_LMatrix4d_operator_1505_nb_inplace_add,
  &Dtool_LMatrix4d_operator_1506_nb_inplace_subtract,
  &Dtool_LMatrix4d_operator_1507_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LMatrix4d_operator_1508_nb_inplace_divide,
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix4d_operator_1504_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LMatrix4d_operator_1508_nb_inplace_true_divide,
#else
  0,
#endif
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LMatrix4d = {
  &Dtool_LMatrix4d_size_1465_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_LMatrix4d_operator_1464_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_LMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_LMatrix4d_compare_to_1489_tp_compare,
#endif
    &Dtool_LMatrix4d_repr_1537_tp_repr,
    &Dtool_NumberMethods_LMatrix4d,
    &Dtool_SequenceMethods_LMatrix4d,
    0, // tp_as_mapping
    &Dtool_LMatrix4d_get_hash_1490_tp_hash,
    &Dtool_LMatrix4d_operator_1477,
    &Dtool_Str_LMatrix4d,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a 4-by-4 transform matrix.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_LMatrix4d,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LMatrix4d,
    0, // tp_members
    Dtool_Properties_LMatrix4d,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_LMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LMatrix4d,
  Dtool_UpcastInterface_LMatrix4d,
  Dtool_DowncastInterface_LMatrix4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LMatrix4d,
};

static void Dtool_PyModuleClassInit_LMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_LMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LMatrix4d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(LMatrix4d::num_components));
    PyDict_SetItemString(dict, "is_int", Dtool_WrapValue(LMatrix4d::is_int));
    // Nested Object   LMatrix4d_Row;
    Dtool_PyModuleClassInit_LMatrix4d_Row(NULL);
    PyDict_SetItemString(dict, "Row", (PyObject *)&Dtool_LMatrix4d_Row);
    // Nested Object   LMatrix4d_CRow;
    Dtool_PyModuleClassInit_LMatrix4d_CRow(NULL);
    PyDict_SetItemString(dict, "CRow", (PyObject *)&Dtool_LMatrix4d_CRow);
    if (PyType_Ready((PyTypeObject *)&Dtool_LMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LMatrix4d);
  }
}

/**
 * Python method tables for UnalignedLMatrix4d (UnalignedLMatrix4d)
 */
static PyMethodDef Dtool_Methods_UnalignedLMatrix4d[] = {
  {"assign", &Dtool_UnalignedLMatrix4d_operator_1548, METH_O, (const char *)Dtool_UnalignedLMatrix4d_operator_1548_comment},
  {"set", (PyCFunction) &Dtool_UnalignedLMatrix4d_set_1549, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_UnalignedLMatrix4d_set_1549_comment},
  {"get_num_components", &Dtool_UnalignedLMatrix4d_get_num_components_1552, METH_NOARGS, (const char *)Dtool_UnalignedLMatrix4d_get_num_components_1552_comment},
  {"getNumComponents", &Dtool_UnalignedLMatrix4d_get_num_components_1552, METH_NOARGS, (const char *)Dtool_UnalignedLMatrix4d_get_num_components_1552_comment},
  {"get_class_type", &Dtool_UnalignedLMatrix4d_get_class_type_1553, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLMatrix4d_get_class_type_1553_comment},
  {"getClassType", &Dtool_UnalignedLMatrix4d_get_class_type_1553, METH_NOARGS | METH_STATIC, (const char *)Dtool_UnalignedLMatrix4d_get_class_type_1553_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

/**
 * Python function wrapper for:
 * inline double UnalignedLMatrix4d::operator ()(int row, int col) const
 */
static PyObject *Dtool_UnalignedLMatrix4d_operator_1550(PyObject *self, PyObject *args, PyObject *kwds)
 {
  UnalignedLMatrix4d *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UnalignedLMatrix4d, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double UnalignedLMatrix4d::operator ()(int row, int col) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"row", "col", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:__call__", (char **)keyword_list, &param1, &param2)) {
    double return_value = (*(const UnalignedLMatrix4d*)local_this).operator ()((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(UnalignedLMatrix4d self, int row, int col)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_UnalignedLMatrix4d = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_UnalignedLMatrix4d = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.UnalignedLMatrix4d",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_UnalignedLMatrix4d,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_UnalignedLMatrix4d,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    &Dtool_UnalignedLMatrix4d_operator_1550,
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an \"unaligned\" LMatrix4.  It has no functionality other than to\n"
    " * store numbers, and it will pack them in as tightly as possible, avoiding\n"
    " * any SSE2 alignment requirements shared by the primary LMatrix4 class.\n"
    " *\n"
    " * Use it only when you need to pack numbers tightly without respect to\n"
    " * alignment, and then copy it to a proper LMatrix4 to get actual use from it.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_UnalignedLMatrix4d,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_UnalignedLMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_UnalignedLMatrix4d,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UnalignedLMatrix4d,
  Dtool_UpcastInterface_UnalignedLMatrix4d,
  Dtool_DowncastInterface_UnalignedLMatrix4d,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_UnalignedLMatrix4d,
};

static void Dtool_PyModuleClassInit_UnalignedLMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UnalignedLMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_UnalignedLMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum UnalignedLMatrix4d::;
    PyDict_SetItemString(dict, "num_components", Dtool_WrapValue(UnalignedLMatrix4d::num_components));
    if (PyType_Ready((PyTypeObject *)&Dtool_UnalignedLMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UnalignedLMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UnalignedLMatrix4d);
  }
}

/**
 * Python method tables for LQuaternionf (LQuaternionf)
 */
static PyMethodDef Dtool_Methods_LQuaternionf[] = {
  {"pure_imaginary", &Dtool_LQuaternionf_pure_imaginary_1565, METH_O | METH_STATIC, (const char *)Dtool_LQuaternionf_pure_imaginary_1565_comment},
  {"pureImaginary", &Dtool_LQuaternionf_pure_imaginary_1565, METH_O | METH_STATIC, (const char *)Dtool_LQuaternionf_pure_imaginary_1565_comment},
  {"conjugate", &Dtool_LQuaternionf_conjugate_1566, METH_NOARGS, (const char *)Dtool_LQuaternionf_conjugate_1566_comment},
  {"xform", &Dtool_LQuaternionf_xform_1567, METH_O, (const char *)Dtool_LQuaternionf_xform_1567_comment},
  {"multiply", &Dtool_LQuaternionf_multiply_1568, METH_O, (const char *)Dtool_LQuaternionf_multiply_1568_comment},
  {"angle_rad", &Dtool_LQuaternionf_angle_rad_1572, METH_O, (const char *)Dtool_LQuaternionf_angle_rad_1572_comment},
  {"angleRad", &Dtool_LQuaternionf_angle_rad_1572, METH_O, (const char *)Dtool_LQuaternionf_angle_rad_1572_comment},
  {"angle_deg", &Dtool_LQuaternionf_angle_deg_1573, METH_O, (const char *)Dtool_LQuaternionf_angle_deg_1573_comment},
  {"angleDeg", &Dtool_LQuaternionf_angle_deg_1573, METH_O, (const char *)Dtool_LQuaternionf_angle_deg_1573_comment},
  {"almost_equal", (PyCFunction) &Dtool_LQuaternionf_almost_equal_1577, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_almost_equal_1577_comment},
  {"almostEqual", (PyCFunction) &Dtool_LQuaternionf_almost_equal_1577, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_almost_equal_1577_comment},
  {"is_same_direction", &Dtool_LQuaternionf_is_same_direction_1578, METH_O, (const char *)Dtool_LQuaternionf_is_same_direction_1578_comment},
  {"isSameDirection", &Dtool_LQuaternionf_is_same_direction_1578, METH_O, (const char *)Dtool_LQuaternionf_is_same_direction_1578_comment},
  {"almost_same_direction", (PyCFunction) &Dtool_LQuaternionf_almost_same_direction_1579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_almost_same_direction_1579_comment},
  {"almostSameDirection", (PyCFunction) &Dtool_LQuaternionf_almost_same_direction_1579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_almost_same_direction_1579_comment},
  {"output", &Dtool_LQuaternionf_output_1580, METH_O, (const char *)Dtool_LQuaternionf_output_1580_comment},
  {"extract_to_matrix", &Dtool_LQuaternionf_extract_to_matrix_1581, METH_O, (const char *)Dtool_LQuaternionf_extract_to_matrix_1581_comment},
  {"extractToMatrix", &Dtool_LQuaternionf_extract_to_matrix_1581, METH_O, (const char *)Dtool_LQuaternionf_extract_to_matrix_1581_comment},
  {"set_from_matrix", &Dtool_LQuaternionf_set_from_matrix_1582, METH_O, (const char *)Dtool_LQuaternionf_set_from_matrix_1582_comment},
  {"setFromMatrix", &Dtool_LQuaternionf_set_from_matrix_1582, METH_O, (const char *)Dtool_LQuaternionf_set_from_matrix_1582_comment},
  {"set_hpr", (PyCFunction) &Dtool_LQuaternionf_set_hpr_1583, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_set_hpr_1583_comment},
  {"setHpr", (PyCFunction) &Dtool_LQuaternionf_set_hpr_1583, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_set_hpr_1583_comment},
  {"get_hpr", (PyCFunction) &Dtool_LQuaternionf_get_hpr_1584, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_hpr_1584_comment},
  {"getHpr", (PyCFunction) &Dtool_LQuaternionf_get_hpr_1584, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_hpr_1584_comment},
  {"get_axis", &Dtool_LQuaternionf_get_axis_1585, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_axis_1585_comment},
  {"getAxis", &Dtool_LQuaternionf_get_axis_1585, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_axis_1585_comment},
  {"get_axis_normalized", &Dtool_LQuaternionf_get_axis_normalized_1586, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_axis_normalized_1586_comment},
  {"getAxisNormalized", &Dtool_LQuaternionf_get_axis_normalized_1586, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_axis_normalized_1586_comment},
  {"get_angle_rad", &Dtool_LQuaternionf_get_angle_rad_1587, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_angle_rad_1587_comment},
  {"getAngleRad", &Dtool_LQuaternionf_get_angle_rad_1587, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_angle_rad_1587_comment},
  {"get_angle", &Dtool_LQuaternionf_get_angle_1588, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_angle_1588_comment},
  {"getAngle", &Dtool_LQuaternionf_get_angle_1588, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_angle_1588_comment},
  {"set_from_axis_angle_rad", (PyCFunction) &Dtool_LQuaternionf_set_from_axis_angle_rad_1589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_set_from_axis_angle_rad_1589_comment},
  {"setFromAxisAngleRad", (PyCFunction) &Dtool_LQuaternionf_set_from_axis_angle_rad_1589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_set_from_axis_angle_rad_1589_comment},
  {"set_from_axis_angle", (PyCFunction) &Dtool_LQuaternionf_set_from_axis_angle_1590, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_set_from_axis_angle_1590_comment},
  {"setFromAxisAngle", (PyCFunction) &Dtool_LQuaternionf_set_from_axis_angle_1590, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_set_from_axis_angle_1590_comment},
  {"get_up", (PyCFunction) &Dtool_LQuaternionf_get_up_1591, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_up_1591_comment},
  {"getUp", (PyCFunction) &Dtool_LQuaternionf_get_up_1591, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_up_1591_comment},
  {"get_right", (PyCFunction) &Dtool_LQuaternionf_get_right_1592, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_right_1592_comment},
  {"getRight", (PyCFunction) &Dtool_LQuaternionf_get_right_1592, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_right_1592_comment},
  {"get_forward", (PyCFunction) &Dtool_LQuaternionf_get_forward_1593, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_forward_1593_comment},
  {"getForward", (PyCFunction) &Dtool_LQuaternionf_get_forward_1593, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaternionf_get_forward_1593_comment},
  {"get_r", &Dtool_LQuaternionf_get_r_1594, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_r_1594_comment},
  {"getR", &Dtool_LQuaternionf_get_r_1594, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_r_1594_comment},
  {"get_i", &Dtool_LQuaternionf_get_i_1595, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_i_1595_comment},
  {"getI", &Dtool_LQuaternionf_get_i_1595, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_i_1595_comment},
  {"get_j", &Dtool_LQuaternionf_get_j_1596, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_j_1596_comment},
  {"getJ", &Dtool_LQuaternionf_get_j_1596, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_j_1596_comment},
  {"get_k", &Dtool_LQuaternionf_get_k_1597, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_k_1597_comment},
  {"getK", &Dtool_LQuaternionf_get_k_1597, METH_NOARGS, (const char *)Dtool_LQuaternionf_get_k_1597_comment},
  {"set_r", &Dtool_LQuaternionf_set_r_1598, METH_O, (const char *)Dtool_LQuaternionf_set_r_1598_comment},
  {"setR", &Dtool_LQuaternionf_set_r_1598, METH_O, (const char *)Dtool_LQuaternionf_set_r_1598_comment},
  {"set_i", &Dtool_LQuaternionf_set_i_1599, METH_O, (const char *)Dtool_LQuaternionf_set_i_1599_comment},
  {"setI", &Dtool_LQuaternionf_set_i_1599, METH_O, (const char *)Dtool_LQuaternionf_set_i_1599_comment},
  {"set_j", &Dtool_LQuaternionf_set_j_1600, METH_O, (const char *)Dtool_LQuaternionf_set_j_1600_comment},
  {"setJ", &Dtool_LQuaternionf_set_j_1600, METH_O, (const char *)Dtool_LQuaternionf_set_j_1600_comment},
  {"set_k", &Dtool_LQuaternionf_set_k_1601, METH_O, (const char *)Dtool_LQuaternionf_set_k_1601_comment},
  {"setK", &Dtool_LQuaternionf_set_k_1601, METH_O, (const char *)Dtool_LQuaternionf_set_k_1601_comment},
  {"normalize", &Dtool_LQuaternionf_normalize_1602, METH_NOARGS, (const char *)Dtool_LQuaternionf_normalize_1602_comment},
  {"conjugate_from", &Dtool_LQuaternionf_conjugate_from_1603, METH_O, (const char *)Dtool_LQuaternionf_conjugate_from_1603_comment},
  {"conjugateFrom", &Dtool_LQuaternionf_conjugate_from_1603, METH_O, (const char *)Dtool_LQuaternionf_conjugate_from_1603_comment},
  {"conjugate_in_place", &Dtool_LQuaternionf_conjugate_in_place_1604, METH_NOARGS, (const char *)Dtool_LQuaternionf_conjugate_in_place_1604_comment},
  {"conjugateInPlace", &Dtool_LQuaternionf_conjugate_in_place_1604, METH_NOARGS, (const char *)Dtool_LQuaternionf_conjugate_in_place_1604_comment},
  {"invert_from", &Dtool_LQuaternionf_invert_from_1605, METH_O, (const char *)Dtool_LQuaternionf_invert_from_1605_comment},
  {"invertFrom", &Dtool_LQuaternionf_invert_from_1605, METH_O, (const char *)Dtool_LQuaternionf_invert_from_1605_comment},
  {"invert_in_place", &Dtool_LQuaternionf_invert_in_place_1606, METH_NOARGS, (const char *)Dtool_LQuaternionf_invert_in_place_1606_comment},
  {"invertInPlace", &Dtool_LQuaternionf_invert_in_place_1606, METH_NOARGS, (const char *)Dtool_LQuaternionf_invert_in_place_1606_comment},
  {"is_identity", &Dtool_LQuaternionf_is_identity_1607, METH_NOARGS, (const char *)Dtool_LQuaternionf_is_identity_1607_comment},
  {"isIdentity", &Dtool_LQuaternionf_is_identity_1607, METH_NOARGS, (const char *)Dtool_LQuaternionf_is_identity_1607_comment},
  {"is_almost_identity", &Dtool_LQuaternionf_is_almost_identity_1608, METH_O, (const char *)Dtool_LQuaternionf_is_almost_identity_1608_comment},
  {"isAlmostIdentity", &Dtool_LQuaternionf_is_almost_identity_1608, METH_O, (const char *)Dtool_LQuaternionf_is_almost_identity_1608_comment},
  {"ident_quat", &Dtool_LQuaternionf_ident_quat_1609, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaternionf_ident_quat_1609_comment},
  {"identQuat", &Dtool_LQuaternionf_ident_quat_1609, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaternionf_ident_quat_1609_comment},
  {"get_class_type", &Dtool_LQuaternionf_get_class_type_1610, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaternionf_get_class_type_1610_comment},
  {"getClassType", &Dtool_LQuaternionf_get_class_type_1610, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaternionf_get_class_type_1610_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1570_nb_add(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaternionf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.__add__", "LQuaternionf");
  }
  LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1575_nb_divide(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaternionf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaternionf LQuaternionf::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1576_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaternionf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &)
    LQuaternionf arg_local;
    LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.__imul__", "LQuaternionf");
      return NULL;
    }
    (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LQuaternionf.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1574_nb_multiply(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaternionf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &)
    LMatrix4f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4f *return_value = new LMatrix4f((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &)
    LMatrix3f const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3f, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3f *return_value = new LMatrix3f((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const
    LQuaternionf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
    if (arg_this != NULL) {
      LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  {
    // -2 inline LQuaternionf LQuaternionf::operator *(float scalar) const
    if (PyNumber_Check(arg)) {
      LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator *((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4f *return_value = new LMatrix4f((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
    }
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3f *return_value = new LMatrix3f((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
    }
  }

  {
    // -2 inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const
    LQuaternionf arg_local;
    LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != NULL)) {
      LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  // No coercion possible: inline LQuaternionf LQuaternionf::operator *(float scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1569_nb_negative(PyObject *self) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LQuaternionf LQuaternionf::operator -(void) const
  LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LQuaternionf self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1571_nb_subtract(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaternionf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaternionf.__sub__", "LQuaternionf");
  }
  LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaternionf slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LQuaternionf_operator_1575_nb_true_divide(PyObject *self, PyObject *arg) {
  LQuaternionf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaternionf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaternionf LQuaternionf::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LQuaternionf *return_value = new LQuaternionf((*(const LQuaternionf*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
//  A __repr__ function
//     LQuaternionf
//////////////////
static PyObject *Dtool_Repr_LQuaternionf(PyObject *self) {
  LQuaternionf *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaternionf, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LQuaternionf = {
  &Dtool_LQuaternionf_operator_1570_nb_add,
  &Dtool_LQuaternionf_operator_1571_nb_subtract,
  &Dtool_LQuaternionf_operator_1574_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LQuaternionf_operator_1575_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LQuaternionf_operator_1569_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  &Dtool_LQuaternionf_operator_1576_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LQuaternionf_operator_1575_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LQuaternionf = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LQuaternionf = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LQuaternionf = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LQuaternionf = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LQuaternionf",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LQuaternionf,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LQuaternionf,
    &Dtool_NumberMethods_LQuaternionf,
    &Dtool_SequenceMethods_LQuaternionf,
    &Dtool_MappingMethods_LQuaternionf,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_LQuaternionf,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LQuaternionf,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base quaternion class\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LQuaternionf,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LQuaternionf,
    PyType_GenericAlloc,
    Dtool_new_LQuaternionf,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LQuaternionf,
  Dtool_UpcastInterface_LQuaternionf,
  Dtool_DowncastInterface_LQuaternionf,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LQuaternionf,
};

static void Dtool_PyModuleClassInit_LQuaternionf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4f(NULL);
    Dtool_LQuaternionf._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4f);
    PyObject *dict = PyDict_New();
    Dtool_LQuaternionf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LQuaternionf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LQuaternionf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LQuaternionf);
  }
}

/**
 * Python method tables for LQuaterniond (LQuaterniond)
 */
static PyMethodDef Dtool_Methods_LQuaterniond[] = {
  {"pure_imaginary", &Dtool_LQuaterniond_pure_imaginary_1614, METH_O | METH_STATIC, (const char *)Dtool_LQuaterniond_pure_imaginary_1614_comment},
  {"pureImaginary", &Dtool_LQuaterniond_pure_imaginary_1614, METH_O | METH_STATIC, (const char *)Dtool_LQuaterniond_pure_imaginary_1614_comment},
  {"conjugate", &Dtool_LQuaterniond_conjugate_1615, METH_NOARGS, (const char *)Dtool_LQuaterniond_conjugate_1615_comment},
  {"xform", &Dtool_LQuaterniond_xform_1616, METH_O, (const char *)Dtool_LQuaterniond_xform_1616_comment},
  {"multiply", &Dtool_LQuaterniond_multiply_1617, METH_O, (const char *)Dtool_LQuaterniond_multiply_1617_comment},
  {"angle_rad", &Dtool_LQuaterniond_angle_rad_1621, METH_O, (const char *)Dtool_LQuaterniond_angle_rad_1621_comment},
  {"angleRad", &Dtool_LQuaterniond_angle_rad_1621, METH_O, (const char *)Dtool_LQuaterniond_angle_rad_1621_comment},
  {"angle_deg", &Dtool_LQuaterniond_angle_deg_1622, METH_O, (const char *)Dtool_LQuaterniond_angle_deg_1622_comment},
  {"angleDeg", &Dtool_LQuaterniond_angle_deg_1622, METH_O, (const char *)Dtool_LQuaterniond_angle_deg_1622_comment},
  {"almost_equal", (PyCFunction) &Dtool_LQuaterniond_almost_equal_1626, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_almost_equal_1626_comment},
  {"almostEqual", (PyCFunction) &Dtool_LQuaterniond_almost_equal_1626, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_almost_equal_1626_comment},
  {"is_same_direction", &Dtool_LQuaterniond_is_same_direction_1627, METH_O, (const char *)Dtool_LQuaterniond_is_same_direction_1627_comment},
  {"isSameDirection", &Dtool_LQuaterniond_is_same_direction_1627, METH_O, (const char *)Dtool_LQuaterniond_is_same_direction_1627_comment},
  {"almost_same_direction", (PyCFunction) &Dtool_LQuaterniond_almost_same_direction_1628, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_almost_same_direction_1628_comment},
  {"almostSameDirection", (PyCFunction) &Dtool_LQuaterniond_almost_same_direction_1628, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_almost_same_direction_1628_comment},
  {"output", &Dtool_LQuaterniond_output_1629, METH_O, (const char *)Dtool_LQuaterniond_output_1629_comment},
  {"extract_to_matrix", &Dtool_LQuaterniond_extract_to_matrix_1630, METH_O, (const char *)Dtool_LQuaterniond_extract_to_matrix_1630_comment},
  {"extractToMatrix", &Dtool_LQuaterniond_extract_to_matrix_1630, METH_O, (const char *)Dtool_LQuaterniond_extract_to_matrix_1630_comment},
  {"set_from_matrix", &Dtool_LQuaterniond_set_from_matrix_1631, METH_O, (const char *)Dtool_LQuaterniond_set_from_matrix_1631_comment},
  {"setFromMatrix", &Dtool_LQuaterniond_set_from_matrix_1631, METH_O, (const char *)Dtool_LQuaterniond_set_from_matrix_1631_comment},
  {"set_hpr", (PyCFunction) &Dtool_LQuaterniond_set_hpr_1632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_set_hpr_1632_comment},
  {"setHpr", (PyCFunction) &Dtool_LQuaterniond_set_hpr_1632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_set_hpr_1632_comment},
  {"get_hpr", (PyCFunction) &Dtool_LQuaterniond_get_hpr_1633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_hpr_1633_comment},
  {"getHpr", (PyCFunction) &Dtool_LQuaterniond_get_hpr_1633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_hpr_1633_comment},
  {"get_axis", &Dtool_LQuaterniond_get_axis_1634, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_axis_1634_comment},
  {"getAxis", &Dtool_LQuaterniond_get_axis_1634, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_axis_1634_comment},
  {"get_axis_normalized", &Dtool_LQuaterniond_get_axis_normalized_1635, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_axis_normalized_1635_comment},
  {"getAxisNormalized", &Dtool_LQuaterniond_get_axis_normalized_1635, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_axis_normalized_1635_comment},
  {"get_angle_rad", &Dtool_LQuaterniond_get_angle_rad_1636, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_angle_rad_1636_comment},
  {"getAngleRad", &Dtool_LQuaterniond_get_angle_rad_1636, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_angle_rad_1636_comment},
  {"get_angle", &Dtool_LQuaterniond_get_angle_1637, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_angle_1637_comment},
  {"getAngle", &Dtool_LQuaterniond_get_angle_1637, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_angle_1637_comment},
  {"set_from_axis_angle_rad", (PyCFunction) &Dtool_LQuaterniond_set_from_axis_angle_rad_1638, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_set_from_axis_angle_rad_1638_comment},
  {"setFromAxisAngleRad", (PyCFunction) &Dtool_LQuaterniond_set_from_axis_angle_rad_1638, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_set_from_axis_angle_rad_1638_comment},
  {"set_from_axis_angle", (PyCFunction) &Dtool_LQuaterniond_set_from_axis_angle_1639, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_set_from_axis_angle_1639_comment},
  {"setFromAxisAngle", (PyCFunction) &Dtool_LQuaterniond_set_from_axis_angle_1639, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_set_from_axis_angle_1639_comment},
  {"get_up", (PyCFunction) &Dtool_LQuaterniond_get_up_1640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_up_1640_comment},
  {"getUp", (PyCFunction) &Dtool_LQuaterniond_get_up_1640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_up_1640_comment},
  {"get_right", (PyCFunction) &Dtool_LQuaterniond_get_right_1641, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_right_1641_comment},
  {"getRight", (PyCFunction) &Dtool_LQuaterniond_get_right_1641, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_right_1641_comment},
  {"get_forward", (PyCFunction) &Dtool_LQuaterniond_get_forward_1642, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_forward_1642_comment},
  {"getForward", (PyCFunction) &Dtool_LQuaterniond_get_forward_1642, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LQuaterniond_get_forward_1642_comment},
  {"get_r", &Dtool_LQuaterniond_get_r_1643, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_r_1643_comment},
  {"getR", &Dtool_LQuaterniond_get_r_1643, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_r_1643_comment},
  {"get_i", &Dtool_LQuaterniond_get_i_1644, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_i_1644_comment},
  {"getI", &Dtool_LQuaterniond_get_i_1644, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_i_1644_comment},
  {"get_j", &Dtool_LQuaterniond_get_j_1645, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_j_1645_comment},
  {"getJ", &Dtool_LQuaterniond_get_j_1645, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_j_1645_comment},
  {"get_k", &Dtool_LQuaterniond_get_k_1646, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_k_1646_comment},
  {"getK", &Dtool_LQuaterniond_get_k_1646, METH_NOARGS, (const char *)Dtool_LQuaterniond_get_k_1646_comment},
  {"set_r", &Dtool_LQuaterniond_set_r_1647, METH_O, (const char *)Dtool_LQuaterniond_set_r_1647_comment},
  {"setR", &Dtool_LQuaterniond_set_r_1647, METH_O, (const char *)Dtool_LQuaterniond_set_r_1647_comment},
  {"set_i", &Dtool_LQuaterniond_set_i_1648, METH_O, (const char *)Dtool_LQuaterniond_set_i_1648_comment},
  {"setI", &Dtool_LQuaterniond_set_i_1648, METH_O, (const char *)Dtool_LQuaterniond_set_i_1648_comment},
  {"set_j", &Dtool_LQuaterniond_set_j_1649, METH_O, (const char *)Dtool_LQuaterniond_set_j_1649_comment},
  {"setJ", &Dtool_LQuaterniond_set_j_1649, METH_O, (const char *)Dtool_LQuaterniond_set_j_1649_comment},
  {"set_k", &Dtool_LQuaterniond_set_k_1650, METH_O, (const char *)Dtool_LQuaterniond_set_k_1650_comment},
  {"setK", &Dtool_LQuaterniond_set_k_1650, METH_O, (const char *)Dtool_LQuaterniond_set_k_1650_comment},
  {"normalize", &Dtool_LQuaterniond_normalize_1651, METH_NOARGS, (const char *)Dtool_LQuaterniond_normalize_1651_comment},
  {"conjugate_from", &Dtool_LQuaterniond_conjugate_from_1652, METH_O, (const char *)Dtool_LQuaterniond_conjugate_from_1652_comment},
  {"conjugateFrom", &Dtool_LQuaterniond_conjugate_from_1652, METH_O, (const char *)Dtool_LQuaterniond_conjugate_from_1652_comment},
  {"conjugate_in_place", &Dtool_LQuaterniond_conjugate_in_place_1653, METH_NOARGS, (const char *)Dtool_LQuaterniond_conjugate_in_place_1653_comment},
  {"conjugateInPlace", &Dtool_LQuaterniond_conjugate_in_place_1653, METH_NOARGS, (const char *)Dtool_LQuaterniond_conjugate_in_place_1653_comment},
  {"invert_from", &Dtool_LQuaterniond_invert_from_1654, METH_O, (const char *)Dtool_LQuaterniond_invert_from_1654_comment},
  {"invertFrom", &Dtool_LQuaterniond_invert_from_1654, METH_O, (const char *)Dtool_LQuaterniond_invert_from_1654_comment},
  {"invert_in_place", &Dtool_LQuaterniond_invert_in_place_1655, METH_NOARGS, (const char *)Dtool_LQuaterniond_invert_in_place_1655_comment},
  {"invertInPlace", &Dtool_LQuaterniond_invert_in_place_1655, METH_NOARGS, (const char *)Dtool_LQuaterniond_invert_in_place_1655_comment},
  {"is_identity", &Dtool_LQuaterniond_is_identity_1656, METH_NOARGS, (const char *)Dtool_LQuaterniond_is_identity_1656_comment},
  {"isIdentity", &Dtool_LQuaterniond_is_identity_1656, METH_NOARGS, (const char *)Dtool_LQuaterniond_is_identity_1656_comment},
  {"is_almost_identity", &Dtool_LQuaterniond_is_almost_identity_1657, METH_O, (const char *)Dtool_LQuaterniond_is_almost_identity_1657_comment},
  {"isAlmostIdentity", &Dtool_LQuaterniond_is_almost_identity_1657, METH_O, (const char *)Dtool_LQuaterniond_is_almost_identity_1657_comment},
  {"ident_quat", &Dtool_LQuaterniond_ident_quat_1658, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaterniond_ident_quat_1658_comment},
  {"identQuat", &Dtool_LQuaterniond_ident_quat_1658, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaterniond_ident_quat_1658_comment},
  {"get_class_type", &Dtool_LQuaterniond_get_class_type_1659, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaterniond_get_class_type_1659_comment},
  {"getClassType", &Dtool_LQuaterniond_get_class_type_1659, METH_NOARGS | METH_STATIC, (const char *)Dtool_LQuaterniond_get_class_type_1659_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_add -> operator +
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1619_nb_add(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaterniond, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.__add__", "LQuaterniond");
  }
  LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator +(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1624_nb_divide(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaterniond, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaterniond LQuaterniond::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_inplace_multiply -> operator *=
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1625_nb_inplace_multiply(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaterniond, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &)
    LQuaterniond arg_local;
    LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
    if (!(arg_this != NULL)) {
      Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.__imul__", "LQuaterniond");
      return NULL;
    }
    (*local_this).operator *=(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LQuaterniond.__imul__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1623_nb_multiply(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaterniond, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &)
    LMatrix3d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix3d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix3d *return_value = new LMatrix3d((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &)
    LMatrix4d const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LMatrix4d, (void **)&arg_this);
    if (arg_this != NULL) {
      LMatrix4d *return_value = new LMatrix4d((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const
    LQuaterniond const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaterniond, (void **)&arg_this);
    if (arg_this != NULL) {
      LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  {
    // -2 inline LQuaterniond LQuaterniond::operator *(double scalar) const
    if (PyNumber_Check(arg)) {
      LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator *(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix3d *return_value = new LMatrix3d((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, true, false);
    }
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if ((arg_this != NULL)) {
      LMatrix4d *return_value = new LMatrix4d((*local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, true, false);
    }
  }

  {
    // -2 inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const
    LQuaterniond arg_local;
    LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
    if ((arg_this != NULL)) {
      LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  // No coercion possible: inline LQuaterniond LQuaterniond::operator *(double scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_negative -> operator -
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1618_nb_negative(PyObject *self) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline LQuaterniond LQuaterniond::operator -(void) const
  LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator -());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__neg__(LQuaterniond self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1620_nb_subtract(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaterniond, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const
  LQuaterniond arg_local;
  LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LQuaterniond.__sub__", "LQuaterniond");
  }
  LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator -(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LQuaterniond slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LQuaterniond_operator_1624_nb_true_divide(PyObject *self, PyObject *arg) {
  LQuaterniond *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LQuaterniond, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LQuaterniond LQuaterniond::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LQuaterniond *return_value = new LQuaterniond((*(const LQuaterniond*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
//////////////////
//  A __repr__ function
//     LQuaterniond
//////////////////
static PyObject *Dtool_Repr_LQuaterniond(PyObject *self) {
  LQuaterniond *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LQuaterniond, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_LQuaterniond = {
  &Dtool_LQuaterniond_operator_1619_nb_add,
  &Dtool_LQuaterniond_operator_1620_nb_subtract,
  &Dtool_LQuaterniond_operator_1623_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LQuaterniond_operator_1624_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  &Dtool_LQuaterniond_operator_1618_nb_negative,
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  &Dtool_LQuaterniond_operator_1625_nb_inplace_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LQuaterniond_operator_1624_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LQuaterniond = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LQuaterniond = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LQuaterniond = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LQuaterniond = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LQuaterniond",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LQuaterniond,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_LQuaterniond,
    &Dtool_NumberMethods_LQuaterniond,
    &Dtool_SequenceMethods_LQuaterniond,
    &Dtool_MappingMethods_LQuaterniond,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_LQuaterniond,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LQuaterniond,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base quaternion class\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LQuaterniond,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LQuaterniond,
    PyType_GenericAlloc,
    Dtool_new_LQuaterniond,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LQuaterniond,
  Dtool_UpcastInterface_LQuaterniond,
  Dtool_DowncastInterface_LQuaterniond,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LQuaterniond,
};

static void Dtool_PyModuleClassInit_LQuaterniond(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LVecBase4d(NULL);
    Dtool_LQuaterniond._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LVecBase4d);
    PyObject *dict = PyDict_New();
    Dtool_LQuaterniond._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LQuaterniond) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LQuaterniond)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LQuaterniond);
  }
}

/**
 * Python method tables for LRotationf (LRotationf)
 */
static PyMethodDef Dtool_Methods_LRotationf[] = {
  {"get_class_type", &Dtool_LRotationf_get_class_type_1665, METH_NOARGS | METH_STATIC, (const char *)Dtool_LRotationf_get_class_type_1665_comment},
  {"getClassType", &Dtool_LRotationf_get_class_type_1665, METH_NOARGS | METH_STATIC, (const char *)Dtool_LRotationf_get_class_type_1665_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LRotationf slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LRotationf_operator_1664_nb_divide(PyObject *self, PyObject *arg) {
  LRotationf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LRotationf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LRotationf LRotationf::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LRotationf *return_value = new LRotationf((*(const LRotationf*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LRotationf slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LRotationf_operator_1663_nb_multiply(PyObject *self, PyObject *arg) {
  LRotationf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LRotationf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LRotationf LRotationf::operator *(LRotationf const &other) const
    LRotationf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LRotationf, (void **)&arg_this);
    if (arg_this != NULL) {
      LRotationf *return_value = new LRotationf((*(const LRotationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
    }
  }

  {
    // -2 inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const
    LQuaternionf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
    if (arg_this != NULL) {
      LQuaternionf *return_value = new LQuaternionf((*(const LRotationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  {
    // -2 inline LRotationf LRotationf::operator *(float scalar) const
    if (PyNumber_Check(arg)) {
      LRotationf *return_value = new LRotationf((*(const LRotationf*)local_this).operator *((float)PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
    }
  }

  {
    // -2 inline LRotationf LRotationf::operator *(LRotationf const &other) const
    LRotationf arg_local;
    LRotationf const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
    if ((arg_this != NULL)) {
      LRotationf *return_value = new LRotationf((*(const LRotationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
    }
  }

  {
    // -2 inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const
    LQuaternionf arg_local;
    LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != NULL)) {
      LQuaternionf *return_value = new LQuaternionf((*(const LRotationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
    }
  }

  // No coercion possible: inline LRotationf LRotationf::operator *(float scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LRotationf slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LRotationf_operator_1664_nb_true_divide(PyObject *self, PyObject *arg) {
  LRotationf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LRotationf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LRotationf LRotationf::operator /(float scalar) const
  if (PyNumber_Check(arg)) {
    LRotationf *return_value = new LRotationf((*(const LRotationf*)local_this).operator /((float)PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
static PyNumberMethods Dtool_NumberMethods_LRotationf = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LRotationf_operator_1663_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LRotationf_operator_1664_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LRotationf_operator_1664_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LRotationf = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LRotationf = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LRotationf = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LRotationf = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LRotationf",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LRotationf,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LRotationf,
    &Dtool_SequenceMethods_LRotationf,
    &Dtool_MappingMethods_LRotationf,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LRotationf,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a unit quaternion representing a rotation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LRotationf,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LRotationf,
    PyType_GenericAlloc,
    Dtool_new_LRotationf,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LRotationf,
  Dtool_UpcastInterface_LRotationf,
  Dtool_DowncastInterface_LRotationf,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LRotationf,
};

static void Dtool_PyModuleClassInit_LRotationf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LQuaternionf(NULL);
    Dtool_LRotationf._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LQuaternionf);
    PyObject *dict = PyDict_New();
    Dtool_LRotationf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LRotationf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LRotationf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LRotationf);
  }
}

/**
 * Python method tables for LRotationd (LRotationd)
 */
static PyMethodDef Dtool_Methods_LRotationd[] = {
  {"get_class_type", &Dtool_LRotationd_get_class_type_1671, METH_NOARGS | METH_STATIC, (const char *)Dtool_LRotationd_get_class_type_1671_comment},
  {"getClassType", &Dtool_LRotationd_get_class_type_1671, METH_NOARGS | METH_STATIC, (const char *)Dtool_LRotationd_get_class_type_1671_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LRotationd slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_LRotationd_operator_1670_nb_divide(PyObject *self, PyObject *arg) {
  LRotationd *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LRotationd, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LRotationd LRotationd::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LRotationd *return_value = new LRotationd((*(const LRotationd*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationd, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LRotationd slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LRotationd_operator_1669_nb_multiply(PyObject *self, PyObject *arg) {
  LRotationd *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LRotationd, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LRotationd LRotationd::operator *(LRotationd const &other) const
    LRotationd const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LRotationd, (void **)&arg_this);
    if (arg_this != NULL) {
      LRotationd *return_value = new LRotationd((*(const LRotationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationd, true, false);
    }
  }

  {
    // -2 inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const
    LQuaterniond const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaterniond, (void **)&arg_this);
    if (arg_this != NULL) {
      LQuaterniond *return_value = new LQuaterniond((*(const LRotationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  {
    // -2 inline LRotationd LRotationd::operator *(double scalar) const
    if (PyNumber_Check(arg)) {
      LRotationd *return_value = new LRotationd((*(const LRotationd*)local_this).operator *(PyFloat_AsDouble(arg)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationd, true, false);
    }
  }

  {
    // -2 inline LRotationd LRotationd::operator *(LRotationd const &other) const
    LRotationd arg_local;
    LRotationd const *arg_this = Dtool_Coerce_LRotationd(arg, arg_local);
    if ((arg_this != NULL)) {
      LRotationd *return_value = new LRotationd((*(const LRotationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationd, true, false);
    }
  }

  {
    // -2 inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const
    LQuaterniond arg_local;
    LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
    if ((arg_this != NULL)) {
      LQuaterniond *return_value = new LQuaterniond((*(const LRotationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaterniond, true, false);
    }
  }

  // No coercion possible: inline LRotationd LRotationd::operator *(double scalar) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#if PY_VERSION_HEX >= 0x3000000
//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LRotationd slot nb_true_divide -> operator /
//////////////////
static PyObject *Dtool_LRotationd_operator_1670_nb_true_divide(PyObject *self, PyObject *arg) {
  LRotationd *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LRotationd, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline LRotationd LRotationd::operator /(double scalar) const
  if (PyNumber_Check(arg)) {
    LRotationd *return_value = new LRotationd((*(const LRotationd*)local_this).operator /(PyFloat_AsDouble(arg)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationd, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

#endif  // PY_VERSION_HEX >= 0x3000000
static PyNumberMethods Dtool_NumberMethods_LRotationd = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LRotationd_operator_1669_nb_multiply,
#if PY_MAJOR_VERSION < 3
  &Dtool_LRotationd_operator_1670_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
#if PY_VERSION_HEX >= 0x3000000
  &Dtool_LRotationd_operator_1670_nb_true_divide,
#else
  0,
#endif
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LRotationd = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LRotationd = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LRotationd = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LRotationd = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LRotationd",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LRotationd,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LRotationd,
    &Dtool_SequenceMethods_LRotationd,
    &Dtool_MappingMethods_LRotationd,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LRotationd,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a unit quaternion representing a rotation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LRotationd,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LRotationd,
    PyType_GenericAlloc,
    Dtool_new_LRotationd,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LRotationd,
  Dtool_UpcastInterface_LRotationd,
  Dtool_DowncastInterface_LRotationd,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LRotationd,
};

static void Dtool_PyModuleClassInit_LRotationd(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LQuaterniond(NULL);
    Dtool_LRotationd._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LQuaterniond);
    PyObject *dict = PyDict_New();
    Dtool_LRotationd._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LRotationd) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LRotationd)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LRotationd);
  }
}

/**
 * Python method tables for LOrientationf (LOrientationf)
 */
static PyMethodDef Dtool_Methods_LOrientationf[] = {
  {"get_class_type", &Dtool_LOrientationf_get_class_type_1676, METH_NOARGS | METH_STATIC, (const char *)Dtool_LOrientationf_get_class_type_1676_comment},
  {"getClassType", &Dtool_LOrientationf_get_class_type_1676, METH_NOARGS | METH_STATIC, (const char *)Dtool_LOrientationf_get_class_type_1676_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LOrientationf slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LOrientationf_operator_1675_nb_multiply(PyObject *self, PyObject *arg) {
  LOrientationf *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LOrientationf, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LOrientationf LOrientationf::operator *(LRotationf const &other) const
    LRotationf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LRotationf, (void **)&arg_this);
    if (arg_this != NULL) {
      LOrientationf *return_value = new LOrientationf((*(const LOrientationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, true, false);
    }
  }

  {
    // -2 inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const
    LQuaternionf const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaternionf, (void **)&arg_this);
    if (arg_this != NULL) {
      LOrientationf *return_value = new LOrientationf((*(const LOrientationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, true, false);
    }
  }

  {
    // -2 inline LOrientationf LOrientationf::operator *(LRotationf const &other) const
    LRotationf arg_local;
    LRotationf const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
    if ((arg_this != NULL)) {
      LOrientationf *return_value = new LOrientationf((*(const LOrientationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, true, false);
    }
  }

  {
    // -2 inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const
    LQuaternionf arg_local;
    LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != NULL)) {
      LOrientationf *return_value = new LOrientationf((*(const LOrientationf*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_LOrientationf = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LOrientationf_operator_1675_nb_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LOrientationf = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LOrientationf = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LOrientationf = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LOrientationf = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LOrientationf",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LOrientationf,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LOrientationf,
    &Dtool_SequenceMethods_LOrientationf,
    &Dtool_MappingMethods_LOrientationf,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LOrientationf,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a unit quaternion representing an orientation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LOrientationf,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LOrientationf,
    PyType_GenericAlloc,
    Dtool_new_LOrientationf,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LOrientationf,
  Dtool_UpcastInterface_LOrientationf,
  Dtool_DowncastInterface_LOrientationf,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LOrientationf,
};

static void Dtool_PyModuleClassInit_LOrientationf(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LQuaternionf(NULL);
    Dtool_LOrientationf._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LQuaternionf);
    PyObject *dict = PyDict_New();
    Dtool_LOrientationf._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LOrientationf) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LOrientationf)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LOrientationf);
  }
}

/**
 * Python method tables for LOrientationd (LOrientationd)
 */
static PyMethodDef Dtool_Methods_LOrientationd[] = {
  {"get_class_type", &Dtool_LOrientationd_get_class_type_1681, METH_NOARGS | METH_STATIC, (const char *)Dtool_LOrientationd_get_class_type_1681_comment},
  {"getClassType", &Dtool_LOrientationd_get_class_type_1681, METH_NOARGS | METH_STATIC, (const char *)Dtool_LOrientationd_get_class_type_1681_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LOrientationd slot nb_multiply -> operator *
//////////////////
static PyObject *Dtool_LOrientationd_operator_1680_nb_multiply(PyObject *self, PyObject *arg) {
  LOrientationd *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_LOrientationd, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline LOrientationd LOrientationd::operator *(LRotationd const &other) const
    LRotationd const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LRotationd, (void **)&arg_this);
    if (arg_this != NULL) {
      LOrientationd *return_value = new LOrientationd((*(const LOrientationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationd, true, false);
    }
  }

  {
    // -2 inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const
    LQuaterniond const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_LQuaterniond, (void **)&arg_this);
    if (arg_this != NULL) {
      LOrientationd *return_value = new LOrientationd((*(const LOrientationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationd, true, false);
    }
  }

  {
    // -2 inline LOrientationd LOrientationd::operator *(LRotationd const &other) const
    LRotationd arg_local;
    LRotationd const *arg_this = Dtool_Coerce_LRotationd(arg, arg_local);
    if ((arg_this != NULL)) {
      LOrientationd *return_value = new LOrientationd((*(const LOrientationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationd, true, false);
    }
  }

  {
    // -2 inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const
    LQuaterniond arg_local;
    LQuaterniond const *arg_this = Dtool_Coerce_LQuaterniond(arg, arg_local);
    if ((arg_this != NULL)) {
      LOrientationd *return_value = new LOrientationd((*(const LOrientationd*)local_this).operator *(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationd, true, false);
    }
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_LOrientationd = {
  0, // nb_add
  0, // nb_subtract
  &Dtool_LOrientationd_operator_1680_nb_multiply,
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LOrientationd = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LOrientationd = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LOrientationd = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LOrientationd = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LOrientationd",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LOrientationd,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LOrientationd,
    &Dtool_SequenceMethods_LOrientationd,
    &Dtool_MappingMethods_LOrientationd,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LOrientationd,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a unit quaternion representing an orientation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LOrientationd,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LOrientationd,
    PyType_GenericAlloc,
    Dtool_new_LOrientationd,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LOrientationd,
  Dtool_UpcastInterface_LOrientationd,
  Dtool_DowncastInterface_LOrientationd,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_LOrientationd,
};

static void Dtool_PyModuleClassInit_LOrientationd(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LQuaterniond(NULL);
    Dtool_LOrientationd._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LQuaterniond);
    PyObject *dict = PyDict_New();
    Dtool_LOrientationd._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LOrientationd) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LOrientationd)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LOrientationd);
  }
}

/**
 * Python method tables for ConfigVariableColor (ConfigVariableColor)
 */
static PyMethodDef Dtool_Methods_ConfigVariableColor[] = {
  {"assign", &Dtool_ConfigVariableColor_operator_1756, METH_O, (const char *)Dtool_ConfigVariableColor_operator_1756_comment},
  {"set_value", &Dtool_ConfigVariableColor_set_value_1759, METH_O, (const char *)Dtool_ConfigVariableColor_set_value_1759_comment},
  {"setValue", &Dtool_ConfigVariableColor_set_value_1759, METH_O, (const char *)Dtool_ConfigVariableColor_set_value_1759_comment},
  {"get_value", &Dtool_ConfigVariableColor_get_value_1760, METH_NOARGS, (const char *)Dtool_ConfigVariableColor_get_value_1760_comment},
  {"getValue", &Dtool_ConfigVariableColor_get_value_1760, METH_NOARGS, (const char *)Dtool_ConfigVariableColor_get_value_1760_comment},
  {"get_default_value", &Dtool_ConfigVariableColor_get_default_value_1761, METH_NOARGS, (const char *)Dtool_ConfigVariableColor_get_default_value_1761_comment},
  {"getDefaultValue", &Dtool_ConfigVariableColor_get_default_value_1761, METH_NOARGS, (const char *)Dtool_ConfigVariableColor_get_default_value_1761_comment},
  {"operator_typecast", &Dtool_ConfigVariableColor_operator_typecast_1757, METH_NOARGS, (const char *)Dtool_ConfigVariableColor_operator_typecast_1757_comment},
  {"operatorTypecast", &Dtool_ConfigVariableColor_operator_typecast_1757, METH_NOARGS, (const char *)Dtool_ConfigVariableColor_operator_typecast_1757_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableColor slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableColor_operator_1758_mp_subscript(PyObject *self, PyObject *arg) {
  ConfigVariableColor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableColor, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat ConfigVariableColor::operator [](int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*(const ConfigVariableColor*)local_this).operator []((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableColor self, int n)\n");
  }
  return NULL;
}

static PyNumberMethods Dtool_NumberMethods_ConfigVariableColor = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableColor = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableColor = {
  0, // mp_length
  &Dtool_ConfigVariableColor_operator_1758_mp_subscript,
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableColor = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableColor = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableColor",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableColor,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableColor,
    &Dtool_SequenceMethods_ConfigVariableColor,
    &Dtool_MappingMethods_ConfigVariableColor,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableColor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a set of\n"
    " * floating-point types representing a color value.\n"
    " *\n"
    " * It interprets the color differently depending on how many words were\n"
    " * specified: if only one, it is interpreted as a shade of gray with alpha 1.\n"
    " * If two values were specified, a grayscale and alpha pair.  If three, a set\n"
    " * of R, G, B values with alpha 1, and if four, a complete RGBA color.\n"
    " *\n"
    " * This isn't defined in dtool because it relies on the LColor class, which is\n"
    " * defined in linmath.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableColor,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableColor,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableColor,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableColor,
  Dtool_UpcastInterface_ConfigVariableColor,
  Dtool_DowncastInterface_ConfigVariableColor,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableColor,
  (CoerceFunction)Dtool_Coerce_ConfigVariableColor,
};

static void Dtool_PyModuleClassInit_ConfigVariableColor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ConfigVariable != NULL);
    assert(Dtool_Ptr_ConfigVariable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ConfigVariable->_Dtool_ModuleClassInit(NULL);
    Dtool_ConfigVariableColor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableColor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableColor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableColor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableColor);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3linmath_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MathNumbers", Dtool_MathNumbers);
#endif
  Dtool_LVecBase2f._type = LVecBase2f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase2f);
  Dtool_LVecBase2d._type = LVecBase2d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase2d);
  Dtool_LVecBase2i._type = LVecBase2i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase2i);
  Dtool_LVector2f._type = LVector2f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector2f);
  Dtool_LVector2d._type = LVector2d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector2d);
  Dtool_LVector2i._type = LVector2i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector2i);
  Dtool_LPoint2f._type = LPoint2f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint2f);
  Dtool_LPoint2d._type = LPoint2d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint2d);
  Dtool_LPoint2i._type = LPoint2i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint2i);
  Dtool_LVecBase3f._type = LVecBase3f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase3f);
  Dtool_LVecBase3d._type = LVecBase3d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase3d);
  Dtool_LVecBase3i._type = LVecBase3i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase3i);
  Dtool_LVector3f._type = LVector3f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector3f);
  Dtool_LVector3d._type = LVector3d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector3d);
  Dtool_LVector3i._type = LVector3i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector3i);
  Dtool_LPoint3f._type = LPoint3f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint3f);
  Dtool_LPoint3d._type = LPoint3d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint3d);
  Dtool_LPoint3i._type = LPoint3i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint3i);
  Dtool_LVecBase4f._type = LVecBase4f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase4f);
  Dtool_UnalignedLVecBase4f._type = UnalignedLVecBase4f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UnalignedLVecBase4f);
  Dtool_LVecBase4d._type = LVecBase4d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase4d);
  Dtool_UnalignedLVecBase4d._type = UnalignedLVecBase4d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UnalignedLVecBase4d);
  Dtool_LVecBase4i._type = LVecBase4i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVecBase4i);
  Dtool_UnalignedLVecBase4i._type = UnalignedLVecBase4i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UnalignedLVecBase4i);
  Dtool_LVector4f._type = LVector4f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector4f);
  Dtool_LVector4d._type = LVector4d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector4d);
  Dtool_LVector4i._type = LVector4i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LVector4i);
  Dtool_LPoint4f._type = LPoint4f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint4f);
  Dtool_LPoint4d._type = LPoint4d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint4d);
  Dtool_LPoint4i._type = LPoint4i::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LPoint4i);
  Dtool_LMatrix3f._type = LMatrix3f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LMatrix3f);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix3f::Row", Dtool_LMatrix3f_Row);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix3f::CRow", Dtool_LMatrix3f_CRow);
#endif
  Dtool_LMatrix4f._type = LMatrix4f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LMatrix4f);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix4f::Row", Dtool_LMatrix4f_Row);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix4f::CRow", Dtool_LMatrix4f_CRow);
#endif
  Dtool_UnalignedLMatrix4f._type = UnalignedLMatrix4f::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UnalignedLMatrix4f);
  Dtool_LMatrix3d._type = LMatrix3d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LMatrix3d);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix3d::Row", Dtool_LMatrix3d_Row);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix3d::CRow", Dtool_LMatrix3d_CRow);
#endif
  Dtool_LMatrix4d._type = LMatrix4d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LMatrix4d);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix4d::Row", Dtool_LMatrix4d_Row);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LMatrix4d::CRow", Dtool_LMatrix4d_CRow);
#endif
  Dtool_UnalignedLMatrix4d._type = UnalignedLMatrix4d::get_class_type();
  RegisterRuntimeTypedClass(Dtool_UnalignedLMatrix4d);
  Dtool_LQuaternionf._type = LQuaternionf::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LQuaternionf);
  Dtool_LQuaterniond._type = LQuaterniond::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LQuaterniond);
  Dtool_LRotationf._type = LRotationf::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LRotationf);
  Dtool_LRotationd._type = LRotationd::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LRotationd);
  Dtool_LOrientationf._type = LOrientationf::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LOrientationf);
  Dtool_LOrientationd._type = LOrientationd::get_class_type();
  RegisterRuntimeTypedClass(Dtool_LOrientationd);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableColor", Dtool_ConfigVariableColor);
#endif
}

void Dtool_libp3linmath_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_ConfigFlags = LookupNamedClass("ConfigFlags");
  Dtool_Ptr_ConfigVariableBase = LookupNamedClass("ConfigVariableBase");
  Dtool_Ptr_ConfigVariable = LookupNamedClass("ConfigVariable");
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_DatagramIterator = LookupRuntimeTypedClass(DatagramIterator::get_class_type());
#endif
}

void Dtool_libp3linmath_BuildInstants(PyObject *module) {
  (void) module;
  // enum CoordinateSystem
  PyModule_AddObject(module, "CS_default", Dtool_WrapValue(::CS_default));
  PyModule_AddObject(module, "CSDefault", Dtool_WrapValue(::CS_default));
  PyModule_AddObject(module, "CS_zup_right", Dtool_WrapValue(::CS_zup_right));
  PyModule_AddObject(module, "CSZupRight", Dtool_WrapValue(::CS_zup_right));
  PyModule_AddObject(module, "CS_yup_right", Dtool_WrapValue(::CS_yup_right));
  PyModule_AddObject(module, "CSYupRight", Dtool_WrapValue(::CS_yup_right));
  PyModule_AddObject(module, "CS_zup_left", Dtool_WrapValue(::CS_zup_left));
  PyModule_AddObject(module, "CSZupLeft", Dtool_WrapValue(::CS_zup_left));
  PyModule_AddObject(module, "CS_yup_left", Dtool_WrapValue(::CS_yup_left));
  PyModule_AddObject(module, "CSYupLeft", Dtool_WrapValue(::CS_yup_left));
  PyModule_AddObject(module, "CS_invalid", Dtool_WrapValue(::CS_invalid));
  PyModule_AddObject(module, "CSInvalid", Dtool_WrapValue(::CS_invalid));
  // MathNumbers
  Dtool_PyModuleClassInit_MathNumbers(module);
  PyModule_AddObject(module, "MathNumbers", (PyObject *)&Dtool_MathNumbers);
  // LVecBase2f
  Dtool_PyModuleClassInit_LVecBase2f(module);
  PyModule_AddObject(module, "LVecBase2f", (PyObject *)&Dtool_LVecBase2f);
  // LVecBase2d
  Dtool_PyModuleClassInit_LVecBase2d(module);
  PyModule_AddObject(module, "LVecBase2d", (PyObject *)&Dtool_LVecBase2d);
  // LVecBase2i
  Dtool_PyModuleClassInit_LVecBase2i(module);
  PyModule_AddObject(module, "LVecBase2i", (PyObject *)&Dtool_LVecBase2i);
  // LVector2f
  Dtool_PyModuleClassInit_LVector2f(module);
  PyModule_AddObject(module, "LVector2f", (PyObject *)&Dtool_LVector2f);
  // LVector2d
  Dtool_PyModuleClassInit_LVector2d(module);
  PyModule_AddObject(module, "LVector2d", (PyObject *)&Dtool_LVector2d);
  // LVector2i
  Dtool_PyModuleClassInit_LVector2i(module);
  PyModule_AddObject(module, "LVector2i", (PyObject *)&Dtool_LVector2i);
  // LPoint2f
  Dtool_PyModuleClassInit_LPoint2f(module);
  PyModule_AddObject(module, "LPoint2f", (PyObject *)&Dtool_LPoint2f);
  // LPoint2d
  Dtool_PyModuleClassInit_LPoint2d(module);
  PyModule_AddObject(module, "LPoint2d", (PyObject *)&Dtool_LPoint2d);
  // LPoint2i
  Dtool_PyModuleClassInit_LPoint2i(module);
  PyModule_AddObject(module, "LPoint2i", (PyObject *)&Dtool_LPoint2i);
  // LVecBase3f
  Dtool_PyModuleClassInit_LVecBase3f(module);
  PyModule_AddObject(module, "LVecBase3f", (PyObject *)&Dtool_LVecBase3f);
  // LVecBase3d
  Dtool_PyModuleClassInit_LVecBase3d(module);
  PyModule_AddObject(module, "LVecBase3d", (PyObject *)&Dtool_LVecBase3d);
  // LVecBase3i
  Dtool_PyModuleClassInit_LVecBase3i(module);
  PyModule_AddObject(module, "LVecBase3i", (PyObject *)&Dtool_LVecBase3i);
  // LVector3f
  Dtool_PyModuleClassInit_LVector3f(module);
  PyModule_AddObject(module, "LVector3f", (PyObject *)&Dtool_LVector3f);
  // LVector3d
  Dtool_PyModuleClassInit_LVector3d(module);
  PyModule_AddObject(module, "LVector3d", (PyObject *)&Dtool_LVector3d);
  // LVector3i
  Dtool_PyModuleClassInit_LVector3i(module);
  PyModule_AddObject(module, "LVector3i", (PyObject *)&Dtool_LVector3i);
  // LPoint3f
  Dtool_PyModuleClassInit_LPoint3f(module);
  PyModule_AddObject(module, "LPoint3f", (PyObject *)&Dtool_LPoint3f);
  // LPoint3d
  Dtool_PyModuleClassInit_LPoint3d(module);
  PyModule_AddObject(module, "LPoint3d", (PyObject *)&Dtool_LPoint3d);
  // LPoint3i
  Dtool_PyModuleClassInit_LPoint3i(module);
  PyModule_AddObject(module, "LPoint3i", (PyObject *)&Dtool_LPoint3i);
  // LVecBase4f
  Dtool_PyModuleClassInit_LVecBase4f(module);
  PyModule_AddObject(module, "LVecBase4f", (PyObject *)&Dtool_LVecBase4f);
  // UnalignedLVecBase4f
  Dtool_PyModuleClassInit_UnalignedLVecBase4f(module);
  PyModule_AddObject(module, "UnalignedLVecBase4f", (PyObject *)&Dtool_UnalignedLVecBase4f);
  // LVecBase4d
  Dtool_PyModuleClassInit_LVecBase4d(module);
  PyModule_AddObject(module, "LVecBase4d", (PyObject *)&Dtool_LVecBase4d);
  // UnalignedLVecBase4d
  Dtool_PyModuleClassInit_UnalignedLVecBase4d(module);
  PyModule_AddObject(module, "UnalignedLVecBase4d", (PyObject *)&Dtool_UnalignedLVecBase4d);
  // LVecBase4i
  Dtool_PyModuleClassInit_LVecBase4i(module);
  PyModule_AddObject(module, "LVecBase4i", (PyObject *)&Dtool_LVecBase4i);
  // UnalignedLVecBase4i
  Dtool_PyModuleClassInit_UnalignedLVecBase4i(module);
  PyModule_AddObject(module, "UnalignedLVecBase4i", (PyObject *)&Dtool_UnalignedLVecBase4i);
  // LVector4f
  Dtool_PyModuleClassInit_LVector4f(module);
  PyModule_AddObject(module, "LVector4f", (PyObject *)&Dtool_LVector4f);
  // LVector4d
  Dtool_PyModuleClassInit_LVector4d(module);
  PyModule_AddObject(module, "LVector4d", (PyObject *)&Dtool_LVector4d);
  // LVector4i
  Dtool_PyModuleClassInit_LVector4i(module);
  PyModule_AddObject(module, "LVector4i", (PyObject *)&Dtool_LVector4i);
  // LPoint4f
  Dtool_PyModuleClassInit_LPoint4f(module);
  PyModule_AddObject(module, "LPoint4f", (PyObject *)&Dtool_LPoint4f);
  // LPoint4d
  Dtool_PyModuleClassInit_LPoint4d(module);
  PyModule_AddObject(module, "LPoint4d", (PyObject *)&Dtool_LPoint4d);
  // LPoint4i
  Dtool_PyModuleClassInit_LPoint4i(module);
  PyModule_AddObject(module, "LPoint4i", (PyObject *)&Dtool_LPoint4i);
  // LMatrix3f
  Dtool_PyModuleClassInit_LMatrix3f(module);
  PyModule_AddObject(module, "LMatrix3f", (PyObject *)&Dtool_LMatrix3f);
  // LMatrix4f
  Dtool_PyModuleClassInit_LMatrix4f(module);
  PyModule_AddObject(module, "LMatrix4f", (PyObject *)&Dtool_LMatrix4f);
  // UnalignedLMatrix4f
  Dtool_PyModuleClassInit_UnalignedLMatrix4f(module);
  PyModule_AddObject(module, "UnalignedLMatrix4f", (PyObject *)&Dtool_UnalignedLMatrix4f);
  // LMatrix3d
  Dtool_PyModuleClassInit_LMatrix3d(module);
  PyModule_AddObject(module, "LMatrix3d", (PyObject *)&Dtool_LMatrix3d);
  // LMatrix4d
  Dtool_PyModuleClassInit_LMatrix4d(module);
  PyModule_AddObject(module, "LMatrix4d", (PyObject *)&Dtool_LMatrix4d);
  // UnalignedLMatrix4d
  Dtool_PyModuleClassInit_UnalignedLMatrix4d(module);
  PyModule_AddObject(module, "UnalignedLMatrix4d", (PyObject *)&Dtool_UnalignedLMatrix4d);
  // LQuaternionf
  Dtool_PyModuleClassInit_LQuaternionf(module);
  PyModule_AddObject(module, "LQuaternionf", (PyObject *)&Dtool_LQuaternionf);
  // LQuaterniond
  Dtool_PyModuleClassInit_LQuaterniond(module);
  PyModule_AddObject(module, "LQuaterniond", (PyObject *)&Dtool_LQuaterniond);
  // LRotationf
  Dtool_PyModuleClassInit_LRotationf(module);
  PyModule_AddObject(module, "LRotationf", (PyObject *)&Dtool_LRotationf);
  // LRotationd
  Dtool_PyModuleClassInit_LRotationd(module);
  PyModule_AddObject(module, "LRotationd", (PyObject *)&Dtool_LRotationd);
  // LOrientationf
  Dtool_PyModuleClassInit_LOrientationf(module);
  PyModule_AddObject(module, "LOrientationf", (PyObject *)&Dtool_LOrientationf);
  // LOrientationd
  Dtool_PyModuleClassInit_LOrientationd(module);
  PyModule_AddObject(module, "LOrientationd", (PyObject *)&Dtool_LOrientationd);
  // typedef LPoint3f LVertexf
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "LVertexf", (PyObject *)&Dtool_LPoint3f);
  // typedef LVector3f LNormalf
  Dtool_PyModuleClassInit_LVector3f(module);
  Py_INCREF((PyObject *)&Dtool_LVector3f);
  PyModule_AddObject(module, "LNormalf", (PyObject *)&Dtool_LVector3f);
  // typedef LPoint2f LTexCoordf
  Dtool_PyModuleClassInit_LPoint2f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2f);
  PyModule_AddObject(module, "LTexCoordf", (PyObject *)&Dtool_LPoint2f);
  // typedef LPoint3f LTexCoord3f
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "LTexCoord3f", (PyObject *)&Dtool_LPoint3f);
  // typedef LVecBase4f LColorf
  Dtool_PyModuleClassInit_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4f);
  PyModule_AddObject(module, "LColorf", (PyObject *)&Dtool_LVecBase4f);
  // typedef LVecBase3f LRGBColorf
  Dtool_PyModuleClassInit_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3f);
  PyModule_AddObject(module, "LRGBColorf", (PyObject *)&Dtool_LVecBase3f);
  // typedef LPoint3d LVertexd
  Dtool_PyModuleClassInit_LPoint3d(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3d);
  PyModule_AddObject(module, "LVertexd", (PyObject *)&Dtool_LPoint3d);
  // typedef LVector3d LNormald
  Dtool_PyModuleClassInit_LVector3d(module);
  Py_INCREF((PyObject *)&Dtool_LVector3d);
  PyModule_AddObject(module, "LNormald", (PyObject *)&Dtool_LVector3d);
  // typedef LPoint2d LTexCoordd
  Dtool_PyModuleClassInit_LPoint2d(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2d);
  PyModule_AddObject(module, "LTexCoordd", (PyObject *)&Dtool_LPoint2d);
  // typedef LPoint3d LTexCoord3d
  Dtool_PyModuleClassInit_LPoint3d(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3d);
  PyModule_AddObject(module, "LTexCoord3d", (PyObject *)&Dtool_LPoint3d);
  // typedef LVecBase4d LColord
  Dtool_PyModuleClassInit_LVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4d);
  PyModule_AddObject(module, "LColord", (PyObject *)&Dtool_LVecBase4d);
  // typedef LVecBase3d LRGBColord
  Dtool_PyModuleClassInit_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3d);
  PyModule_AddObject(module, "LRGBColord", (PyObject *)&Dtool_LVecBase3d);
  // typedef LMatrix4f Mat4F
  Dtool_PyModuleClassInit_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix4f);
  PyModule_AddObject(module, "Mat4F", (PyObject *)&Dtool_LMatrix4f);
  // typedef LMatrix3f Mat3F
  Dtool_PyModuleClassInit_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix3f);
  PyModule_AddObject(module, "Mat3F", (PyObject *)&Dtool_LMatrix3f);
  // typedef LVecBase4f VBase4F
  Dtool_PyModuleClassInit_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4f);
  PyModule_AddObject(module, "VBase4F", (PyObject *)&Dtool_LVecBase4f);
  // typedef LVector4f Vec4F
  Dtool_PyModuleClassInit_LVector4f(module);
  Py_INCREF((PyObject *)&Dtool_LVector4f);
  PyModule_AddObject(module, "Vec4F", (PyObject *)&Dtool_LVector4f);
  // typedef LPoint4f Point4F
  Dtool_PyModuleClassInit_LPoint4f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint4f);
  PyModule_AddObject(module, "Point4F", (PyObject *)&Dtool_LPoint4f);
  // typedef LVecBase3f VBase3F
  Dtool_PyModuleClassInit_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3f);
  PyModule_AddObject(module, "VBase3F", (PyObject *)&Dtool_LVecBase3f);
  // typedef LVector3f Vec3F
  Dtool_PyModuleClassInit_LVector3f(module);
  Py_INCREF((PyObject *)&Dtool_LVector3f);
  PyModule_AddObject(module, "Vec3F", (PyObject *)&Dtool_LVector3f);
  // typedef LPoint3f Point3F
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "Point3F", (PyObject *)&Dtool_LPoint3f);
  // typedef LVecBase2f VBase2F
  Dtool_PyModuleClassInit_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase2f);
  PyModule_AddObject(module, "VBase2F", (PyObject *)&Dtool_LVecBase2f);
  // typedef LVector2f Vec2F
  Dtool_PyModuleClassInit_LVector2f(module);
  Py_INCREF((PyObject *)&Dtool_LVector2f);
  PyModule_AddObject(module, "Vec2F", (PyObject *)&Dtool_LVector2f);
  // typedef LPoint2f Point2F
  Dtool_PyModuleClassInit_LPoint2f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2f);
  PyModule_AddObject(module, "Point2F", (PyObject *)&Dtool_LPoint2f);
  // typedef LQuaternionf QuatF
  Dtool_PyModuleClassInit_LQuaternionf(module);
  Py_INCREF((PyObject *)&Dtool_LQuaternionf);
  PyModule_AddObject(module, "QuatF", (PyObject *)&Dtool_LQuaternionf);
  // typedef LMatrix4d Mat4D
  Dtool_PyModuleClassInit_LMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix4d);
  PyModule_AddObject(module, "Mat4D", (PyObject *)&Dtool_LMatrix4d);
  // typedef LMatrix3d Mat3D
  Dtool_PyModuleClassInit_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix3d);
  PyModule_AddObject(module, "Mat3D", (PyObject *)&Dtool_LMatrix3d);
  // typedef LVecBase4d VBase4D
  Dtool_PyModuleClassInit_LVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4d);
  PyModule_AddObject(module, "VBase4D", (PyObject *)&Dtool_LVecBase4d);
  // typedef LVector4d Vec4D
  Dtool_PyModuleClassInit_LVector4d(module);
  Py_INCREF((PyObject *)&Dtool_LVector4d);
  PyModule_AddObject(module, "Vec4D", (PyObject *)&Dtool_LVector4d);
  // typedef LPoint4d Point4D
  Dtool_PyModuleClassInit_LPoint4d(module);
  Py_INCREF((PyObject *)&Dtool_LPoint4d);
  PyModule_AddObject(module, "Point4D", (PyObject *)&Dtool_LPoint4d);
  // typedef LVecBase3d VBase3D
  Dtool_PyModuleClassInit_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3d);
  PyModule_AddObject(module, "VBase3D", (PyObject *)&Dtool_LVecBase3d);
  // typedef LVector3d Vec3D
  Dtool_PyModuleClassInit_LVector3d(module);
  Py_INCREF((PyObject *)&Dtool_LVector3d);
  PyModule_AddObject(module, "Vec3D", (PyObject *)&Dtool_LVector3d);
  // typedef LPoint3d Point3D
  Dtool_PyModuleClassInit_LPoint3d(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3d);
  PyModule_AddObject(module, "Point3D", (PyObject *)&Dtool_LPoint3d);
  // typedef LVecBase2d VBase2D
  Dtool_PyModuleClassInit_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase2d);
  PyModule_AddObject(module, "VBase2D", (PyObject *)&Dtool_LVecBase2d);
  // typedef LVector2d Vec2D
  Dtool_PyModuleClassInit_LVector2d(module);
  Py_INCREF((PyObject *)&Dtool_LVector2d);
  PyModule_AddObject(module, "Vec2D", (PyObject *)&Dtool_LVector2d);
  // typedef LPoint2d Point2D
  Dtool_PyModuleClassInit_LPoint2d(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2d);
  PyModule_AddObject(module, "Point2D", (PyObject *)&Dtool_LPoint2d);
  // typedef LQuaterniond QuatD
  Dtool_PyModuleClassInit_LQuaterniond(module);
  Py_INCREF((PyObject *)&Dtool_LQuaterniond);
  PyModule_AddObject(module, "QuatD", (PyObject *)&Dtool_LQuaterniond);
  // typedef LVecBase2f LVecBase2
  Dtool_PyModuleClassInit_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase2f);
  PyModule_AddObject(module, "LVecBase2", (PyObject *)&Dtool_LVecBase2f);
  // typedef LPoint2f LPoint2
  Dtool_PyModuleClassInit_LPoint2f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2f);
  PyModule_AddObject(module, "LPoint2", (PyObject *)&Dtool_LPoint2f);
  // typedef LVector2f LVector2
  Dtool_PyModuleClassInit_LVector2f(module);
  Py_INCREF((PyObject *)&Dtool_LVector2f);
  PyModule_AddObject(module, "LVector2", (PyObject *)&Dtool_LVector2f);
  // typedef LVecBase3f LVecBase3
  Dtool_PyModuleClassInit_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3f);
  PyModule_AddObject(module, "LVecBase3", (PyObject *)&Dtool_LVecBase3f);
  // typedef LPoint3f LPoint3
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "LPoint3", (PyObject *)&Dtool_LPoint3f);
  // typedef LVector3f LVector3
  Dtool_PyModuleClassInit_LVector3f(module);
  Py_INCREF((PyObject *)&Dtool_LVector3f);
  PyModule_AddObject(module, "LVector3", (PyObject *)&Dtool_LVector3f);
  // typedef LVecBase4f LVecBase4
  Dtool_PyModuleClassInit_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4f);
  PyModule_AddObject(module, "LVecBase4", (PyObject *)&Dtool_LVecBase4f);
  // typedef LPoint4f LPoint4
  Dtool_PyModuleClassInit_LPoint4f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint4f);
  PyModule_AddObject(module, "LPoint4", (PyObject *)&Dtool_LPoint4f);
  // typedef LVector4f LVector4
  Dtool_PyModuleClassInit_LVector4f(module);
  Py_INCREF((PyObject *)&Dtool_LVector4f);
  PyModule_AddObject(module, "LVector4", (PyObject *)&Dtool_LVector4f);
  // typedef LQuaternionf LQuaternion
  Dtool_PyModuleClassInit_LQuaternionf(module);
  Py_INCREF((PyObject *)&Dtool_LQuaternionf);
  PyModule_AddObject(module, "LQuaternion", (PyObject *)&Dtool_LQuaternionf);
  // typedef LRotationf LRotation
  Dtool_PyModuleClassInit_LRotationf(module);
  Py_INCREF((PyObject *)&Dtool_LRotationf);
  PyModule_AddObject(module, "LRotation", (PyObject *)&Dtool_LRotationf);
  // typedef LOrientationf LOrientation
  Dtool_PyModuleClassInit_LOrientationf(module);
  Py_INCREF((PyObject *)&Dtool_LOrientationf);
  PyModule_AddObject(module, "LOrientation", (PyObject *)&Dtool_LOrientationf);
  // typedef LMatrix3f LMatrix3
  Dtool_PyModuleClassInit_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix3f);
  PyModule_AddObject(module, "LMatrix3", (PyObject *)&Dtool_LMatrix3f);
  // typedef LMatrix4f LMatrix4
  Dtool_PyModuleClassInit_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix4f);
  PyModule_AddObject(module, "LMatrix4", (PyObject *)&Dtool_LMatrix4f);
  // typedef LPoint3f LVertex
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "LVertex", (PyObject *)&Dtool_LPoint3f);
  // typedef LVector3f LNormal
  Dtool_PyModuleClassInit_LVector3f(module);
  Py_INCREF((PyObject *)&Dtool_LVector3f);
  PyModule_AddObject(module, "LNormal", (PyObject *)&Dtool_LVector3f);
  // typedef LPoint2f LTexCoord
  Dtool_PyModuleClassInit_LPoint2f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2f);
  PyModule_AddObject(module, "LTexCoord", (PyObject *)&Dtool_LPoint2f);
  // typedef LPoint3f LTexCoord3
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "LTexCoord3", (PyObject *)&Dtool_LPoint3f);
  // typedef LVecBase4f LColor
  Dtool_PyModuleClassInit_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4f);
  PyModule_AddObject(module, "LColor", (PyObject *)&Dtool_LVecBase4f);
  // typedef LVecBase3f LRGBColor
  Dtool_PyModuleClassInit_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3f);
  PyModule_AddObject(module, "LRGBColor", (PyObject *)&Dtool_LVecBase3f);
  // typedef UnalignedLVecBase4f UnalignedLVecBase4
  Dtool_PyModuleClassInit_UnalignedLVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_UnalignedLVecBase4f);
  PyModule_AddObject(module, "UnalignedLVecBase4", (PyObject *)&Dtool_UnalignedLVecBase4f);
  // typedef UnalignedLMatrix4f UnalignedLMatrix4
  Dtool_PyModuleClassInit_UnalignedLMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_UnalignedLMatrix4f);
  PyModule_AddObject(module, "UnalignedLMatrix4", (PyObject *)&Dtool_UnalignedLMatrix4f);
  // typedef LMatrix4f Mat4
  Dtool_PyModuleClassInit_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix4f);
  PyModule_AddObject(module, "Mat4", (PyObject *)&Dtool_LMatrix4f);
  // typedef LMatrix3f Mat3
  Dtool_PyModuleClassInit_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_LMatrix3f);
  PyModule_AddObject(module, "Mat3", (PyObject *)&Dtool_LMatrix3f);
  // typedef LVecBase4f VBase4
  Dtool_PyModuleClassInit_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase4f);
  PyModule_AddObject(module, "VBase4", (PyObject *)&Dtool_LVecBase4f);
  // typedef LVector4f Vec4
  Dtool_PyModuleClassInit_LVector4f(module);
  Py_INCREF((PyObject *)&Dtool_LVector4f);
  PyModule_AddObject(module, "Vec4", (PyObject *)&Dtool_LVector4f);
  // typedef LPoint4f Point4
  Dtool_PyModuleClassInit_LPoint4f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint4f);
  PyModule_AddObject(module, "Point4", (PyObject *)&Dtool_LPoint4f);
  // typedef LVecBase3f VBase3
  Dtool_PyModuleClassInit_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase3f);
  PyModule_AddObject(module, "VBase3", (PyObject *)&Dtool_LVecBase3f);
  // typedef LVector3f Vec3
  Dtool_PyModuleClassInit_LVector3f(module);
  Py_INCREF((PyObject *)&Dtool_LVector3f);
  PyModule_AddObject(module, "Vec3", (PyObject *)&Dtool_LVector3f);
  // typedef LPoint3f Point3
  Dtool_PyModuleClassInit_LPoint3f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint3f);
  PyModule_AddObject(module, "Point3", (PyObject *)&Dtool_LPoint3f);
  // typedef LVecBase2f VBase2
  Dtool_PyModuleClassInit_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_LVecBase2f);
  PyModule_AddObject(module, "VBase2", (PyObject *)&Dtool_LVecBase2f);
  // typedef LVector2f Vec2
  Dtool_PyModuleClassInit_LVector2f(module);
  Py_INCREF((PyObject *)&Dtool_LVector2f);
  PyModule_AddObject(module, "Vec2", (PyObject *)&Dtool_LVector2f);
  // typedef LPoint2f Point2
  Dtool_PyModuleClassInit_LPoint2f(module);
  Py_INCREF((PyObject *)&Dtool_LPoint2f);
  PyModule_AddObject(module, "Point2", (PyObject *)&Dtool_LPoint2f);
  // typedef LQuaternionf Quat
  Dtool_PyModuleClassInit_LQuaternionf(module);
  Py_INCREF((PyObject *)&Dtool_LQuaternionf);
  PyModule_AddObject(module, "Quat", (PyObject *)&Dtool_LQuaternionf);
  // ConfigVariableColor
  Dtool_PyModuleClassInit_ConfigVariableColor(module);
  PyModule_AddObject(module, "ConfigVariableColor", (PyObject *)&Dtool_ConfigVariableColor);
}

static PyMethodDef python_simple_funcs[] = {
  {"deg_2_rad", &Dtool_deg_2_rad_4, METH_O, (const char *)Dtool_deg_2_rad_4_comment},
  {"deg2Rad", &Dtool_deg_2_rad_4, METH_O, (const char *)Dtool_deg_2_rad_4_comment},
  {"rad_2_deg", &Dtool_rad_2_deg_5, METH_O, (const char *)Dtool_rad_2_deg_5_comment},
  {"rad2Deg", &Dtool_rad_2_deg_5, METH_O, (const char *)Dtool_rad_2_deg_5_comment},
  {"get_default_coordinate_system", &Dtool_get_default_coordinate_system_547, METH_NOARGS, (const char *)Dtool_get_default_coordinate_system_547_comment},
  {"getDefaultCoordinateSystem", &Dtool_get_default_coordinate_system_547, METH_NOARGS, (const char *)Dtool_get_default_coordinate_system_547_comment},
  {"parse_coordinate_system_string", &Dtool_parse_coordinate_system_string_548, METH_O, (const char *)Dtool_parse_coordinate_system_string_548_comment},
  {"parseCoordinateSystemString", &Dtool_parse_coordinate_system_string_548, METH_O, (const char *)Dtool_parse_coordinate_system_string_548_comment},
  {"format_coordinate_system", &Dtool_format_coordinate_system_549, METH_O, (const char *)Dtool_format_coordinate_system_549_comment},
  {"formatCoordinateSystem", &Dtool_format_coordinate_system_549, METH_O, (const char *)Dtool_format_coordinate_system_549_comment},
  {"is_right_handed", (PyCFunction) &Dtool_is_right_handed_550, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_is_right_handed_550_comment},
  {"isRightHanded", (PyCFunction) &Dtool_is_right_handed_550, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_is_right_handed_550_comment},
  {"transpose", &Dtool_transpose_1233, METH_O, (const char *)Dtool_transpose_1233_comment},
  {"invert", &Dtool_invert_1234, METH_O, (const char *)Dtool_invert_1234_comment},
  {"__mul__", (PyCFunction) &Dtool_operator_1555, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_operator_1555_comment},
  {"__imul__", (PyCFunction) &Dtool_operator_1556, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_operator_1556_comment},
  {"generic_write_datagram", (PyCFunction) &Dtool_generic_write_datagram_1557, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_generic_write_datagram_1557_comment},
  {"genericWriteDatagram", (PyCFunction) &Dtool_generic_write_datagram_1557, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_generic_write_datagram_1557_comment},
  {"generic_read_datagram", (PyCFunction) &Dtool_generic_read_datagram_1558, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_generic_read_datagram_1558_comment},
  {"genericReadDatagram", (PyCFunction) &Dtool_generic_read_datagram_1558, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_generic_read_datagram_1558_comment},
  {"compose_matrix", (PyCFunction) &Dtool_compose_matrix_1559, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compose_matrix_1559_comment},
  {"composeMatrix", (PyCFunction) &Dtool_compose_matrix_1559, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compose_matrix_1559_comment},
  {"decompose_matrix", (PyCFunction) &Dtool_decompose_matrix_1560, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompose_matrix_1560_comment},
  {"decomposeMatrix", (PyCFunction) &Dtool_decompose_matrix_1560, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompose_matrix_1560_comment},
  {"decompose_matrix_old_hpr", (PyCFunction) &Dtool_decompose_matrix_old_hpr_1561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompose_matrix_old_hpr_1561_comment},
  {"decomposeMatrixOldHpr", (PyCFunction) &Dtool_decompose_matrix_old_hpr_1561, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompose_matrix_old_hpr_1561_comment},
  {"old_to_new_hpr", &Dtool_old_to_new_hpr_1562, METH_O, (const char *)Dtool_old_to_new_hpr_1562_comment},
  {"oldToNewHpr", &Dtool_old_to_new_hpr_1562, METH_O, (const char *)Dtool_old_to_new_hpr_1562_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3linmath_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478209841,  /* file_identifier */
  "libp3linmath",  /* library_name */
  "Ns0b",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3linmath.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  3882  /* next_index */
};

Configure(_in_configure_libp3linmath);
ConfigureFn(_in_configure_libp3linmath) {
  interrogate_request_module(&_in_module_def);
}

