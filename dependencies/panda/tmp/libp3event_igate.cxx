/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/event -Ipanda/src/event -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3event_igate.cxx -od built/pandac/input/libp3event.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/event -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3event asyncTask.h asyncTaskChain.h asyncTaskCollection.h asyncTaskManager.h asyncTaskPause.h asyncTaskSequence.h buttonEvent.h buttonEventList.h config_event.h event.h eventHandler.h eventParameter.h eventQueue.h eventReceiver.h genericAsyncTask.h p3event_composite1.cxx p3event_composite2.cxx pointerEvent.h pointerEventList.h pt_Event.h pythonTask.h throw_event.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3event
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "asyncTask.h"
#include "asyncTaskBase.h"
#include "asyncTaskChain.h"
#include "asyncTaskCollection.h"
#include "asyncTaskManager.h"
#include "asyncTaskPause.h"
#include "asyncTaskSequence.h"
#include "buttonEvent.h"
#include "buttonEventList.h"
#include "buttonHandle.h"
#include "clockObject.h"
#include "conditionVar.h"
#include "conditionVarFull.h"
#include "config_event.h"
#include "event.h"
#include "eventHandler.h"
#include "eventParameter.h"
#include "eventQueue.h"
#include "eventReceiver.h"
#include "genericAsyncTask.h"
#include "indirectCompareNames.h"
#include "lightMutex.h"
#include "modifierButtons.h"
#include "mutexHolder.h"
#include "notifyCategoryProxy.h"
#include "ordered_vector.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "pdeque.h"
#include "pmap.h"
#include "pmutex.h"
#include "pointerEvent.h"
#include "pointerEventList.h"
#include "pset.h"
#include "pt_Event.h"
#include "pvector.h"
#include "py_panda.h"
#include "pythonTask.h"
#include "thread.h"
#include "throw_event.h"
#include "typedObject.h"
#include "typedReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AsyncTask
 */
typedef AsyncTask AsyncTask_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTask, AsyncTask_localtype, AsyncTask);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
static void Dtool_PyModuleClassInit_AsyncTask(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskCollection
 */
typedef AsyncTaskCollection AsyncTaskCollection_localtype;
Define_Module_Class(panda3d.core, AsyncTaskCollection, AsyncTaskCollection_localtype, AsyncTaskCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskCollection = &Dtool_AsyncTaskCollection;
static void Dtool_PyModuleClassInit_AsyncTaskCollection(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskChain
 */
typedef AsyncTaskChain AsyncTaskChain_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskChain, AsyncTaskChain_localtype, AsyncTaskChain);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskChain = &Dtool_AsyncTaskChain;
static void Dtool_PyModuleClassInit_AsyncTaskChain(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskManager
 */
typedef AsyncTaskManager AsyncTaskManager_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskManager, AsyncTaskManager_localtype, AsyncTaskManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskManager = &Dtool_AsyncTaskManager;
static void Dtool_PyModuleClassInit_AsyncTaskManager(PyObject *module);
bool Dtool_ConstCoerce_AsyncTaskManager(PyObject *args, CPT(AsyncTaskManager) &coerced);
bool Dtool_Coerce_AsyncTaskManager(PyObject *args, PT(AsyncTaskManager) &coerced);

/**
 * Forward declarations for top-level class AsyncTaskPause
 */
typedef AsyncTaskPause AsyncTaskPause_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskPause, AsyncTaskPause_localtype, AsyncTaskPause);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskPause = &Dtool_AsyncTaskPause;
static void Dtool_PyModuleClassInit_AsyncTaskPause(PyObject *module);
bool Dtool_ConstCoerce_AsyncTaskPause(PyObject *args, CPT(AsyncTaskPause) &coerced);
bool Dtool_Coerce_AsyncTaskPause(PyObject *args, PT(AsyncTaskPause) &coerced);

/**
 * Forward declarations for top-level class AsyncTaskSequence
 */
typedef AsyncTaskSequence AsyncTaskSequence_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskSequence, AsyncTaskSequence_localtype, AsyncTaskSequence);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskSequence = &Dtool_AsyncTaskSequence;
static void Dtool_PyModuleClassInit_AsyncTaskSequence(PyObject *module);
bool Dtool_ConstCoerce_AsyncTaskSequence(PyObject *args, CPT(AsyncTaskSequence) &coerced);
bool Dtool_Coerce_AsyncTaskSequence(PyObject *args, PT(AsyncTaskSequence) &coerced);

/**
 * Forward declarations for top-level class EventParameter
 */
typedef EventParameter EventParameter_localtype;
Define_Module_Class(panda3d.core, EventParameter, EventParameter_localtype, EventParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventParameter = &Dtool_EventParameter;
static void Dtool_PyModuleClassInit_EventParameter(PyObject *module);
bool Dtool_ConstCoerce_EventParameter(PyObject *args, EventParameter const *&coerced, bool &manage);
bool Dtool_Coerce_EventParameter(PyObject *args, EventParameter *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Event
 */
typedef Event Event_localtype;
Define_Module_ClassRef(panda3d.core, Event, Event_localtype, Event);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Event = &Dtool_Event;
static void Dtool_PyModuleClassInit_Event(PyObject *module);
bool Dtool_ConstCoerce_Event(PyObject *args, CPT(Event) &coerced);
bool Dtool_Coerce_Event(PyObject *args, PT(Event) &coerced);

/**
 * Forward declarations for top-level class EventHandler
 */
typedef EventHandler EventHandler_localtype;
Define_Module_Class(panda3d.core, EventHandler, EventHandler_localtype, EventHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventHandler = &Dtool_EventHandler;
static void Dtool_PyModuleClassInit_EventHandler(PyObject *module);
bool Dtool_ConstCoerce_EventHandler(PyObject *args, EventHandler const *&coerced, bool &manage);
bool Dtool_Coerce_EventHandler(PyObject *args, EventHandler *&coerced, bool &manage);

/**
 * Forward declarations for top-level class EventQueue
 */
typedef EventQueue EventQueue_localtype;
Define_Module_Class(panda3d.core, EventQueue, EventQueue_localtype, EventQueue);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventQueue = &Dtool_EventQueue;
static void Dtool_PyModuleClassInit_EventQueue(PyObject *module);

/**
 * Forward declarations for top-level class PointerEventList
 */
typedef PointerEventList PointerEventList_localtype;
Define_Module_ClassRef(panda3d.core, PointerEventList, PointerEventList_localtype, PointerEventList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerEventList = &Dtool_PointerEventList;
static void Dtool_PyModuleClassInit_PointerEventList(PyObject *module);

/**
 * Forward declarations for top-level class PythonTask
 */
typedef PythonTask PythonTask_localtype;
Define_Module_ClassRef(panda3d.core, PythonTask, PythonTask_localtype, PythonTask);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PythonTask = &Dtool_PythonTask;
static void Dtool_PyModuleClassInit_PythonTask(PyObject *module);
bool Dtool_ConstCoerce_PythonTask(PyObject *args, CPT(PythonTask) &coerced);
bool Dtool_Coerce_PythonTask(PyObject *args, PT(PythonTask) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// GlobPattern
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GlobPattern;
inline static bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_GlobPattern != NULL, false);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, GlobPattern const *&, bool&))Dtool_Ptr_GlobPattern->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_GlobPattern != NULL, false);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, GlobPattern *&, bool&))Dtool_Ptr_GlobPattern->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_GlobPattern;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
extern bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage);
extern bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// AsyncTaskBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AsyncTaskBase;
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTaskBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskBase = &Dtool_AsyncTaskBase;
#endif
// ClockObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ClockObject;
#else
extern struct Dtool_PyTypedObject Dtool_ClockObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClockObject = &Dtool_ClockObject;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// ParamValueBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ParamValueBase;
#else
extern struct Dtool_PyTypedObject Dtool_ParamValueBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValueBase = &Dtool_ParamValueBase;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class AsyncTask
 */
/**
 * Python function wrapper for:
 * inline AsyncTask::State AsyncTask::get_state(void) const
 */
static PyObject *Dtool_AsyncTask_get_state_5(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AsyncTask::State AsyncTask::get_state(void) const
  AsyncTask::State return_value = (*(const AsyncTask*)local_this).get_state();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_state_5_comment =
  "C++ Interface:\n"
  "get_state(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the task.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_state_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncTask::is_alive(void) const
 */
static PyObject *Dtool_AsyncTask_is_alive_6(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AsyncTask::is_alive(void) const
  bool return_value = (*(const AsyncTask*)local_this).is_alive();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_is_alive_6_comment =
  "C++ Interface:\n"
  "is_alive(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns true if the task is currently active or sleeping on some task\n"
  " * chain, meaning that it will be executed in its turn, or false if it is not\n"
  " * active.  If the task has recently been removed while it is in the middle of\n"
  " * execution, this will return false, because the task will not run again once\n"
  " * it finishes.\n"
  " */";
#else
static const char *Dtool_AsyncTask_is_alive_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskManager *AsyncTask::get_manager(void) const
 */
static PyObject *Dtool_AsyncTask_get_manager_7(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AsyncTaskManager *AsyncTask::get_manager(void) const
  AsyncTaskManager *return_value = (*(const AsyncTask*)local_this).get_manager();
  if (return_value != (AsyncTaskManager *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AsyncTaskManager *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_manager_7_comment =
  "C++ Interface:\n"
  "get_manager(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the AsyncTaskManager that this task is active on.  This will be\n"
  " * NULL if the state is S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_manager_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::remove(void)
 */
static PyObject *Dtool_AsyncTask_remove_8(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.remove")) {
    return NULL;
  }
  // 1-void AsyncTask::remove(void)
  (*local_this).remove();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_remove_8_comment =
  "C++ Interface:\n"
  "remove(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Removes the task from its active manager, if any, and makes the state\n"
  " * S_inactive (or possible S_servicing_removed).  This is a no-op if the state\n"
  " * is already S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_remove_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::set_delay(double delay)
 */
static PyObject *Dtool_AsyncTask_set_delay_9(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_delay")) {
    return NULL;
  }
  // 1-inline void AsyncTask::set_delay(double delay)
  if (PyNumber_Check(arg)) {
    (*local_this).set_delay(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_delay(const AsyncTask self, double delay)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_delay_9_comment =
  "C++ Interface:\n"
  "set_delay(const AsyncTask self, double delay)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of time, in seconds, by which this task will be\n"
  " * delayed after it has been added to the AsyncTaskManager.  At least the\n"
  " * specified amount of time (and possibly more) will elapse before the task\n"
  " * begins.\n"
  " *\n"
  " * You may specify a delay of 0.0 to guarantee that the task will run in the\n"
  " * next epoch following the one in which it is added.\n"
  " *\n"
  " * Setting this value after the task has already been added will not affect\n"
  " * the task's wake time; it will only affect the task if it is re-added to the\n"
  " * queue in the future, for instance if the task returns DS_again.  However,\n"
  " * see recalc_wake_time() if you wish to apply the delay effect immediately.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_delay_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::clear_delay(void)
 */
static PyObject *Dtool_AsyncTask_clear_delay_10(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.clear_delay")) {
    return NULL;
  }
  // 1-inline void AsyncTask::clear_delay(void)
  (*local_this).clear_delay();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_clear_delay_10_comment =
  "C++ Interface:\n"
  "clear_delay(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Removes any delay specified for the task.  The next time the task is added\n"
  " * to the queue, it will run immediately.  This does not affect the task's\n"
  " * wake time if it has already been added to the queue.\n"
  " */";
#else
static const char *Dtool_AsyncTask_clear_delay_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncTask::has_delay(void) const
 */
static PyObject *Dtool_AsyncTask_has_delay_11(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AsyncTask::has_delay(void) const
  bool return_value = (*(const AsyncTask*)local_this).has_delay();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_has_delay_11_comment =
  "C++ Interface:\n"
  "has_delay(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns true if a delay has been set for this task via set_delay(), or\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTask_has_delay_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_delay(void) const
 */
static PyObject *Dtool_AsyncTask_get_delay_12(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AsyncTask::get_delay(void) const
  double return_value = (*(const AsyncTask*)local_this).get_delay();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_delay_12_comment =
  "C++ Interface:\n"
  "get_delay(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the delay value that has been set via set_delay, if any.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_delay_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double AsyncTask::get_wake_time(void) const
 */
static PyObject *Dtool_AsyncTask_get_wake_time_13(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-double AsyncTask::get_wake_time(void) const
  double return_value = (*(const AsyncTask*)local_this).get_wake_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_wake_time_13_comment =
  "C++ Interface:\n"
  "get_wake_time(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * If this task has been added to an AsyncTaskManager with a delay in effect,\n"
  " * this returns the time at which the task is expected to awaken.  It has no\n"
  " * meaning if the task has not yet been added to a queue, or if there was no\n"
  " * delay in effect at the time the task was added.\n"
  " *\n"
  " * If the task's status is not S_sleeping, this returns 0.0.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_wake_time_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::recalc_wake_time(void)
 */
static PyObject *Dtool_AsyncTask_recalc_wake_time_14(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.recalc_wake_time")) {
    return NULL;
  }
  // 1-void AsyncTask::recalc_wake_time(void)
  (*local_this).recalc_wake_time();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_recalc_wake_time_14_comment =
  "C++ Interface:\n"
  "recalc_wake_time(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * If the task is currently sleeping on a task chain, this resets its wake\n"
  " * time to the current time + get_delay().  It is as if the task had suddenly\n"
  " * returned DS_again.  The task will sleep for its current delay seconds\n"
  " * before running again.  This method may therefore be used to make the task\n"
  " * wake up sooner or later than it would have otherwise.\n"
  " *\n"
  " * If the task is not already sleeping, this method has no effect.\n"
  " */";
#else
static const char *Dtool_AsyncTask_recalc_wake_time_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_start_time(void) const
 */
static PyObject *Dtool_AsyncTask_get_start_time_15(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AsyncTask::get_start_time(void) const
  double return_value = (*(const AsyncTask*)local_this).get_start_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_start_time_15_comment =
  "C++ Interface:\n"
  "get_start_time(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the time at which the task was started, according to the task\n"
  " * manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_start_time_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double AsyncTask::get_elapsed_time(void) const
 */
static PyObject *Dtool_AsyncTask_get_elapsed_time_16(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-double AsyncTask::get_elapsed_time(void) const
  double return_value = (*(const AsyncTask*)local_this).get_elapsed_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_elapsed_time_16_comment =
  "C++ Interface:\n"
  "get_elapsed_time(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time that has elapsed since the task was started,\n"
  " * according to the task manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_elapsed_time_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTask::get_start_frame(void) const
 */
static PyObject *Dtool_AsyncTask_get_start_frame_17(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AsyncTask::get_start_frame(void) const
  int return_value = (*(const AsyncTask*)local_this).get_start_frame();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_start_frame_17_comment =
  "C++ Interface:\n"
  "get_start_frame(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the frame number at which the task was started, according to the\n"
  " * task manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_start_frame_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AsyncTask::get_elapsed_frames(void) const
 */
static PyObject *Dtool_AsyncTask_get_elapsed_frames_18(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AsyncTask::get_elapsed_frames(void) const
  int return_value = (*(const AsyncTask*)local_this).get_elapsed_frames();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_elapsed_frames_18_comment =
  "C++ Interface:\n"
  "get_elapsed_frames(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames that have elapsed since the task was started,\n"
  " * according to the task manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_elapsed_frames_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_name(std::string const &name)
 */
static PyObject *Dtool_AsyncTask_set_name_19(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_name")) {
    return NULL;
  }
  // 1-void AsyncTask::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const AsyncTask self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_name_19_comment =
  "C++ Interface:\n"
  "set_name(const AsyncTask self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_name_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::clear_name(void)
 */
static PyObject *Dtool_AsyncTask_clear_name_20(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.clear_name")) {
    return NULL;
  }
  // 1-inline void AsyncTask::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_clear_name_20_comment =
  "C++ Interface:\n"
  "clear_name(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Resets the task's name to empty.\n"
  " */";
#else
static const char *Dtool_AsyncTask_clear_name_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string AsyncTask::get_name_prefix(void) const
 */
static PyObject *Dtool_AsyncTask_get_name_prefix_21(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string AsyncTask::get_name_prefix(void) const
  std::string return_value = (*(const AsyncTask*)local_this).get_name_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_name_prefix_21_comment =
  "C++ Interface:\n"
  "get_name_prefix(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the initial part of the name, up to but not including any trailing\n"
  " * digits following a hyphen or underscore.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_name_prefix_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const
 */
static PyObject *Dtool_AsyncTask_get_task_id_22(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const
  AtomicAdjust::Integer return_value = (*(const AsyncTask*)local_this).get_task_id();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_task_id_22_comment =
  "C++ Interface:\n"
  "get_task_id(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns a number guaranteed to be unique for each different AsyncTask\n"
  " * object in the universe.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_task_id_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_task_chain(std::string const &chain_name)
 */
static PyObject *Dtool_AsyncTask_set_task_chain_23(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_task_chain")) {
    return NULL;
  }
  // 1-void AsyncTask::set_task_chain(std::string const &chain_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_task_chain(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_task_chain(const AsyncTask self, str chain_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_task_chain_23_comment =
  "C++ Interface:\n"
  "set_task_chain(const AsyncTask self, str chain_name)\n"
  "\n"
  "/**\n"
  " * Specifies the AsyncTaskChain on which this task will be running.  Each task\n"
  " * chain runs tasks independently of the others.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_task_chain_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &AsyncTask::get_task_chain(void) const
 */
static PyObject *Dtool_AsyncTask_get_task_chain_24(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &AsyncTask::get_task_chain(void) const
  std::string const &return_value = (*(const AsyncTask*)local_this).get_task_chain();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_task_chain_24_comment =
  "C++ Interface:\n"
  "get_task_chain(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the AsyncTaskChain on which this task will be running.  Each task\n"
  " * chain runs tasks independently of the others.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_task_chain_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_sort(int sort)
 */
static PyObject *Dtool_AsyncTask_set_sort_25(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_sort")) {
    return NULL;
  }
  // 1-void AsyncTask::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_sort((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const AsyncTask self, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_sort_25_comment =
  "C++ Interface:\n"
  "set_sort(const AsyncTask self, int sort)\n"
  "\n"
  "/**\n"
  " * Specifies a sort value for this task.  Within a given AsyncTaskManager, all\n"
  " * of the tasks with a given sort value are guaranteed to be completed before\n"
  " * any tasks with a higher sort value are begun.\n"
  " *\n"
  " * To put it another way, two tasks might execute in parallel with each other\n"
  " * only if they both have the same sort value.  Tasks with a lower sort value\n"
  " * are executed first.\n"
  " *\n"
  " * This is different from the priority, which makes no such exclusion\n"
  " * guarantees.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_sort_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTask::get_sort(void) const
 */
static PyObject *Dtool_AsyncTask_get_sort_26(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AsyncTask::get_sort(void) const
  int return_value = (*(const AsyncTask*)local_this).get_sort();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_sort_26_comment =
  "C++ Interface:\n"
  "get_sort(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the task's current sort value.  See set_sort().\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_sort_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_priority(int priority)
 */
static PyObject *Dtool_AsyncTask_set_priority_27(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_priority")) {
    return NULL;
  }
  // 1-void AsyncTask::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_priority((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const AsyncTask self, int priority)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_priority_27_comment =
  "C++ Interface:\n"
  "set_priority(const AsyncTask self, int priority)\n"
  "\n"
  "/**\n"
  " * Specifies a priority value for this task.  In general, tasks with a higher\n"
  " * priority value are executed before tasks with a lower priority value (but\n"
  " * only for tasks with the same sort value).\n"
  " *\n"
  " * Unlike the sort value, tasks with different priorities may execute at the\n"
  " * same time, if the AsyncTaskManager has more than one thread servicing\n"
  " * tasks.\n"
  " *\n"
  " * Also see AsyncTaskChain::set_timeslice_priority(), which changes the\n"
  " * meaning of this value.  In the default mode, when the timeslice_priority\n"
  " * flag is false, all tasks always run once per epoch, regardless of their\n"
  " * priority values (that is, the priority controls the order of the task\n"
  " * execution only, not the number of times it runs).  On the other hand, if\n"
  " * you set the timeslice_priority flag to true, then changing a task's\n"
  " * priority has an effect on the number of times it runs.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_priority_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTask::get_priority(void) const
 */
static PyObject *Dtool_AsyncTask_get_priority_28(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AsyncTask::get_priority(void) const
  int return_value = (*(const AsyncTask*)local_this).get_priority();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_priority_28_comment =
  "C++ Interface:\n"
  "get_priority(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the task's current priority value.  See set_priority().\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_priority_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::set_done_event(std::string const &done_event)
 */
static PyObject *Dtool_AsyncTask_set_done_event_29(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_done_event")) {
    return NULL;
  }
  // 1-inline void AsyncTask::set_done_event(std::string const &done_event)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_done_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_done_event(const AsyncTask self, str done_event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_done_event_29_comment =
  "C++ Interface:\n"
  "set_done_event(const AsyncTask self, str done_event)\n"
  "\n"
  "/**\n"
  " * Sets the event name that will be triggered when the task finishes.  This\n"
  " * should only be called before the task has been started, or after it has\n"
  " * finished and before it is about to be restarted (i.e.  when get_state()\n"
  " * returns S_inactive).\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_done_event_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &AsyncTask::get_done_event(void) const
 */
static PyObject *Dtool_AsyncTask_get_done_event_30(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &AsyncTask::get_done_event(void) const
  std::string const &return_value = (*(const AsyncTask*)local_this).get_done_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_done_event_30_comment =
  "C++ Interface:\n"
  "get_done_event(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be triggered when the task finishes.  See\n"
  " * set_done_event().\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_done_event_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_python_object(PyObject *python_object)
 */
static PyObject *Dtool_AsyncTask_set_python_object_31(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_python_object")) {
    return NULL;
  }
  // 1-void AsyncTask::set_python_object(PyObject *python_object)
  (*local_this).set_python_object(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_object(const AsyncTask self, object python_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_python_object_31_comment =
  "C++ Interface:\n"
  "set_python_object(const AsyncTask self, object python_object)\n"
  "\n"
  "/**\n"
  " * Specifies an arbitrary Python object that will be piggybacked on the task\n"
  " * object.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_python_object_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *AsyncTask::get_python_object(void) const
 */
static PyObject *Dtool_AsyncTask_get_python_object_32(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *AsyncTask::get_python_object(void) const
  PyObject *return_value = (*(const AsyncTask*)local_this).get_python_object();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_python_object_32_comment =
  "C++ Interface:\n"
  "get_python_object(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the Python object that was specified to set_python_object(), if\n"
  " * any, or None if no object was specified.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_python_object_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_dt(void) const
 */
static PyObject *Dtool_AsyncTask_get_dt_33(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AsyncTask::get_dt(void) const
  double return_value = (*(const AsyncTask*)local_this).get_dt();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_dt_33_comment =
  "C++ Interface:\n"
  "get_dt(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time elapsed during the task's previous run cycle, in\n"
  " * seconds.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_dt_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_max_dt(void) const
 */
static PyObject *Dtool_AsyncTask_get_max_dt_34(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AsyncTask::get_max_dt(void) const
  double return_value = (*(const AsyncTask*)local_this).get_max_dt();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_max_dt_34_comment =
  "C++ Interface:\n"
  "get_max_dt(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum amount of time elapsed during any one of the task's\n"
  " * previous run cycles, in seconds.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_max_dt_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_average_dt(void) const
 */
static PyObject *Dtool_AsyncTask_get_average_dt_35(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double AsyncTask::get_average_dt(void) const
  double return_value = (*(const AsyncTask*)local_this).get_average_dt();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_average_dt_35_comment =
  "C++ Interface:\n"
  "get_average_dt(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the average amount of time elapsed during each of the task's\n"
  " * previous run cycles, in seconds.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_average_dt_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTask::output(ostream &out) const
 */
static PyObject *Dtool_AsyncTask_output_36(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AsyncTask::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AsyncTask.output", false, true);
  if (arg_this != NULL) {
    (*(const AsyncTask*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTask self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_output_36_comment =
  "C++ Interface:\n"
  "output(AsyncTask self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTask_output_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTask::get_class_type(void)
 */
static PyObject *Dtool_AsyncTask_get_class_type_37(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTask::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AsyncTask::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_class_type_37_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTask_get_class_type_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void)
 */
static PyObject *Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147(PyObject *self, PyObject *) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.downcast_to_AsyncTaskSequence")) {
    return NULL;
  }
  // 1-AsyncTaskSequence *AsyncTask::downcast_to_AsyncTaskSequence(void)
  AsyncTaskSequence *return_value = (AsyncTaskSequence *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskSequence, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147_comment =
  "C++ Interface:\n"
  "downcast_to_AsyncTaskSequence(const AsyncTask self)\n"
  "\n"
  "downcast from AsyncTask to AsyncTaskSequence";
#else
static const char *Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTask::AsyncTask(AsyncTask const &) = default
 */
static int Dtool_Init_AsyncTask(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTask() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline AsyncTask::AsyncTask(AsyncTask const &) = default
  AsyncTask const *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 0, "AsyncTask.AsyncTask", true, true);
  if (arg_this != NULL) {
    AsyncTask *return_value = new AsyncTask(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTask, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTask(const AsyncTask param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AsyncTask(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTask) {
    printf("AsyncTask ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTask *local_this = (AsyncTask *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return (AsyncTaskBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTaskBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncTaskBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncTaskBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncTaskBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTask(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTask*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AsyncTaskCollection
 */
/**
 * Python function wrapper for:
 * void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy)
 */
static PyObject *Dtool_AsyncTaskCollection_operator_41(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.assign")) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    AsyncTaskCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const AsyncTaskCollection self, const AsyncTaskCollection copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_operator_41_comment =
  "C++ Interface:\n"
  "assign(const AsyncTaskCollection self, const AsyncTaskCollection copy)\n";
#else
static const char *Dtool_AsyncTaskCollection_operator_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::add_task(AsyncTask *task)
 */
static PyObject *Dtool_AsyncTaskCollection_add_task_43(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.add_task")) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::add_task(AsyncTask *task)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskCollection.add_task", false, true);
  if (arg_this != NULL) {
    (*local_this).add_task(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_task(const AsyncTaskCollection self, AsyncTask task)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_add_task_43_comment =
  "C++ Interface:\n"
  "add_task(const AsyncTaskCollection self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Adds a new AsyncTask to the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_add_task_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskCollection::remove_task(AsyncTask *task)
 * void AsyncTaskCollection::remove_task(int index)
 */
static PyObject *Dtool_AsyncTaskCollection_remove_task_44(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.remove_task")) {
    return NULL;
  }
  {
    // -2 bool AsyncTaskCollection::remove_task(AsyncTask *task)
    AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskCollection.remove_task", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).remove_task(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 void AsyncTaskCollection::remove_task(int index)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      (*local_this).remove_task((int)arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: bool AsyncTaskCollection::remove_task(AsyncTask *task)
  // No coercion possible: void AsyncTaskCollection::remove_task(int index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_task(const AsyncTaskCollection self, AsyncTask task)\n"
      "remove_task(const AsyncTaskCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_remove_task_44_comment =
  "C++ Interface:\n"
  "remove_task(const AsyncTaskCollection self, AsyncTask task)\n"
  "remove_task(const AsyncTaskCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated AsyncTask from the collection.  Returns true if the\n"
  " * task was removed, false if it was not a member of the collection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the nth AsyncTask from the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_remove_task_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other)
 */
static PyObject *Dtool_AsyncTaskCollection_add_tasks_from_45(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.add_tasks_from")) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.add_tasks_from", true, true);
  if (arg_this != NULL) {
    (*local_this).add_tasks_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_add_tasks_from_45_comment =
  "C++ Interface:\n"
  "add_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the AsyncTasks indicated in the other collection to this task.\n"
  " * The other tasks are simply appended to the end of the tasks in this list;\n"
  " * duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_add_tasks_from_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other)
 */
static PyObject *Dtool_AsyncTaskCollection_remove_tasks_from_46(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.remove_tasks_from")) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.remove_tasks_from", true, true);
  if (arg_this != NULL) {
    (*local_this).remove_tasks_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_remove_tasks_from_46_comment =
  "C++ Interface:\n"
  "remove_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the AsyncTasks listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_remove_tasks_from_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::remove_duplicate_tasks(void)
 */
static PyObject *Dtool_AsyncTaskCollection_remove_duplicate_tasks_47(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.remove_duplicate_tasks")) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::remove_duplicate_tasks(void)
  (*local_this).remove_duplicate_tasks();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_remove_duplicate_tasks_47_comment =
  "C++ Interface:\n"
  "remove_duplicate_tasks(const AsyncTaskCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same AsyncTasks on this collection.\n"
  " * If a AsyncTask appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_remove_duplicate_tasks_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskCollection::has_task(AsyncTask *task) const
 */
static PyObject *Dtool_AsyncTaskCollection_has_task_48(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool AsyncTaskCollection::has_task(AsyncTask *task) const
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskCollection.has_task", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const AsyncTaskCollection*)local_this).has_task(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_task(AsyncTaskCollection self, AsyncTask task)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_has_task_48_comment =
  "C++ Interface:\n"
  "has_task(AsyncTaskCollection self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated AsyncTask appears in this collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_has_task_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::clear(void)
 */
static PyObject *Dtool_AsyncTaskCollection_clear_49(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.clear")) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_clear_49_comment =
  "C++ Interface:\n"
  "clear(const AsyncTaskCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all AsyncTasks from the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_clear_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskCollection::find_task(std::string const &name) const
 */
static PyObject *Dtool_AsyncTaskCollection_find_task_50(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTask *AsyncTaskCollection::find_task(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AsyncTask *return_value = (*(const AsyncTaskCollection*)local_this).find_task(std::string(param1_str, param1_len));
    if (return_value != (AsyncTask *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AsyncTask *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_task(AsyncTaskCollection self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_find_task_50_comment =
  "C++ Interface:\n"
  "find_task(AsyncTaskCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the task in the collection with the indicated name, if any, or NULL\n"
  " * if no task has that name.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_find_task_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskCollection::get_num_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskCollection_get_num_tasks_51(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AsyncTaskCollection::get_num_tasks(void) const
  int return_value = (*(const AsyncTaskCollection*)local_this).get_num_tasks();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_get_num_tasks_51_comment =
  "C++ Interface:\n"
  "get_num_tasks(AsyncTaskCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of AsyncTasks in the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_get_num_tasks_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskCollection::get_task(int index) const
 */
static PyObject *Dtool_AsyncTaskCollection_get_task_52(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTask *AsyncTaskCollection::get_task(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AsyncTask *return_value = (*(const AsyncTaskCollection*)local_this).get_task((int)arg_val);
    if (return_value != (AsyncTask *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AsyncTask *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_task(AsyncTaskCollection self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_get_task_52_comment =
  "C++ Interface:\n"
  "get_task(AsyncTaskCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth AsyncTask in the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_get_task_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::output(ostream &out) const
 */
static PyObject *Dtool_AsyncTaskCollection_output_58(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AsyncTaskCollection.output", false, true);
  if (arg_this != NULL) {
    (*(const AsyncTaskCollection*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTaskCollection self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_output_58_comment =
  "C++ Interface:\n"
  "output(AsyncTaskCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the AsyncTaskCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_output_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AsyncTaskCollection_write_59(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  // 1-void AsyncTaskCollection::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "AsyncTaskCollection.write", false, true);
    if (param1_this != NULL) {
      (*(const AsyncTaskCollection*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AsyncTaskCollection self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_write_59_comment =
  "C++ Interface:\n"
  "write(AsyncTaskCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the AsyncTaskCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_write_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void)
 */
static PyObject *Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.downcast_to_AsyncTaskSequence")) {
    return NULL;
  }
  // 1-AsyncTaskSequence *AsyncTaskCollection::downcast_to_AsyncTaskSequence(void)
  AsyncTaskSequence *return_value = (AsyncTaskSequence *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskSequence, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149_comment =
  "C++ Interface:\n"
  "downcast_to_AsyncTaskSequence(const AsyncTaskCollection self)\n"
  "\n"
  "downcast from AsyncTaskCollection to AsyncTaskSequence";
#else
static const char *Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection::AsyncTaskCollection(void)
 * AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy)
 */
static int Dtool_Init_AsyncTaskCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-AsyncTaskCollection::AsyncTaskCollection(void)
      AsyncTaskCollection *return_value = new AsyncTaskCollection();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy)
      AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 0, "AsyncTaskCollection.AsyncTaskCollection", true, true);
      if (arg_this != NULL) {
        AsyncTaskCollection *return_value = new AsyncTaskCollection(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskCollection()\n"
      "AsyncTaskCollection(const AsyncTaskCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AsyncTaskCollection_get_tasks(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_tasks();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AsyncTaskCollection_get_task_52(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AsyncTaskCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTaskCollection) {
    printf("AsyncTaskCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTaskCollection *local_this = (AsyncTaskCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTaskCollection) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTaskCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTaskCollection) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AsyncTaskChain
 */
/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_tick_clock(bool tick_clock)
 */
static PyObject *Dtool_AsyncTaskChain_set_tick_clock_68(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_tick_clock")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::set_tick_clock(bool tick_clock)
  (*local_this).set_tick_clock((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tick_clock(const AsyncTaskChain self, bool tick_clock)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_tick_clock_68_comment =
  "C++ Interface:\n"
  "set_tick_clock(const AsyncTaskChain self, bool tick_clock)\n"
  "\n"
  "/**\n"
  " * Sets the tick_clock flag.  When this is true, get_clock()->tick() will be\n"
  " * called automatically at each task epoch.  This is false by default.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_tick_clock_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::get_tick_clock(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_tick_clock_69(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool AsyncTaskChain::get_tick_clock(void) const
  bool return_value = (*(const AsyncTaskChain*)local_this).get_tick_clock();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_tick_clock_69_comment =
  "C++ Interface:\n"
  "get_tick_clock(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the tick_clock flag.  See set_tick_clock().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_tick_clock_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_num_threads(int num_threads)
 */
static PyObject *Dtool_AsyncTaskChain_set_num_threads_70(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_num_threads")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::set_num_threads(int num_threads)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).set_num_threads((int)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_threads(const AsyncTaskChain self, int num_threads)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_num_threads_70_comment =
  "C++ Interface:\n"
  "set_num_threads(const AsyncTaskChain self, int num_threads)\n"
  "\n"
  "/**\n"
  " * Changes the number of threads for this task chain.  This may require\n"
  " * stopping the threads if they are already running.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_num_threads_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskChain::get_num_threads(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_num_threads_71(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AsyncTaskChain::get_num_threads(void) const
  int return_value = (*(const AsyncTaskChain*)local_this).get_num_threads();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_num_threads_71_comment =
  "C++ Interface:\n"
  "get_num_threads(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads that will be servicing tasks for this chain.\n"
  " * Also see get_num_running_threads().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_num_threads_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskChain::get_num_running_threads(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_num_running_threads_72(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AsyncTaskChain::get_num_running_threads(void) const
  int return_value = (*(const AsyncTaskChain*)local_this).get_num_running_threads();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_num_running_threads_72_comment =
  "C++ Interface:\n"
  "get_num_running_threads(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads that have been created and are actively\n"
  " * running.  This will return 0 before the threads have been started; it will\n"
  " * also return 0 if thread support is not available.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_num_running_threads_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_thread_priority(ThreadPriority priority)
 */
static PyObject *Dtool_AsyncTaskChain_set_thread_priority_73(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_thread_priority")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::set_thread_priority(ThreadPriority priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).set_thread_priority((ThreadPriority)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thread_priority(const AsyncTaskChain self, int priority)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_thread_priority_73_comment =
  "C++ Interface:\n"
  "set_thread_priority(const AsyncTaskChain self, int priority)\n"
  "\n"
  "/**\n"
  " * Changes the priority associated with threads that serve this task chain.\n"
  " * This may require stopping the threads if they are already running.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_thread_priority_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ThreadPriority AsyncTaskChain::get_thread_priority(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_thread_priority_74(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-ThreadPriority AsyncTaskChain::get_thread_priority(void) const
  ThreadPriority return_value = (*(const AsyncTaskChain*)local_this).get_thread_priority();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_thread_priority_74_comment =
  "C++ Interface:\n"
  "get_thread_priority(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the priority associated with threads that serve this task chain.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_thread_priority_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_frame_budget(double frame_budget)
 */
static PyObject *Dtool_AsyncTaskChain_set_frame_budget_75(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_frame_budget")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::set_frame_budget(double frame_budget)
  if (PyNumber_Check(arg)) {
    (*local_this).set_frame_budget(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_budget(const AsyncTaskChain self, double frame_budget)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_frame_budget_75_comment =
  "C++ Interface:\n"
  "set_frame_budget(const AsyncTaskChain self, double frame_budget)\n"
  "\n"
  "/**\n"
  " * Sets the maximum amount of time per frame the tasks on this chain are\n"
  " * granted for execution.  If this is less than zero, there is no limit; if it\n"
  " * is >= 0, it represents a maximum amount of time (in seconds) that will be\n"
  " * used to execute tasks.  If this time is exceeded in any one frame, the task\n"
  " * chain will stop executing tasks until the next frame, as defined by the\n"
  " * TaskManager's clock.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_frame_budget_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double AsyncTaskChain::get_frame_budget(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_frame_budget_76(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-double AsyncTaskChain::get_frame_budget(void) const
  double return_value = (*(const AsyncTaskChain*)local_this).get_frame_budget();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_frame_budget_76_comment =
  "C++ Interface:\n"
  "get_frame_budget(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum amount of time per frame the tasks on this chain are\n"
  " * granted for execution.  See set_frame_budget().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_frame_budget_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_frame_sync(bool frame_sync)
 */
static PyObject *Dtool_AsyncTaskChain_set_frame_sync_77(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_frame_sync")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::set_frame_sync(bool frame_sync)
  (*local_this).set_frame_sync((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_sync(const AsyncTaskChain self, bool frame_sync)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_frame_sync_77_comment =
  "C++ Interface:\n"
  "set_frame_sync(const AsyncTaskChain self, bool frame_sync)\n"
  "\n"
  "/**\n"
  " * Sets the frame_sync flag.  When this flag is true, this task chain will be\n"
  " * forced to sync with the TaskManager's clock.  It will run no faster than\n"
  " * one epoch per clock frame.\n"
  " *\n"
  " * When this flag is false, the default, the task chain will finish all of its\n"
  " * tasks and then immediately start from the first task again, regardless of\n"
  " * the clock frame.  When it is true, the task chain will finish all of its\n"
  " * tasks and then wait for the clock to tick to the next frame before resuming\n"
  " * the first task.\n"
  " *\n"
  " * This only makes sense for threaded task chains.  Non-threaded task chains\n"
  " * are automatically synchronous.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_frame_sync_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::get_frame_sync(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_frame_sync_78(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool AsyncTaskChain::get_frame_sync(void) const
  bool return_value = (*(const AsyncTaskChain*)local_this).get_frame_sync();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_frame_sync_78_comment =
  "C++ Interface:\n"
  "get_frame_sync(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the frame_sync flag.  See set_frame_sync().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_frame_sync_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority)
 */
static PyObject *Dtool_AsyncTaskChain_set_timeslice_priority_79(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_timeslice_priority")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority)
  (*local_this).set_timeslice_priority((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_timeslice_priority(const AsyncTaskChain self, bool timeslice_priority)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_timeslice_priority_79_comment =
  "C++ Interface:\n"
  "set_timeslice_priority(const AsyncTaskChain self, bool timeslice_priority)\n"
  "\n"
  "/**\n"
  " * Sets the timeslice_priority flag.  This changes the interpretation of\n"
  " * priority, and the number of times per epoch each task will run.\n"
  " *\n"
  " * When this flag is true, some tasks might not run in any given epoch.\n"
  " * Instead, tasks with priority higher than 1 will be given precedence, in\n"
  " * proportion to the amount of time they have already used.  This gives\n"
  " * higher-priority tasks more runtime than lower-priority tasks.  Each task\n"
  " * gets the amount of time proportional to its priority value, so a task with\n"
  " * priority 100 will get five times as much processing time as a task with\n"
  " * priority 20.  For these purposes, priority values less than 1 are deemed to\n"
  " * be equal to 1.\n"
  " *\n"
  " * When this flag is false (the default), all tasks are run exactly once each\n"
  " * epoch, round-robin style.  Priority is only used to determine which task\n"
  " * runs first within tasks of the same sort value.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_timeslice_priority_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::get_timeslice_priority(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_timeslice_priority_80(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool AsyncTaskChain::get_timeslice_priority(void) const
  bool return_value = (*(const AsyncTaskChain*)local_this).get_timeslice_priority();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_timeslice_priority_80_comment =
  "C++ Interface:\n"
  "get_timeslice_priority(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the timeslice_priority flag.  This changes the interpretation of\n"
  " * priority, and the number of times per epoch each task will run.  See\n"
  " * set_timeslice_priority().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_timeslice_priority_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::stop_threads(void)
 */
static PyObject *Dtool_AsyncTaskChain_stop_threads_81(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.stop_threads")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::stop_threads(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).stop_threads();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_stop_threads_81_comment =
  "C++ Interface:\n"
  "stop_threads(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Stops any threads that are currently running.  If any tasks are still\n"
  " * pending and have not yet been picked up by a thread, they will not be\n"
  " * serviced unless poll() or start_threads() is later called.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_stop_threads_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::start_threads(void)
 */
static PyObject *Dtool_AsyncTaskChain_start_threads_82(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.start_threads")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::start_threads(void)
  (*local_this).start_threads();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_start_threads_82_comment =
  "C++ Interface:\n"
  "start_threads(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Starts any requested threads to service the tasks on the queue.  This is\n"
  " * normally not necessary, since adding a task will start the threads\n"
  " * automatically.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_start_threads_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncTaskChain::is_started(void) const
 */
static PyObject *Dtool_AsyncTaskChain_is_started_83(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AsyncTaskChain::is_started(void) const
  bool return_value = (*(const AsyncTaskChain*)local_this).is_started();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_is_started_83_comment =
  "C++ Interface:\n"
  "is_started(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns true if the thread(s) have been started and are ready to service\n"
  " * requests, false otherwise.  If this is false, the next call to add() or\n"
  " * add_and_do() will automatically start the threads.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_is_started_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::has_task(AsyncTask *task) const
 */
static PyObject *Dtool_AsyncTaskChain_has_task_84(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool AsyncTaskChain::has_task(AsyncTask *task) const
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskChain.has_task", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const AsyncTaskChain*)local_this).has_task(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_task(AsyncTaskChain self, AsyncTask task)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_has_task_84_comment =
  "C++ Interface:\n"
  "has_task(AsyncTaskChain self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated task has been added to this AsyncTaskChain,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_has_task_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::wait_for_tasks(void)
 */
static PyObject *Dtool_AsyncTaskChain_wait_for_tasks_85(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.wait_for_tasks")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::wait_for_tasks(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).wait_for_tasks();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_wait_for_tasks_85_comment =
  "C++ Interface:\n"
  "wait_for_tasks(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Blocks until the task list is empty.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_wait_for_tasks_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskChain::get_num_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_num_tasks_86(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AsyncTaskChain::get_num_tasks(void) const
  int return_value = (*(const AsyncTaskChain*)local_this).get_num_tasks();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_num_tasks_86_comment =
  "C++ Interface:\n"
  "get_num_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the number of tasks that are currently active or sleeping within\n"
  " * the task chain.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_num_tasks_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskChain::get_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_tasks_87(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskChain::get_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskChain*)local_this).get_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_tasks_87_comment =
  "C++ Interface:\n"
  "get_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active or sleeping on the task chain, at\n"
  " * the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_tasks_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_active_tasks_88(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskChain*)local_this).get_active_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_active_tasks_88_comment =
  "C++ Interface:\n"
  "get_active_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active (and not sleeping) on the task\n"
  " * chain, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_active_tasks_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_sleeping_tasks_89(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskChain*)local_this).get_sleeping_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_sleeping_tasks_89_comment =
  "C++ Interface:\n"
  "get_sleeping_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are sleeping (and not active) on the task\n"
  " * chain, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_sleeping_tasks_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::poll(void)
 */
static PyObject *Dtool_AsyncTaskChain_poll_90(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.poll")) {
    return NULL;
  }
  // 1-void AsyncTaskChain::poll(void)
  (*local_this).poll();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_poll_90_comment =
  "C++ Interface:\n"
  "poll(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Runs through all the tasks in the task list, once, if the task chain is\n"
  " * running in single-threaded mode (no threads available).  This method does\n"
  " * nothing in threaded mode, so it may safely be called in either case.\n"
  " *\n"
  " * Normally, you would not call this function directly; instead, call\n"
  " * AsyncTaskManager::poll(), which polls all of the task chains in sequence.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_poll_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double AsyncTaskChain::get_next_wake_time(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_next_wake_time_91(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-double AsyncTaskChain::get_next_wake_time(void) const
  double return_value = (*(const AsyncTaskChain*)local_this).get_next_wake_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_next_wake_time_91_comment =
  "C++ Interface:\n"
  "get_next_wake_time(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the scheduled time (on the manager's clock) of the next sleeping\n"
  " * task, on any task chain, to awaken.  Returns -1 if there are no sleeping\n"
  " * tasks.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_next_wake_time_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskChain::output(ostream &out) const
 */
static PyObject *Dtool_AsyncTaskChain_output_92(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AsyncTaskChain::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AsyncTaskChain.output", false, true);
  if (arg_this != NULL) {
    (*(const AsyncTaskChain*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTaskChain self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_output_92_comment =
  "C++ Interface:\n"
  "output(AsyncTaskChain self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_output_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskChain::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AsyncTaskChain_write_93(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AsyncTaskChain::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "AsyncTaskChain.write", false, true);
    if (param1_this != NULL) {
      (*(const AsyncTaskChain*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AsyncTaskChain self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_write_93_comment =
  "C++ Interface:\n"
  "write(AsyncTaskChain self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_write_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskChain::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskChain_get_class_type_94(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskChain::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AsyncTaskChain::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_class_type_94_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskChain_get_class_type_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.upcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AsyncTaskChain self)\n"
  "\n"
  "upcast from AsyncTaskChain to TypedReferenceCount";
#else
static const char *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *AsyncTaskChain::upcast_to_Namable(void)
 */
static PyObject *Dtool_AsyncTaskChain_upcast_to_Namable_65(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *AsyncTaskChain::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_upcast_to_Namable_65_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AsyncTaskChain self)\n"
  "\n"
  "upcast from AsyncTaskChain to Namable";
#else
static const char *Dtool_AsyncTaskChain_upcast_to_Namable_65_comment = NULL;
#endif

static int Dtool_Init_AsyncTaskChain(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AsyncTaskChain(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTaskChain) {
    printf("AsyncTaskChain ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTaskChain *local_this = (AsyncTaskChain *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTaskChain) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTaskChain(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTaskChain) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AsyncTaskManager
 */
/**
 * Python function wrapper for:
 * void AsyncTaskManager::cleanup(void)
 */
static PyObject *Dtool_AsyncTaskManager_cleanup_102(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.cleanup")) {
    return NULL;
  }
  // 1-void AsyncTaskManager::cleanup(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).cleanup();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_cleanup_102_comment =
  "C++ Interface:\n"
  "cleanup(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Stops all threads and messily empties the task list.  This is intended to\n"
  " * be called on destruction only.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_cleanup_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTaskManager::set_clock(ClockObject *clock)
 */
static PyObject *Dtool_AsyncTaskManager_set_clock_103(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.set_clock")) {
    return NULL;
  }
  // 1-inline void AsyncTaskManager::set_clock(ClockObject *clock)
  ClockObject *arg_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ClockObject, 1, "AsyncTaskManager.set_clock", false, true);
  if (arg_this != NULL) {
    (*local_this).set_clock(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clock(const AsyncTaskManager self, ClockObject clock)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_set_clock_103_comment =
  "C++ Interface:\n"
  "set_clock(const AsyncTaskManager self, ClockObject clock)\n"
  "\n"
  "/**\n"
  " * Replaces the clock pointer used within the AsyncTaskManager.  This is used\n"
  " * to control when tasks with a set_delay() specified will be scheduled.  It\n"
  " * can also be ticked automatically each epoch, if set_tick_clock() is true.\n"
  " *\n"
  " * The default is the global clock pointer.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_set_clock_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ClockObject *AsyncTaskManager::get_clock(void)
 */
static PyObject *Dtool_AsyncTaskManager_get_clock_104(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.get_clock")) {
    return NULL;
  }
  // 1-inline ClockObject *AsyncTaskManager::get_clock(void)
  ClockObject *return_value = (*local_this).get_clock();
  if (return_value != (ClockObject *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (ClockObject *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_clock_104_comment =
  "C++ Interface:\n"
  "get_clock(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the clock pointer used within the AsyncTaskManager.  See\n"
  " * set_clock().\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_clock_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskManager::get_num_task_chains(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_num_task_chains_108(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int AsyncTaskManager::get_num_task_chains(void) const
  int return_value = (*(const AsyncTaskManager*)local_this).get_num_task_chains();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_num_task_chains_108_comment =
  "C++ Interface:\n"
  "get_num_task_chains(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different task chains.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_num_task_chains_108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const
 */
static PyObject *Dtool_AsyncTaskManager_get_task_chain_109(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AsyncTaskChain *return_value = (*(const AsyncTaskManager*)local_this).get_task_chain((int)arg_val);
    if (return_value != (AsyncTaskChain *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AsyncTaskChain *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskChain, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_task_chain(AsyncTaskManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_task_chain_109_comment =
  "C++ Interface:\n"
  "get_task_chain(AsyncTaskManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth task chain.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_task_chain_109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name)
 */
static PyObject *Dtool_AsyncTaskManager_make_task_chain_111(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.make_task_chain")) {
    return NULL;
  }
  // 1-AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AsyncTaskChain *return_value = (*local_this).make_task_chain(std::string(param1_str, param1_len));
    if (return_value != (AsyncTaskChain *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AsyncTaskChain *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskChain, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_task_chain(const AsyncTaskManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_make_task_chain_111_comment =
  "C++ Interface:\n"
  "make_task_chain(const AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Creates a new AsyncTaskChain of the indicated name and stores it within the\n"
  " * AsyncTaskManager.  If a task chain with this name already exists, returns\n"
  " * it instead.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_make_task_chain_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &name)
 */
static PyObject *Dtool_AsyncTaskManager_find_task_chain_112(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.find_task_chain")) {
    return NULL;
  }
  // 1-AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AsyncTaskChain *return_value = (*local_this).find_task_chain(std::string(param1_str, param1_len));
    if (return_value != (AsyncTaskChain *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AsyncTaskChain *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskChain, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_task_chain(const AsyncTaskManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_task_chain_112_comment =
  "C++ Interface:\n"
  "find_task_chain(const AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Searches a new AsyncTaskChain of the indicated name and returns it if it\n"
  " * exists, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_task_chain_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskManager::remove_task_chain(std::string const &name)
 */
static PyObject *Dtool_AsyncTaskManager_remove_task_chain_113(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.remove_task_chain")) {
    return NULL;
  }
  // 1-bool AsyncTaskManager::remove_task_chain(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).remove_task_chain(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_task_chain(const AsyncTaskManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_remove_task_chain_113_comment =
  "C++ Interface:\n"
  "remove_task_chain(const AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the AsyncTaskChain of the indicated name.  If the chain still has\n"
  " * tasks, this will block until all tasks are finished.\n"
  " *\n"
  " * Returns true if successful, or false if the chain did not exist.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_remove_task_chain_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::add(AsyncTask *task)
 */
static PyObject *Dtool_AsyncTaskManager_add_114(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.add")) {
    return NULL;
  }
  // 1-void AsyncTaskManager::add(AsyncTask *task)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskManager.add", false, true);
  if (arg_this != NULL) {
    (*local_this).add(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const AsyncTaskManager self, AsyncTask task)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_add_114_comment =
  "C++ Interface:\n"
  "add(const AsyncTaskManager self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Adds the indicated task to the active queue.  It is an error if the task is\n"
  " * already added to this or any other active queue.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_add_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskManager::has_task(AsyncTask *task) const
 */
static PyObject *Dtool_AsyncTaskManager_has_task_115(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool AsyncTaskManager::has_task(AsyncTask *task) const
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskManager.has_task", false, true);
  if (arg_this != NULL) {
    bool return_value = (*(const AsyncTaskManager*)local_this).has_task(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_task(AsyncTaskManager self, AsyncTask task)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_has_task_115_comment =
  "C++ Interface:\n"
  "has_task(AsyncTaskManager self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated task has been added to this AsyncTaskManager,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_has_task_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskManager::find_task(std::string const &name) const
 */
static PyObject *Dtool_AsyncTaskManager_find_task_116(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTask *AsyncTaskManager::find_task(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AsyncTask *return_value = (*(const AsyncTaskManager*)local_this).find_task(std::string(param1_str, param1_len));
    if (return_value != (AsyncTask *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (AsyncTask *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_task(AsyncTaskManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_task_116_comment =
  "C++ Interface:\n"
  "find_task(AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first task found with the indicated name, or NULL if there is\n"
  " * no task with the indicated name.\n"
  " *\n"
  " * If there are multiple tasks with the same name, returns one of them\n"
  " * arbitrarily.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_task_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &name) const
 */
static PyObject *Dtool_AsyncTaskManager_find_tasks_117(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).find_tasks(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_tasks(AsyncTaskManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_tasks_117_comment =
  "C++ Interface:\n"
  "find_tasks(AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the list of tasks found with the indicated name.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_tasks_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const
 */
static PyObject *Dtool_AsyncTaskManager_find_tasks_matching_118(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const
  GlobPattern const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AsyncTaskManager.find_tasks_matching", "GlobPattern");
  }
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).find_tasks_matching(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_tasks_matching(AsyncTaskManager self, const GlobPattern pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_tasks_matching_118_comment =
  "C++ Interface:\n"
  "find_tasks_matching(AsyncTaskManager self, const GlobPattern pattern)\n"
  "\n"
  "/**\n"
  " * Returns the list of tasks found whose name matches the indicated glob\n"
  " * pattern, e.g.  \"my_task_*\".\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_tasks_matching_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskManager::remove(AsyncTask *task)
 * int AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
 */
static PyObject *Dtool_AsyncTaskManager_remove_119(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.remove")) {
    return NULL;
  }
  {
    // -2 bool AsyncTaskManager::remove(AsyncTask *task)
    AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskManager.remove", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).remove(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 int AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
    AsyncTaskCollection const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_AsyncTaskCollection, (void **)&arg_this);
    if (arg_this != NULL) {
      int return_value = (*local_this).remove(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: bool AsyncTaskManager::remove(AsyncTask *task)
  // No coercion possible: int AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove(const AsyncTaskManager self, AsyncTask task)\n"
      "remove(const AsyncTaskManager self, const AsyncTaskCollection tasks)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_remove_119_comment =
  "C++ Interface:\n"
  "remove(const AsyncTaskManager self, AsyncTask task)\n"
  "remove(const AsyncTaskManager self, const AsyncTaskCollection tasks)\n"
  "\n"
  "/**\n"
  " * Removes the indicated task from the active queue.  Returns true if the task\n"
  " * is successfully removed, or false if it wasn't there.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes all of the tasks in the AsyncTaskCollection.  Returns the number of\n"
  " * tasks removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_remove_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::wait_for_tasks(void)
 */
static PyObject *Dtool_AsyncTaskManager_wait_for_tasks_120(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.wait_for_tasks")) {
    return NULL;
  }
  // 1-void AsyncTaskManager::wait_for_tasks(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).wait_for_tasks();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_wait_for_tasks_120_comment =
  "C++ Interface:\n"
  "wait_for_tasks(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Blocks until the task list is empty.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_wait_for_tasks_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::stop_threads(void)
 */
static PyObject *Dtool_AsyncTaskManager_stop_threads_121(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.stop_threads")) {
    return NULL;
  }
  // 1-void AsyncTaskManager::stop_threads(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).stop_threads();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_stop_threads_121_comment =
  "C++ Interface:\n"
  "stop_threads(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Stops any threads that are currently running.  If any tasks are still\n"
  " * pending and have not yet been picked up by a thread, they will not be\n"
  " * serviced unless poll() or start_threads() is later called.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_stop_threads_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::start_threads(void)
 */
static PyObject *Dtool_AsyncTaskManager_start_threads_122(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.start_threads")) {
    return NULL;
  }
  // 1-void AsyncTaskManager::start_threads(void)
  (*local_this).start_threads();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_start_threads_122_comment =
  "C++ Interface:\n"
  "start_threads(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Starts any requested threads to service the tasks on the queue.  This is\n"
  " * normally not necessary, since adding a task will start the threads\n"
  " * automatically.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_start_threads_122_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTaskManager::get_num_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_num_tasks_123(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AsyncTaskManager::get_num_tasks(void) const
  int return_value = (*(const AsyncTaskManager*)local_this).get_num_tasks();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_num_tasks_123_comment =
  "C++ Interface:\n"
  "get_num_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of tasks that are currently active or sleeping within\n"
  " * the task manager.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_num_tasks_123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_tasks_124(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).get_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_tasks_124_comment =
  "C++ Interface:\n"
  "get_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active or sleeping on the task manager,\n"
  " * at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_tasks_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_active_tasks_125(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).get_active_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_active_tasks_125_comment =
  "C++ Interface:\n"
  "get_active_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active (and not sleeping) on the task\n"
  " * manager, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_active_tasks_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_sleeping_tasks_126(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).get_sleeping_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_sleeping_tasks_126_comment =
  "C++ Interface:\n"
  "get_sleeping_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are sleeping (and not active) on the task\n"
  " * manager, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_sleeping_tasks_126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::poll(void)
 */
static PyObject *Dtool_AsyncTaskManager_poll_130(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.poll")) {
    return NULL;
  }
  // 1-void AsyncTaskManager::poll(void)
  (*local_this).poll();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_poll_130_comment =
  "C++ Interface:\n"
  "poll(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Runs through all the tasks in the task list, once, if the task manager is\n"
  " * running in single-threaded mode (no threads available).  This method does\n"
  " * nothing in threaded mode, so it may safely be called in either case.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_poll_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double AsyncTaskManager::get_next_wake_time(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_next_wake_time_131(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-double AsyncTaskManager::get_next_wake_time(void) const
  double return_value = (*(const AsyncTaskManager*)local_this).get_next_wake_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_next_wake_time_131_comment =
  "C++ Interface:\n"
  "get_next_wake_time(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the scheduled time (on the manager's clock) of the next sleeping\n"
  " * task, on any task chain, to awaken.  Returns -1 if there are no sleeping\n"
  " * tasks.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_next_wake_time_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskManager::output(ostream &out) const
 */
static PyObject *Dtool_AsyncTaskManager_output_134(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AsyncTaskManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AsyncTaskManager.output", false, true);
  if (arg_this != NULL) {
    (*(const AsyncTaskManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTaskManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_output_134_comment =
  "C++ Interface:\n"
  "output(AsyncTaskManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_output_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskManager::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AsyncTaskManager_write_135(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AsyncTaskManager::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "AsyncTaskManager.write", false, true);
    if (param1_this != NULL) {
      (*(const AsyncTaskManager*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AsyncTaskManager self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_write_135_comment =
  "C++ Interface:\n"
  "write(AsyncTaskManager self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_write_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void)
 */
static PyObject *Dtool_AsyncTaskManager_get_global_ptr_136(PyObject *, PyObject *) {
  // 1-static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void)
  AsyncTaskManager *return_value = AsyncTaskManager::get_global_ptr();
  if (return_value != (AsyncTaskManager *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AsyncTaskManager *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_global_ptr_136_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global AsyncTaskManager.  This is the\n"
  " * AsyncTaskManager that most code should use for queueing tasks and suchlike.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_global_ptr_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskManager::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskManager_get_class_type_137(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskManager::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AsyncTaskManager::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_class_type_137_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskManager_get_class_type_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.upcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AsyncTaskManager self)\n"
  "\n"
  "upcast from AsyncTaskManager to TypedReferenceCount";
#else
static const char *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Namable *AsyncTaskManager::upcast_to_Namable(void)
 */
static PyObject *Dtool_AsyncTaskManager_upcast_to_Namable_98(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.upcast_to_Namable")) {
    return NULL;
  }
  // 1-Namable *AsyncTaskManager::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_upcast_to_Namable_98_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AsyncTaskManager self)\n"
  "\n"
  "upcast from AsyncTaskManager to Namable";
#else
static const char *Dtool_AsyncTaskManager_upcast_to_Namable_98_comment = NULL;
#endif

static PyObject *Dtool_AsyncTaskManager_clock_Getter(PyObject *self, void *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.clock")) {
    return NULL;
  }

  // 1-inline ClockObject *AsyncTaskManager::get_clock(void)
  ClockObject *return_value = (*local_this).get_clock();
  if (return_value != (ClockObject *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (ClockObject *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

static int Dtool_AsyncTaskManager_clock_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.clock")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete clock attribute");
    return -1;
  }
  // 1-inline void AsyncTaskManager::set_clock(ClockObject *clock)
  ClockObject *arg_this = (ClockObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ClockObject, 1, "AsyncTaskManager.set_clock", false, true);
  if (arg_this != NULL) {
    (*local_this).set_clock(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clock(const AsyncTaskManager self, ClockObject clock)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTaskManager_tasks_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }

  // 1-AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).get_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

static PyObject *Dtool_AsyncTaskManager_active_tasks_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }

  // 1-AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).get_active_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

static PyObject *Dtool_AsyncTaskManager_sleeping_tasks_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }

  // 1-AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskManager*)local_this).get_sleeping_tasks());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

static PyObject *Dtool_AsyncTaskManager_next_wake_time_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }

  // 1-double AsyncTaskManager::get_next_wake_time(void) const
  double return_value = (*(const AsyncTaskManager*)local_this).get_next_wake_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * AsyncTaskManager::AsyncTaskManager(std::string const &name)
 */
static int Dtool_Init_AsyncTaskManager(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskManager() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "name");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'name' (pos 1) not found");
    return -1;
  }
  // 1-AsyncTaskManager::AsyncTaskManager(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    AsyncTaskManager *return_value = new AsyncTaskManager(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskManager, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskManager(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AsyncTaskManager(PyObject *args, CPT(AsyncTaskManager) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AsyncTaskManager, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskManager::AsyncTaskManager(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      AsyncTaskManager *return_value = new AsyncTaskManager(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_AsyncTaskManager(PyObject *args, PT(AsyncTaskManager) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AsyncTaskManager, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskManager::AsyncTaskManager(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      AsyncTaskManager *return_value = new AsyncTaskManager(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AsyncTaskManager_get_task_chains(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_task_chains();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AsyncTaskManager_get_task_chain_109(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AsyncTaskManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTaskManager) {
    printf("AsyncTaskManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTaskManager *local_this = (AsyncTaskManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTaskManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTaskManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTaskManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AsyncTaskPause
 */
/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskPause::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskPause_get_class_type_143(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskPause::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AsyncTaskPause::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskPause_get_class_type_143_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskPause_get_class_type_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default
 * AsyncTaskPause::AsyncTaskPause(double delay)
 */
static int Dtool_Init_AsyncTaskPause(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskPause() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AsyncTaskPause", (char **)keyword_list, &param0)) {
      AsyncTaskPause const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_AsyncTaskPause, (void **)&param0_this);
      if (param0_this != NULL) {
        AsyncTaskPause *return_value = new AsyncTaskPause(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskPause, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 AsyncTaskPause::AsyncTaskPause(double delay)
    double param0;
    static const char *keyword_list[] = {"delay", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "d:AsyncTaskPause", (char **)keyword_list, &param0)) {
      AsyncTaskPause *return_value = new AsyncTaskPause((double)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskPause, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AsyncTaskPause", (char **)keyword_list, &param0)) {
      CPT(AsyncTaskPause) param0_this;
      if (Dtool_ConstCoerce_AsyncTaskPause(param0, param0_this)) {
        AsyncTaskPause *return_value = new AsyncTaskPause(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskPause, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: AsyncTaskPause::AsyncTaskPause(double delay)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskPause(const AsyncTaskPause param0)\n"
      "AsyncTaskPause(double delay)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AsyncTaskPause(PyObject *args, CPT(AsyncTaskPause) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AsyncTaskPause, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskPause::AsyncTaskPause(double delay)
    if (PyNumber_Check(arg)) {
      AsyncTaskPause *return_value = new AsyncTaskPause(PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_AsyncTaskPause(PyObject *args, PT(AsyncTaskPause) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AsyncTaskPause, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskPause::AsyncTaskPause(double delay)
    if (PyNumber_Check(arg)) {
      AsyncTaskPause *return_value = new AsyncTaskPause(PyFloat_AsDouble(arg));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_AsyncTaskPause(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTaskPause) {
    printf("AsyncTaskPause ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTaskPause *local_this = (AsyncTaskPause *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTaskPause) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return (AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTaskPause(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTaskPause) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AsyncTaskSequence
 */
/**
 * Python function wrapper for:
 * inline void AsyncTaskSequence::set_repeat_count(int repeat_count)
 */
static PyObject *Dtool_AsyncTaskSequence_set_repeat_count_155(PyObject *self, PyObject *arg) {
  AsyncTaskSequence *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskSequence, (void **)&local_this, "AsyncTaskSequence.set_repeat_count")) {
    return NULL;
  }
  // 1-inline void AsyncTaskSequence::set_repeat_count(int repeat_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_repeat_count((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_repeat_count(const AsyncTaskSequence self, int repeat_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_set_repeat_count_155_comment =
  "C++ Interface:\n"
  "set_repeat_count(const AsyncTaskSequence self, int repeat_count)\n"
  "\n"
  "/**\n"
  " * Sets the repeat count of the sequence.  If the count is 0 or 1, the\n"
  " * sequence will run exactly once.  If it is greater than 0, it will run that\n"
  " * number of times.  If it is negative, it will run forever until it is\n"
  " * explicitly removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskSequence_set_repeat_count_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTaskSequence::get_repeat_count(void) const
 */
static PyObject *Dtool_AsyncTaskSequence_get_repeat_count_156(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskSequence, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AsyncTaskSequence::get_repeat_count(void) const
  int return_value = (*(const AsyncTaskSequence*)local_this).get_repeat_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_get_repeat_count_156_comment =
  "C++ Interface:\n"
  "get_repeat_count(AsyncTaskSequence self)\n"
  "\n"
  "/**\n"
  " * Returns the repeat count of the sequence.  See set_repeat_count().\n"
  " */";
#else
static const char *Dtool_AsyncTaskSequence_get_repeat_count_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTaskSequence::get_current_task_index(void) const
 */
static PyObject *Dtool_AsyncTaskSequence_get_current_task_index_157(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskSequence, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int AsyncTaskSequence::get_current_task_index(void) const
  int return_value = (*(const AsyncTaskSequence*)local_this).get_current_task_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_get_current_task_index_157_comment =
  "C++ Interface:\n"
  "get_current_task_index(AsyncTaskSequence self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the task within the sequence that is currently being\n"
  " * executed (or that will be executed at the next epoch).\n"
  " */";
#else
static const char *Dtool_AsyncTaskSequence_get_current_task_index_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskSequence::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskSequence_get_class_type_158(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskSequence::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AsyncTaskSequence::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_get_class_type_158_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskSequence_get_class_type_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void)
 */
static PyObject *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskSequence, (void **)&local_this, "AsyncTaskSequence.upcast_to_AsyncTask")) {
    return NULL;
  }
  // 1-AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void)
  AsyncTask *return_value = (AsyncTask *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146_comment =
  "C++ Interface:\n"
  "upcast_to_AsyncTask(const AsyncTaskSequence self)\n"
  "\n"
  "upcast from AsyncTaskSequence to AsyncTask";
#else
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void)
 */
static PyObject *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskSequence, (void **)&local_this, "AsyncTaskSequence.upcast_to_AsyncTaskCollection")) {
    return NULL;
  }
  // 1-AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void)
  AsyncTaskCollection *return_value = (AsyncTaskCollection *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148_comment =
  "C++ Interface:\n"
  "upcast_to_AsyncTaskCollection(const AsyncTaskSequence self)\n"
  "\n"
  "upcast from AsyncTaskSequence to AsyncTaskCollection";
#else
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default
 * AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
 */
static int Dtool_Init_AsyncTaskSequence(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskSequence() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AsyncTaskSequence", (char **)keyword_list, &param0)) {
      AsyncTaskSequence const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_AsyncTaskSequence, (void **)&param0_this);
      if (param0_this != NULL) {
        AsyncTaskSequence *return_value = new AsyncTaskSequence(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskSequence, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:AsyncTaskSequence", (char **)keyword_list, &param0_str, &param0_len)) {
      AsyncTaskSequence *return_value = new AsyncTaskSequence(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskSequence, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:AsyncTaskSequence", (char **)keyword_list, &param0)) {
      CPT(AsyncTaskSequence) param0_this;
      if (Dtool_ConstCoerce_AsyncTaskSequence(param0, param0_this)) {
        AsyncTaskSequence *return_value = new AsyncTaskSequence(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskSequence, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskSequence(const AsyncTaskSequence param0)\n"
      "AsyncTaskSequence(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AsyncTaskSequence(PyObject *args, CPT(AsyncTaskSequence) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AsyncTaskSequence, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      AsyncTaskSequence *return_value = new AsyncTaskSequence(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_AsyncTaskSequence(PyObject *args, PT(AsyncTaskSequence) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AsyncTaskSequence, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      AsyncTaskSequence *return_value = new AsyncTaskSequence(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_AsyncTaskSequence(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AsyncTaskSequence) {
    printf("AsyncTaskSequence ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AsyncTaskSequence *local_this = (AsyncTaskSequence *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AsyncTaskSequence) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return (AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskCollection) {
    return (AsyncTaskCollection *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AsyncTaskSequence(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AsyncTaskSequence) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskCollection) {
    AsyncTaskCollection* other_this = (AsyncTaskCollection*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EventParameter
 */
/**
 * Python function wrapper for:
 * inline EventParameter &EventParameter::operator =(EventParameter const &copy)
 */
static PyObject *Dtool_EventParameter_operator_161(PyObject *self, PyObject *arg) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventParameter, (void **)&local_this, "EventParameter.assign")) {
    return NULL;
  }
  // 1-inline EventParameter &EventParameter::operator =(EventParameter const &copy)
  EventParameter const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_EventParameter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EventParameter.assign", "EventParameter");
  }
  (*local_this).operator =(*arg_this);
  EventParameter *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EventParameter self, const EventParameter copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_operator_161_comment =
  "C++ Interface:\n"
  "assign(const EventParameter self, const EventParameter copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventParameter_operator_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_empty(void) const
 */
static PyObject *Dtool_EventParameter_is_empty_163(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EventParameter::is_empty(void) const
  bool return_value = (*(const EventParameter*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_empty_163_comment =
  "C++ Interface:\n"
  "is_empty(EventParameter self)\n"
  "\n"
  "// These functions are conveniences to easily determine if the\n"
  "// EventParameter is one of the predefined parameter types, and retrieve the\n"
  "// corresponding value.  Of course, it is possible that the EventParameter\n"
  "// is some user-defined type, and is none of these.\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter is the empty parameter, storing nothing,\n"
  " * or false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_empty_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_int(void) const
 */
static PyObject *Dtool_EventParameter_is_int_164(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EventParameter::is_int(void) const
  bool return_value = (*(const EventParameter*)local_this).is_int();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_int_164_comment =
  "C++ Interface:\n"
  "is_int(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores an integer value, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_int_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int EventParameter::get_int_value(void) const
 */
static PyObject *Dtool_EventParameter_get_int_value_165(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int EventParameter::get_int_value(void) const
  int return_value = (*(const EventParameter*)local_this).get_int_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_int_value_165_comment =
  "C++ Interface:\n"
  "get_int_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_int() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_int_value_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_double(void) const
 */
static PyObject *Dtool_EventParameter_is_double_166(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EventParameter::is_double(void) const
  bool return_value = (*(const EventParameter*)local_this).is_double();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_double_166_comment =
  "C++ Interface:\n"
  "is_double(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a double floating-point value,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_double_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double EventParameter::get_double_value(void) const
 */
static PyObject *Dtool_EventParameter_get_double_value_167(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double EventParameter::get_double_value(void) const
  double return_value = (*(const EventParameter*)local_this).get_double_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_double_value_167_comment =
  "C++ Interface:\n"
  "get_double_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_double() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_double_value_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_string(void) const
 */
static PyObject *Dtool_EventParameter_is_string_168(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EventParameter::is_string(void) const
  bool return_value = (*(const EventParameter*)local_this).is_string();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_string_168_comment =
  "C++ Interface:\n"
  "is_string(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a string value, false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_string_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string EventParameter::get_string_value(void) const
 */
static PyObject *Dtool_EventParameter_get_string_value_169(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string EventParameter::get_string_value(void) const
  std::string return_value = (*(const EventParameter*)local_this).get_string_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_string_value_169_comment =
  "C++ Interface:\n"
  "get_string_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_string() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_string_value_169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_wstring(void) const
 */
static PyObject *Dtool_EventParameter_is_wstring_170(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EventParameter::is_wstring(void) const
  bool return_value = (*(const EventParameter*)local_this).is_wstring();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_wstring_170_comment =
  "C++ Interface:\n"
  "is_wstring(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a wstring value, false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_wstring_170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring EventParameter::get_wstring_value(void) const
 */
static PyObject *Dtool_EventParameter_get_wstring_value_171(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring EventParameter::get_wstring_value(void) const
  std::wstring return_value = (*(const EventParameter*)local_this).get_wstring_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_wstring_value_171_comment =
  "C++ Interface:\n"
  "get_wstring_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_wstring() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_wstring_value_171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_typed_ref_count(void) const
 */
static PyObject *Dtool_EventParameter_is_typed_ref_count_172(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool EventParameter::is_typed_ref_count(void) const
  bool return_value = (*(const EventParameter*)local_this).is_typed_ref_count();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_typed_ref_count_172_comment =
  "C++ Interface:\n"
  "is_typed_ref_count(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a TypedReferenceCount pointer,\n"
  " * false otherwise.  Note that a TypedReferenceCount is not exactly the same\n"
  " * kind of pointer as a TypedWritableReferenceCount, hence the need for this\n"
  " * separate call.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_typed_ref_count_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const
 */
static PyObject *Dtool_EventParameter_get_typed_ref_count_value_173(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const
  TypedReferenceCount *return_value = (*(const EventParameter*)local_this).get_typed_ref_count_value();
  if (return_value != (TypedReferenceCount *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TypedReferenceCount *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_typed_ref_count_value_173_comment =
  "C++ Interface:\n"
  "get_typed_ref_count_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_typed_ref_count() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_typed_ref_count_value_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const
 */
static PyObject *Dtool_EventParameter_get_ptr_174(PyObject *self, PyObject *) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const
  TypedWritableReferenceCount *return_value = (*(const EventParameter*)local_this).get_ptr();
  if (return_value != (TypedWritableReferenceCount *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (TypedWritableReferenceCount *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_ptr_174_comment =
  "C++ Interface:\n"
  "get_ptr(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves a pointer to the actual value stored in the parameter.  The\n"
  " * TypeHandle of this pointer may be examined to determine the actual type of\n"
  " * parameter it contains.  This is the only way to retrieve the value when it\n"
  " * is not one of the above predefined types.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_ptr_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EventParameter::output(ostream &out) const
 */
static PyObject *Dtool_EventParameter_output_175(PyObject *self, PyObject *arg) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EventParameter::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "EventParameter.output", false, true);
  if (arg_this != NULL) {
    (*(const EventParameter*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(EventParameter self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_output_175_comment =
  "C++ Interface:\n"
  "output(EventParameter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventParameter_output_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EventParameter::EventParameter(void)
 * inline EventParameter::EventParameter(EventParameter const &copy)
 * inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
 * inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
 * inline EventParameter::EventParameter(double value)
 * inline EventParameter::EventParameter(int value)
 * inline EventParameter::EventParameter(std::string const &value)
 * inline EventParameter::EventParameter(std::wstring const &value)
 */
static int Dtool_Init_EventParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EventParameter::EventParameter(void)
      EventParameter *return_value = new EventParameter();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EventParameter::EventParameter(EventParameter const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventParameter", (char **)keyword_list, &param0)) {
          EventParameter const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EventParameter, (void **)&param0_this);
          if (param0_this != NULL) {
            EventParameter *return_value = new EventParameter(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
        PyObject *param0;
        static const char *keyword_list[] = {"ptr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventParameter", (char **)keyword_list, &param0)) {
          TypedWritableReferenceCount const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypedWritableReferenceCount, (void **)&param0_this);
          if (param0_this != NULL) {
            EventParameter *return_value = new EventParameter(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
        PyObject *param0;
        static const char *keyword_list[] = {"ptr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventParameter", (char **)keyword_list, &param0)) {
          TypedReferenceCount const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypedReferenceCount, (void **)&param0_this);
          if (param0_this != NULL) {
            EventParameter *return_value = new EventParameter(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(std::wstring const &value)
        #if PY_VERSION_HEX >= 0x03020000
        PyObject *param0;
        #else
        PyUnicodeObject *param0;
        #endif
        static const char *keyword_list[] = {"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "U:EventParameter", (char **)keyword_list, &param0)) {
#if PY_VERSION_HEX >= 0x03030000
          Py_ssize_t param0_len;
          wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
          Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
          wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
          PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
          EventParameter *return_value = new EventParameter(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
          PyMem_Free(param0_str);
#endif
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(std::string const &value)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EventParameter", (char **)keyword_list, &param0_str, &param0_len)) {
          EventParameter *return_value = new EventParameter(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(int value)
        int param0;
        static const char *keyword_list[] = {"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:EventParameter", (char **)keyword_list, &param0)) {
          EventParameter *return_value = new EventParameter((int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(double value)
        double param0;
        static const char *keyword_list[] = {"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:EventParameter", (char **)keyword_list, &param0)) {
          EventParameter *return_value = new EventParameter((double)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(EventParameter const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventParameter", (char **)keyword_list, &param0)) {
          EventParameter const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_EventParameter(param0, param0_this, param0_manage)) {
            EventParameter *return_value = new EventParameter(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
      // No coercion possible: inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
      // No coercion possible: inline EventParameter::EventParameter(std::wstring const &value)
      // No coercion possible: inline EventParameter::EventParameter(std::string const &value)
      // No coercion possible: inline EventParameter::EventParameter(int value)
      // No coercion possible: inline EventParameter::EventParameter(double value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EventParameter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EventParameter()\n"
      "EventParameter(const EventParameter copy)\n"
      "EventParameter(const TypedWritableReferenceCount ptr)\n"
      "EventParameter(const TypedReferenceCount ptr)\n"
      "EventParameter(unicode value)\n"
      "EventParameter(str value)\n"
      "EventParameter(int value)\n"
      "EventParameter(double value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EventParameter(PyObject *args, EventParameter const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EventParameter, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
      TypedWritableReferenceCount const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypedWritableReferenceCount, (void **)&arg_this);
      if (arg_this != NULL) {
        EventParameter *return_value = new EventParameter(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
      TypedReferenceCount const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypedReferenceCount, (void **)&arg_this);
      if (arg_this != NULL) {
        EventParameter *return_value = new EventParameter(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(std::wstring const &value)
      #if PY_VERSION_HEX >= 0x03020000
      PyObject *param0;
      #else
      PyUnicodeObject *param0;
      #endif
      if (PyArg_Parse(arg, "U:EventParameter", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param0_len;
        wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
        Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
        wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
        PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
        EventParameter *return_value = new EventParameter(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param0_str);
#endif
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline EventParameter::EventParameter(std::string const &value)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EventParameter *return_value = new EventParameter(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline EventParameter::EventParameter(int value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return false;
        }
#endif
        EventParameter *return_value = new EventParameter((int)arg_val);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(double value)
      if (PyNumber_Check(arg)) {
        EventParameter *return_value = new EventParameter(PyFloat_AsDouble(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  }
  return false;
}

bool Dtool_Coerce_EventParameter(PyObject *args, EventParameter *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EventParameter, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
      TypedWritableReferenceCount const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypedWritableReferenceCount, (void **)&arg_this);
      if (arg_this != NULL) {
        EventParameter *return_value = new EventParameter(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
      TypedReferenceCount const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypedReferenceCount, (void **)&arg_this);
      if (arg_this != NULL) {
        EventParameter *return_value = new EventParameter(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(std::wstring const &value)
      #if PY_VERSION_HEX >= 0x03020000
      PyObject *param0;
      #else
      PyUnicodeObject *param0;
      #endif
      if (PyArg_Parse(arg, "U:EventParameter", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param0_len;
        wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
        Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
        wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
        PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
        EventParameter *return_value = new EventParameter(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param0_str);
#endif
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline EventParameter::EventParameter(std::string const &value)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        EventParameter *return_value = new EventParameter(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline EventParameter::EventParameter(int value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return false;
        }
#endif
        EventParameter *return_value = new EventParameter((int)arg_val);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(double value)
      if (PyNumber_Check(arg)) {
        EventParameter *return_value = new EventParameter(PyFloat_AsDouble(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_EventParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EventParameter) {
    printf("EventParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EventParameter *local_this = (EventParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EventParameter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EventParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EventParameter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Event
 */
/**
 * Python function wrapper for:
 * void Event::operator =(Event const &copy)
 */
static PyObject *Dtool_Event_operator_178(PyObject *self, PyObject *arg) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.assign")) {
    return NULL;
  }
  // 1-void Event::operator =(Event const &copy)
  CPT(Event) arg_this;
  if (!Dtool_ConstCoerce_Event(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Event.assign", "Event");
  }
  (*local_this).operator =(*MOVE(arg_this));
  Event *return_value = local_this;
  if (return_value != (Event *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Event *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Event, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Event self, const Event copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Event_operator_178_comment =
  "C++ Interface:\n"
  "assign(const Event self, const Event copy)\n";
#else
static const char *Dtool_Event_operator_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Event::set_name(std::string const &name)
 */
static PyObject *Dtool_Event_set_name_179(PyObject *self, PyObject *arg) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.set_name")) {
    return NULL;
  }
  // 1-inline void Event::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const Event self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Event_set_name_179_comment =
  "C++ Interface:\n"
  "set_name(const Event self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_set_name_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Event::clear_name(void)
 */
static PyObject *Dtool_Event_clear_name_180(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.clear_name")) {
    return NULL;
  }
  // 1-inline void Event::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Event_clear_name_180_comment =
  "C++ Interface:\n"
  "clear_name(const Event self)\n"
  "\n"
  "/**\n"
  " * Resets the Event's name to empty.\n"
  " */";
#else
static const char *Dtool_Event_clear_name_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Event::has_name(void) const
 */
static PyObject *Dtool_Event_has_name_181(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Event::has_name(void) const
  bool return_value = (*(const Event*)local_this).has_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_has_name_181_comment =
  "C++ Interface:\n"
  "has_name(Event self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Event has a nonempty name set, false if the name is\n"
  " * empty.\n"
  " */";
#else
static const char *Dtool_Event_has_name_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Event::get_name(void) const
 */
static PyObject *Dtool_Event_get_name_182(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Event::get_name(void) const
  std::string const &return_value = (*(const Event*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_get_name_182_comment =
  "C++ Interface:\n"
  "get_name(Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_get_name_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Event::add_parameter(EventParameter const &obj)
 */
static PyObject *Dtool_Event_add_parameter_183(PyObject *self, PyObject *arg) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.add_parameter")) {
    return NULL;
  }
  // 1-void Event::add_parameter(EventParameter const &obj)
  EventParameter const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_EventParameter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Event.add_parameter", "EventParameter");
  }
  (*local_this).add_parameter(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_parameter(const Event self, const EventParameter obj)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Event_add_parameter_183_comment =
  "C++ Interface:\n"
  "add_parameter(const Event self, const EventParameter obj)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_add_parameter_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Event::get_num_parameters(void) const
 */
static PyObject *Dtool_Event_get_num_parameters_184(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Event::get_num_parameters(void) const
  int return_value = (*(const Event*)local_this).get_num_parameters();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_get_num_parameters_184_comment =
  "C++ Interface:\n"
  "get_num_parameters(Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_get_num_parameters_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EventParameter Event::get_parameter(int n) const
 */
static PyObject *Dtool_Event_get_parameter_185(PyObject *self, PyObject *arg) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  // 1-EventParameter Event::get_parameter(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EventParameter *return_value = new EventParameter((*(const Event*)local_this).get_parameter((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parameter(Event self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Event_get_parameter_185_comment =
  "C++ Interface:\n"
  "get_parameter(Event self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_get_parameter_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Event::has_receiver(void) const
 */
static PyObject *Dtool_Event_has_receiver_187(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Event::has_receiver(void) const
  bool return_value = (*(const Event*)local_this).has_receiver();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_has_receiver_187_comment =
  "C++ Interface:\n"
  "has_receiver(Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_has_receiver_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Event::clear_receiver(void)
 */
static PyObject *Dtool_Event_clear_receiver_190(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.clear_receiver")) {
    return NULL;
  }
  // 1-void Event::clear_receiver(void)
  (*local_this).clear_receiver();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Event_clear_receiver_190_comment =
  "C++ Interface:\n"
  "clear_receiver(const Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_clear_receiver_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Event::output(ostream &out) const
 */
static PyObject *Dtool_Event_output_191(PyObject *self, PyObject *arg) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Event::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Event.output", false, true);
  if (arg_this != NULL) {
    (*(const Event*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Event self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Event_output_191_comment =
  "C++ Interface:\n"
  "output(Event self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_output_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Event::get_class_type(void)
 */
static PyObject *Dtool_Event_get_class_type_200(PyObject *, PyObject *) {
  // 1-static TypeHandle Event::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Event::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Event_get_class_type_200_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Event_get_class_type_200_comment = NULL;
#endif

static PyObject *Dtool_Event_name_Getter(PyObject *self, void *) {
  const Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &Event::get_name(void) const
  std::string const &return_value = (*(const Event*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Event_name_Setter(PyObject *self, PyObject *arg, void *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.name")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void Event::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const Event self, str name)\n");
  }
  return -1;
}

/**
 * sequence length function for property Event::parameters
 */
static Py_ssize_t Dtool_Event_parameters_Len(PyObject *self) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_parameters();
}

/**
 * sequence getter for property Event::parameters
 */
static PyObject *Dtool_Event_parameters_Getitem(PyObject *self, Py_ssize_t index) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_parameters()) {
    PyErr_SetString(PyExc_IndexError, "Event.parameters[] index out of range");
    return NULL;
  }
  // 1-EventParameter Event::get_parameter(int n) const
  EventParameter *return_value = new EventParameter((*(const Event*)local_this).get_parameter(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parameter(Event self, index)\n");
  }
}

static PyObject *Dtool_Event_parameters_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_Event_parameters_Len;
  wrap->_getitem_func = &Dtool_Event_parameters_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * Event::Event(Event const &copy)
 * Event::Event(std::string const &event_name, EventReceiver *receiver = 0)
 */
static int Dtool_Init_Event(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 Event::Event(std::string const &event_name, EventReceiver *receiver = 0)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"event_name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Event", (char **)keyword_list, &param0_str, &param0_len)) {
      Event *return_value = new Event(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Event, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: Event::Event(std::string const &event_name, EventReceiver *receiver = 0)
  {
    // -2 Event::Event(Event const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Event", (char **)keyword_list, &param0)) {
      CPT(Event) param0_this;
      if (Dtool_ConstCoerce_Event(param0, param0_this)) {
        Event *return_value = new Event(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Event, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Event(str event_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Event(PyObject *args, CPT(Event) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Event, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Event *return_value = new Event(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      if (PyArg_ParseTuple(args, "s#:Event", &param0_str, &param0_len)) {
        Event *return_value = new Event(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Event(PyObject *args, PT(Event) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Event, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Event *return_value = new Event(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      if (PyArg_ParseTuple(args, "s#:Event", &param0_str, &param0_len)) {
        Event *return_value = new Event(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Event_get_parameters(PyObject *self, PyObject *) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_parameters();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Event_get_parameter_185(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Event(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Event) {
    printf("Event ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Event *local_this = (Event *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Event) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Event(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Event) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Event*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Event*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Event*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EventHandler
 */
/**
 * Python function wrapper for:
 * void EventHandler::process_events(void)
 */
static PyObject *Dtool_EventHandler_process_events_204(PyObject *self, PyObject *) {
  EventHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventHandler, (void **)&local_this, "EventHandler.process_events")) {
    return NULL;
  }
  // 1-void EventHandler::process_events(void)
  (*local_this).process_events();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_process_events_204_comment =
  "C++ Interface:\n"
  "process_events(const EventHandler self)\n"
  "\n"
  "/**\n"
  " * The main processing loop of the EventHandler.  This function must be called\n"
  " * periodically to service events.  Walks through each pending event and calls\n"
  " * its assigned hooks.\n"
  " */";
#else
static const char *Dtool_EventHandler_process_events_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void EventHandler::dispatch_event(Event const *)
 */
static PyObject *Dtool_EventHandler_dispatch_event_205(PyObject *self, PyObject *arg) {
  EventHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventHandler, (void **)&local_this, "EventHandler.dispatch_event")) {
    return NULL;
  }
  // 1-virtual void EventHandler::dispatch_event(Event const *)
  CPT(Event) arg_this;
  if (!Dtool_ConstCoerce_Event(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EventHandler.dispatch_event", "Event");
  }
  (*local_this).dispatch_event(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dispatch_event(const EventHandler self, const Event param0)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_dispatch_event_205_comment =
  "C++ Interface:\n"
  "dispatch_event(const EventHandler self, const Event param0)\n"
  "\n"
  "/**\n"
  " * Calls the hooks assigned to the indicated single event.\n"
  " */";
#else
static const char *Dtool_EventHandler_dispatch_event_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EventHandler::write(ostream &out) const
 */
static PyObject *Dtool_EventHandler_write_206(PyObject *self, PyObject *arg) {
  EventHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventHandler, (void **)&local_this)) {
    return NULL;
  }
  // 1-void EventHandler::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "EventHandler.write", false, true);
  if (arg_this != NULL) {
    (*(const EventHandler*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EventHandler self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_write_206_comment =
  "C++ Interface:\n"
  "write(EventHandler self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventHandler_write_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = 0)
 */
static PyObject *Dtool_EventHandler_get_global_event_handler_207(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = 0)
  PyObject *param0 = NULL;
  static const char *keyword_list[] = {"queue", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:get_global_event_handler", (char **)keyword_list, &param0)) {
    EventQueue *param0_this = 0;
    if (param0 != (PyObject *)NULL) {
      param0_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EventQueue, 0, "EventHandler.get_global_event_handler", false, true);
    }
    if ((param0 == NULL || param0_this != NULL)) {
      EventHandler *return_value = EventHandler::get_global_event_handler(param0_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      if (return_value == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EventHandler, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_global_event_handler(EventQueue queue)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_get_global_event_handler_207_comment =
  "C++ Interface:\n"
  "get_global_event_handler(EventQueue queue)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one global EventHandler object.  If the global\n"
  " * object has not yet been created, this will create it.\n"
  " */";
#else
static const char *Dtool_EventHandler_get_global_event_handler_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EventHandler::get_class_type(void)
 */
static PyObject *Dtool_EventHandler_get_class_type_208(PyObject *, PyObject *) {
  // 1-static TypeHandle EventHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(EventHandler::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_get_class_type_208_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EventHandler_get_class_type_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline EventHandler::EventHandler(EventHandler const &) = default
 * EventHandler::EventHandler(EventQueue *ev_queue)
 */
static int Dtool_Init_EventHandler(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EventHandler() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline EventHandler::EventHandler(EventHandler const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventHandler", (char **)keyword_list, &param0)) {
      EventHandler const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_EventHandler, (void **)&param0_this);
      if (param0_this != NULL) {
        EventHandler *return_value = new EventHandler(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventHandler, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 EventHandler::EventHandler(EventQueue *ev_queue)
    PyObject *param0;
    static const char *keyword_list[] = {"ev_queue", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventHandler", (char **)keyword_list, &param0)) {
      EventQueue *param0_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EventQueue, 0, "EventHandler.EventHandler", false, false);
      if (param0_this != NULL) {
        EventHandler *return_value = new EventHandler(param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventHandler, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline EventHandler::EventHandler(EventHandler const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:EventHandler", (char **)keyword_list, &param0)) {
      EventHandler const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_EventHandler(param0, param0_this, param0_manage)) {
        EventHandler *return_value = new EventHandler(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventHandler, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: EventHandler::EventHandler(EventQueue *ev_queue)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EventHandler(const EventHandler param0)\n"
      "EventHandler(EventQueue ev_queue)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_EventHandler(PyObject *args, EventHandler const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EventHandler, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EventHandler::EventHandler(EventQueue *ev_queue)
    EventQueue *arg_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EventQueue, 0, "EventHandler.EventHandler", false, false);
    if (arg_this != NULL) {
      EventHandler *return_value = new EventHandler(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_EventHandler(PyObject *args, EventHandler *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_EventHandler, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-EventHandler::EventHandler(EventQueue *ev_queue)
    EventQueue *arg_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EventQueue, 0, "EventHandler.EventHandler", false, false);
    if (arg_this != NULL) {
      EventHandler *return_value = new EventHandler(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_EventHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EventHandler) {
    printf("EventHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EventHandler *local_this = (EventHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EventHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EventHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EventHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EventHandler*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class EventQueue
 */
/**
 * Python function wrapper for:
 * void EventQueue::queue_event(CPT_Event event)
 */
static PyObject *Dtool_EventQueue_queue_event_213(PyObject *self, PyObject *arg) {
  EventQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventQueue, (void **)&local_this, "EventQueue.queue_event")) {
    return NULL;
  }
  // 1-void EventQueue::queue_event(CPT_Event event)
  CPT(Event) arg_this;
  if (!Dtool_ConstCoerce_Event(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EventQueue.queue_event", "Event");
  }
  (*local_this).queue_event(MOVE(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "queue_event(const EventQueue self, const Event event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_queue_event_213_comment =
  "C++ Interface:\n"
  "queue_event(const EventQueue self, const Event event)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventQueue_queue_event_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void EventQueue::clear(void)
 */
static PyObject *Dtool_EventQueue_clear_214(PyObject *self, PyObject *) {
  EventQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventQueue, (void **)&local_this, "EventQueue.clear")) {
    return NULL;
  }
  // 1-void EventQueue::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_clear_214_comment =
  "C++ Interface:\n"
  "clear(const EventQueue self)\n"
  "\n"
  "/**\n"
  " * Empties all events on the queue, throwing them on the floor.\n"
  " */";
#else
static const char *Dtool_EventQueue_clear_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EventQueue::is_queue_empty(void) const
 */
static PyObject *Dtool_EventQueue_is_queue_empty_215(PyObject *self, PyObject *) {
  EventQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventQueue, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EventQueue::is_queue_empty(void) const
  bool return_value = (*(const EventQueue*)local_this).is_queue_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_is_queue_empty_215_comment =
  "C++ Interface:\n"
  "is_queue_empty(EventQueue self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventQueue_is_queue_empty_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool EventQueue::is_queue_full(void) const
 */
static PyObject *Dtool_EventQueue_is_queue_full_216(PyObject *self, PyObject *) {
  EventQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventQueue, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool EventQueue::is_queue_full(void) const
  bool return_value = (*(const EventQueue*)local_this).is_queue_full();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_is_queue_full_216_comment =
  "C++ Interface:\n"
  "is_queue_full(EventQueue self)\n"
  "\n"
  "/**\n"
  " * This function is deprecated--the queue is never full these days.\n"
  " */";
#else
static const char *Dtool_EventQueue_is_queue_full_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CPT_Event EventQueue::dequeue_event(void)
 */
static PyObject *Dtool_EventQueue_dequeue_event_217(PyObject *self, PyObject *) {
  EventQueue *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventQueue, (void **)&local_this, "EventQueue.dequeue_event")) {
    return NULL;
  }
  // 1-CPT_Event EventQueue::dequeue_event(void)
  ConstPointerTo< Event > return_value = (*local_this).dequeue_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  Event const *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Event, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_dequeue_event_217_comment =
  "C++ Interface:\n"
  "dequeue_event(const EventQueue self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventQueue_dequeue_event_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline EventQueue *EventQueue::get_global_event_queue(void)
 */
static PyObject *Dtool_EventQueue_get_global_event_queue_218(PyObject *, PyObject *) {
  // 1-static inline EventQueue *EventQueue::get_global_event_queue(void)
  EventQueue *return_value = EventQueue::get_global_event_queue();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventQueue, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_get_global_event_queue_218_comment =
  "C++ Interface:\n"
  "get_global_event_queue()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one global EventQueue object.  If the global\n"
  " * object has not yet been created, this will create it.\n"
  " */";
#else
static const char *Dtool_EventQueue_get_global_event_queue_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * EventQueue::EventQueue(void)
 */
static int Dtool_Init_EventQueue(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EventQueue() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EventQueue::EventQueue(void)
  EventQueue *return_value = new EventQueue();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventQueue, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EventQueue()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EventQueue(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_EventQueue) {
    printf("EventQueue ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  EventQueue *local_this = (EventQueue *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_EventQueue) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_EventQueue(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_EventQueue) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerEventList
 */
/**
 * Python function wrapper for:
 * inline int PointerEventList::get_num_events(void) const
 */
static PyObject *Dtool_PointerEventList_get_num_events_222(PyObject *self, PyObject *) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerEventList::get_num_events(void) const
  int return_value = (*(const PointerEventList*)local_this).get_num_events();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_num_events_222_comment =
  "C++ Interface:\n"
  "get_num_events(PointerEventList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of events in the list.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_num_events_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerEventList::get_in_window(int n) const
 */
static PyObject *Dtool_PointerEventList_get_in_window_223(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PointerEventList::get_in_window(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const PointerEventList*)local_this).get_in_window((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in_window(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_in_window_223_comment =
  "C++ Interface:\n"
  "get_in_window(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the in-window flag of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_in_window_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_xpos(int n) const
 */
static PyObject *Dtool_PointerEventList_get_xpos_224(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerEventList::get_xpos(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const PointerEventList*)local_this).get_xpos((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xpos(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_xpos_224_comment =
  "C++ Interface:\n"
  "get_xpos(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the x-coordinate of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_xpos_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_ypos(int n) const
 */
static PyObject *Dtool_PointerEventList_get_ypos_225(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerEventList::get_ypos(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const PointerEventList*)local_this).get_ypos((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ypos(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_ypos_225_comment =
  "C++ Interface:\n"
  "get_ypos(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the y-coordinate of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_ypos_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_dx(int n) const
 */
static PyObject *Dtool_PointerEventList_get_dx_226(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerEventList::get_dx(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const PointerEventList*)local_this).get_dx((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dx(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_dx_226_comment =
  "C++ Interface:\n"
  "get_dx(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the x-coordinate of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_dx_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_dy(int n) const
 */
static PyObject *Dtool_PointerEventList_get_dy_227(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerEventList::get_dy(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const PointerEventList*)local_this).get_dy((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dy(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_dy_227_comment =
  "C++ Interface:\n"
  "get_dy(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the y-coordinate of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_dy_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_sequence(int n) const
 */
static PyObject *Dtool_PointerEventList_get_sequence_228(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerEventList::get_sequence(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const PointerEventList*)local_this).get_sequence((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sequence(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_sequence_228_comment =
  "C++ Interface:\n"
  "get_sequence(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the sequence number of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_sequence_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_length(int n) const
 */
static PyObject *Dtool_PointerEventList_get_length_229(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double PointerEventList::get_length(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const PointerEventList*)local_this).get_length((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_length(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_length_229_comment =
  "C++ Interface:\n"
  "get_length(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the length of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_length_229_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_direction(int n) const
 */
static PyObject *Dtool_PointerEventList_get_direction_230(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double PointerEventList::get_direction(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const PointerEventList*)local_this).get_direction((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_direction(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_direction_230_comment =
  "C++ Interface:\n"
  "get_direction(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the direction of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_direction_230_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_rotation(int n) const
 */
static PyObject *Dtool_PointerEventList_get_rotation_231(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double PointerEventList::get_rotation(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const PointerEventList*)local_this).get_rotation((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rotation(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_rotation_231_comment =
  "C++ Interface:\n"
  "get_rotation(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the rotation of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_rotation_231_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_time(int n) const
 */
static PyObject *Dtool_PointerEventList_get_time_232(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double PointerEventList::get_time(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = (*(const PointerEventList*)local_this).get_time((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_time(PointerEventList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_time_232_comment =
  "C++ Interface:\n"
  "get_time(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the timestamp of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_time_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerEventList::clear(void)
 */
static PyObject *Dtool_PointerEventList_clear_233(PyObject *self, PyObject *) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.clear")) {
    return NULL;
  }
  // 1-inline void PointerEventList::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_clear_233_comment =
  "C++ Interface:\n"
  "clear(const PointerEventList self)\n"
  "\n"
  "/**\n"
  " * Empties all the events from the list.\n"
  " */";
#else
static const char *Dtool_PointerEventList_clear_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerEventList::pop_front(void)
 */
static PyObject *Dtool_PointerEventList_pop_front_234(PyObject *self, PyObject *) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.pop_front")) {
    return NULL;
  }
  // 1-inline void PointerEventList::pop_front(void)
  (*local_this).pop_front();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_pop_front_234_comment =
  "C++ Interface:\n"
  "pop_front(const PointerEventList self)\n"
  "\n"
  "/**\n"
  " * Discards the first event on the list.\n"
  " */";
#else
static const char *Dtool_PointerEventList_pop_front_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time)
 */
static PyObject *Dtool_PointerEventList_add_event_235(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.add_event")) {
    return NULL;
  }
  // 1-void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time)
  PyObject *param1;
  int param2;
  int param3;
  int param4;
  double param5;
  static const char *keyword_list[] = {"in_win", "xpos", "ypos", "seq", "time", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiiid:add_event", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    (*local_this).add_event((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3, (int)param4, (double)param5);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_event(const PointerEventList self, bool in_win, int xpos, int ypos, int seq, double time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_add_event_235_comment =
  "C++ Interface:\n"
  "add_event(const PointerEventList self, bool in_win, int xpos, int ypos, int seq, double time)\n"
  "\n"
  "/**\n"
  " * Adds a new event to the end of the list.  Automatically calculates the dx,\n"
  " * dy, length, direction, and rotation for all but the first event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_add_event_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PointerEventList::encircles(int x, int y) const
 */
static PyObject *Dtool_PointerEventList_encircles_236(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PointerEventList::encircles(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:encircles", (char **)keyword_list, &param1, &param2)) {
    bool return_value = (*(const PointerEventList*)local_this).encircles((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encircles(PointerEventList self, int x, int y)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_encircles_236_comment =
  "C++ Interface:\n"
  "encircles(PointerEventList self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns true if the trail loops around the specified point.\n"
  " */";
#else
static const char *Dtool_PointerEventList_encircles_236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double PointerEventList::total_turns(double sec) const
 */
static PyObject *Dtool_PointerEventList_total_turns_237(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerEventList, (void **)&local_this)) {
    return NULL;
  }
  // 1-double PointerEventList::total_turns(double sec) const
  if (PyNumber_Check(arg)) {
    double return_value = (*(const PointerEventList*)local_this).total_turns(PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "total_turns(PointerEventList self, double sec)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_total_turns_237_comment =
  "C++ Interface:\n"
  "total_turns(PointerEventList self, double sec)\n"
  "\n"
  "/**\n"
  " * returns the total angular deviation that the trail has made in the\n"
  " * specified time period.  A small number means that the trail is moving in a\n"
  " * relatively straight line, a large number means that the trail is zig-\n"
  " * zagging or spinning.  The result is in degrees.\n"
  " */";
#else
static const char *Dtool_PointerEventList_total_turns_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double PointerEventList::match_pattern(std::string const &pattern, double rot, double seglen)
 */
static PyObject *Dtool_PointerEventList_match_pattern_238(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerEventList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.match_pattern")) {
    return NULL;
  }
  // 1-double PointerEventList::match_pattern(std::string const &pattern, double rot, double seglen)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  double param2;
  double param3;
  static const char *keyword_list[] = {"pattern", "rot", "seglen", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dd:match_pattern", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    double return_value = (*local_this).match_pattern(std::string(param1_str, param1_len), (double)param2, (double)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "match_pattern(const PointerEventList self, str pattern, double rot, double seglen)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_match_pattern_238_comment =
  "C++ Interface:\n"
  "match_pattern(const PointerEventList self, str pattern, double rot, double seglen)\n"
  "\n"
  "/**\n"
  " * This function is not implemented yet.  It is a work in progress.  The\n"
  " * intent is as follows:\n"
  " *\n"
  " * Returns a nonzero value if the mouse movements match the specified pattern.\n"
  " * The higher the value, the better the match.  The pattern is a sequence of\n"
  " * compass directions (ie, \"E\", \"NE\", etc) separated by spaces.  If rot is\n"
  " * nonzero, then the pattern is rotated counterclockwise by the specified\n"
  " * amount before testing.  Seglen is the minimum length a mouse movement needs\n"
  " * to be in order to be considered significant.\n"
  " */";
#else
static const char *Dtool_PointerEventList_match_pattern_238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PointerEventList::get_class_type(void)
 */
static PyObject *Dtool_PointerEventList_get_class_type_239(PyObject *, PyObject *) {
  // 1-static TypeHandle PointerEventList::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PointerEventList::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_class_type_239_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PointerEventList_get_class_type_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerEventList::PointerEventList(void)
 */
static int Dtool_Init_PointerEventList(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PointerEventList() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline PointerEventList::PointerEventList(void)
  PointerEventList *return_value = new PointerEventList();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerEventList, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerEventList()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PointerEventList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerEventList) {
    printf("PointerEventList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerEventList *local_this = (PointerEventList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerEventList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerEventList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerEventList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PointerEventList*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PythonTask
 */
/**
 * Python function wrapper for:
 * void PythonTask::set_function(PyObject *function)
 */
static PyObject *Dtool_PythonTask_set_function_246(PyObject *self, PyObject *arg) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_function")) {
    return NULL;
  }
  // 1-void PythonTask::set_function(PyObject *function)
  (*local_this).set_function(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_function(const PythonTask self, object function)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_function_246_comment =
  "C++ Interface:\n"
  "set_function(const PythonTask self, object function)\n";
#else
static const char *Dtool_PythonTask_set_function_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonTask::get_function(void)
 */
static PyObject *Dtool_PythonTask_get_function_247(PyObject *self, PyObject *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_function")) {
    return NULL;
  }
  // 1-PyObject *PythonTask::get_function(void)
  PyObject *return_value = (*local_this).get_function();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_function_247_comment =
  "C++ Interface:\n"
  "get_function(const PythonTask self)\n";
#else
static const char *Dtool_PythonTask_get_function_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PythonTask::set_args(PyObject *args, bool append_task)
 */
static PyObject *Dtool_PythonTask_set_args_248(PyObject *self, PyObject *args, PyObject *kwds) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_args")) {
    return NULL;
  }
  // 1-void PythonTask::set_args(PyObject *args, bool append_task)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"args", "append_task", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_args", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_args(param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_args(const PythonTask self, object args, bool append_task)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_args_248_comment =
  "C++ Interface:\n"
  "set_args(const PythonTask self, object args, bool append_task)\n";
#else
static const char *Dtool_PythonTask_set_args_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonTask::get_args(void)
 */
static PyObject *Dtool_PythonTask_get_args_249(PyObject *self, PyObject *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_args")) {
    return NULL;
  }
  // 1-PyObject *PythonTask::get_args(void)
  PyObject *return_value = (*local_this).get_args();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_args_249_comment =
  "C++ Interface:\n"
  "get_args(const PythonTask self)\n";
#else
static const char *Dtool_PythonTask_get_args_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PythonTask::set_upon_death(PyObject *upon_death)
 */
static PyObject *Dtool_PythonTask_set_upon_death_250(PyObject *self, PyObject *arg) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_upon_death")) {
    return NULL;
  }
  // 1-void PythonTask::set_upon_death(PyObject *upon_death)
  (*local_this).set_upon_death(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_upon_death(const PythonTask self, object upon_death)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_upon_death_250_comment =
  "C++ Interface:\n"
  "set_upon_death(const PythonTask self, object upon_death)\n";
#else
static const char *Dtool_PythonTask_set_upon_death_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonTask::get_upon_death(void)
 */
static PyObject *Dtool_PythonTask_get_upon_death_251(PyObject *self, PyObject *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_upon_death")) {
    return NULL;
  }
  // 1-PyObject *PythonTask::get_upon_death(void)
  PyObject *return_value = (*local_this).get_upon_death();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_upon_death_251_comment =
  "C++ Interface:\n"
  "get_upon_death(const PythonTask self)\n";
#else
static const char *Dtool_PythonTask_get_upon_death_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PythonTask::set_owner(PyObject *owner)
 */
static PyObject *Dtool_PythonTask_set_owner_252(PyObject *self, PyObject *arg) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_owner")) {
    return NULL;
  }
  // 1-void PythonTask::set_owner(PyObject *owner)
  (*local_this).set_owner(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_owner(const PythonTask self, object owner)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_owner_252_comment =
  "C++ Interface:\n"
  "set_owner(const PythonTask self, object owner)\n";
#else
static const char *Dtool_PythonTask_set_owner_252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonTask::get_owner(void)
 */
static PyObject *Dtool_PythonTask_get_owner_253(PyObject *self, PyObject *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_owner")) {
    return NULL;
  }
  // 1-PyObject *PythonTask::get_owner(void)
  PyObject *return_value = (*local_this).get_owner();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_owner_253_comment =
  "C++ Interface:\n"
  "get_owner(const PythonTask self)\n";
#else
static const char *Dtool_PythonTask_get_owner_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PythonTask::set_delay(PyObject *delay)
 */
static PyObject *Dtool_PythonTask_set_delay_259(PyObject *self, PyObject *arg) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_delay")) {
    return NULL;
  }
  // 1-inline void PythonTask::set_delay(PyObject *delay)
  (*local_this).set_delay(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_delay(const PythonTask self, object delay)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_delay_259_comment =
  "C++ Interface:\n"
  "set_delay(const PythonTask self, object delay)\n"
  "\n"
  "/**\n"
  " * If None is passed, calls clear_delay, otherwise sets the delay time.  See\n"
  " * AsyncTask::set_delay() and AsyncTask::clear_delay().\n"
  " */";
#else
static const char *Dtool_PythonTask_set_delay_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *PythonTask::get_delay(void) const
 */
static PyObject *Dtool_PythonTask_get_delay_260(PyObject *self, PyObject *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PyObject *PythonTask::get_delay(void) const
  PyObject *return_value = (*(const PythonTask*)local_this).get_delay();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_delay_260_comment =
  "C++ Interface:\n"
  "get_delay(PythonTask self)\n"
  "\n"
  "/**\n"
  " * Returns the delay time if set, None otherwise.  See AsyncTask::has_delay()\n"
  " * and AsyncTask::get_delay().\n"
  " */";
#else
static const char *Dtool_PythonTask_get_delay_260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PythonTask::get_class_type(void)
 */
static PyObject *Dtool_PythonTask_get_class_type_285(PyObject *, PyObject *) {
  // 1-static TypeHandle PythonTask::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PythonTask::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_class_type_285_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PythonTask_get_class_type_285_comment = NULL;
#endif

static PyObject *Dtool_PythonTask_name_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &PythonTask::get_name(void) const
  std::string const &return_value = (*(const PythonTask*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask_name_Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.name")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-void PythonTask::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const PythonTask self, str name)\n");
  }
  return -1;
}

static PyObject *Dtool_PythonTask_time_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-double PythonTask::get_elapsed_time(void) const
  double return_value = (*(const PythonTask*)local_this).get_elapsed_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_wake_time_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-double PythonTask::get_wake_time(void) const
  double return_value = (*(const PythonTask*)local_this).get_wake_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_wakeTime_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-double PythonTask::get_wake_time(void) const
  double return_value = (*(const PythonTask*)local_this).get_wake_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_delay_time_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *PythonTask::get_delay(void) const
  PyObject *return_value = (*(const PythonTask*)local_this).get_delay();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask_delay_time_Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.delay_time")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete delay_time attribute");
    return -1;
  }
  // 1-inline void PythonTask::set_delay(PyObject *delay)
  (*local_this).set_delay(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_delay(const PythonTask self, object delay)\n");
  }
  return -1;
}

static PyObject *Dtool_PythonTask_delayTime_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PyObject *PythonTask::get_delay(void) const
  PyObject *return_value = (*(const PythonTask*)local_this).get_delay();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask_delayTime_Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.delayTime")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete delayTime attribute");
    return -1;
  }
  // 1-inline void PythonTask::set_delay(PyObject *delay)
  (*local_this).set_delay(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_delay(const PythonTask self, object delay)\n");
  }
  return -1;
}

static PyObject *Dtool_PythonTask_frame_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-int PythonTask::get_elapsed_frames(void) const
  int return_value = (*(const PythonTask*)local_this).get_elapsed_frames();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_id_Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline AtomicAdjust::Integer PythonTask::get_task_id(void) const
  AtomicAdjust::Integer return_value = (*(const PythonTask*)local_this).get_task_id();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask___dict___Getter(PyObject *self, void *) {
  const PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-PyObject *PythonTask::get_dict(void) const
  PyObject *return_value = ((const PythonTask*)local_this)->__dict__;
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask___dict___Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.__dict__")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete __dict__ attribute");
    return -1;
  }
  // 1-void PythonTask::set_dict(PyObject *value)
  (local_this)->__dict__ = arg;
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dict(const PythonTask self, object value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PythonTask::PythonTask(PyObject *function = (& ::_Py_NoneStruct), std::string const &name = string())
 * inline PythonTask::PythonTask(PythonTask const &) = default
 */
static int Dtool_Init_PythonTask(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
      PythonTask *return_value = new PythonTask();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonTask, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 PythonTask::PythonTask(PyObject *function, std::string const &name = string())
        PyObject *param0;
        const char *param1_str = "";
        Py_ssize_t param1_len = 0;
        static const char *keyword_list[] = {"function", "name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:PythonTask", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
          PythonTask *return_value = new PythonTask(param0, std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            unref_delete(return_value);
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              unref_delete(return_value);
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonTask, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PythonTask::PythonTask(PyObject *function, std::string const &name = string())
      {
        // -2 inline PythonTask::PythonTask(PythonTask const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PythonTask", (char **)keyword_list, &param0)) {
          CPT(PythonTask) param0_this;
          if (Dtool_ConstCoerce_PythonTask(param0, param0_this)) {
            PythonTask *return_value = new PythonTask(*MOVE(param0_this));
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonTask, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PythonTask() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PythonTask()\n"
      "PythonTask(object function, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PythonTask(PyObject *args, CPT(PythonTask) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PythonTask, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
    PythonTask *return_value = new PythonTask(arg);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = MOVE(return_value);
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:PythonTask", &param0, &param1_str, &param1_len)) {
        PythonTask *return_value = new PythonTask(param0, std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PythonTask(PyObject *args, PT(PythonTask) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PythonTask, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
    PythonTask *return_value = new PythonTask(arg);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = MOVE(return_value);
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:PythonTask", &param0, &param1_str, &param1_len)) {
        PythonTask *return_value = new PythonTask(param0, std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != (PyObject *)NULL) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = MOVE(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PythonTask(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PythonTask) {
    printf("PythonTask ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PythonTask *local_this = (PythonTask *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PythonTask) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return (AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PythonTask(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PythonTask) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PythonTask*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for AsyncTask (AsyncTask)
 */
static PyMethodDef Dtool_Methods_AsyncTask[] = {
  {"get_state", &Dtool_AsyncTask_get_state_5, METH_NOARGS, (const char *)Dtool_AsyncTask_get_state_5_comment},
  {"getState", &Dtool_AsyncTask_get_state_5, METH_NOARGS, (const char *)Dtool_AsyncTask_get_state_5_comment},
  {"is_alive", &Dtool_AsyncTask_is_alive_6, METH_NOARGS, (const char *)Dtool_AsyncTask_is_alive_6_comment},
  {"isAlive", &Dtool_AsyncTask_is_alive_6, METH_NOARGS, (const char *)Dtool_AsyncTask_is_alive_6_comment},
  {"get_manager", &Dtool_AsyncTask_get_manager_7, METH_NOARGS, (const char *)Dtool_AsyncTask_get_manager_7_comment},
  {"getManager", &Dtool_AsyncTask_get_manager_7, METH_NOARGS, (const char *)Dtool_AsyncTask_get_manager_7_comment},
  {"remove", &Dtool_AsyncTask_remove_8, METH_NOARGS, (const char *)Dtool_AsyncTask_remove_8_comment},
  {"set_delay", &Dtool_AsyncTask_set_delay_9, METH_O, (const char *)Dtool_AsyncTask_set_delay_9_comment},
  {"setDelay", &Dtool_AsyncTask_set_delay_9, METH_O, (const char *)Dtool_AsyncTask_set_delay_9_comment},
  {"clear_delay", &Dtool_AsyncTask_clear_delay_10, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_delay_10_comment},
  {"clearDelay", &Dtool_AsyncTask_clear_delay_10, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_delay_10_comment},
  {"has_delay", &Dtool_AsyncTask_has_delay_11, METH_NOARGS, (const char *)Dtool_AsyncTask_has_delay_11_comment},
  {"hasDelay", &Dtool_AsyncTask_has_delay_11, METH_NOARGS, (const char *)Dtool_AsyncTask_has_delay_11_comment},
  {"get_delay", &Dtool_AsyncTask_get_delay_12, METH_NOARGS, (const char *)Dtool_AsyncTask_get_delay_12_comment},
  {"getDelay", &Dtool_AsyncTask_get_delay_12, METH_NOARGS, (const char *)Dtool_AsyncTask_get_delay_12_comment},
  {"get_wake_time", &Dtool_AsyncTask_get_wake_time_13, METH_NOARGS, (const char *)Dtool_AsyncTask_get_wake_time_13_comment},
  {"getWakeTime", &Dtool_AsyncTask_get_wake_time_13, METH_NOARGS, (const char *)Dtool_AsyncTask_get_wake_time_13_comment},
  {"recalc_wake_time", &Dtool_AsyncTask_recalc_wake_time_14, METH_NOARGS, (const char *)Dtool_AsyncTask_recalc_wake_time_14_comment},
  {"recalcWakeTime", &Dtool_AsyncTask_recalc_wake_time_14, METH_NOARGS, (const char *)Dtool_AsyncTask_recalc_wake_time_14_comment},
  {"get_start_time", &Dtool_AsyncTask_get_start_time_15, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_time_15_comment},
  {"getStartTime", &Dtool_AsyncTask_get_start_time_15, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_time_15_comment},
  {"get_elapsed_time", &Dtool_AsyncTask_get_elapsed_time_16, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_time_16_comment},
  {"getElapsedTime", &Dtool_AsyncTask_get_elapsed_time_16, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_time_16_comment},
  {"get_start_frame", &Dtool_AsyncTask_get_start_frame_17, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_frame_17_comment},
  {"getStartFrame", &Dtool_AsyncTask_get_start_frame_17, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_frame_17_comment},
  {"get_elapsed_frames", &Dtool_AsyncTask_get_elapsed_frames_18, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_frames_18_comment},
  {"getElapsedFrames", &Dtool_AsyncTask_get_elapsed_frames_18, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_frames_18_comment},
  {"set_name", &Dtool_AsyncTask_set_name_19, METH_O, (const char *)Dtool_AsyncTask_set_name_19_comment},
  {"setName", &Dtool_AsyncTask_set_name_19, METH_O, (const char *)Dtool_AsyncTask_set_name_19_comment},
  {"clear_name", &Dtool_AsyncTask_clear_name_20, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_name_20_comment},
  {"clearName", &Dtool_AsyncTask_clear_name_20, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_name_20_comment},
  {"get_name_prefix", &Dtool_AsyncTask_get_name_prefix_21, METH_NOARGS, (const char *)Dtool_AsyncTask_get_name_prefix_21_comment},
  {"getNamePrefix", &Dtool_AsyncTask_get_name_prefix_21, METH_NOARGS, (const char *)Dtool_AsyncTask_get_name_prefix_21_comment},
  {"get_task_id", &Dtool_AsyncTask_get_task_id_22, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_id_22_comment},
  {"getTaskId", &Dtool_AsyncTask_get_task_id_22, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_id_22_comment},
  {"set_task_chain", &Dtool_AsyncTask_set_task_chain_23, METH_O, (const char *)Dtool_AsyncTask_set_task_chain_23_comment},
  {"setTaskChain", &Dtool_AsyncTask_set_task_chain_23, METH_O, (const char *)Dtool_AsyncTask_set_task_chain_23_comment},
  {"get_task_chain", &Dtool_AsyncTask_get_task_chain_24, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_chain_24_comment},
  {"getTaskChain", &Dtool_AsyncTask_get_task_chain_24, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_chain_24_comment},
  {"set_sort", &Dtool_AsyncTask_set_sort_25, METH_O, (const char *)Dtool_AsyncTask_set_sort_25_comment},
  {"setSort", &Dtool_AsyncTask_set_sort_25, METH_O, (const char *)Dtool_AsyncTask_set_sort_25_comment},
  {"get_sort", &Dtool_AsyncTask_get_sort_26, METH_NOARGS, (const char *)Dtool_AsyncTask_get_sort_26_comment},
  {"getSort", &Dtool_AsyncTask_get_sort_26, METH_NOARGS, (const char *)Dtool_AsyncTask_get_sort_26_comment},
  {"set_priority", &Dtool_AsyncTask_set_priority_27, METH_O, (const char *)Dtool_AsyncTask_set_priority_27_comment},
  {"setPriority", &Dtool_AsyncTask_set_priority_27, METH_O, (const char *)Dtool_AsyncTask_set_priority_27_comment},
  {"get_priority", &Dtool_AsyncTask_get_priority_28, METH_NOARGS, (const char *)Dtool_AsyncTask_get_priority_28_comment},
  {"getPriority", &Dtool_AsyncTask_get_priority_28, METH_NOARGS, (const char *)Dtool_AsyncTask_get_priority_28_comment},
  {"set_done_event", &Dtool_AsyncTask_set_done_event_29, METH_O, (const char *)Dtool_AsyncTask_set_done_event_29_comment},
  {"setDoneEvent", &Dtool_AsyncTask_set_done_event_29, METH_O, (const char *)Dtool_AsyncTask_set_done_event_29_comment},
  {"get_done_event", &Dtool_AsyncTask_get_done_event_30, METH_NOARGS, (const char *)Dtool_AsyncTask_get_done_event_30_comment},
  {"getDoneEvent", &Dtool_AsyncTask_get_done_event_30, METH_NOARGS, (const char *)Dtool_AsyncTask_get_done_event_30_comment},
  {"set_python_object", &Dtool_AsyncTask_set_python_object_31, METH_O, (const char *)Dtool_AsyncTask_set_python_object_31_comment},
  {"setPythonObject", &Dtool_AsyncTask_set_python_object_31, METH_O, (const char *)Dtool_AsyncTask_set_python_object_31_comment},
  {"get_python_object", &Dtool_AsyncTask_get_python_object_32, METH_NOARGS, (const char *)Dtool_AsyncTask_get_python_object_32_comment},
  {"getPythonObject", &Dtool_AsyncTask_get_python_object_32, METH_NOARGS, (const char *)Dtool_AsyncTask_get_python_object_32_comment},
  {"get_dt", &Dtool_AsyncTask_get_dt_33, METH_NOARGS, (const char *)Dtool_AsyncTask_get_dt_33_comment},
  {"getDt", &Dtool_AsyncTask_get_dt_33, METH_NOARGS, (const char *)Dtool_AsyncTask_get_dt_33_comment},
  {"get_max_dt", &Dtool_AsyncTask_get_max_dt_34, METH_NOARGS, (const char *)Dtool_AsyncTask_get_max_dt_34_comment},
  {"getMaxDt", &Dtool_AsyncTask_get_max_dt_34, METH_NOARGS, (const char *)Dtool_AsyncTask_get_max_dt_34_comment},
  {"get_average_dt", &Dtool_AsyncTask_get_average_dt_35, METH_NOARGS, (const char *)Dtool_AsyncTask_get_average_dt_35_comment},
  {"getAverageDt", &Dtool_AsyncTask_get_average_dt_35, METH_NOARGS, (const char *)Dtool_AsyncTask_get_average_dt_35_comment},
  {"output", &Dtool_AsyncTask_output_36, METH_O, (const char *)Dtool_AsyncTask_output_36_comment},
  {"get_class_type", &Dtool_AsyncTask_get_class_type_37, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTask_get_class_type_37_comment},
  {"getClassType", &Dtool_AsyncTask_get_class_type_37, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTask_get_class_type_37_comment},
  {"downcast_to_AsyncTaskSequence", &Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147, METH_NOARGS, (const char *)Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147_comment},
  {"downcastToAsyncTaskSequence", &Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147, METH_NOARGS, (const char *)Dtool_AsyncTask_downcast_to_AsyncTaskSequence_147_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AsyncTask
//////////////////
static PyObject *Dtool_Repr_AsyncTask(PyObject *self) {
  AsyncTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AsyncTask = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTask = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AsyncTask = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AsyncTask = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AsyncTask = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTask",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTask,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AsyncTask,
    &Dtool_NumberMethods_AsyncTask,
    &Dtool_SequenceMethods_AsyncTask,
    &Dtool_MappingMethods_AsyncTask,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_AsyncTask,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AsyncTask,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class represents a concrete task performed by an AsyncManager.\n"
    " * Normally, you would subclass from this class, and override do_task(), to\n"
    " * define the functionality you wish to have the task perform.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTask,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTask,
    PyType_GenericAlloc,
    Dtool_new_AsyncTask,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTask,
  Dtool_UpcastInterface_AsyncTask,
  Dtool_DowncastInterface_AsyncTask,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AsyncTask(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTaskBase != NULL);
    assert(Dtool_Ptr_AsyncTaskBase->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_AsyncTaskBase->_Dtool_ModuleClassInit(NULL);
    Dtool_AsyncTask._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTaskBase);
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_AsyncTask._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AsyncTask::DoneStatus;
    PyDict_SetItemString(dict, "DS_done", Dtool_WrapValue(AsyncTask::DS_done));
    PyDict_SetItemString(dict, "DSDone", Dtool_WrapValue(AsyncTask::DS_done));
    PyDict_SetItemString(dict, "DS_cont", Dtool_WrapValue(AsyncTask::DS_cont));
    PyDict_SetItemString(dict, "DSCont", Dtool_WrapValue(AsyncTask::DS_cont));
    PyDict_SetItemString(dict, "DS_again", Dtool_WrapValue(AsyncTask::DS_again));
    PyDict_SetItemString(dict, "DSAgain", Dtool_WrapValue(AsyncTask::DS_again));
    PyDict_SetItemString(dict, "DS_pickup", Dtool_WrapValue(AsyncTask::DS_pickup));
    PyDict_SetItemString(dict, "DSPickup", Dtool_WrapValue(AsyncTask::DS_pickup));
    PyDict_SetItemString(dict, "DS_exit", Dtool_WrapValue(AsyncTask::DS_exit));
    PyDict_SetItemString(dict, "DSExit", Dtool_WrapValue(AsyncTask::DS_exit));
    PyDict_SetItemString(dict, "DS_pause", Dtool_WrapValue(AsyncTask::DS_pause));
    PyDict_SetItemString(dict, "DSPause", Dtool_WrapValue(AsyncTask::DS_pause));
    PyDict_SetItemString(dict, "DS_interrupt", Dtool_WrapValue(AsyncTask::DS_interrupt));
    PyDict_SetItemString(dict, "DSInterrupt", Dtool_WrapValue(AsyncTask::DS_interrupt));
    // enum AsyncTask::State;
    PyDict_SetItemString(dict, "S_inactive", Dtool_WrapValue(AsyncTask::S_inactive));
    PyDict_SetItemString(dict, "SInactive", Dtool_WrapValue(AsyncTask::S_inactive));
    PyDict_SetItemString(dict, "S_active", Dtool_WrapValue(AsyncTask::S_active));
    PyDict_SetItemString(dict, "SActive", Dtool_WrapValue(AsyncTask::S_active));
    PyDict_SetItemString(dict, "S_servicing", Dtool_WrapValue(AsyncTask::S_servicing));
    PyDict_SetItemString(dict, "SServicing", Dtool_WrapValue(AsyncTask::S_servicing));
    PyDict_SetItemString(dict, "S_servicing_removed", Dtool_WrapValue(AsyncTask::S_servicing_removed));
    PyDict_SetItemString(dict, "SServicingRemoved", Dtool_WrapValue(AsyncTask::S_servicing_removed));
    PyDict_SetItemString(dict, "S_sleeping", Dtool_WrapValue(AsyncTask::S_sleeping));
    PyDict_SetItemString(dict, "SSleeping", Dtool_WrapValue(AsyncTask::S_sleeping));
    PyDict_SetItemString(dict, "S_active_nested", Dtool_WrapValue(AsyncTask::S_active_nested));
    PyDict_SetItemString(dict, "SActiveNested", Dtool_WrapValue(AsyncTask::S_active_nested));
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTask) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTask)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTask);
  }
}

/**
 * Python method tables for AsyncTaskCollection (AsyncTaskCollection)
 */
static PyMethodDef Dtool_Methods_AsyncTaskCollection[] = {
  {"assign", &Dtool_AsyncTaskCollection_operator_41, METH_O, (const char *)Dtool_AsyncTaskCollection_operator_41_comment},
  {"add_task", &Dtool_AsyncTaskCollection_add_task_43, METH_O, (const char *)Dtool_AsyncTaskCollection_add_task_43_comment},
  {"addTask", &Dtool_AsyncTaskCollection_add_task_43, METH_O, (const char *)Dtool_AsyncTaskCollection_add_task_43_comment},
  {"remove_task", &Dtool_AsyncTaskCollection_remove_task_44, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_task_44_comment},
  {"removeTask", &Dtool_AsyncTaskCollection_remove_task_44, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_task_44_comment},
  {"add_tasks_from", &Dtool_AsyncTaskCollection_add_tasks_from_45, METH_O, (const char *)Dtool_AsyncTaskCollection_add_tasks_from_45_comment},
  {"addTasksFrom", &Dtool_AsyncTaskCollection_add_tasks_from_45, METH_O, (const char *)Dtool_AsyncTaskCollection_add_tasks_from_45_comment},
  {"remove_tasks_from", &Dtool_AsyncTaskCollection_remove_tasks_from_46, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_tasks_from_46_comment},
  {"removeTasksFrom", &Dtool_AsyncTaskCollection_remove_tasks_from_46, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_tasks_from_46_comment},
  {"remove_duplicate_tasks", &Dtool_AsyncTaskCollection_remove_duplicate_tasks_47, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_remove_duplicate_tasks_47_comment},
  {"removeDuplicateTasks", &Dtool_AsyncTaskCollection_remove_duplicate_tasks_47, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_remove_duplicate_tasks_47_comment},
  {"has_task", &Dtool_AsyncTaskCollection_has_task_48, METH_O, (const char *)Dtool_AsyncTaskCollection_has_task_48_comment},
  {"hasTask", &Dtool_AsyncTaskCollection_has_task_48, METH_O, (const char *)Dtool_AsyncTaskCollection_has_task_48_comment},
  {"clear", &Dtool_AsyncTaskCollection_clear_49, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_clear_49_comment},
  {"find_task", &Dtool_AsyncTaskCollection_find_task_50, METH_O, (const char *)Dtool_AsyncTaskCollection_find_task_50_comment},
  {"findTask", &Dtool_AsyncTaskCollection_find_task_50, METH_O, (const char *)Dtool_AsyncTaskCollection_find_task_50_comment},
  {"get_num_tasks", &Dtool_AsyncTaskCollection_get_num_tasks_51, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_get_num_tasks_51_comment},
  {"getNumTasks", &Dtool_AsyncTaskCollection_get_num_tasks_51, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_get_num_tasks_51_comment},
  {"get_task", &Dtool_AsyncTaskCollection_get_task_52, METH_O, (const char *)Dtool_AsyncTaskCollection_get_task_52_comment},
  {"getTask", &Dtool_AsyncTaskCollection_get_task_52, METH_O, (const char *)Dtool_AsyncTaskCollection_get_task_52_comment},
  {"output", &Dtool_AsyncTaskCollection_output_58, METH_O, (const char *)Dtool_AsyncTaskCollection_output_58_comment},
  {"write", (PyCFunction) &Dtool_AsyncTaskCollection_write_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncTaskCollection_write_59_comment},
  {"downcast_to_AsyncTaskSequence", &Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149_comment},
  {"downcastToAsyncTaskSequence", &Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_downcast_to_AsyncTaskSequence_149_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_tasks", (PyCFunction) &MakeSeq_AsyncTaskCollection_get_tasks, METH_NOARGS, NULL},
  { "getTasks", (PyCFunction) &MakeSeq_AsyncTaskCollection_get_tasks, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_57_nb_add(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_AsyncTaskCollection, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &other) const
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.__add__", true, true);
  if (arg_this != NULL) {
    AsyncTaskCollection *return_value = new AsyncTaskCollection((*(const AsyncTaskCollection*)local_this).operator +(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_56_nb_inplace_add(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_AsyncTaskCollection, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &other)
    AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.__iadd__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call AsyncTaskCollection.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_54_sq_item(PyObject *self, Py_ssize_t index) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "AsyncTaskCollection index out of range");
    return NULL;
  }
  // 1-AsyncTask *AsyncTaskCollection::operator [](int index) const
  AsyncTask *return_value = (*(const AsyncTaskCollection*)local_this).operator [](index);
  if (return_value != (AsyncTask *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (AsyncTask *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(AsyncTaskCollection self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_AsyncTaskCollection_size_55_sq_length(PyObject *self) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     AsyncTaskCollection
//////////////////
static PyObject *Dtool_Repr_AsyncTaskCollection(PyObject *self) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AsyncTaskCollection
//////////////////
static PyObject *Dtool_Str_AsyncTaskCollection(PyObject *self) {
  AsyncTaskCollection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AsyncTaskCollection = {
  &Dtool_AsyncTaskCollection_operator_57_nb_add,
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_AsyncTaskCollection_operator_56_nb_inplace_add,
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskCollection = {
  &Dtool_AsyncTaskCollection_size_55_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_AsyncTaskCollection_operator_54_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_AsyncTaskCollection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTaskCollection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskCollection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AsyncTaskCollection,
    &Dtool_NumberMethods_AsyncTaskCollection,
    &Dtool_SequenceMethods_AsyncTaskCollection,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AsyncTaskCollection,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A list of tasks, for instance as returned by some of the AsyncTaskManager\n"
    " * query functions.  This also serves to define an AsyncTaskSequence.\n"
    " *\n"
    " * TODO: None of this is thread-safe yet.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTaskCollection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskCollection,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskCollection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskCollection,
  Dtool_UpcastInterface_AsyncTaskCollection,
  Dtool_DowncastInterface_AsyncTaskCollection,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AsyncTaskCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AsyncTaskCollection._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskCollection);
  }
}

/**
 * Python method tables for AsyncTaskChain (AsyncTaskChain)
 */
static PyMethodDef Dtool_Methods_AsyncTaskChain[] = {
  {"set_tick_clock", &Dtool_AsyncTaskChain_set_tick_clock_68, METH_O, (const char *)Dtool_AsyncTaskChain_set_tick_clock_68_comment},
  {"setTickClock", &Dtool_AsyncTaskChain_set_tick_clock_68, METH_O, (const char *)Dtool_AsyncTaskChain_set_tick_clock_68_comment},
  {"get_tick_clock", &Dtool_AsyncTaskChain_get_tick_clock_69, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tick_clock_69_comment},
  {"getTickClock", &Dtool_AsyncTaskChain_get_tick_clock_69, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tick_clock_69_comment},
  {"set_num_threads", &Dtool_AsyncTaskChain_set_num_threads_70, METH_O, (const char *)Dtool_AsyncTaskChain_set_num_threads_70_comment},
  {"setNumThreads", &Dtool_AsyncTaskChain_set_num_threads_70, METH_O, (const char *)Dtool_AsyncTaskChain_set_num_threads_70_comment},
  {"get_num_threads", &Dtool_AsyncTaskChain_get_num_threads_71, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_threads_71_comment},
  {"getNumThreads", &Dtool_AsyncTaskChain_get_num_threads_71, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_threads_71_comment},
  {"get_num_running_threads", &Dtool_AsyncTaskChain_get_num_running_threads_72, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_running_threads_72_comment},
  {"getNumRunningThreads", &Dtool_AsyncTaskChain_get_num_running_threads_72, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_running_threads_72_comment},
  {"set_thread_priority", &Dtool_AsyncTaskChain_set_thread_priority_73, METH_O, (const char *)Dtool_AsyncTaskChain_set_thread_priority_73_comment},
  {"setThreadPriority", &Dtool_AsyncTaskChain_set_thread_priority_73, METH_O, (const char *)Dtool_AsyncTaskChain_set_thread_priority_73_comment},
  {"get_thread_priority", &Dtool_AsyncTaskChain_get_thread_priority_74, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_thread_priority_74_comment},
  {"getThreadPriority", &Dtool_AsyncTaskChain_get_thread_priority_74, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_thread_priority_74_comment},
  {"set_frame_budget", &Dtool_AsyncTaskChain_set_frame_budget_75, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_budget_75_comment},
  {"setFrameBudget", &Dtool_AsyncTaskChain_set_frame_budget_75, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_budget_75_comment},
  {"get_frame_budget", &Dtool_AsyncTaskChain_get_frame_budget_76, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_budget_76_comment},
  {"getFrameBudget", &Dtool_AsyncTaskChain_get_frame_budget_76, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_budget_76_comment},
  {"set_frame_sync", &Dtool_AsyncTaskChain_set_frame_sync_77, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_sync_77_comment},
  {"setFrameSync", &Dtool_AsyncTaskChain_set_frame_sync_77, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_sync_77_comment},
  {"get_frame_sync", &Dtool_AsyncTaskChain_get_frame_sync_78, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_sync_78_comment},
  {"getFrameSync", &Dtool_AsyncTaskChain_get_frame_sync_78, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_sync_78_comment},
  {"set_timeslice_priority", &Dtool_AsyncTaskChain_set_timeslice_priority_79, METH_O, (const char *)Dtool_AsyncTaskChain_set_timeslice_priority_79_comment},
  {"setTimeslicePriority", &Dtool_AsyncTaskChain_set_timeslice_priority_79, METH_O, (const char *)Dtool_AsyncTaskChain_set_timeslice_priority_79_comment},
  {"get_timeslice_priority", &Dtool_AsyncTaskChain_get_timeslice_priority_80, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_timeslice_priority_80_comment},
  {"getTimeslicePriority", &Dtool_AsyncTaskChain_get_timeslice_priority_80, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_timeslice_priority_80_comment},
  {"stop_threads", &Dtool_AsyncTaskChain_stop_threads_81, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_stop_threads_81_comment},
  {"stopThreads", &Dtool_AsyncTaskChain_stop_threads_81, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_stop_threads_81_comment},
  {"start_threads", &Dtool_AsyncTaskChain_start_threads_82, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_start_threads_82_comment},
  {"startThreads", &Dtool_AsyncTaskChain_start_threads_82, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_start_threads_82_comment},
  {"is_started", &Dtool_AsyncTaskChain_is_started_83, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_is_started_83_comment},
  {"isStarted", &Dtool_AsyncTaskChain_is_started_83, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_is_started_83_comment},
  {"has_task", &Dtool_AsyncTaskChain_has_task_84, METH_O, (const char *)Dtool_AsyncTaskChain_has_task_84_comment},
  {"hasTask", &Dtool_AsyncTaskChain_has_task_84, METH_O, (const char *)Dtool_AsyncTaskChain_has_task_84_comment},
  {"wait_for_tasks", &Dtool_AsyncTaskChain_wait_for_tasks_85, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_wait_for_tasks_85_comment},
  {"waitForTasks", &Dtool_AsyncTaskChain_wait_for_tasks_85, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_wait_for_tasks_85_comment},
  {"get_num_tasks", &Dtool_AsyncTaskChain_get_num_tasks_86, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_tasks_86_comment},
  {"getNumTasks", &Dtool_AsyncTaskChain_get_num_tasks_86, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_tasks_86_comment},
  {"get_tasks", &Dtool_AsyncTaskChain_get_tasks_87, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tasks_87_comment},
  {"getTasks", &Dtool_AsyncTaskChain_get_tasks_87, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tasks_87_comment},
  {"get_active_tasks", &Dtool_AsyncTaskChain_get_active_tasks_88, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_active_tasks_88_comment},
  {"getActiveTasks", &Dtool_AsyncTaskChain_get_active_tasks_88, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_active_tasks_88_comment},
  {"get_sleeping_tasks", &Dtool_AsyncTaskChain_get_sleeping_tasks_89, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_sleeping_tasks_89_comment},
  {"getSleepingTasks", &Dtool_AsyncTaskChain_get_sleeping_tasks_89, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_sleeping_tasks_89_comment},
  {"poll", &Dtool_AsyncTaskChain_poll_90, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_poll_90_comment},
  {"get_next_wake_time", &Dtool_AsyncTaskChain_get_next_wake_time_91, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_next_wake_time_91_comment},
  {"getNextWakeTime", &Dtool_AsyncTaskChain_get_next_wake_time_91, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_next_wake_time_91_comment},
  {"output", &Dtool_AsyncTaskChain_output_92, METH_O, (const char *)Dtool_AsyncTaskChain_output_92_comment},
  {"write", (PyCFunction) &Dtool_AsyncTaskChain_write_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncTaskChain_write_93_comment},
  {"get_class_type", &Dtool_AsyncTaskChain_get_class_type_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskChain_get_class_type_94_comment},
  {"getClassType", &Dtool_AsyncTaskChain_get_class_type_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskChain_get_class_type_94_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62_comment},
  {"upcastToTypedReferenceCount", &Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_62_comment},
  {"upcast_to_Namable", &Dtool_AsyncTaskChain_upcast_to_Namable_65, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_Namable_65_comment},
  {"upcastToNamable", &Dtool_AsyncTaskChain_upcast_to_Namable_65, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_Namable_65_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AsyncTaskChain
//////////////////
static PyObject *Dtool_Repr_AsyncTaskChain(PyObject *self) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AsyncTaskChain
//////////////////
static PyObject *Dtool_Str_AsyncTaskChain(PyObject *self) {
  AsyncTaskChain *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AsyncTaskChain = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskChain = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskChain = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskChain = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AsyncTaskChain = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTaskChain",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskChain,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AsyncTaskChain,
    &Dtool_NumberMethods_AsyncTaskChain,
    &Dtool_SequenceMethods_AsyncTaskChain,
    &Dtool_MappingMethods_AsyncTaskChain,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AsyncTaskChain,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AsyncTaskChain,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain\n"
    " * maintains a separate list of tasks, and will execute them with its own set\n"
    " * of threads.  Each chain may thereby operate independently of the other\n"
    " * chains.\n"
    " *\n"
    " * The AsyncTaskChain will spawn a specified number of threads (possibly 0) to\n"
    " * serve the tasks.  If there are no threads, you must call poll() from time\n"
    " * to time to serve the tasks in the main thread.  Normally this is done by\n"
    " * calling AsyncTaskManager::poll().\n"
    " *\n"
    " * Each task will run exactly once each epoch.  Beyond that, the tasks' sort\n"
    " * and priority values control the order in which they are run: tasks are run\n"
    " * in increasing order by sort value, and within the same sort value, they are\n"
    " * run roughly in decreasing order by priority value, with some exceptions for\n"
    " * parallelism.  Tasks with different sort values are never run in parallel\n"
    " * together, but tasks with different priority values might be (if there is\n"
    " * more than one thread).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTaskChain,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskChain,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskChain,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskChain,
  Dtool_UpcastInterface_AsyncTaskChain,
  Dtool_DowncastInterface_AsyncTaskChain,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AsyncTaskChain(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_AsyncTaskChain._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskChain._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskChain) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskChain)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskChain);
  }
}

/**
 * Python method tables for AsyncTaskManager (AsyncTaskManager)
 */
static PyMethodDef Dtool_Methods_AsyncTaskManager[] = {
  {"cleanup", &Dtool_AsyncTaskManager_cleanup_102, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_cleanup_102_comment},
  {"set_clock", &Dtool_AsyncTaskManager_set_clock_103, METH_O, (const char *)Dtool_AsyncTaskManager_set_clock_103_comment},
  {"setClock", &Dtool_AsyncTaskManager_set_clock_103, METH_O, (const char *)Dtool_AsyncTaskManager_set_clock_103_comment},
  {"get_clock", &Dtool_AsyncTaskManager_get_clock_104, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_clock_104_comment},
  {"getClock", &Dtool_AsyncTaskManager_get_clock_104, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_clock_104_comment},
  {"get_num_task_chains", &Dtool_AsyncTaskManager_get_num_task_chains_108, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_task_chains_108_comment},
  {"getNumTaskChains", &Dtool_AsyncTaskManager_get_num_task_chains_108, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_task_chains_108_comment},
  {"get_task_chain", &Dtool_AsyncTaskManager_get_task_chain_109, METH_O, (const char *)Dtool_AsyncTaskManager_get_task_chain_109_comment},
  {"getTaskChain", &Dtool_AsyncTaskManager_get_task_chain_109, METH_O, (const char *)Dtool_AsyncTaskManager_get_task_chain_109_comment},
  {"make_task_chain", &Dtool_AsyncTaskManager_make_task_chain_111, METH_O, (const char *)Dtool_AsyncTaskManager_make_task_chain_111_comment},
  {"makeTaskChain", &Dtool_AsyncTaskManager_make_task_chain_111, METH_O, (const char *)Dtool_AsyncTaskManager_make_task_chain_111_comment},
  {"find_task_chain", &Dtool_AsyncTaskManager_find_task_chain_112, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_chain_112_comment},
  {"findTaskChain", &Dtool_AsyncTaskManager_find_task_chain_112, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_chain_112_comment},
  {"remove_task_chain", &Dtool_AsyncTaskManager_remove_task_chain_113, METH_O, (const char *)Dtool_AsyncTaskManager_remove_task_chain_113_comment},
  {"removeTaskChain", &Dtool_AsyncTaskManager_remove_task_chain_113, METH_O, (const char *)Dtool_AsyncTaskManager_remove_task_chain_113_comment},
  {"add", &Dtool_AsyncTaskManager_add_114, METH_O, (const char *)Dtool_AsyncTaskManager_add_114_comment},
  {"has_task", &Dtool_AsyncTaskManager_has_task_115, METH_O, (const char *)Dtool_AsyncTaskManager_has_task_115_comment},
  {"hasTask", &Dtool_AsyncTaskManager_has_task_115, METH_O, (const char *)Dtool_AsyncTaskManager_has_task_115_comment},
  {"find_task", &Dtool_AsyncTaskManager_find_task_116, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_116_comment},
  {"findTask", &Dtool_AsyncTaskManager_find_task_116, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_116_comment},
  {"find_tasks", &Dtool_AsyncTaskManager_find_tasks_117, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_117_comment},
  {"findTasks", &Dtool_AsyncTaskManager_find_tasks_117, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_117_comment},
  {"find_tasks_matching", &Dtool_AsyncTaskManager_find_tasks_matching_118, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_matching_118_comment},
  {"findTasksMatching", &Dtool_AsyncTaskManager_find_tasks_matching_118, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_matching_118_comment},
  {"remove", &Dtool_AsyncTaskManager_remove_119, METH_O, (const char *)Dtool_AsyncTaskManager_remove_119_comment},
  {"wait_for_tasks", &Dtool_AsyncTaskManager_wait_for_tasks_120, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_wait_for_tasks_120_comment},
  {"waitForTasks", &Dtool_AsyncTaskManager_wait_for_tasks_120, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_wait_for_tasks_120_comment},
  {"stop_threads", &Dtool_AsyncTaskManager_stop_threads_121, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_stop_threads_121_comment},
  {"stopThreads", &Dtool_AsyncTaskManager_stop_threads_121, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_stop_threads_121_comment},
  {"start_threads", &Dtool_AsyncTaskManager_start_threads_122, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_start_threads_122_comment},
  {"startThreads", &Dtool_AsyncTaskManager_start_threads_122, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_start_threads_122_comment},
  {"get_num_tasks", &Dtool_AsyncTaskManager_get_num_tasks_123, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_tasks_123_comment},
  {"getNumTasks", &Dtool_AsyncTaskManager_get_num_tasks_123, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_tasks_123_comment},
  {"get_tasks", &Dtool_AsyncTaskManager_get_tasks_124, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_tasks_124_comment},
  {"getTasks", &Dtool_AsyncTaskManager_get_tasks_124, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_tasks_124_comment},
  {"get_active_tasks", &Dtool_AsyncTaskManager_get_active_tasks_125, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_active_tasks_125_comment},
  {"getActiveTasks", &Dtool_AsyncTaskManager_get_active_tasks_125, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_active_tasks_125_comment},
  {"get_sleeping_tasks", &Dtool_AsyncTaskManager_get_sleeping_tasks_126, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_sleeping_tasks_126_comment},
  {"getSleepingTasks", &Dtool_AsyncTaskManager_get_sleeping_tasks_126, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_sleeping_tasks_126_comment},
  {"poll", &Dtool_AsyncTaskManager_poll_130, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_poll_130_comment},
  {"get_next_wake_time", &Dtool_AsyncTaskManager_get_next_wake_time_131, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_next_wake_time_131_comment},
  {"getNextWakeTime", &Dtool_AsyncTaskManager_get_next_wake_time_131, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_next_wake_time_131_comment},
  {"output", &Dtool_AsyncTaskManager_output_134, METH_O, (const char *)Dtool_AsyncTaskManager_output_134_comment},
  {"write", (PyCFunction) &Dtool_AsyncTaskManager_write_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncTaskManager_write_135_comment},
  {"get_global_ptr", &Dtool_AsyncTaskManager_get_global_ptr_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_global_ptr_136_comment},
  {"getGlobalPtr", &Dtool_AsyncTaskManager_get_global_ptr_136, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_global_ptr_136_comment},
  {"get_class_type", &Dtool_AsyncTaskManager_get_class_type_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_class_type_137_comment},
  {"getClassType", &Dtool_AsyncTaskManager_get_class_type_137, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_class_type_137_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96_comment},
  {"upcastToTypedReferenceCount", &Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_96_comment},
  {"upcast_to_Namable", &Dtool_AsyncTaskManager_upcast_to_Namable_98, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_Namable_98_comment},
  {"upcastToNamable", &Dtool_AsyncTaskManager_upcast_to_Namable_98, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_Namable_98_comment},
  {"get_task_chains", (PyCFunction) &MakeSeq_AsyncTaskManager_get_task_chains, METH_NOARGS, NULL},
  { "getTaskChains", (PyCFunction) &MakeSeq_AsyncTaskManager_get_task_chains, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AsyncTaskManager
//////////////////
static PyObject *Dtool_Repr_AsyncTaskManager(PyObject *self) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AsyncTaskManager
//////////////////
static PyObject *Dtool_Str_AsyncTaskManager(PyObject *self) {
  AsyncTaskManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AsyncTaskManager[] = {
  {(char *)"clock", &Dtool_AsyncTaskManager_clock_Getter, &Dtool_AsyncTaskManager_clock_Setter, NULL, NULL},
  {(char *)"tasks", &Dtool_AsyncTaskManager_tasks_Getter, NULL, NULL, NULL},
  {(char *)"active_tasks", &Dtool_AsyncTaskManager_active_tasks_Getter, NULL, NULL, NULL},
  {(char *)"sleeping_tasks", &Dtool_AsyncTaskManager_sleeping_tasks_Getter, NULL, NULL, NULL},
  {(char *)"next_wake_time", &Dtool_AsyncTaskManager_next_wake_time_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskManager = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskManager = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskManager = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AsyncTaskManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTaskManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AsyncTaskManager,
    &Dtool_NumberMethods_AsyncTaskManager,
    &Dtool_SequenceMethods_AsyncTaskManager,
    &Dtool_MappingMethods_AsyncTaskManager,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AsyncTaskManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AsyncTaskManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to manage a loose queue of isolated tasks, which can be performed\n"
    " * either synchronously (in the foreground thread) or asynchronously (by a\n"
    " * background thread).\n"
    " *\n"
    " * The AsyncTaskManager is actually a collection of AsyncTaskChains, each of\n"
    " * which maintains a list of tasks.  Each chain can be either foreground or\n"
    " * background (it may run only in the main thread, or it may be serviced by\n"
    " * one or more background threads). See AsyncTaskChain for more information.\n"
    " *\n"
    " * If you do not require background processing, it is perfectly acceptable to\n"
    " * create only one AsyncTaskChain, which runs in the main thread.  This is a\n"
    " * common configuration.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTaskManager,
    0, // tp_members
    Dtool_Properties_AsyncTaskManager,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskManager,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskManager,
  Dtool_UpcastInterface_AsyncTaskManager,
  Dtool_DowncastInterface_AsyncTaskManager,
  (CoerceFunction)Dtool_ConstCoerce_AsyncTaskManager,
  (CoerceFunction)Dtool_Coerce_AsyncTaskManager,
};

static void Dtool_PyModuleClassInit_AsyncTaskManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    assert(Dtool_Ptr_Namable != NULL);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(NULL);
    Dtool_AsyncTaskManager._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskManager);
  }
}

/**
 * Python method tables for AsyncTaskPause (AsyncTaskPause)
 */
static PyMethodDef Dtool_Methods_AsyncTaskPause[] = {
  {"get_class_type", &Dtool_AsyncTaskPause_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskPause_get_class_type_143_comment},
  {"getClassType", &Dtool_AsyncTaskPause_get_class_type_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskPause_get_class_type_143_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskPause = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskPause = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskPause = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskPause = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AsyncTaskPause = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTaskPause",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskPause,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AsyncTaskPause,
    &Dtool_SequenceMethods_AsyncTaskPause,
    &Dtool_MappingMethods_AsyncTaskPause,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AsyncTaskPause,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of task that simple returns DS_pause, to pause for a\n"
    " * specified number of seconds and then finish.  It's intended to be used\n"
    " * within an AsyncTaskSequence.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTaskPause,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskPause,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskPause,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskPause,
  Dtool_UpcastInterface_AsyncTaskPause,
  Dtool_DowncastInterface_AsyncTaskPause,
  (CoerceFunction)Dtool_ConstCoerce_AsyncTaskPause,
  (CoerceFunction)Dtool_Coerce_AsyncTaskPause,
};

static void Dtool_PyModuleClassInit_AsyncTaskPause(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncTask(NULL);
    Dtool_AsyncTaskPause._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AsyncTask);
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskPause._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskPause) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskPause)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskPause);
  }
}

/**
 * Python method tables for AsyncTaskSequence (AsyncTaskSequence)
 */
static PyMethodDef Dtool_Methods_AsyncTaskSequence[] = {
  {"set_repeat_count", &Dtool_AsyncTaskSequence_set_repeat_count_155, METH_O, (const char *)Dtool_AsyncTaskSequence_set_repeat_count_155_comment},
  {"setRepeatCount", &Dtool_AsyncTaskSequence_set_repeat_count_155, METH_O, (const char *)Dtool_AsyncTaskSequence_set_repeat_count_155_comment},
  {"get_repeat_count", &Dtool_AsyncTaskSequence_get_repeat_count_156, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_repeat_count_156_comment},
  {"getRepeatCount", &Dtool_AsyncTaskSequence_get_repeat_count_156, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_repeat_count_156_comment},
  {"get_current_task_index", &Dtool_AsyncTaskSequence_get_current_task_index_157, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_current_task_index_157_comment},
  {"getCurrentTaskIndex", &Dtool_AsyncTaskSequence_get_current_task_index_157, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_current_task_index_157_comment},
  {"get_class_type", &Dtool_AsyncTaskSequence_get_class_type_158, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskSequence_get_class_type_158_comment},
  {"getClassType", &Dtool_AsyncTaskSequence_get_class_type_158, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskSequence_get_class_type_158_comment},
  {"upcast_to_AsyncTask", &Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146_comment},
  {"upcastToAsyncTask", &Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTask_146_comment},
  {"upcast_to_AsyncTaskCollection", &Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148_comment},
  {"upcastToAsyncTaskCollection", &Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_148_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskSequence = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskSequence = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskSequence = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskSequence = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AsyncTaskSequence = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AsyncTaskSequence",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskSequence,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AsyncTaskSequence,
    &Dtool_SequenceMethods_AsyncTaskSequence,
    &Dtool_MappingMethods_AsyncTaskSequence,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AsyncTaskSequence,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of task that serves as a list of tasks internally.  Each\n"
    " * task on the list is executed in sequence, one per epoch.\n"
    " *\n"
    " * This is similar to a Sequence interval, though it has some slightly\n"
    " * different abilities.  For instance, although you can't start at any\n"
    " * arbitrary point in the sequence, you can construct a task sequence whose\n"
    " * duration changes during playback.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AsyncTaskSequence,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskSequence,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskSequence,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskSequence,
  Dtool_UpcastInterface_AsyncTaskSequence,
  Dtool_DowncastInterface_AsyncTaskSequence,
  (CoerceFunction)Dtool_ConstCoerce_AsyncTaskSequence,
  (CoerceFunction)Dtool_Coerce_AsyncTaskSequence,
};

static void Dtool_PyModuleClassInit_AsyncTaskSequence(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncTask(NULL);
    Dtool_PyModuleClassInit_AsyncTaskCollection(NULL);
    Dtool_AsyncTaskSequence._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_AsyncTask, (PyTypeObject *)&Dtool_AsyncTaskCollection);
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskSequence._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskSequence) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskSequence)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskSequence);
  }
}

/**
 * Python method tables for EventParameter (EventParameter)
 */
static PyMethodDef Dtool_Methods_EventParameter[] = {
  {"assign", &Dtool_EventParameter_operator_161, METH_O, (const char *)Dtool_EventParameter_operator_161_comment},
  {"is_empty", &Dtool_EventParameter_is_empty_163, METH_NOARGS, (const char *)Dtool_EventParameter_is_empty_163_comment},
  {"isEmpty", &Dtool_EventParameter_is_empty_163, METH_NOARGS, (const char *)Dtool_EventParameter_is_empty_163_comment},
  {"is_int", &Dtool_EventParameter_is_int_164, METH_NOARGS, (const char *)Dtool_EventParameter_is_int_164_comment},
  {"isInt", &Dtool_EventParameter_is_int_164, METH_NOARGS, (const char *)Dtool_EventParameter_is_int_164_comment},
  {"get_int_value", &Dtool_EventParameter_get_int_value_165, METH_NOARGS, (const char *)Dtool_EventParameter_get_int_value_165_comment},
  {"getIntValue", &Dtool_EventParameter_get_int_value_165, METH_NOARGS, (const char *)Dtool_EventParameter_get_int_value_165_comment},
  {"is_double", &Dtool_EventParameter_is_double_166, METH_NOARGS, (const char *)Dtool_EventParameter_is_double_166_comment},
  {"isDouble", &Dtool_EventParameter_is_double_166, METH_NOARGS, (const char *)Dtool_EventParameter_is_double_166_comment},
  {"get_double_value", &Dtool_EventParameter_get_double_value_167, METH_NOARGS, (const char *)Dtool_EventParameter_get_double_value_167_comment},
  {"getDoubleValue", &Dtool_EventParameter_get_double_value_167, METH_NOARGS, (const char *)Dtool_EventParameter_get_double_value_167_comment},
  {"is_string", &Dtool_EventParameter_is_string_168, METH_NOARGS, (const char *)Dtool_EventParameter_is_string_168_comment},
  {"isString", &Dtool_EventParameter_is_string_168, METH_NOARGS, (const char *)Dtool_EventParameter_is_string_168_comment},
  {"get_string_value", &Dtool_EventParameter_get_string_value_169, METH_NOARGS, (const char *)Dtool_EventParameter_get_string_value_169_comment},
  {"getStringValue", &Dtool_EventParameter_get_string_value_169, METH_NOARGS, (const char *)Dtool_EventParameter_get_string_value_169_comment},
  {"is_wstring", &Dtool_EventParameter_is_wstring_170, METH_NOARGS, (const char *)Dtool_EventParameter_is_wstring_170_comment},
  {"isWstring", &Dtool_EventParameter_is_wstring_170, METH_NOARGS, (const char *)Dtool_EventParameter_is_wstring_170_comment},
  {"get_wstring_value", &Dtool_EventParameter_get_wstring_value_171, METH_NOARGS, (const char *)Dtool_EventParameter_get_wstring_value_171_comment},
  {"getWstringValue", &Dtool_EventParameter_get_wstring_value_171, METH_NOARGS, (const char *)Dtool_EventParameter_get_wstring_value_171_comment},
  {"is_typed_ref_count", &Dtool_EventParameter_is_typed_ref_count_172, METH_NOARGS, (const char *)Dtool_EventParameter_is_typed_ref_count_172_comment},
  {"isTypedRefCount", &Dtool_EventParameter_is_typed_ref_count_172, METH_NOARGS, (const char *)Dtool_EventParameter_is_typed_ref_count_172_comment},
  {"get_typed_ref_count_value", &Dtool_EventParameter_get_typed_ref_count_value_173, METH_NOARGS, (const char *)Dtool_EventParameter_get_typed_ref_count_value_173_comment},
  {"getTypedRefCountValue", &Dtool_EventParameter_get_typed_ref_count_value_173, METH_NOARGS, (const char *)Dtool_EventParameter_get_typed_ref_count_value_173_comment},
  {"get_ptr", &Dtool_EventParameter_get_ptr_174, METH_NOARGS, (const char *)Dtool_EventParameter_get_ptr_174_comment},
  {"getPtr", &Dtool_EventParameter_get_ptr_174, METH_NOARGS, (const char *)Dtool_EventParameter_get_ptr_174_comment},
  {"output", &Dtool_EventParameter_output_175, METH_O, (const char *)Dtool_EventParameter_output_175_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     EventParameter
//////////////////
static PyObject *Dtool_Repr_EventParameter(PyObject *self) {
  EventParameter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EventParameter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_EventParameter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.EventParameter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EventParameter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_EventParameter,
    &Dtool_NumberMethods_EventParameter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_EventParameter,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An optional parameter associated with an event.  Each event may have zero\n"
    " * or more of these.  Each parameter stores a pointer to a\n"
    " * TypedWritableReferenceCount object, which of course could be pretty much\n"
    " * anything.  To store a simple value like a double or a string, the\n"
    " * EventParameter constructors transparently use the ParamValue template class\n"
    " * from paramValue.h.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EventParameter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EventParameter,
    PyType_GenericAlloc,
    Dtool_new_EventParameter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EventParameter,
  Dtool_UpcastInterface_EventParameter,
  Dtool_DowncastInterface_EventParameter,
  (CoerceFunction)Dtool_ConstCoerce_EventParameter,
  (CoerceFunction)Dtool_Coerce_EventParameter,
};

static void Dtool_PyModuleClassInit_EventParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EventParameter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_EventParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EventParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EventParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EventParameter);
  }
}

/**
 * Python method tables for Event (Event)
 */
static PyMethodDef Dtool_Methods_Event[] = {
  {"assign", &Dtool_Event_operator_178, METH_O, (const char *)Dtool_Event_operator_178_comment},
  {"set_name", &Dtool_Event_set_name_179, METH_O, (const char *)Dtool_Event_set_name_179_comment},
  {"setName", &Dtool_Event_set_name_179, METH_O, (const char *)Dtool_Event_set_name_179_comment},
  {"clear_name", &Dtool_Event_clear_name_180, METH_NOARGS, (const char *)Dtool_Event_clear_name_180_comment},
  {"clearName", &Dtool_Event_clear_name_180, METH_NOARGS, (const char *)Dtool_Event_clear_name_180_comment},
  {"has_name", &Dtool_Event_has_name_181, METH_NOARGS, (const char *)Dtool_Event_has_name_181_comment},
  {"hasName", &Dtool_Event_has_name_181, METH_NOARGS, (const char *)Dtool_Event_has_name_181_comment},
  {"get_name", &Dtool_Event_get_name_182, METH_NOARGS, (const char *)Dtool_Event_get_name_182_comment},
  {"getName", &Dtool_Event_get_name_182, METH_NOARGS, (const char *)Dtool_Event_get_name_182_comment},
  {"add_parameter", &Dtool_Event_add_parameter_183, METH_O, (const char *)Dtool_Event_add_parameter_183_comment},
  {"addParameter", &Dtool_Event_add_parameter_183, METH_O, (const char *)Dtool_Event_add_parameter_183_comment},
  {"get_num_parameters", &Dtool_Event_get_num_parameters_184, METH_NOARGS, (const char *)Dtool_Event_get_num_parameters_184_comment},
  {"getNumParameters", &Dtool_Event_get_num_parameters_184, METH_NOARGS, (const char *)Dtool_Event_get_num_parameters_184_comment},
  {"get_parameter", &Dtool_Event_get_parameter_185, METH_O, (const char *)Dtool_Event_get_parameter_185_comment},
  {"getParameter", &Dtool_Event_get_parameter_185, METH_O, (const char *)Dtool_Event_get_parameter_185_comment},
  {"has_receiver", &Dtool_Event_has_receiver_187, METH_NOARGS, (const char *)Dtool_Event_has_receiver_187_comment},
  {"hasReceiver", &Dtool_Event_has_receiver_187, METH_NOARGS, (const char *)Dtool_Event_has_receiver_187_comment},
  {"clear_receiver", &Dtool_Event_clear_receiver_190, METH_NOARGS, (const char *)Dtool_Event_clear_receiver_190_comment},
  {"clearReceiver", &Dtool_Event_clear_receiver_190, METH_NOARGS, (const char *)Dtool_Event_clear_receiver_190_comment},
  {"output", &Dtool_Event_output_191, METH_O, (const char *)Dtool_Event_output_191_comment},
  {"get_class_type", &Dtool_Event_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_Event_get_class_type_200_comment},
  {"getClassType", &Dtool_Event_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_Event_get_class_type_200_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_parameters", (PyCFunction) &MakeSeq_Event_get_parameters, METH_NOARGS, NULL},
  { "getParameters", (PyCFunction) &MakeSeq_Event_get_parameters, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Event
//////////////////
static PyObject *Dtool_Repr_Event(PyObject *self) {
  Event *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Event[] = {
  {(char *)"name", &Dtool_Event_name_Getter, &Dtool_Event_name_Setter, NULL, NULL},
  {(char *)"parameters", &Dtool_Event_parameters_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Event = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Event = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Event = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Event = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Event = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Event",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Event,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_Event,
    &Dtool_NumberMethods_Event,
    &Dtool_SequenceMethods_Event,
    &Dtool_MappingMethods_Event,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_Event,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Event,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A named event, possibly with parameters.  Anyone in any thread may throw an\n"
    " * event at any time; there will be one process responsible for reading and\n"
    " * dispacting on the events (but not necessarily immediately).\n"
    " *\n"
    " * This function use to inherit from Namable, but that makes it too expensive\n"
    " * to get its name the Python code.  Now it just copies the Namable interface\n"
    " * in.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Event,
    0, // tp_members
    Dtool_Properties_Event,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Event,
    PyType_GenericAlloc,
    Dtool_new_Event,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Event,
  Dtool_UpcastInterface_Event,
  Dtool_DowncastInterface_Event,
  (CoerceFunction)Dtool_ConstCoerce_Event,
  (CoerceFunction)Dtool_Coerce_Event,
};

static void Dtool_PyModuleClassInit_Event(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_Event._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_Event._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Event) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Event)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Event);
  }
}

/**
 * Python method tables for EventHandler (EventHandler)
 */
static PyMethodDef Dtool_Methods_EventHandler[] = {
  {"process_events", &Dtool_EventHandler_process_events_204, METH_NOARGS, (const char *)Dtool_EventHandler_process_events_204_comment},
  {"processEvents", &Dtool_EventHandler_process_events_204, METH_NOARGS, (const char *)Dtool_EventHandler_process_events_204_comment},
  {"dispatch_event", &Dtool_EventHandler_dispatch_event_205, METH_O, (const char *)Dtool_EventHandler_dispatch_event_205_comment},
  {"dispatchEvent", &Dtool_EventHandler_dispatch_event_205, METH_O, (const char *)Dtool_EventHandler_dispatch_event_205_comment},
  {"write", &Dtool_EventHandler_write_206, METH_O, (const char *)Dtool_EventHandler_write_206_comment},
  {"get_global_event_handler", (PyCFunction) &Dtool_EventHandler_get_global_event_handler_207, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EventHandler_get_global_event_handler_207_comment},
  {"getGlobalEventHandler", (PyCFunction) &Dtool_EventHandler_get_global_event_handler_207, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EventHandler_get_global_event_handler_207_comment},
  {"get_class_type", &Dtool_EventHandler_get_class_type_208, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventHandler_get_class_type_208_comment},
  {"getClassType", &Dtool_EventHandler_get_class_type_208, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventHandler_get_class_type_208_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     EventHandler
//////////////////
static PyObject *Dtool_Str_EventHandler(PyObject *self) {
  EventHandler *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventHandler, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EventHandler = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EventHandler = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_EventHandler = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_EventHandler = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_EventHandler = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.EventHandler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EventHandler,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EventHandler,
    &Dtool_SequenceMethods_EventHandler,
    &Dtool_MappingMethods_EventHandler,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_EventHandler,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_EventHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to monitor events from the C++ side of things.  It maintains a set\n"
    " * of \"hooks\", function pointers assigned to event names, and calls the\n"
    " * appropriate hooks when the matching event is detected.\n"
    " *\n"
    " * This class is not necessary when the hooks are detected and processed\n"
    " * entirely by the scripting language, e.g.  via Scheme hooks or the messenger\n"
    " * in Python.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EventHandler,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EventHandler,
    PyType_GenericAlloc,
    Dtool_new_EventHandler,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EventHandler,
  Dtool_UpcastInterface_EventHandler,
  Dtool_DowncastInterface_EventHandler,
  (CoerceFunction)Dtool_ConstCoerce_EventHandler,
  (CoerceFunction)Dtool_Coerce_EventHandler,
};

static void Dtool_PyModuleClassInit_EventHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_EventHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_EventHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EventHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EventHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EventHandler);
  }
}

/**
 * Python method tables for EventQueue (EventQueue)
 */
static PyMethodDef Dtool_Methods_EventQueue[] = {
  {"queue_event", &Dtool_EventQueue_queue_event_213, METH_O, (const char *)Dtool_EventQueue_queue_event_213_comment},
  {"queueEvent", &Dtool_EventQueue_queue_event_213, METH_O, (const char *)Dtool_EventQueue_queue_event_213_comment},
  {"clear", &Dtool_EventQueue_clear_214, METH_NOARGS, (const char *)Dtool_EventQueue_clear_214_comment},
  {"is_queue_empty", &Dtool_EventQueue_is_queue_empty_215, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_empty_215_comment},
  {"isQueueEmpty", &Dtool_EventQueue_is_queue_empty_215, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_empty_215_comment},
  {"is_queue_full", &Dtool_EventQueue_is_queue_full_216, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_full_216_comment},
  {"isQueueFull", &Dtool_EventQueue_is_queue_full_216, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_full_216_comment},
  {"dequeue_event", &Dtool_EventQueue_dequeue_event_217, METH_NOARGS, (const char *)Dtool_EventQueue_dequeue_event_217_comment},
  {"dequeueEvent", &Dtool_EventQueue_dequeue_event_217, METH_NOARGS, (const char *)Dtool_EventQueue_dequeue_event_217_comment},
  {"get_global_event_queue", &Dtool_EventQueue_get_global_event_queue_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventQueue_get_global_event_queue_218_comment},
  {"getGlobalEventQueue", &Dtool_EventQueue_get_global_event_queue_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventQueue_get_global_event_queue_218_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_EventQueue = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_EventQueue = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.EventQueue",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_EventQueue,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_EventQueue,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A queue of pending events.  As events are thrown, they are added to this\n"
    " * queue; eventually, they will be extracted out again by an EventHandler and\n"
    " * processed.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_EventQueue,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_EventQueue,
    PyType_GenericAlloc,
    Dtool_new_EventQueue,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EventQueue,
  Dtool_UpcastInterface_EventQueue,
  Dtool_DowncastInterface_EventQueue,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_EventQueue(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EventQueue._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_EventQueue._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EventQueue) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EventQueue)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EventQueue);
  }
}

/**
 * Python method tables for PointerEventList (PointerEventList)
 */
static PyMethodDef Dtool_Methods_PointerEventList[] = {
  {"get_num_events", &Dtool_PointerEventList_get_num_events_222, METH_NOARGS, (const char *)Dtool_PointerEventList_get_num_events_222_comment},
  {"getNumEvents", &Dtool_PointerEventList_get_num_events_222, METH_NOARGS, (const char *)Dtool_PointerEventList_get_num_events_222_comment},
  {"get_in_window", &Dtool_PointerEventList_get_in_window_223, METH_O, (const char *)Dtool_PointerEventList_get_in_window_223_comment},
  {"getInWindow", &Dtool_PointerEventList_get_in_window_223, METH_O, (const char *)Dtool_PointerEventList_get_in_window_223_comment},
  {"get_xpos", &Dtool_PointerEventList_get_xpos_224, METH_O, (const char *)Dtool_PointerEventList_get_xpos_224_comment},
  {"getXpos", &Dtool_PointerEventList_get_xpos_224, METH_O, (const char *)Dtool_PointerEventList_get_xpos_224_comment},
  {"get_ypos", &Dtool_PointerEventList_get_ypos_225, METH_O, (const char *)Dtool_PointerEventList_get_ypos_225_comment},
  {"getYpos", &Dtool_PointerEventList_get_ypos_225, METH_O, (const char *)Dtool_PointerEventList_get_ypos_225_comment},
  {"get_dx", &Dtool_PointerEventList_get_dx_226, METH_O, (const char *)Dtool_PointerEventList_get_dx_226_comment},
  {"getDx", &Dtool_PointerEventList_get_dx_226, METH_O, (const char *)Dtool_PointerEventList_get_dx_226_comment},
  {"get_dy", &Dtool_PointerEventList_get_dy_227, METH_O, (const char *)Dtool_PointerEventList_get_dy_227_comment},
  {"getDy", &Dtool_PointerEventList_get_dy_227, METH_O, (const char *)Dtool_PointerEventList_get_dy_227_comment},
  {"get_sequence", &Dtool_PointerEventList_get_sequence_228, METH_O, (const char *)Dtool_PointerEventList_get_sequence_228_comment},
  {"getSequence", &Dtool_PointerEventList_get_sequence_228, METH_O, (const char *)Dtool_PointerEventList_get_sequence_228_comment},
  {"get_length", &Dtool_PointerEventList_get_length_229, METH_O, (const char *)Dtool_PointerEventList_get_length_229_comment},
  {"getLength", &Dtool_PointerEventList_get_length_229, METH_O, (const char *)Dtool_PointerEventList_get_length_229_comment},
  {"get_direction", &Dtool_PointerEventList_get_direction_230, METH_O, (const char *)Dtool_PointerEventList_get_direction_230_comment},
  {"getDirection", &Dtool_PointerEventList_get_direction_230, METH_O, (const char *)Dtool_PointerEventList_get_direction_230_comment},
  {"get_rotation", &Dtool_PointerEventList_get_rotation_231, METH_O, (const char *)Dtool_PointerEventList_get_rotation_231_comment},
  {"getRotation", &Dtool_PointerEventList_get_rotation_231, METH_O, (const char *)Dtool_PointerEventList_get_rotation_231_comment},
  {"get_time", &Dtool_PointerEventList_get_time_232, METH_O, (const char *)Dtool_PointerEventList_get_time_232_comment},
  {"getTime", &Dtool_PointerEventList_get_time_232, METH_O, (const char *)Dtool_PointerEventList_get_time_232_comment},
  {"clear", &Dtool_PointerEventList_clear_233, METH_NOARGS, (const char *)Dtool_PointerEventList_clear_233_comment},
  {"pop_front", &Dtool_PointerEventList_pop_front_234, METH_NOARGS, (const char *)Dtool_PointerEventList_pop_front_234_comment},
  {"popFront", &Dtool_PointerEventList_pop_front_234, METH_NOARGS, (const char *)Dtool_PointerEventList_pop_front_234_comment},
  {"add_event", (PyCFunction) &Dtool_PointerEventList_add_event_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_add_event_235_comment},
  {"addEvent", (PyCFunction) &Dtool_PointerEventList_add_event_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_add_event_235_comment},
  {"encircles", (PyCFunction) &Dtool_PointerEventList_encircles_236, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_encircles_236_comment},
  {"total_turns", &Dtool_PointerEventList_total_turns_237, METH_O, (const char *)Dtool_PointerEventList_total_turns_237_comment},
  {"totalTurns", &Dtool_PointerEventList_total_turns_237, METH_O, (const char *)Dtool_PointerEventList_total_turns_237_comment},
  {"match_pattern", (PyCFunction) &Dtool_PointerEventList_match_pattern_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_match_pattern_238_comment},
  {"matchPattern", (PyCFunction) &Dtool_PointerEventList_match_pattern_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_match_pattern_238_comment},
  {"get_class_type", &Dtool_PointerEventList_get_class_type_239, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointerEventList_get_class_type_239_comment},
  {"getClassType", &Dtool_PointerEventList_get_class_type_239, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointerEventList_get_class_type_239_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerEventList = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerEventList = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerEventList = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerEventList = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerEventList = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerEventList",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerEventList,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerEventList,
    &Dtool_SequenceMethods_PointerEventList,
    &Dtool_MappingMethods_PointerEventList,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerEventList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Records a set of pointer events that happened recently.  This class is\n"
    " * usually used only in the data graph, to transmit the recent pointer\n"
    " * presses, but it may be used anywhere a list of PointerEvents is desired.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerEventList,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerEventList,
    PyType_GenericAlloc,
    Dtool_new_PointerEventList,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerEventList,
  Dtool_UpcastInterface_PointerEventList,
  Dtool_DowncastInterface_PointerEventList,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerEventList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ParamValueBase != NULL);
    assert(Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit(NULL);
    Dtool_PointerEventList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ParamValueBase);
    PyObject *dict = PyDict_New();
    Dtool_PointerEventList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerEventList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerEventList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerEventList);
  }
}

/**
 * Python method tables for PythonTask (PythonTask)
 */
static PyMethodDef Dtool_Methods_PythonTask[] = {
  {"set_function", &Dtool_PythonTask_set_function_246, METH_O, (const char *)Dtool_PythonTask_set_function_246_comment},
  {"setFunction", &Dtool_PythonTask_set_function_246, METH_O, (const char *)Dtool_PythonTask_set_function_246_comment},
  {"get_function", &Dtool_PythonTask_get_function_247, METH_NOARGS, (const char *)Dtool_PythonTask_get_function_247_comment},
  {"getFunction", &Dtool_PythonTask_get_function_247, METH_NOARGS, (const char *)Dtool_PythonTask_get_function_247_comment},
  {"set_args", (PyCFunction) &Dtool_PythonTask_set_args_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PythonTask_set_args_248_comment},
  {"setArgs", (PyCFunction) &Dtool_PythonTask_set_args_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PythonTask_set_args_248_comment},
  {"get_args", &Dtool_PythonTask_get_args_249, METH_NOARGS, (const char *)Dtool_PythonTask_get_args_249_comment},
  {"getArgs", &Dtool_PythonTask_get_args_249, METH_NOARGS, (const char *)Dtool_PythonTask_get_args_249_comment},
  {"set_upon_death", &Dtool_PythonTask_set_upon_death_250, METH_O, (const char *)Dtool_PythonTask_set_upon_death_250_comment},
  {"setUponDeath", &Dtool_PythonTask_set_upon_death_250, METH_O, (const char *)Dtool_PythonTask_set_upon_death_250_comment},
  {"get_upon_death", &Dtool_PythonTask_get_upon_death_251, METH_NOARGS, (const char *)Dtool_PythonTask_get_upon_death_251_comment},
  {"getUponDeath", &Dtool_PythonTask_get_upon_death_251, METH_NOARGS, (const char *)Dtool_PythonTask_get_upon_death_251_comment},
  {"set_owner", &Dtool_PythonTask_set_owner_252, METH_O, (const char *)Dtool_PythonTask_set_owner_252_comment},
  {"setOwner", &Dtool_PythonTask_set_owner_252, METH_O, (const char *)Dtool_PythonTask_set_owner_252_comment},
  {"get_owner", &Dtool_PythonTask_get_owner_253, METH_NOARGS, (const char *)Dtool_PythonTask_get_owner_253_comment},
  {"getOwner", &Dtool_PythonTask_get_owner_253, METH_NOARGS, (const char *)Dtool_PythonTask_get_owner_253_comment},
  {"set_delay", &Dtool_PythonTask_set_delay_259, METH_O, (const char *)Dtool_PythonTask_set_delay_259_comment},
  {"setDelay", &Dtool_PythonTask_set_delay_259, METH_O, (const char *)Dtool_PythonTask_set_delay_259_comment},
  {"get_delay", &Dtool_PythonTask_get_delay_260, METH_NOARGS, (const char *)Dtool_PythonTask_get_delay_260_comment},
  {"getDelay", &Dtool_PythonTask_get_delay_260, METH_NOARGS, (const char *)Dtool_PythonTask_get_delay_260_comment},
  {"get_class_type", &Dtool_PythonTask_get_class_type_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonTask_get_class_type_285_comment},
  {"getClassType", &Dtool_PythonTask_get_class_type_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonTask_get_class_type_285_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_clear -> __clear__
//////////////////
static int Dtool_PythonTask_clear_258_tp_clear(PyObject *self) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return -1;
  }

  return (int) (*local_this).__clear__();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_getattro -> __getattr__
//////////////////
static PyObject *Dtool_PythonTask_getattr_256_tp_getattro(PyObject *self, PyObject *arg) {
  PyObject *res = PyObject_GenericGetAttr(self, arg);
  if (res != NULL) {
    return res;
  }
  if (_PyErr_OCCURRED() != PyExc_AttributeError) {
    return NULL;
  }
  PyErr_Clear();

  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return NULL;
  }

  // 1-PyObject *PythonTask::__getattr__(PyObject *attr) const
  PyObject *return_value = (*(const PythonTask*)local_this).__getattr__(arg);
  return Dtool_Return(return_value);
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_setattro -> __setattr__
//////////////////
static int Dtool_PythonTask_setattr_254_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  PythonTask *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != (PyObject *)NULL) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int PythonTask::__setattr__(PyObject *self, PyObject *attr, PyObject *v)
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "__setattr__", 2, 2, &param1, &param2)) {
        int return_value = (*local_this).__setattr__(self, param1, param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call PythonTask.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const PythonTask self, object attr, object v)\n");
    }
    return -1;

  } else { // __delattr__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int PythonTask::__delattr__(PyObject *self, PyObject *attr)
      int return_value = (*local_this).__delattr__(self, arg);
      if (Dtool_CheckErrorOccurred()) {
        return -1;
      }
      return return_value;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PythonTask.__delattr__() on a const object.");
      return -1;
#endif
    }
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__delattr__(const PythonTask self, object attr)\n");
    }
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_traverse -> __traverse__
//////////////////
static int Dtool_PythonTask_traverse_257_tp_traverse(PyObject *self, visitproc visit, void *arg) {
  PythonTask *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PythonTask, (void **) &local_this);
  if (local_this == NULL) {
    return 0;
  }

  return (*local_this).__traverse__(visit, arg);
}

static PyGetSetDef Dtool_Properties_PythonTask[] = {
  {(char *)"name", &Dtool_PythonTask_name_Getter, &Dtool_PythonTask_name_Setter, (char *)
    "// The name of this task.",
    NULL},
  {(char *)"time", &Dtool_PythonTask_time_Getter, NULL, (char *)
    "// The amount of seconds that have elapsed since the task was started,\n"
    "// according to the task manager's clock.",
    NULL},
  {(char *)"wake_time", &Dtool_PythonTask_wake_time_Getter, NULL, (char *)
    "// If this task has been added to an AsyncTaskManager with a delay in\n"
    "// effect, this contains the time at which the task is expected to awaken.\n"
    "// It has no meaning of the task has not yet been added to a queue, or if\n"
    "// there was no delay in effect at the time the task was added.  If the\n"
    "// task's status is not S_sleeping, this contains 0.0.",
    NULL},
  {(char *)"wakeTime", &Dtool_PythonTask_wakeTime_Getter, NULL, (char *)
    "// Alias of wake_time.",
    NULL},
  {(char *)"delay_time", &Dtool_PythonTask_delay_time_Getter, &Dtool_PythonTask_delay_time_Setter, (char *)
    "// The delay value that has been set on this task, if any, or None.",
    NULL},
  {(char *)"delayTime", &Dtool_PythonTask_delayTime_Getter, &Dtool_PythonTask_delayTime_Setter, (char *)
    "// Alias of delay_time.",
    NULL},
  {(char *)"frame", &Dtool_PythonTask_frame_Getter, NULL, (char *)
    "// The number of frames that have elapsed since the task was started,\n"
    "// according to the task manager's clock.",
    NULL},
  {(char *)"id", &Dtool_PythonTask_id_Getter, NULL, (char *)
    "// This is a number guaranteed to be unique for each different AsyncTask\n"
    "// object in the universe.",
    NULL},
  {(char *)"__dict__", &Dtool_PythonTask___dict___Getter, &Dtool_PythonTask___dict___Setter, (char *)
    "// This is a special variable to hold the instance dictionary in which\n"
    "// custom variables may be stored.",
    NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PythonTask = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PythonTask = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PythonTask = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PythonTask = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PythonTask = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PythonTask",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PythonTask,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PythonTask,
    &Dtool_SequenceMethods_PythonTask,
    &Dtool_MappingMethods_PythonTask,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    &Dtool_PythonTask_getattr_256_tp_getattro,
    &Dtool_PythonTask_setattr_254_tp_setattro,
    &Dtool_BufferProcs_PythonTask,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class exists to allow association of a Python function with the\n"
    " * AsyncTaskManager.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PythonTask,
    0, // tp_members
    Dtool_Properties_PythonTask,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PythonTask,
    PyType_GenericAlloc,
    Dtool_new_PythonTask,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PythonTask,
  Dtool_UpcastInterface_PythonTask,
  Dtool_DowncastInterface_PythonTask,
  (CoerceFunction)Dtool_ConstCoerce_PythonTask,
  (CoerceFunction)Dtool_Coerce_PythonTask,
};

static void Dtool_PyModuleClassInit_PythonTask(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncTask(NULL);
    Dtool_PythonTask._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AsyncTask);
    PyObject *dict = PyDict_New();
    Dtool_PythonTask._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PythonTask) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PythonTask)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PythonTask);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3event_RegisterTypes() {
  Dtool_AsyncTask._type = AsyncTask::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AsyncTask);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("AsyncTaskCollection", Dtool_AsyncTaskCollection);
#endif
  Dtool_AsyncTaskChain._type = AsyncTaskChain::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AsyncTaskChain);
  Dtool_AsyncTaskManager._type = AsyncTaskManager::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AsyncTaskManager);
  Dtool_AsyncTaskPause._type = AsyncTaskPause::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AsyncTaskPause);
  Dtool_AsyncTaskSequence._type = AsyncTaskSequence::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AsyncTaskSequence);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("EventParameter", Dtool_EventParameter);
#endif
  Dtool_Event._type = Event::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Event);
  Dtool_EventHandler._type = EventHandler::get_class_type();
  RegisterRuntimeTypedClass(Dtool_EventHandler);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("EventQueue", Dtool_EventQueue);
#endif
  Dtool_PointerEventList._type = PointerEventList::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PointerEventList);
  Dtool_PythonTask._type = PythonTask::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PythonTask);
}

void Dtool_libp3event_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_GlobPattern = LookupNamedClass("GlobPattern");
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_AsyncTaskBase = LookupRuntimeTypedClass(AsyncTaskBase::get_class_type());
  Dtool_Ptr_ClockObject = LookupRuntimeTypedClass(ClockObject::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_ParamValueBase = LookupRuntimeTypedClass(ParamValueBase::get_class_type());
#endif
}

void Dtool_libp3event_BuildInstants(PyObject *module) {
  (void) module;
  // AsyncTask
  Dtool_PyModuleClassInit_AsyncTask(module);
  PyModule_AddObject(module, "AsyncTask", (PyObject *)&Dtool_AsyncTask);
  // AsyncTaskCollection
  Dtool_PyModuleClassInit_AsyncTaskCollection(module);
  PyModule_AddObject(module, "AsyncTaskCollection", (PyObject *)&Dtool_AsyncTaskCollection);
  // AsyncTaskChain
  Dtool_PyModuleClassInit_AsyncTaskChain(module);
  PyModule_AddObject(module, "AsyncTaskChain", (PyObject *)&Dtool_AsyncTaskChain);
  // AsyncTaskManager
  Dtool_PyModuleClassInit_AsyncTaskManager(module);
  PyModule_AddObject(module, "AsyncTaskManager", (PyObject *)&Dtool_AsyncTaskManager);
  // AsyncTaskPause
  Dtool_PyModuleClassInit_AsyncTaskPause(module);
  PyModule_AddObject(module, "AsyncTaskPause", (PyObject *)&Dtool_AsyncTaskPause);
  // AsyncTaskSequence
  Dtool_PyModuleClassInit_AsyncTaskSequence(module);
  PyModule_AddObject(module, "AsyncTaskSequence", (PyObject *)&Dtool_AsyncTaskSequence);
  // EventParameter
  Dtool_PyModuleClassInit_EventParameter(module);
  PyModule_AddObject(module, "EventParameter", (PyObject *)&Dtool_EventParameter);
  // Event
  Dtool_PyModuleClassInit_Event(module);
  PyModule_AddObject(module, "Event", (PyObject *)&Dtool_Event);
  // EventHandler
  Dtool_PyModuleClassInit_EventHandler(module);
  PyModule_AddObject(module, "EventHandler", (PyObject *)&Dtool_EventHandler);
  // EventQueue
  Dtool_PyModuleClassInit_EventQueue(module);
  PyModule_AddObject(module, "EventQueue", (PyObject *)&Dtool_EventQueue);
  // PointerEventList
  Dtool_PyModuleClassInit_PointerEventList(module);
  PyModule_AddObject(module, "PointerEventList", (PyObject *)&Dtool_PointerEventList);
  // PythonTask
  Dtool_PyModuleClassInit_PythonTask(module);
  PyModule_AddObject(module, "PythonTask", (PyObject *)&Dtool_PythonTask);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3event_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210198,  /* file_identifier */
  "libp3event",  /* library_name */
  "_0BP",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3event.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  576  /* next_index */
};

Configure(_in_configure_libp3event);
ConfigureFn(_in_configure_libp3event) {
  interrogate_request_module(&_in_module_def);
}

