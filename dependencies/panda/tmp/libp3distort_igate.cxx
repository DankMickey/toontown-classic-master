/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/distort -Ipanda/src/distort -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3distort_igate.cxx -od built/pandac/input/libp3distort.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/metalibs/pandafx -Ipanda/src/distort -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/nvidiacg/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.fx -library libp3distort config_distort.h cylindricalLens.h fisheyeLens.h nonlinearImager.h oSphereLens.h p3distort_composite1.cxx pSphereLens.h projectionScreen.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3distort
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "asyncTask.h"
#include "callbackObject.h"
#include "camera.h"
#include "configVariableBool.h"
#include "config_distort.h"
#include "cylindricalLens.h"
#include "displayRegion.h"
#include "fisheyeLens.h"
#include "graphicsEngine.h"
#include "graphicsOutput.h"
#include "lens.h"
#include "nodePath.h"
#include "nonlinearImager.h"
#include "notifyCategoryProxy.h"
#include "oSphereLens.h"
#include "pSphereLens.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "pointerTo.h"
#include "projectionScreen.h"
#include "pvector.h"
#include "texture.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CylindricalLens
 */
typedef CylindricalLens CylindricalLens_localtype;
Define_Module_ClassRef(panda3d.fx, CylindricalLens, CylindricalLens_localtype, CylindricalLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CylindricalLens = &Dtool_CylindricalLens;
static void Dtool_PyModuleClassInit_CylindricalLens(PyObject *module);

/**
 * Forward declarations for top-level class FisheyeLens
 */
typedef FisheyeLens FisheyeLens_localtype;
Define_Module_ClassRef(panda3d.fx, FisheyeLens, FisheyeLens_localtype, FisheyeLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FisheyeLens = &Dtool_FisheyeLens;
static void Dtool_PyModuleClassInit_FisheyeLens(PyObject *module);

/**
 * Forward declarations for top-level class ProjectionScreen
 */
typedef ProjectionScreen ProjectionScreen_localtype;
Define_Module_ClassRef(panda3d.fx, ProjectionScreen, ProjectionScreen_localtype, ProjectionScreen);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ProjectionScreen = &Dtool_ProjectionScreen;
static void Dtool_PyModuleClassInit_ProjectionScreen(PyObject *module);
bool Dtool_ConstCoerce_ProjectionScreen(PyObject *args, CPT(ProjectionScreen) &coerced);
bool Dtool_Coerce_ProjectionScreen(PyObject *args, PT(ProjectionScreen) &coerced);

/**
 * Forward declarations for top-level class NonlinearImager
 */
typedef NonlinearImager NonlinearImager_localtype;
Define_Module_Class(panda3d.fx, NonlinearImager, NonlinearImager_localtype, NonlinearImager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NonlinearImager = &Dtool_NonlinearImager;
static void Dtool_PyModuleClassInit_NonlinearImager(PyObject *module);

/**
 * Forward declarations for top-level class OSphereLens
 */
typedef OSphereLens OSphereLens_localtype;
Define_Module_ClassRef(panda3d.fx, OSphereLens, OSphereLens_localtype, OSphereLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OSphereLens = &Dtool_OSphereLens;
static void Dtool_PyModuleClassInit_OSphereLens(PyObject *module);

/**
 * Forward declarations for top-level class PSphereLens
 */
typedef PSphereLens PSphereLens_localtype;
Define_Module_ClassRef(panda3d.fx, PSphereLens, PSphereLens_localtype, PSphereLens);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PSphereLens = &Dtool_PSphereLens;
static void Dtool_PyModuleClassInit_PSphereLens(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritable;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedWritableReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// UpdateSeq
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_UpdateSeq;
#else
extern struct Dtool_PyTypedObject Dtool_UpdateSeq;
static struct Dtool_PyTypedObject *const Dtool_Ptr_UpdateSeq = &Dtool_UpdateSeq;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase4f;
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// Lens
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Lens;
#else
extern struct Dtool_PyTypedObject Dtool_Lens;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Lens = &Dtool_Lens;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PandaNode;
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// GeomNode
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GeomNode;
#else
extern struct Dtool_PyTypedObject Dtool_GeomNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GeomNode = &Dtool_GeomNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// PfmFile
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_PfmFile;
#else
extern struct Dtool_PyTypedObject Dtool_PfmFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PfmFile = &Dtool_PfmFile;
#endif
// DisplayRegion
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DisplayRegion;
#else
extern struct Dtool_PyTypedObject Dtool_DisplayRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
#endif
// GraphicsOutput
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsOutput;
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
#endif
// GraphicsEngine
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_GraphicsEngine;
inline static bool Dtool_ConstCoerce_GraphicsEngine(PyObject *args, CPT(GraphicsEngine) &coerced) {
  nassertr(Dtool_Ptr_GraphicsEngine != NULL, false);
  nassertr(Dtool_Ptr_GraphicsEngine->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(GraphicsEngine) &))Dtool_Ptr_GraphicsEngine->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_GraphicsEngine(PyObject *args, PT(GraphicsEngine) &coerced) {
  nassertr(Dtool_Ptr_GraphicsEngine != NULL, false);
  nassertr(Dtool_Ptr_GraphicsEngine->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(GraphicsEngine) &))Dtool_Ptr_GraphicsEngine->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsEngine;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsEngine = &Dtool_GraphicsEngine;
extern bool Dtool_ConstCoerce_GraphicsEngine(PyObject *args, CPT(GraphicsEngine) &coerced);
extern bool Dtool_Coerce_GraphicsEngine(PyObject *args, PT(GraphicsEngine) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CylindricalLens
 */
/**
 * Python function wrapper for:
 * static TypeHandle CylindricalLens::get_class_type(void)
 */
static PyObject *Dtool_CylindricalLens_get_class_type_4(PyObject *, PyObject *) {
  // 1-static TypeHandle CylindricalLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(CylindricalLens::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CylindricalLens_get_class_type_4_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CylindricalLens_get_class_type_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CylindricalLens::CylindricalLens(void)
 */
static int Dtool_Init_CylindricalLens(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CylindricalLens() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline CylindricalLens::CylindricalLens(void)
  CylindricalLens *return_value = new CylindricalLens();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CylindricalLens, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CylindricalLens()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CylindricalLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CylindricalLens) {
    printf("CylindricalLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CylindricalLens *local_this = (CylindricalLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CylindricalLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CylindricalLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CylindricalLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (CylindricalLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CylindricalLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CylindricalLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CylindricalLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CylindricalLens*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FisheyeLens
 */
/**
 * Python function wrapper for:
 * static TypeHandle FisheyeLens::get_class_type(void)
 */
static PyObject *Dtool_FisheyeLens_get_class_type_8(PyObject *, PyObject *) {
  // 1-static TypeHandle FisheyeLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(FisheyeLens::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FisheyeLens_get_class_type_8_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FisheyeLens_get_class_type_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline FisheyeLens::FisheyeLens(void)
 */
static int Dtool_Init_FisheyeLens(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FisheyeLens() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline FisheyeLens::FisheyeLens(void)
  FisheyeLens *return_value = new FisheyeLens();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FisheyeLens, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FisheyeLens()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FisheyeLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FisheyeLens) {
    printf("FisheyeLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FisheyeLens *local_this = (FisheyeLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FisheyeLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FisheyeLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FisheyeLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (FisheyeLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FisheyeLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FisheyeLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (FisheyeLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (FisheyeLens*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ProjectionScreen
 */
/**
 * Python function wrapper for:
 * void ProjectionScreen::set_projector(NodePath const &projector)
 */
static PyObject *Dtool_ProjectionScreen_set_projector_13(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_projector")) {
    return NULL;
  }
  // 1-void ProjectionScreen::set_projector(NodePath const &projector)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ProjectionScreen.set_projector", true, true);
  if (arg_this != NULL) {
    (*local_this).set_projector(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_projector(const ProjectionScreen self, const NodePath projector)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_projector_13_comment =
  "C++ Interface:\n"
  "set_projector(const ProjectionScreen self, const NodePath projector)\n"
  "\n"
  "/**\n"
  " * Specifies the LensNode that is to serve as the projector for this screen.\n"
  " * The relative position of the LensNode to the ProjectionScreen, as well as\n"
  " * the properties of the lens associated with the LensNode, determines the\n"
  " * UV's that will be assigned to the geometry within the ProjectionScreen.\n"
  " *\n"
  " * The NodePath must refer to a LensNode (or a Camera).\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_projector_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &ProjectionScreen::get_projector(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_projector_14(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NodePath const &ProjectionScreen::get_projector(void) const
  NodePath const *return_value = &((*(const ProjectionScreen*)local_this).get_projector());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_projector_14_comment =
  "C++ Interface:\n"
  "get_projector(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath to the LensNode that is to serve as the projector for\n"
  " * this screen, or empty if no projector is associated.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_projector_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::clear_undist_lut(void)
 */
static PyObject *Dtool_ProjectionScreen_clear_undist_lut_15(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.clear_undist_lut")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::clear_undist_lut(void)
  (*local_this).clear_undist_lut();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_clear_undist_lut_15_comment =
  "C++ Interface:\n"
  "clear_undist_lut(const ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Removes the distortion lookup table from the projector, if specified.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_clear_undist_lut_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_undist_lut(PfmFile const &undist_lut)
 */
static PyObject *Dtool_ProjectionScreen_set_undist_lut_16(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_undist_lut")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_undist_lut(PfmFile const &undist_lut)
  PfmFile const *arg_this = (PfmFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PfmFile, 1, "ProjectionScreen.set_undist_lut", true, true);
  if (arg_this != NULL) {
    (*local_this).set_undist_lut(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_undist_lut(const ProjectionScreen self, const PfmFile undist_lut)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_undist_lut_16_comment =
  "C++ Interface:\n"
  "set_undist_lut(const ProjectionScreen self, const PfmFile undist_lut)\n"
  "\n"
  "/**\n"
  " * Applies a distortion lookup table to the projector.  This mapping warps the\n"
  " * lens effect by passing each ray through an indirection table: the point\n"
  " * (u,v) in the indicated lookup table stores the actual (u,v) that the lens\n"
  " * produces.\n"
  " *\n"
  " * This does not affect the operation of generate_screen().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_undist_lut_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ProjectionScreen::has_undist_lut(void) const
 */
static PyObject *Dtool_ProjectionScreen_has_undist_lut_17(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ProjectionScreen::has_undist_lut(void) const
  bool return_value = (*(const ProjectionScreen*)local_this).has_undist_lut();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_has_undist_lut_17_comment =
  "C++ Interface:\n"
  "has_undist_lut(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns true if a valid distortion lookup table was provided via\n"
  " * set_undist_lut(), false otherwise.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_has_undist_lut_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PfmFile const &ProjectionScreen::get_undist_lut(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_undist_lut_18(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PfmFile const &ProjectionScreen::get_undist_lut(void) const
  PfmFile const *return_value = &((*(const ProjectionScreen*)local_this).get_undist_lut());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PfmFile, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_undist_lut_18_comment =
  "C++ Interface:\n"
  "get_undist_lut(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns the distortion lookup table provided via set_undist_lut(), if any.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_undist_lut_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GeomNode > ProjectionScreen::generate_screen(NodePath const &projector, std::string const &screen_name, int num_x_verts, int num_y_verts, PN_stdfloat distance, PN_stdfloat fill_ratio)
 */
static PyObject *Dtool_ProjectionScreen_generate_screen_19(PyObject *self, PyObject *args, PyObject *kwds) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.generate_screen")) {
    return NULL;
  }
  // 1-PointerTo< GeomNode > ProjectionScreen::generate_screen(NodePath const &projector, std::string const &screen_name, int num_x_verts, int num_y_verts, PN_stdfloat distance, PN_stdfloat fill_ratio)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  int param3;
  int param4;
  float param5;
  float param6;
  static const char *keyword_list[] = {"projector", "screen_name", "num_x_verts", "num_y_verts", "distance", "fill_ratio", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#iiff:generate_screen", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "ProjectionScreen.generate_screen", true, true);
    if (param1_this != NULL) {
      PointerTo< GeomNode > return_value = (*local_this).generate_screen(*param1_this, std::string(param2_str, param2_len), (int)param3, (int)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      GeomNode *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GeomNode, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_screen(const ProjectionScreen self, const NodePath projector, str screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_generate_screen_19_comment =
  "C++ Interface:\n"
  "generate_screen(const ProjectionScreen self, const NodePath projector, str screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n"
  "\n"
  "/**\n"
  " * Synthesizes a polygon mesh based on the projection area of the indicated\n"
  " * projector.  This generates and returns a new GeomNode but does not\n"
  " * automatically parent it to the ProjectionScreen node; see\n"
  " * regenerate_screen().\n"
  " *\n"
  " * The specified projector need not be the same as the projector given to the\n"
  " * ProjectionScreen with set_projector() (although this is often what you\n"
  " * want).\n"
  " *\n"
  " * num_x_verts and num_y_verts specify the number of vertices to make in the\n"
  " * grid across the horizontal and vertical dimension of the projector,\n"
  " * respectively; distance represents the approximate distance of the screen\n"
  " * from the lens center.\n"
  " *\n"
  " * The fill_ratio parameter specifies the fraction of the image to cover.  If\n"
  " * it is 1.0, the entire image is shown full-size; if it is 0.9, 10% of the\n"
  " * image around the edges is not part of the grid (and the grid is drawn\n"
  " * smaller by the same 10%).  This is intended to work around graphics drivers\n"
  " * that tend to show dark edges or other unsatisfactory artifacts around the\n"
  " * edges of textures: render the texture larger than necessary by a certain\n"
  " * fraction, and make the screen smaller by the inverse fraction.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_generate_screen_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProjectionScreen::regenerate_screen(NodePath const &projector, std::string const &screen_name, int num_x_verts, int num_y_verts, PN_stdfloat distance, PN_stdfloat fill_ratio)
 */
static PyObject *Dtool_ProjectionScreen_regenerate_screen_20(PyObject *self, PyObject *args, PyObject *kwds) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.regenerate_screen")) {
    return NULL;
  }
  // 1-void ProjectionScreen::regenerate_screen(NodePath const &projector, std::string const &screen_name, int num_x_verts, int num_y_verts, PN_stdfloat distance, PN_stdfloat fill_ratio)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  int param3;
  int param4;
  float param5;
  float param6;
  static const char *keyword_list[] = {"projector", "screen_name", "num_x_verts", "num_y_verts", "distance", "fill_ratio", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#iiff:regenerate_screen", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "ProjectionScreen.regenerate_screen", true, true);
    if (param1_this != NULL) {
      (*local_this).regenerate_screen(*param1_this, std::string(param2_str, param2_len), (int)param3, (int)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "regenerate_screen(const ProjectionScreen self, const NodePath projector, str screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_regenerate_screen_20_comment =
  "C++ Interface:\n"
  "regenerate_screen(const ProjectionScreen self, const NodePath projector, str screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n"
  "\n"
  "/**\n"
  " * Removes all the children from the ProjectionScreen node, and adds the newly\n"
  " * generated child returned by generate_screen().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_regenerate_screen_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PandaNode > ProjectionScreen::make_flat_mesh(NodePath const &this_np, NodePath const &camera)
 */
static PyObject *Dtool_ProjectionScreen_make_flat_mesh_21(PyObject *self, PyObject *args, PyObject *kwds) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.make_flat_mesh")) {
    return NULL;
  }
  // 1-PointerTo< PandaNode > ProjectionScreen::make_flat_mesh(NodePath const &this_np, NodePath const &camera)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"this_np", "camera", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:make_flat_mesh", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "ProjectionScreen.make_flat_mesh", true, true);
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "ProjectionScreen.make_flat_mesh", true, true);
    if (param1_this != NULL && param2_this != NULL) {
      PointerTo< PandaNode > return_value = (*local_this).make_flat_mesh(*param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      PandaNode *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_flat_mesh(const ProjectionScreen self, const NodePath this_np, const NodePath camera)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_make_flat_mesh_21_comment =
  "C++ Interface:\n"
  "make_flat_mesh(const ProjectionScreen self, const NodePath this_np, const NodePath camera)\n"
  "\n"
  "/**\n"
  " * Generates a deep copy of the hierarchy at the ProjectionScreen node and\n"
  " * below, with vertices flattened into two dimensions as if they were seen by\n"
  " * the indicated camera node.\n"
  " *\n"
  " * This is useful for rendering an image as seen through a non-linear lens.\n"
  " * The resulting mesh will have vertices in the range [-1, 1] in both x and y,\n"
  " * and may be then rendered with an ordinary orthographic lens, to generate\n"
  " * the effect of seeing the image through the specified non-linear lens.\n"
  " *\n"
  " * The returned node has no parent; it is up to the caller to parent it\n"
  " * somewhere or store it so that it does not get dereferenced and deleted.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_make_flat_mesh_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_texcoord_name(std::string const &texcoord_name)
 */
static PyObject *Dtool_ProjectionScreen_set_texcoord_name_22(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_texcoord_name")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_texcoord_name(std::string const &texcoord_name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_texcoord_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texcoord_name(const ProjectionScreen self, str texcoord_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_texcoord_name_22_comment =
  "C++ Interface:\n"
  "set_texcoord_name(const ProjectionScreen self, str texcoord_name)\n"
  "\n"
  "/**\n"
  " * Specifies the name of the texture coordinates that are generated by this\n"
  " * particular ProjectionScreen.  This can be used in the presence of\n"
  " * multitexturing to compute the UV's for just a subset of all of the active\n"
  " * stages of the multitexture pipeline.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_texcoord_name_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ProjectionScreen::get_texcoord_name(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_texcoord_name_23(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ProjectionScreen::get_texcoord_name(void) const
  std::string return_value = (*(const ProjectionScreen*)local_this).get_texcoord_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_texcoord_name_23_comment =
  "C++ Interface:\n"
  "get_texcoord_name(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the texture coordinates that will be generated by this\n"
  " * particular ProjectionScreen, as set by set_texcoord_name().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_texcoord_name_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_invert_uvs(bool invert_uvs)
 */
static PyObject *Dtool_ProjectionScreen_set_invert_uvs_24(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_invert_uvs")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_invert_uvs(bool invert_uvs)
  (*local_this).set_invert_uvs((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_invert_uvs(const ProjectionScreen self, bool invert_uvs)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_invert_uvs_24_comment =
  "C++ Interface:\n"
  "set_invert_uvs(const ProjectionScreen self, bool invert_uvs)\n"
  "\n"
  "/**\n"
  " * Some OpenGL graphics drivers are known to invert the framebuffer image when\n"
  " * they copy it to texture.  (This is arguably a problem with the OpenGL spec,\n"
  " * which seems to be unclear about the proper ordering of pixels in this\n"
  " * operation.)\n"
  " *\n"
  " * In any case, set this true to compensate for this effect by inverting the\n"
  " * UV's of the projection screen.  The default is taken from the Configrc\n"
  " * variable project-invert-uvs.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_invert_uvs_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ProjectionScreen::get_invert_uvs(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_invert_uvs_25(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ProjectionScreen::get_invert_uvs(void) const
  bool return_value = (*(const ProjectionScreen*)local_this).get_invert_uvs();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_invert_uvs_25_comment =
  "C++ Interface:\n"
  "get_invert_uvs(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns whether this screen is compensating for a graphics driver inverting\n"
  " * the framebuffer image.  See set_invert_uvs().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_invert_uvs_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_texcoord_3d(bool texcoord_3d)
 */
static PyObject *Dtool_ProjectionScreen_set_texcoord_3d_26(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_texcoord_3d")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_texcoord_3d(bool texcoord_3d)
  (*local_this).set_texcoord_3d((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texcoord_3d(const ProjectionScreen self, bool texcoord_3d)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_texcoord_3d_26_comment =
  "C++ Interface:\n"
  "set_texcoord_3d(const ProjectionScreen self, bool texcoord_3d)\n"
  "\n"
  "/**\n"
  " * Set this true to force 3-D texture coordinates to be created for the\n"
  " * geometry.  When this is true and the geometry has only 2-D texture\n"
  " * coordinates, those texture coordinates are dumped in favor of 3-D\n"
  " * coordinates.  When this is false, whatever texture coordinates already\n"
  " * exist are preserved as-is.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_texcoord_3d_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ProjectionScreen::get_texcoord_3d(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_texcoord_3d_27(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ProjectionScreen::get_texcoord_3d(void) const
  bool return_value = (*(const ProjectionScreen*)local_this).get_texcoord_3d();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_texcoord_3d_27_comment =
  "C++ Interface:\n"
  "get_texcoord_3d(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * See set_texcoord_3d().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_texcoord_3d_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_vignette_on(bool vignette_on)
 */
static PyObject *Dtool_ProjectionScreen_set_vignette_on_28(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_vignette_on")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_vignette_on(bool vignette_on)
  (*local_this).set_vignette_on((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vignette_on(const ProjectionScreen self, bool vignette_on)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_vignette_on_28_comment =
  "C++ Interface:\n"
  "set_vignette_on(const ProjectionScreen self, bool vignette_on)\n"
  "\n"
  "/**\n"
  " * Specifies whether vertex-based vignetting should be on.  When this is\n"
  " * enabled, vertex color will be set on the screen vertices to color the\n"
  " * screen two distinct colors, usually white and black, for the parts of the\n"
  " * screen in front of and outside the lens' frustum, respectively.  When this\n"
  " * is not enabled, the screen color will be left alone.\n"
  " *\n"
  " * This effect generally looks terrible, but it does at least make the\n"
  " * boundaries of the lens clear.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_vignette_on_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ProjectionScreen::get_vignette_on(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_vignette_on_29(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ProjectionScreen::get_vignette_on(void) const
  bool return_value = (*(const ProjectionScreen*)local_this).get_vignette_on();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_vignette_on_29_comment =
  "C++ Interface:\n"
  "get_vignette_on(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns true if vertex-based vignetting is on, false otherwise.  See\n"
  " * set_vignette_on().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_vignette_on_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_vignette_color(LColor const &vignette_color)
 */
static PyObject *Dtool_ProjectionScreen_set_vignette_color_30(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_vignette_color")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_vignette_color(LColor const &vignette_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ProjectionScreen.set_vignette_color", "LVecBase4f");
  }
  (*local_this).set_vignette_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vignette_color(const ProjectionScreen self, const LVecBase4f vignette_color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_vignette_color_30_comment =
  "C++ Interface:\n"
  "set_vignette_color(const ProjectionScreen self, const LVecBase4f vignette_color)\n"
  "\n"
  "/**\n"
  " * Specifies the color the screen will be painted at the portions outside of\n"
  " * the lens' frustum; i.e.  where the lens can't see it or illuminate it.\n"
  " * This color is only used if the vignette_on flag is true; see\n"
  " * set_vignette_on().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_vignette_color_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &ProjectionScreen::get_vignette_color(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_vignette_color_31(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &ProjectionScreen::get_vignette_color(void) const
  LColor const *return_value = &((*(const ProjectionScreen*)local_this).get_vignette_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_vignette_color_31_comment =
  "C++ Interface:\n"
  "get_vignette_color(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns the color the screen will be painted at the portions outside of the\n"
  " * lens' frustum.  See set_vignette_color().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_vignette_color_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_frame_color(LColor const &frame_color)
 */
static PyObject *Dtool_ProjectionScreen_set_frame_color_32(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_frame_color")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_frame_color(LColor const &frame_color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ProjectionScreen.set_frame_color", "LVecBase4f");
  }
  (*local_this).set_frame_color(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_color(const ProjectionScreen self, const LVecBase4f frame_color)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_frame_color_32_comment =
  "C++ Interface:\n"
  "set_frame_color(const ProjectionScreen self, const LVecBase4f frame_color)\n"
  "\n"
  "/**\n"
  " * Specifies the color the screen will be painted at the portions outside of\n"
  " * the lens' frustum; i.e.  where the lens can't see it or illuminate it.\n"
  " * This color is only used if the vignette_on flag is true; see\n"
  " * set_vignette_on().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_frame_color_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &ProjectionScreen::get_frame_color(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_frame_color_33(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline LColor const &ProjectionScreen::get_frame_color(void) const
  LColor const *return_value = &((*(const ProjectionScreen*)local_this).get_frame_color());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_frame_color_33_comment =
  "C++ Interface:\n"
  "get_frame_color(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns the color the screen will be painted at the portions outside of the\n"
  " * lens' frustum.  See set_frame_color().\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_frame_color_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ProjectionScreen::set_auto_recompute(bool auto_recompute)
 */
static PyObject *Dtool_ProjectionScreen_set_auto_recompute_34(PyObject *self, PyObject *arg) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.set_auto_recompute")) {
    return NULL;
  }
  // 1-inline void ProjectionScreen::set_auto_recompute(bool auto_recompute)
  (*local_this).set_auto_recompute((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_recompute(const ProjectionScreen self, bool auto_recompute)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_set_auto_recompute_34_comment =
  "C++ Interface:\n"
  "set_auto_recompute(const ProjectionScreen self, bool auto_recompute)\n"
  "\n"
  "/**\n"
  " * Sets the auto_recompute flag.  When this is true, the ProjectionScreen will\n"
  " * always be recomputed if necessary before the frame is drawn; when it is\n"
  " * false, an explicit call to recompute_if_stale() may be required.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_set_auto_recompute_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ProjectionScreen::get_auto_recompute(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_auto_recompute_35(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ProjectionScreen::get_auto_recompute(void) const
  bool return_value = (*(const ProjectionScreen*)local_this).get_auto_recompute();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_auto_recompute_35_comment =
  "C++ Interface:\n"
  "get_auto_recompute(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns the auto_recompute flag.  When this is true, the ProjectionScreen\n"
  " * will always be recomputed if necessary before the frame is drawn; when it\n"
  " * is false, an explicit call to recompute_if_stale() may be required.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_auto_recompute_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProjectionScreen::recompute(void)
 */
static PyObject *Dtool_ProjectionScreen_recompute_36(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.recompute")) {
    return NULL;
  }
  // 1-void ProjectionScreen::recompute(void)
  (*local_this).recompute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_recompute_36_comment =
  "C++ Interface:\n"
  "recompute(const ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Recomputes all the UV's for geometry below the ProjectionScreen node, as if\n"
  " * the texture were projected from the associated projector.\n"
  " *\n"
  " * This function is normally called automatically whenever the relevant\n"
  " * properties change, so it should not normally need to be called directly by\n"
  " * the user.  However, it does no harm to call this if there is any doubt.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_recompute_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq const &ProjectionScreen::get_last_screen(void) const
 */
static PyObject *Dtool_ProjectionScreen_get_last_screen_37(PyObject *self, PyObject *) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProjectionScreen, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline UpdateSeq const &ProjectionScreen::get_last_screen(void) const
  UpdateSeq const *return_value = &((*(const ProjectionScreen*)local_this).get_last_screen());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_last_screen_37_comment =
  "C++ Interface:\n"
  "get_last_screen(ProjectionScreen self)\n"
  "\n"
  "/**\n"
  " * Returns an UpdateSeq corresponding to the last time a screen mesh was\n"
  " * generated for the ProjectionScreen.  Each time generate_screen() is called,\n"
  " * this number is incremented; this allows other objects (like\n"
  " * NonlinearImager) to know when they need to recompute themselves.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_get_last_screen_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ProjectionScreen::recompute_if_stale(void)
 * bool ProjectionScreen::recompute_if_stale(NodePath const &this_np)
 */
static PyObject *Dtool_ProjectionScreen_recompute_if_stale_38(PyObject *self, PyObject *args) {
  ProjectionScreen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProjectionScreen, (void **)&local_this, "ProjectionScreen.recompute_if_stale")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-bool ProjectionScreen::recompute_if_stale(void)
      bool return_value = (*local_this).recompute_if_stale();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool ProjectionScreen::recompute_if_stale(NodePath const &this_np)
      NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ProjectionScreen.recompute_if_stale", true, true);
      if (arg_this != NULL) {
        bool return_value = (*local_this).recompute_if_stale(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "recompute_if_stale() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "recompute_if_stale(const ProjectionScreen self)\n"
      "recompute_if_stale(const ProjectionScreen self, const NodePath this_np)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_recompute_if_stale_38_comment =
  "C++ Interface:\n"
  "recompute_if_stale(const ProjectionScreen self)\n"
  "recompute_if_stale(const ProjectionScreen self, const NodePath this_np)\n"
  "\n"
  "/**\n"
  " * Calls recompute() only if the relative transform between the\n"
  " * ProjectionScreen and the projector has changed, or if any other relevant\n"
  " * property has changed.  Returns true if recomputed, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Calls recompute() only if the relative transform between the\n"
  " * ProjectionScreen and the projector has changed, or if any other relevant\n"
  " * property has changed.  Returns true if recomputed, false otherwise.\n"
  " */";
#else
static const char *Dtool_ProjectionScreen_recompute_if_stale_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ProjectionScreen::get_class_type(void)
 */
static PyObject *Dtool_ProjectionScreen_get_class_type_39(PyObject *, PyObject *) {
  // 1-static TypeHandle ProjectionScreen::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ProjectionScreen::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ProjectionScreen_get_class_type_39_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ProjectionScreen_get_class_type_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ProjectionScreen::ProjectionScreen(std::string const &name = "")
 */
static int Dtool_Init_ProjectionScreen(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-ProjectionScreen::ProjectionScreen(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:ProjectionScreen", (char **)keyword_list, &param0_str, &param0_len)) {
    ProjectionScreen *return_value = new ProjectionScreen(std::string(param0_str, param0_len));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ProjectionScreen, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ProjectionScreen(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ProjectionScreen(PyObject *args, CPT(ProjectionScreen) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ProjectionScreen, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ProjectionScreen::ProjectionScreen(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ProjectionScreen *return_value = new ProjectionScreen(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ProjectionScreen(PyObject *args, PT(ProjectionScreen) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ProjectionScreen, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ProjectionScreen::ProjectionScreen(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ProjectionScreen *return_value = new ProjectionScreen(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ProjectionScreen(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ProjectionScreen) {
    printf("ProjectionScreen ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ProjectionScreen *local_this = (ProjectionScreen *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ProjectionScreen) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ProjectionScreen(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ProjectionScreen) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ProjectionScreen*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ProjectionScreen*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ProjectionScreen*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ProjectionScreen*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ProjectionScreen*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ProjectionScreen*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NonlinearImager
 */
/**
 * Python function wrapper for:
 * int NonlinearImager::add_screen(NodePath const &screen, std::string const &name)
 * int NonlinearImager::add_screen(ProjectionScreen *screen)
 */
static PyObject *Dtool_NonlinearImager_add_screen_43(PyObject *self, PyObject *args, PyObject *kwds) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.add_screen")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "screen");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'screen' (pos 1) not found");
      }
      // 1-int NonlinearImager::add_screen(ProjectionScreen *screen)
      PT(ProjectionScreen) arg_this;
      if (!Dtool_Coerce_ProjectionScreen(arg, arg_this)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "NonlinearImager.add_screen", "ProjectionScreen");
      }
      int return_value = (*local_this).add_screen(MOVE(arg_this));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-int NonlinearImager::add_screen(NodePath const &screen, std::string const &name)
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"screen", "name", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add_screen", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "NonlinearImager.add_screen", true, true);
        if (param1_this != NULL) {
          int return_value = (*local_this).add_screen(*param1_this, std::string(param2_str, param2_len));
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_screen() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_screen(const NonlinearImager self, ProjectionScreen screen)\n"
      "add_screen(const NonlinearImager self, const NodePath screen, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_add_screen_43_comment =
  "C++ Interface:\n"
  "add_screen(const NonlinearImager self, ProjectionScreen screen)\n"
  "add_screen(const NonlinearImager self, const NodePath screen, str name)\n"
  "\n"
  "/**\n"
  " * This version of this method is deprecated and will soon be removed.  Use\n"
  " * the version that takes two parameters instead.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new ProjectionScreen to the list of screens that will be processed\n"
  " * by the NonlinearImager.  Each ProjectionScreen represents a view into the\n"
  " * world.  It must be based on a linear camera (or whatever kind of camera is\n"
  " * respected by the graphics engine).\n"
  " *\n"
  " * Each ProjectionScreen object should already have some screen geometry\n"
  " * created.\n"
  " *\n"
  " * As each frame is rendered, an offscreen image will be rendered from the\n"
  " * source camera associated with each ProjectionScreen, and the resulting\n"
  " * image will be applied to the screen geometry.\n"
  " *\n"
  " * The return value is the index number of the new screen.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_add_screen_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int NonlinearImager::find_screen(NodePath const &screen) const
 */
static PyObject *Dtool_NonlinearImager_find_screen_44(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int NonlinearImager::find_screen(NodePath const &screen) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "NonlinearImager.find_screen", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const NonlinearImager*)local_this).find_screen(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_screen(NonlinearImager self, const NodePath screen)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_find_screen_44_comment =
  "C++ Interface:\n"
  "find_screen(NonlinearImager self, const NodePath screen)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the first appearance of the indicated screen\n"
  " * within the imager's list, or -1 if it does not appear.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_find_screen_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::remove_screen(int index)
 */
static PyObject *Dtool_NonlinearImager_remove_screen_45(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.remove_screen")) {
    return NULL;
  }
  // 1-void NonlinearImager::remove_screen(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_screen((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_screen(const NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_remove_screen_45_comment =
  "C++ Interface:\n"
  "remove_screen(const NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the screen with the indicated index number from the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_remove_screen_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::remove_all_screens(void)
 */
static PyObject *Dtool_NonlinearImager_remove_all_screens_46(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.remove_all_screens")) {
    return NULL;
  }
  // 1-void NonlinearImager::remove_all_screens(void)
  (*local_this).remove_all_screens();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_remove_all_screens_46_comment =
  "C++ Interface:\n"
  "remove_all_screens(const NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Removes all screens from the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_remove_all_screens_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int NonlinearImager::get_num_screens(void) const
 */
static PyObject *Dtool_NonlinearImager_get_num_screens_47(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int NonlinearImager::get_num_screens(void) const
  int return_value = (*(const NonlinearImager*)local_this).get_num_screens();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_num_screens_47_comment =
  "C++ Interface:\n"
  "get_num_screens(NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of screens that have been added to the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_num_screens_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath NonlinearImager::get_screen(int index) const
 */
static PyObject *Dtool_NonlinearImager_get_screen_48(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath NonlinearImager::get_screen(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const NonlinearImager*)local_this).get_screen((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_screen(NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_screen_48_comment =
  "C++ Interface:\n"
  "get_screen(NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth screen that has been added to the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_screen_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * GraphicsOutput *NonlinearImager::get_buffer(int index) const
 */
static PyObject *Dtool_NonlinearImager_get_buffer_50(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-GraphicsOutput *NonlinearImager::get_buffer(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    GraphicsOutput *return_value = (*(const NonlinearImager*)local_this).get_buffer((int)arg_val);
    if (return_value != (GraphicsOutput *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (GraphicsOutput *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_buffer(NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_buffer_50_comment =
  "C++ Interface:\n"
  "get_buffer(NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the offscreen buffer that is automatically created for the nth\n"
  " * projection screen.  This may return NULL if the screen is inactive or if it\n"
  " * has not been rendered yet.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_buffer_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::set_texture_size(int index, int width, int height)
 */
static PyObject *Dtool_NonlinearImager_set_texture_size_52(PyObject *self, PyObject *args, PyObject *kwds) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.set_texture_size")) {
    return NULL;
  }
  // 1-void NonlinearImager::set_texture_size(int index, int width, int height)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"index", "width", "height", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:set_texture_size", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).set_texture_size((int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_size(const NonlinearImager self, int index, int width, int height)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_set_texture_size_52_comment =
  "C++ Interface:\n"
  "set_texture_size(const NonlinearImager self, int index, int width, int height)\n"
  "\n"
  "/**\n"
  " * Sets the width and height of the texture used to render the scene for the\n"
  " * indicated screen.  This must be less than or equal to the window size, and\n"
  " * it should be a power of two.\n"
  " *\n"
  " * In general, the larger the texture, the greater the detail of the rendered\n"
  " * scene.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_set_texture_size_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::set_source_camera(int index, NodePath const &source_camera)
 */
static PyObject *Dtool_NonlinearImager_set_source_camera_53(PyObject *self, PyObject *args, PyObject *kwds) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.set_source_camera")) {
    return NULL;
  }
  // 1-void NonlinearImager::set_source_camera(int index, NodePath const &source_camera)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "source_camera", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_source_camera", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NonlinearImager.set_source_camera", true, true);
    if (param2_this != NULL) {
      (*local_this).set_source_camera((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source_camera(const NonlinearImager self, int index, const NodePath source_camera)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_set_source_camera_53_comment =
  "C++ Interface:\n"
  "set_source_camera(const NonlinearImager self, int index, const NodePath source_camera)\n"
  "\n"
  "/**\n"
  " * Specifies the camera that will be used to render the image for this\n"
  " * particular screen.\n"
  " *\n"
  " * The parameter must be a NodePath whose node is a Camera.  The camera itself\n"
  " * indicates the scene that is to be rendered.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_set_source_camera_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::set_screen_active(int index, bool active)
 */
static PyObject *Dtool_NonlinearImager_set_screen_active_54(PyObject *self, PyObject *args, PyObject *kwds) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.set_screen_active")) {
    return NULL;
  }
  // 1-void NonlinearImager::set_screen_active(int index, bool active)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "active", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_screen_active", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_screen_active((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_screen_active(const NonlinearImager self, int index, bool active)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_set_screen_active_54_comment =
  "C++ Interface:\n"
  "set_screen_active(const NonlinearImager self, int index, bool active)\n"
  "\n"
  "/**\n"
  " * Sets the active flag on the indicated screen.  If the active flag is true,\n"
  " * the screen will be used; otherwise, it will not appear.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_set_screen_active_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool NonlinearImager::get_screen_active(int index) const
 */
static PyObject *Dtool_NonlinearImager_get_screen_active_55(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool NonlinearImager::get_screen_active(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const NonlinearImager*)local_this).get_screen_active((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_screen_active(NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_screen_active_55_comment =
  "C++ Interface:\n"
  "get_screen_active(NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the active flag on the indicated screen.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_screen_active_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int NonlinearImager::add_viewer(DisplayRegion *dr)
 */
static PyObject *Dtool_NonlinearImager_add_viewer_56(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.add_viewer")) {
    return NULL;
  }
  // 1-int NonlinearImager::add_viewer(DisplayRegion *dr)
  DisplayRegion *arg_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayRegion, 1, "NonlinearImager.add_viewer", false, true);
  if (arg_this != NULL) {
    int return_value = (*local_this).add_viewer(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_viewer(const NonlinearImager self, DisplayRegion dr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_add_viewer_56_comment =
  "C++ Interface:\n"
  "add_viewer(const NonlinearImager self, DisplayRegion dr)\n"
  "\n"
  "/**\n"
  " * Adds the indicated DisplayRegion as a viewer into the NonlinearImager room.\n"
  " * The camera associated with the DisplayRegion at the time add_viewer() is\n"
  " * called is used as the initial viewer camera; it may have a nonlinear lens,\n"
  " * like a fisheye or cylindrical lens.\n"
  " *\n"
  " * This sets up a special scene graph for this DisplayRegion alone and sets up\n"
  " * the DisplayRegion with a specialty camera.  If future changes to the camera\n"
  " * are desired, you should use the set_viewer_camera() interface.\n"
  " *\n"
  " * All viewers must share the same GraphicsEngine.\n"
  " *\n"
  " * The return value is the index of the new viewer.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_add_viewer_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int NonlinearImager::find_viewer(DisplayRegion *dr) const
 */
static PyObject *Dtool_NonlinearImager_find_viewer_57(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int NonlinearImager::find_viewer(DisplayRegion *dr) const
  DisplayRegion *arg_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayRegion, 1, "NonlinearImager.find_viewer", false, true);
  if (arg_this != NULL) {
    int return_value = (*(const NonlinearImager*)local_this).find_viewer(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_viewer(NonlinearImager self, DisplayRegion dr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_find_viewer_57_comment =
  "C++ Interface:\n"
  "find_viewer(NonlinearImager self, DisplayRegion dr)\n"
  "\n"
  "/**\n"
  " * Returns the index number of the indicated DisplayRegion within the list of\n"
  " * viewers, or -1 if it is not found.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_find_viewer_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::remove_viewer(int index)
 */
static PyObject *Dtool_NonlinearImager_remove_viewer_58(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.remove_viewer")) {
    return NULL;
  }
  // 1-void NonlinearImager::remove_viewer(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).remove_viewer((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_viewer(const NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_remove_viewer_58_comment =
  "C++ Interface:\n"
  "remove_viewer(const NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the viewer with the indicated index number from the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_remove_viewer_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::remove_all_viewers(void)
 */
static PyObject *Dtool_NonlinearImager_remove_all_viewers_59(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.remove_all_viewers")) {
    return NULL;
  }
  // 1-void NonlinearImager::remove_all_viewers(void)
  (*local_this).remove_all_viewers();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_remove_all_viewers_59_comment =
  "C++ Interface:\n"
  "remove_all_viewers(const NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Removes all viewers from the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_remove_all_viewers_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::set_viewer_camera(int index, NodePath const &viewer_camera)
 */
static PyObject *Dtool_NonlinearImager_set_viewer_camera_60(PyObject *self, PyObject *args, PyObject *kwds) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.set_viewer_camera")) {
    return NULL;
  }
  // 1-void NonlinearImager::set_viewer_camera(int index, NodePath const &viewer_camera)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "viewer_camera", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_viewer_camera", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "NonlinearImager.set_viewer_camera", true, true);
    if (param2_this != NULL) {
      (*local_this).set_viewer_camera((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viewer_camera(const NonlinearImager self, int index, const NodePath viewer_camera)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_set_viewer_camera_60_comment =
  "C++ Interface:\n"
  "set_viewer_camera(const NonlinearImager self, int index, const NodePath viewer_camera)\n"
  "\n"
  "/**\n"
  " * Specifies the LensNode that is to serve as the viewer for this screen.  The\n"
  " * relative position of the LensNode to the NonlinearImager, as well as the\n"
  " * properties of the lens associated with the LensNode, determines the UV's\n"
  " * that will be assigned to the geometry within the NonlinearImager.\n"
  " *\n"
  " * It is not necessary to call this except to change the camera after a viewer\n"
  " * has been added, since the default is to use whatever camera is associated\n"
  " * with the DisplayRegion at the time the viewer is added.\n"
  " *\n"
  " * The NodePath must refer to a LensNode (or a Camera).\n"
  " */";
#else
static const char *Dtool_NonlinearImager_set_viewer_camera_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath NonlinearImager::get_viewer_camera(int index) const
 */
static PyObject *Dtool_NonlinearImager_get_viewer_camera_61(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath NonlinearImager::get_viewer_camera(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const NonlinearImager*)local_this).get_viewer_camera((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_viewer_camera(NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_viewer_camera_61_comment =
  "C++ Interface:\n"
  "get_viewer_camera(NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath to the LensNode that is to serve as nth viewer for\n"
  " * this screen.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_viewer_camera_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath NonlinearImager::get_viewer_scene(int index) const
 */
static PyObject *Dtool_NonlinearImager_get_viewer_scene_62(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath NonlinearImager::get_viewer_scene(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath((*(const NonlinearImager*)local_this).get_viewer_scene((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_viewer_scene(NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_viewer_scene_62_comment =
  "C++ Interface:\n"
  "get_viewer_scene(NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the root node of the internal scene graph for the nth\n"
  " * viewer, which is used to render all of the screen meshes for this viewer.\n"
  " *\n"
  " * This is the scene graph in which the screen meshes within the dark room\n"
  " * have been flattened into the appropriate transformation according to the\n"
  " * viewer's lens properties (and position relative to the screens).  It is\n"
  " * this scene graph that is finally rendered to the window.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_viewer_scene_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int NonlinearImager::get_num_viewers(void) const
 */
static PyObject *Dtool_NonlinearImager_get_num_viewers_63(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-int NonlinearImager::get_num_viewers(void) const
  int return_value = (*(const NonlinearImager*)local_this).get_num_viewers();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_num_viewers_63_comment =
  "C++ Interface:\n"
  "get_num_viewers(NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of viewers that have been added to the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_num_viewers_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DisplayRegion *NonlinearImager::get_viewer(int index) const
 */
static PyObject *Dtool_NonlinearImager_get_viewer_64(PyObject *self, PyObject *arg) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-DisplayRegion *NonlinearImager::get_viewer(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DisplayRegion *return_value = (*(const NonlinearImager*)local_this).get_viewer((int)arg_val);
    if (return_value != (DisplayRegion *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (DisplayRegion *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_viewer(NonlinearImager self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_viewer_64_comment =
  "C++ Interface:\n"
  "get_viewer(NonlinearImager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth viewer's DisplayRegion that has been added to the imager.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_viewer_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NodePath NonlinearImager::get_dark_room(void) const
 */
static PyObject *Dtool_NonlinearImager_get_dark_room_66(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-NodePath NonlinearImager::get_dark_room(void) const
  NodePath *return_value = new NodePath((*(const NonlinearImager*)local_this).get_dark_room());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_dark_room_66_comment =
  "C++ Interface:\n"
  "get_dark_room(NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath to the root of the dark room scene.  This is the scene\n"
  " * in which all of the ProjectionScreens and the viewer cameras reside.  It's\n"
  " * a standalone scene with a few projection screens arranged artfully around\n"
  " * one or more viewers; it's so named because it's a little virtual theater.\n"
  " *\n"
  " * Normally this scene is not rendered directly; it only exists as an abstract\n"
  " * concept, and to define the relation between the ProjectionScreens and the\n"
  " * viewers.  But it may be rendered to help visualize the NonlinearImager's\n"
  " * behavior.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_dark_room_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * GraphicsEngine *NonlinearImager::get_graphics_engine(void) const
 */
static PyObject *Dtool_NonlinearImager_get_graphics_engine_67(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  // 1-GraphicsEngine *NonlinearImager::get_graphics_engine(void) const
  GraphicsEngine *return_value = (*(const NonlinearImager*)local_this).get_graphics_engine();
  if (return_value != (GraphicsEngine *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (GraphicsEngine *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsEngine, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_get_graphics_engine_67_comment =
  "C++ Interface:\n"
  "get_graphics_engine(NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsEngine that all of the viewers added to the\n"
  " * NonlinearImager have in common.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_get_graphics_engine_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void NonlinearImager::recompute(void)
 */
static PyObject *Dtool_NonlinearImager_recompute_68(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NonlinearImager, (void **)&local_this, "NonlinearImager.recompute")) {
    return NULL;
  }
  // 1-void NonlinearImager::recompute(void)
  (*local_this).recompute();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NonlinearImager_recompute_68_comment =
  "C++ Interface:\n"
  "recompute(const NonlinearImager self)\n"
  "\n"
  "/**\n"
  " * Forces a regeneration of all the mesh objects, etc.\n"
  " */";
#else
static const char *Dtool_NonlinearImager_recompute_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NonlinearImager::NonlinearImager(void)
 * inline NonlinearImager::NonlinearImager(NonlinearImager const &) = default
 */
static int Dtool_Init_NonlinearImager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NonlinearImager::NonlinearImager(void)
      NonlinearImager *return_value = new NonlinearImager();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NonlinearImager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline NonlinearImager::NonlinearImager(NonlinearImager const &) = default
      NonlinearImager const *arg_this = (NonlinearImager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NonlinearImager, 0, "NonlinearImager.NonlinearImager", true, true);
      if (arg_this != NULL) {
        NonlinearImager *return_value = new NonlinearImager(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NonlinearImager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NonlinearImager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NonlinearImager()\n"
      "NonlinearImager(const NonlinearImager param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NonlinearImager_get_screens(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_screens();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NonlinearImager_get_screen_48(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NonlinearImager_get_buffers(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_screens();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NonlinearImager_get_buffer_50(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NonlinearImager_get_viewers(PyObject *self, PyObject *) {
  NonlinearImager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NonlinearImager, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_viewers();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NonlinearImager_get_viewer_64(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NonlinearImager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NonlinearImager) {
    printf("NonlinearImager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NonlinearImager *local_this = (NonlinearImager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NonlinearImager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NonlinearImager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NonlinearImager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OSphereLens
 */
/**
 * Python function wrapper for:
 * static TypeHandle OSphereLens::get_class_type(void)
 */
static PyObject *Dtool_OSphereLens_get_class_type_71(PyObject *, PyObject *) {
  // 1-static TypeHandle OSphereLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(OSphereLens::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OSphereLens_get_class_type_71_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OSphereLens_get_class_type_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OSphereLens::OSphereLens(void)
 */
static int Dtool_Init_OSphereLens(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OSphereLens() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline OSphereLens::OSphereLens(void)
  OSphereLens *return_value = new OSphereLens();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OSphereLens, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OSphereLens()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OSphereLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OSphereLens) {
    printf("OSphereLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OSphereLens *local_this = (OSphereLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OSphereLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OSphereLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OSphereLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (OSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (OSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (OSphereLens*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PSphereLens
 */
/**
 * Python function wrapper for:
 * static TypeHandle PSphereLens::get_class_type(void)
 */
static PyObject *Dtool_PSphereLens_get_class_type_75(PyObject *, PyObject *) {
  // 1-static TypeHandle PSphereLens::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PSphereLens::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PSphereLens_get_class_type_75_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PSphereLens_get_class_type_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PSphereLens::PSphereLens(void)
 */
static int Dtool_Init_PSphereLens(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PSphereLens() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline PSphereLens::PSphereLens(void)
  PSphereLens *return_value = new PSphereLens();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PSphereLens, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PSphereLens()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PSphereLens(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PSphereLens) {
    printf("PSphereLens ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PSphereLens *local_this = (PSphereLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PSphereLens) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Lens) {
    return (Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(Lens *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(Lens *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PSphereLens(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PSphereLens) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Lens) {
    Lens* other_this = (Lens*)from_this;
    return (PSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PSphereLens*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PSphereLens*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for CylindricalLens (CylindricalLens)
 */
static PyMethodDef Dtool_Methods_CylindricalLens[] = {
  {"get_class_type", &Dtool_CylindricalLens_get_class_type_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_CylindricalLens_get_class_type_4_comment},
  {"getClassType", &Dtool_CylindricalLens_get_class_type_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_CylindricalLens_get_class_type_4_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CylindricalLens = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CylindricalLens = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_CylindricalLens = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_CylindricalLens = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_CylindricalLens = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.fx.CylindricalLens",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CylindricalLens,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CylindricalLens,
    &Dtool_SequenceMethods_CylindricalLens,
    &Dtool_MappingMethods_CylindricalLens,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_CylindricalLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A cylindrical lens.  This is the kind of lens generally used for extremely\n"
    " * wide panoramic shots.  It behaves like a normal perspective lens in the\n"
    " * vertical direction, but it is non-linear in the horizontal dimension: a\n"
    " * point on the film corresponds to a point in space in linear proportion to\n"
    " * its angle to the camera, not to its straight-line distance from the center.\n"
    " *\n"
    " * This allows up to 360 degree lenses in the horizontal dimension, with\n"
    " * relatively little distortion.  The distortion is not very apparent between\n"
    " * two relatively nearby points on the film, but it becomes increasingly\n"
    " * evident as you compare points widely spaced on the film.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CylindricalLens,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CylindricalLens,
    PyType_GenericAlloc,
    Dtool_new_CylindricalLens,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CylindricalLens,
  Dtool_UpcastInterface_CylindricalLens,
  Dtool_DowncastInterface_CylindricalLens,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CylindricalLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Lens != NULL);
    assert(Dtool_Ptr_Lens->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Lens->_Dtool_ModuleClassInit(NULL);
    Dtool_CylindricalLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Lens);
    PyObject *dict = PyDict_New();
    Dtool_CylindricalLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CylindricalLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CylindricalLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CylindricalLens);
  }
}

/**
 * Python method tables for FisheyeLens (FisheyeLens)
 */
static PyMethodDef Dtool_Methods_FisheyeLens[] = {
  {"get_class_type", &Dtool_FisheyeLens_get_class_type_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_FisheyeLens_get_class_type_8_comment},
  {"getClassType", &Dtool_FisheyeLens_get_class_type_8, METH_NOARGS | METH_STATIC, (const char *)Dtool_FisheyeLens_get_class_type_8_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FisheyeLens = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FisheyeLens = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FisheyeLens = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FisheyeLens = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FisheyeLens = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.fx.FisheyeLens",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FisheyeLens,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FisheyeLens,
    &Dtool_SequenceMethods_FisheyeLens,
    &Dtool_MappingMethods_FisheyeLens,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FisheyeLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A fisheye lens.  This nonlinear lens introduces a spherical distortion to\n"
    " * the image, which is minimal at small angles from the lens, and increases at\n"
    " * larger angles from the lens.  The field of view may extend to 360 degrees.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FisheyeLens,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FisheyeLens,
    PyType_GenericAlloc,
    Dtool_new_FisheyeLens,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FisheyeLens,
  Dtool_UpcastInterface_FisheyeLens,
  Dtool_DowncastInterface_FisheyeLens,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_FisheyeLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Lens != NULL);
    assert(Dtool_Ptr_Lens->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Lens->_Dtool_ModuleClassInit(NULL);
    Dtool_FisheyeLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Lens);
    PyObject *dict = PyDict_New();
    Dtool_FisheyeLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FisheyeLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FisheyeLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FisheyeLens);
  }
}

/**
 * Python method tables for ProjectionScreen (ProjectionScreen)
 */
static PyMethodDef Dtool_Methods_ProjectionScreen[] = {
  {"set_projector", &Dtool_ProjectionScreen_set_projector_13, METH_O, (const char *)Dtool_ProjectionScreen_set_projector_13_comment},
  {"setProjector", &Dtool_ProjectionScreen_set_projector_13, METH_O, (const char *)Dtool_ProjectionScreen_set_projector_13_comment},
  {"get_projector", &Dtool_ProjectionScreen_get_projector_14, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_projector_14_comment},
  {"getProjector", &Dtool_ProjectionScreen_get_projector_14, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_projector_14_comment},
  {"clear_undist_lut", &Dtool_ProjectionScreen_clear_undist_lut_15, METH_NOARGS, (const char *)Dtool_ProjectionScreen_clear_undist_lut_15_comment},
  {"clearUndistLut", &Dtool_ProjectionScreen_clear_undist_lut_15, METH_NOARGS, (const char *)Dtool_ProjectionScreen_clear_undist_lut_15_comment},
  {"set_undist_lut", &Dtool_ProjectionScreen_set_undist_lut_16, METH_O, (const char *)Dtool_ProjectionScreen_set_undist_lut_16_comment},
  {"setUndistLut", &Dtool_ProjectionScreen_set_undist_lut_16, METH_O, (const char *)Dtool_ProjectionScreen_set_undist_lut_16_comment},
  {"has_undist_lut", &Dtool_ProjectionScreen_has_undist_lut_17, METH_NOARGS, (const char *)Dtool_ProjectionScreen_has_undist_lut_17_comment},
  {"hasUndistLut", &Dtool_ProjectionScreen_has_undist_lut_17, METH_NOARGS, (const char *)Dtool_ProjectionScreen_has_undist_lut_17_comment},
  {"get_undist_lut", &Dtool_ProjectionScreen_get_undist_lut_18, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_undist_lut_18_comment},
  {"getUndistLut", &Dtool_ProjectionScreen_get_undist_lut_18, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_undist_lut_18_comment},
  {"generate_screen", (PyCFunction) &Dtool_ProjectionScreen_generate_screen_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProjectionScreen_generate_screen_19_comment},
  {"generateScreen", (PyCFunction) &Dtool_ProjectionScreen_generate_screen_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProjectionScreen_generate_screen_19_comment},
  {"regenerate_screen", (PyCFunction) &Dtool_ProjectionScreen_regenerate_screen_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProjectionScreen_regenerate_screen_20_comment},
  {"regenerateScreen", (PyCFunction) &Dtool_ProjectionScreen_regenerate_screen_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProjectionScreen_regenerate_screen_20_comment},
  {"make_flat_mesh", (PyCFunction) &Dtool_ProjectionScreen_make_flat_mesh_21, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProjectionScreen_make_flat_mesh_21_comment},
  {"makeFlatMesh", (PyCFunction) &Dtool_ProjectionScreen_make_flat_mesh_21, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProjectionScreen_make_flat_mesh_21_comment},
  {"set_texcoord_name", &Dtool_ProjectionScreen_set_texcoord_name_22, METH_O, (const char *)Dtool_ProjectionScreen_set_texcoord_name_22_comment},
  {"setTexcoordName", &Dtool_ProjectionScreen_set_texcoord_name_22, METH_O, (const char *)Dtool_ProjectionScreen_set_texcoord_name_22_comment},
  {"get_texcoord_name", &Dtool_ProjectionScreen_get_texcoord_name_23, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_texcoord_name_23_comment},
  {"getTexcoordName", &Dtool_ProjectionScreen_get_texcoord_name_23, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_texcoord_name_23_comment},
  {"set_invert_uvs", &Dtool_ProjectionScreen_set_invert_uvs_24, METH_O, (const char *)Dtool_ProjectionScreen_set_invert_uvs_24_comment},
  {"setInvertUvs", &Dtool_ProjectionScreen_set_invert_uvs_24, METH_O, (const char *)Dtool_ProjectionScreen_set_invert_uvs_24_comment},
  {"get_invert_uvs", &Dtool_ProjectionScreen_get_invert_uvs_25, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_invert_uvs_25_comment},
  {"getInvertUvs", &Dtool_ProjectionScreen_get_invert_uvs_25, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_invert_uvs_25_comment},
  {"set_texcoord_3d", &Dtool_ProjectionScreen_set_texcoord_3d_26, METH_O, (const char *)Dtool_ProjectionScreen_set_texcoord_3d_26_comment},
  {"setTexcoord3d", &Dtool_ProjectionScreen_set_texcoord_3d_26, METH_O, (const char *)Dtool_ProjectionScreen_set_texcoord_3d_26_comment},
  {"get_texcoord_3d", &Dtool_ProjectionScreen_get_texcoord_3d_27, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_texcoord_3d_27_comment},
  {"getTexcoord3d", &Dtool_ProjectionScreen_get_texcoord_3d_27, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_texcoord_3d_27_comment},
  {"set_vignette_on", &Dtool_ProjectionScreen_set_vignette_on_28, METH_O, (const char *)Dtool_ProjectionScreen_set_vignette_on_28_comment},
  {"setVignetteOn", &Dtool_ProjectionScreen_set_vignette_on_28, METH_O, (const char *)Dtool_ProjectionScreen_set_vignette_on_28_comment},
  {"get_vignette_on", &Dtool_ProjectionScreen_get_vignette_on_29, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_vignette_on_29_comment},
  {"getVignetteOn", &Dtool_ProjectionScreen_get_vignette_on_29, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_vignette_on_29_comment},
  {"set_vignette_color", &Dtool_ProjectionScreen_set_vignette_color_30, METH_O, (const char *)Dtool_ProjectionScreen_set_vignette_color_30_comment},
  {"setVignetteColor", &Dtool_ProjectionScreen_set_vignette_color_30, METH_O, (const char *)Dtool_ProjectionScreen_set_vignette_color_30_comment},
  {"get_vignette_color", &Dtool_ProjectionScreen_get_vignette_color_31, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_vignette_color_31_comment},
  {"getVignetteColor", &Dtool_ProjectionScreen_get_vignette_color_31, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_vignette_color_31_comment},
  {"set_frame_color", &Dtool_ProjectionScreen_set_frame_color_32, METH_O, (const char *)Dtool_ProjectionScreen_set_frame_color_32_comment},
  {"setFrameColor", &Dtool_ProjectionScreen_set_frame_color_32, METH_O, (const char *)Dtool_ProjectionScreen_set_frame_color_32_comment},
  {"get_frame_color", &Dtool_ProjectionScreen_get_frame_color_33, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_frame_color_33_comment},
  {"getFrameColor", &Dtool_ProjectionScreen_get_frame_color_33, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_frame_color_33_comment},
  {"set_auto_recompute", &Dtool_ProjectionScreen_set_auto_recompute_34, METH_O, (const char *)Dtool_ProjectionScreen_set_auto_recompute_34_comment},
  {"setAutoRecompute", &Dtool_ProjectionScreen_set_auto_recompute_34, METH_O, (const char *)Dtool_ProjectionScreen_set_auto_recompute_34_comment},
  {"get_auto_recompute", &Dtool_ProjectionScreen_get_auto_recompute_35, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_auto_recompute_35_comment},
  {"getAutoRecompute", &Dtool_ProjectionScreen_get_auto_recompute_35, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_auto_recompute_35_comment},
  {"recompute", &Dtool_ProjectionScreen_recompute_36, METH_NOARGS, (const char *)Dtool_ProjectionScreen_recompute_36_comment},
  {"get_last_screen", &Dtool_ProjectionScreen_get_last_screen_37, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_last_screen_37_comment},
  {"getLastScreen", &Dtool_ProjectionScreen_get_last_screen_37, METH_NOARGS, (const char *)Dtool_ProjectionScreen_get_last_screen_37_comment},
  {"recompute_if_stale", &Dtool_ProjectionScreen_recompute_if_stale_38, METH_VARARGS, (const char *)Dtool_ProjectionScreen_recompute_if_stale_38_comment},
  {"recomputeIfStale", &Dtool_ProjectionScreen_recompute_if_stale_38, METH_VARARGS, (const char *)Dtool_ProjectionScreen_recompute_if_stale_38_comment},
  {"get_class_type", &Dtool_ProjectionScreen_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_ProjectionScreen_get_class_type_39_comment},
  {"getClassType", &Dtool_ProjectionScreen_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_ProjectionScreen_get_class_type_39_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ProjectionScreen = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ProjectionScreen = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ProjectionScreen = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ProjectionScreen = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ProjectionScreen = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.fx.ProjectionScreen",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ProjectionScreen,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ProjectionScreen,
    &Dtool_SequenceMethods_ProjectionScreen,
    &Dtool_MappingMethods_ProjectionScreen,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ProjectionScreen,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A ProjectionScreen implements a simple system for projective texturing.\n"
    " * The ProjectionScreen node is the parent of a hierarchy of geometry that is\n"
    " * considered a \"screen\"; the ProjectionScreen will automatically recompute\n"
    " * all the UV's (for a particular texture stage) on its subordinate geometry\n"
    " * according to the relative position and lens parameters of the indicated\n"
    " * LensNode.\n"
    " *\n"
    " * All this does is recompute UV's; the caller is responsible for applying the\n"
    " * appropriate texture(s) to the geometry.\n"
    " *\n"
    " * This does not take advantage of any hardware-assisted projective texturing;\n"
    " * all of the UV's are computed in the CPU.  (Use NodePath::project_texture()\n"
    " * to enable hardware-assisted projective texturing.)  However, the\n"
    " * ProjectionScreen interface does support any kind of lens, linear or\n"
    " * nonlinear, that might be defined using the Lens interface, including\n"
    " * fisheye and cylindrical lenses.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ProjectionScreen,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ProjectionScreen,
    PyType_GenericAlloc,
    Dtool_new_ProjectionScreen,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ProjectionScreen,
  Dtool_UpcastInterface_ProjectionScreen,
  Dtool_DowncastInterface_ProjectionScreen,
  (CoerceFunction)Dtool_ConstCoerce_ProjectionScreen,
  (CoerceFunction)Dtool_Coerce_ProjectionScreen,
};

static void Dtool_PyModuleClassInit_ProjectionScreen(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != NULL);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(NULL);
    Dtool_ProjectionScreen._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    PyObject *dict = PyDict_New();
    Dtool_ProjectionScreen._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ProjectionScreen) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ProjectionScreen)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ProjectionScreen);
  }
}

/**
 * Python method tables for NonlinearImager (NonlinearImager)
 */
static PyMethodDef Dtool_Methods_NonlinearImager[] = {
  {"add_screen", (PyCFunction) &Dtool_NonlinearImager_add_screen_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_add_screen_43_comment},
  {"addScreen", (PyCFunction) &Dtool_NonlinearImager_add_screen_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_add_screen_43_comment},
  {"find_screen", &Dtool_NonlinearImager_find_screen_44, METH_O, (const char *)Dtool_NonlinearImager_find_screen_44_comment},
  {"findScreen", &Dtool_NonlinearImager_find_screen_44, METH_O, (const char *)Dtool_NonlinearImager_find_screen_44_comment},
  {"remove_screen", &Dtool_NonlinearImager_remove_screen_45, METH_O, (const char *)Dtool_NonlinearImager_remove_screen_45_comment},
  {"removeScreen", &Dtool_NonlinearImager_remove_screen_45, METH_O, (const char *)Dtool_NonlinearImager_remove_screen_45_comment},
  {"remove_all_screens", &Dtool_NonlinearImager_remove_all_screens_46, METH_NOARGS, (const char *)Dtool_NonlinearImager_remove_all_screens_46_comment},
  {"removeAllScreens", &Dtool_NonlinearImager_remove_all_screens_46, METH_NOARGS, (const char *)Dtool_NonlinearImager_remove_all_screens_46_comment},
  {"get_num_screens", &Dtool_NonlinearImager_get_num_screens_47, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_num_screens_47_comment},
  {"getNumScreens", &Dtool_NonlinearImager_get_num_screens_47, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_num_screens_47_comment},
  {"get_screen", &Dtool_NonlinearImager_get_screen_48, METH_O, (const char *)Dtool_NonlinearImager_get_screen_48_comment},
  {"getScreen", &Dtool_NonlinearImager_get_screen_48, METH_O, (const char *)Dtool_NonlinearImager_get_screen_48_comment},
  {"get_buffer", &Dtool_NonlinearImager_get_buffer_50, METH_O, (const char *)Dtool_NonlinearImager_get_buffer_50_comment},
  {"getBuffer", &Dtool_NonlinearImager_get_buffer_50, METH_O, (const char *)Dtool_NonlinearImager_get_buffer_50_comment},
  {"set_texture_size", (PyCFunction) &Dtool_NonlinearImager_set_texture_size_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_texture_size_52_comment},
  {"setTextureSize", (PyCFunction) &Dtool_NonlinearImager_set_texture_size_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_texture_size_52_comment},
  {"set_source_camera", (PyCFunction) &Dtool_NonlinearImager_set_source_camera_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_source_camera_53_comment},
  {"setSourceCamera", (PyCFunction) &Dtool_NonlinearImager_set_source_camera_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_source_camera_53_comment},
  {"set_screen_active", (PyCFunction) &Dtool_NonlinearImager_set_screen_active_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_screen_active_54_comment},
  {"setScreenActive", (PyCFunction) &Dtool_NonlinearImager_set_screen_active_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_screen_active_54_comment},
  {"get_screen_active", &Dtool_NonlinearImager_get_screen_active_55, METH_O, (const char *)Dtool_NonlinearImager_get_screen_active_55_comment},
  {"getScreenActive", &Dtool_NonlinearImager_get_screen_active_55, METH_O, (const char *)Dtool_NonlinearImager_get_screen_active_55_comment},
  {"add_viewer", &Dtool_NonlinearImager_add_viewer_56, METH_O, (const char *)Dtool_NonlinearImager_add_viewer_56_comment},
  {"addViewer", &Dtool_NonlinearImager_add_viewer_56, METH_O, (const char *)Dtool_NonlinearImager_add_viewer_56_comment},
  {"find_viewer", &Dtool_NonlinearImager_find_viewer_57, METH_O, (const char *)Dtool_NonlinearImager_find_viewer_57_comment},
  {"findViewer", &Dtool_NonlinearImager_find_viewer_57, METH_O, (const char *)Dtool_NonlinearImager_find_viewer_57_comment},
  {"remove_viewer", &Dtool_NonlinearImager_remove_viewer_58, METH_O, (const char *)Dtool_NonlinearImager_remove_viewer_58_comment},
  {"removeViewer", &Dtool_NonlinearImager_remove_viewer_58, METH_O, (const char *)Dtool_NonlinearImager_remove_viewer_58_comment},
  {"remove_all_viewers", &Dtool_NonlinearImager_remove_all_viewers_59, METH_NOARGS, (const char *)Dtool_NonlinearImager_remove_all_viewers_59_comment},
  {"removeAllViewers", &Dtool_NonlinearImager_remove_all_viewers_59, METH_NOARGS, (const char *)Dtool_NonlinearImager_remove_all_viewers_59_comment},
  {"set_viewer_camera", (PyCFunction) &Dtool_NonlinearImager_set_viewer_camera_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_viewer_camera_60_comment},
  {"setViewerCamera", (PyCFunction) &Dtool_NonlinearImager_set_viewer_camera_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NonlinearImager_set_viewer_camera_60_comment},
  {"get_viewer_camera", &Dtool_NonlinearImager_get_viewer_camera_61, METH_O, (const char *)Dtool_NonlinearImager_get_viewer_camera_61_comment},
  {"getViewerCamera", &Dtool_NonlinearImager_get_viewer_camera_61, METH_O, (const char *)Dtool_NonlinearImager_get_viewer_camera_61_comment},
  {"get_viewer_scene", &Dtool_NonlinearImager_get_viewer_scene_62, METH_O, (const char *)Dtool_NonlinearImager_get_viewer_scene_62_comment},
  {"getViewerScene", &Dtool_NonlinearImager_get_viewer_scene_62, METH_O, (const char *)Dtool_NonlinearImager_get_viewer_scene_62_comment},
  {"get_num_viewers", &Dtool_NonlinearImager_get_num_viewers_63, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_num_viewers_63_comment},
  {"getNumViewers", &Dtool_NonlinearImager_get_num_viewers_63, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_num_viewers_63_comment},
  {"get_viewer", &Dtool_NonlinearImager_get_viewer_64, METH_O, (const char *)Dtool_NonlinearImager_get_viewer_64_comment},
  {"getViewer", &Dtool_NonlinearImager_get_viewer_64, METH_O, (const char *)Dtool_NonlinearImager_get_viewer_64_comment},
  {"get_dark_room", &Dtool_NonlinearImager_get_dark_room_66, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_dark_room_66_comment},
  {"getDarkRoom", &Dtool_NonlinearImager_get_dark_room_66, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_dark_room_66_comment},
  {"get_graphics_engine", &Dtool_NonlinearImager_get_graphics_engine_67, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_graphics_engine_67_comment},
  {"getGraphicsEngine", &Dtool_NonlinearImager_get_graphics_engine_67, METH_NOARGS, (const char *)Dtool_NonlinearImager_get_graphics_engine_67_comment},
  {"recompute", &Dtool_NonlinearImager_recompute_68, METH_NOARGS, (const char *)Dtool_NonlinearImager_recompute_68_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_screens", (PyCFunction) &MakeSeq_NonlinearImager_get_screens, METH_NOARGS, NULL},
  { "getScreens", (PyCFunction) &MakeSeq_NonlinearImager_get_screens, METH_NOARGS, NULL},
  {"get_buffers", (PyCFunction) &MakeSeq_NonlinearImager_get_buffers, METH_NOARGS, NULL},
  { "getBuffers", (PyCFunction) &MakeSeq_NonlinearImager_get_buffers, METH_NOARGS, NULL},
  {"get_viewers", (PyCFunction) &MakeSeq_NonlinearImager_get_viewers, METH_NOARGS, NULL},
  { "getViewers", (PyCFunction) &MakeSeq_NonlinearImager_get_viewers, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NonlinearImager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_NonlinearImager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.fx.NonlinearImager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NonlinearImager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NonlinearImager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class object combines the rendered output of a 3-d from one or more\n"
    " * linear (e.g.  perspective) cameras, as seen through a single, possibly\n"
    " * nonlinear camera.\n"
    " *\n"
    " * This can be used to generate real-time imagery of a 3-d scene using a\n"
    " * nonlinear camera, for instance a fisheye camera, even though the underlying\n"
    " * graphics engine may only support linear cameras.  It can also pre-distort\n"
    " * imagery to compensate for off-axis projectors, and/or curved screens of any\n"
    " * complexity.\n"
    " *\n"
    "\n"
    " *\n"
    " * A NonlinearImager may be visualized as a dark room into which a number of\n"
    " * projection screens have been placed, of arbitrary size and shape and at any\n"
    " * arbitrary position and orientation to each other.  Onto each of these\n"
    " * screens is projected the view as seen by a normal perspective camera that\n"
    " * exists in the world (that is, under render).\n"
    " *\n"
    " * There also exist in the room one or more (possibly nonlinear) cameras,\n"
    " * called viewers, that observe these screens.  The image of the projection\n"
    " * screens seen by each viewer is finally displayed on the viewer's associated\n"
    " * DisplayRegion.  By placing the viewer(s) appropriately relative to the\n"
    " * screens, and by choosing suitable lens properties for the viewer(s), you\n"
    " * can achieve a wide variety of distortion effects.\n"
    " *\n"
    "\n"
    " *\n"
    " * There are several different LensNode (Camera) objects involved at each\n"
    " * stage in the process.  To help keep them all straight, different words are\n"
    " * used to refer to each different kind of Camera used within this object.\n"
    " * The camera(s) under render, that capture the original view of the world to\n"
    " * be projected onto the screens, are called source cameras, and are set per\n"
    " * screen via set_source_camera().  The LensNode that is associated with each\n"
    " * screen to project the image as seen from the screen's source camera is\n"
    " * called a projector; these are set via the ProjectionScreen::set_projector()\n"
    " * interface.  Finally, the cameras that view the whole configuration of\n"
    " * screens are called viewers; each of these is associated with a\n"
    " * DisplayRegion, and they are set via set_viewer_camera().\n"
    " *\n"
    " * Of all these lenses, only the source cameras must use linear (that is,\n"
    " * perspective or orthographic) lenses.  The projectors and viewers may be any\n"
    " * arbitrary lens, linear or otherwise.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NonlinearImager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NonlinearImager,
    PyType_GenericAlloc,
    Dtool_new_NonlinearImager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NonlinearImager,
  Dtool_UpcastInterface_NonlinearImager,
  Dtool_DowncastInterface_NonlinearImager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NonlinearImager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NonlinearImager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_NonlinearImager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NonlinearImager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NonlinearImager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NonlinearImager);
  }
}

/**
 * Python method tables for OSphereLens (OSphereLens)
 */
static PyMethodDef Dtool_Methods_OSphereLens[] = {
  {"get_class_type", &Dtool_OSphereLens_get_class_type_71, METH_NOARGS | METH_STATIC, (const char *)Dtool_OSphereLens_get_class_type_71_comment},
  {"getClassType", &Dtool_OSphereLens_get_class_type_71, METH_NOARGS | METH_STATIC, (const char *)Dtool_OSphereLens_get_class_type_71_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OSphereLens = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OSphereLens = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OSphereLens = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OSphereLens = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OSphereLens = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.fx.OSphereLens",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OSphereLens,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OSphereLens,
    &Dtool_SequenceMethods_OSphereLens,
    &Dtool_MappingMethods_OSphereLens,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OSphereLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A OSphereLens is a special nonlinear lens that doesn't correspond to any\n"
    " * real physical lenses.  It's primarily useful for generating 360-degree\n"
    " * wraparound images while avoiding the distortion associated with fisheye\n"
    " * images.\n"
    " *\n"
    " * A OSphereLens is similar to a Cylindrical lens and PSphereLens, except that\n"
    " * it is orthographic in the vertical direction.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OSphereLens,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OSphereLens,
    PyType_GenericAlloc,
    Dtool_new_OSphereLens,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OSphereLens,
  Dtool_UpcastInterface_OSphereLens,
  Dtool_DowncastInterface_OSphereLens,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OSphereLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Lens != NULL);
    assert(Dtool_Ptr_Lens->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Lens->_Dtool_ModuleClassInit(NULL);
    Dtool_OSphereLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Lens);
    PyObject *dict = PyDict_New();
    Dtool_OSphereLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OSphereLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OSphereLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OSphereLens);
  }
}

/**
 * Python method tables for PSphereLens (PSphereLens)
 */
static PyMethodDef Dtool_Methods_PSphereLens[] = {
  {"get_class_type", &Dtool_PSphereLens_get_class_type_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_PSphereLens_get_class_type_75_comment},
  {"getClassType", &Dtool_PSphereLens_get_class_type_75, METH_NOARGS | METH_STATIC, (const char *)Dtool_PSphereLens_get_class_type_75_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PSphereLens = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PSphereLens = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PSphereLens = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PSphereLens = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PSphereLens = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.fx.PSphereLens",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PSphereLens,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PSphereLens,
    &Dtool_SequenceMethods_PSphereLens,
    &Dtool_MappingMethods_PSphereLens,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PSphereLens,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A PSphereLens is a special nonlinear lens that doesn't correspond to any\n"
    " * real physical lenses.  It's primarily useful for generating 360-degree\n"
    " * wraparound images while avoiding the distortion associated with fisheye\n"
    " * images.\n"
    " *\n"
    " * A PSphereLens is similar to a cylindrical lens, except it is also curved in\n"
    " * the vertical direction.  This allows it to extend to both poles in the\n"
    " * vertical direction.  The mapping is similar to what many modeling packages\n"
    " * call a sphere mapping: the x coordinate is proportional to azimuth, while\n"
    " * the y coordinate is proportional to altitude.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PSphereLens,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PSphereLens,
    PyType_GenericAlloc,
    Dtool_new_PSphereLens,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PSphereLens,
  Dtool_UpcastInterface_PSphereLens,
  Dtool_DowncastInterface_PSphereLens,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PSphereLens(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Lens != NULL);
    assert(Dtool_Ptr_Lens->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_Lens->_Dtool_ModuleClassInit(NULL);
    Dtool_PSphereLens._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Lens);
    PyObject *dict = PyDict_New();
    Dtool_PSphereLens._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PSphereLens) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PSphereLens)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PSphereLens);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3distort_RegisterTypes() {
  Dtool_CylindricalLens._type = CylindricalLens::get_class_type();
  RegisterRuntimeTypedClass(Dtool_CylindricalLens);
  Dtool_FisheyeLens._type = FisheyeLens::get_class_type();
  RegisterRuntimeTypedClass(Dtool_FisheyeLens);
  Dtool_ProjectionScreen._type = ProjectionScreen::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ProjectionScreen);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NonlinearImager", Dtool_NonlinearImager);
#endif
  Dtool_OSphereLens._type = OSphereLens::get_class_type();
  RegisterRuntimeTypedClass(Dtool_OSphereLens);
  Dtool_PSphereLens._type = PSphereLens::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PSphereLens);
}

void Dtool_libp3distort_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedWritable = LookupRuntimeTypedClass(TypedWritable::get_class_type());
  Dtool_Ptr_TypedWritableReferenceCount = LookupRuntimeTypedClass(TypedWritableReferenceCount::get_class_type());
  Dtool_Ptr_UpdateSeq = LookupNamedClass("UpdateSeq");
  Dtool_Ptr_LVecBase4f = LookupRuntimeTypedClass(LVecBase4f::get_class_type());
  Dtool_Ptr_Lens = LookupRuntimeTypedClass(Lens::get_class_type());
  Dtool_Ptr_PandaNode = LookupRuntimeTypedClass(PandaNode::get_class_type());
  Dtool_Ptr_GeomNode = LookupRuntimeTypedClass(GeomNode::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
  Dtool_Ptr_PfmFile = LookupNamedClass("PfmFile");
  Dtool_Ptr_DisplayRegion = LookupRuntimeTypedClass(DisplayRegion::get_class_type());
  Dtool_Ptr_GraphicsOutput = LookupRuntimeTypedClass(GraphicsOutput::get_class_type());
  Dtool_Ptr_GraphicsEngine = LookupNamedClass("GraphicsEngine");
#endif
}

void Dtool_libp3distort_BuildInstants(PyObject *module) {
  (void) module;
  // CylindricalLens
  Dtool_PyModuleClassInit_CylindricalLens(module);
  PyModule_AddObject(module, "CylindricalLens", (PyObject *)&Dtool_CylindricalLens);
  // FisheyeLens
  Dtool_PyModuleClassInit_FisheyeLens(module);
  PyModule_AddObject(module, "FisheyeLens", (PyObject *)&Dtool_FisheyeLens);
  // ProjectionScreen
  Dtool_PyModuleClassInit_ProjectionScreen(module);
  PyModule_AddObject(module, "ProjectionScreen", (PyObject *)&Dtool_ProjectionScreen);
  // NonlinearImager
  Dtool_PyModuleClassInit_NonlinearImager(module);
  PyModule_AddObject(module, "NonlinearImager", (PyObject *)&Dtool_NonlinearImager);
  // OSphereLens
  Dtool_PyModuleClassInit_OSphereLens(module);
  PyModule_AddObject(module, "OSphereLens", (PyObject *)&Dtool_OSphereLens);
  // PSphereLens
  Dtool_PyModuleClassInit_PSphereLens(module);
  PyModule_AddObject(module, "PSphereLens", (PyObject *)&Dtool_PSphereLens);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3distort_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478213836,  /* file_identifier */
  "libp3distort",  /* library_name */
  "2YN4",  /* library_hash_name */
  "panda3d.fx",  /* module_name */
  "libp3distort.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  182  /* next_index */
};

Configure(_in_configure_libp3distort);
ConfigureFn(_in_configure_libp3distort) {
  interrogate_request_module(&_in_module_def);
}

