/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/downloader -Ipanda/src/downloader -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3downloader_igate.cxx -od built/pandac/input/libp3downloader.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/downloader -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/zlib/include -Sthirdparty/win-libs-vc10/openssl/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3downloader bioPtr.h bioStream.h bioStreamBuf.h bioStreamPtr.h chunkedStream.h chunkedStreamBuf.h config_downloader.h decompressor.h documentSpec.h downloadDb.h download_utils.h extractor.h httpAuthorization.h httpBasicAuthorization.h httpChannel.h httpClient.h httpCookie.h httpDate.h httpDigestAuthorization.h httpEntityTag.h httpEnum.h identityStream.h identityStreamBuf.h multiplexStream.h multiplexStreamBuf.h p3downloader_composite1.cxx p3downloader_composite2.cxx patcher.h socketStream.h stringStream.h stringStreamBuf.h stringStream_ext.h urlSpec.h virtualFileHTTP.h virtualFileMountHTTP.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3downloader
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "bioPtr.h"
#include "bioStream.h"
#include "bioStreamBuf.h"
#include "bioStreamPtr.h"
#include "buffer.h"
#include "chunkedStream.h"
#include "chunkedStreamBuf.h"
#include "config_downloader.h"
#include "datagram.h"
#include "datagramIterator.h"
#include "decompressor.h"
#include "documentSpec.h"
#include "downloadDb.h"
#include "download_utils.h"
#include "dtoolbase.h"
#include "extension.h"
#include "extractor.h"
#include "filename.h"
#include "hashVal.h"
#include "httpAuthorization.h"
#include "httpBasicAuthorization.h"
#include "httpChannel.h"
#include "httpClient.h"
#include "httpCookie.h"
#include "httpDate.h"
#include "httpDigestAuthorization.h"
#include "httpEntityTag.h"
#include "httpEnum.h"
#include "identityStream.h"
#include "identityStreamBuf.h"
#include "multifile.h"
#include "multiplexStream.h"
#include "multiplexStreamBuf.h"
#include "openSSLWrapper.h"
#include "openssl/ssl.h"
#include "pandabase.h"
#include "patcher.h"
#include "pmap.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pvector.h"
#include "py_panda.h"
#include "referenceCount.h"
#include "socketStream.h"
#include <stdio.h>
#include "stringStream.h"
#include "stringStreamBuf.h"
#include "stringStream_ext.h"
#include "urlSpec.h"
#include "vector_int.h"
#include "virtualFileHTTP.h"
#include "virtualFileMountHTTP.h"
#include <winsock2.h>
#include <ws2tcpip.h>

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class SSReader
 */
typedef SSReader SSReader_localtype;
Define_Module_Class(panda3d.core, SSReader, SSReader_localtype, SSReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SSReader = &Dtool_SSReader;
static void Dtool_PyModuleClassInit_SSReader(PyObject *module);

/**
 * Forward declarations for top-level class SSWriter
 */
typedef SSWriter SSWriter_localtype;
Define_Module_Class(panda3d.core, SSWriter, SSWriter_localtype, SSWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SSWriter = &Dtool_SSWriter;
static void Dtool_PyModuleClassInit_SSWriter(PyObject *module);

/**
 * Forward declarations for top-level class ISocketStream
 */
typedef ISocketStream ISocketStream_localtype;
Define_Module_Class(panda3d.core, ISocketStream, ISocketStream_localtype, ISocketStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ISocketStream = &Dtool_ISocketStream;
static void Dtool_PyModuleClassInit_ISocketStream(PyObject *module);

/**
 * Forward declarations for top-level class OSocketStream
 */
typedef OSocketStream OSocketStream_localtype;
Define_Module_Class(panda3d.core, OSocketStream, OSocketStream_localtype, OSocketStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OSocketStream = &Dtool_OSocketStream;
static void Dtool_PyModuleClassInit_OSocketStream(PyObject *module);

/**
 * Forward declarations for top-level class SocketStream
 */
typedef SocketStream SocketStream_localtype;
Define_Module_Class(panda3d.core, SocketStream, SocketStream_localtype, SocketStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SocketStream = &Dtool_SocketStream;
static void Dtool_PyModuleClassInit_SocketStream(PyObject *module);

/**
 * Forward declarations for top-level class URLSpec
 */
typedef URLSpec URLSpec_localtype;
Define_Module_Class(panda3d.core, URLSpec, URLSpec_localtype, URLSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_URLSpec = &Dtool_URLSpec;
static void Dtool_PyModuleClassInit_URLSpec(PyObject *module);
bool Dtool_ConstCoerce_URLSpec(PyObject *args, URLSpec const *&coerced, bool &manage);
bool Dtool_Coerce_URLSpec(PyObject *args, URLSpec *&coerced, bool &manage);

/**
 * Forward declarations for top-level class HTTPEnum
 */
typedef HTTPEnum HTTPEnum_localtype;
Define_Module_Class(panda3d.core, HTTPEnum, HTTPEnum_localtype, HTTPEnum);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPEnum = &Dtool_HTTPEnum;
static void Dtool_PyModuleClassInit_HTTPEnum(PyObject *module);

/**
 * Forward declarations for top-level class HTTPDate
 */
typedef HTTPDate HTTPDate_localtype;
Define_Module_Class(panda3d.core, HTTPDate, HTTPDate_localtype, HTTPDate);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPDate = &Dtool_HTTPDate;
static void Dtool_PyModuleClassInit_HTTPDate(PyObject *module);
bool Dtool_ConstCoerce_HTTPDate(PyObject *args, HTTPDate const *&coerced, bool &manage);
bool Dtool_Coerce_HTTPDate(PyObject *args, HTTPDate *&coerced, bool &manage);

/**
 * Forward declarations for top-level class HTTPCookie
 */
typedef HTTPCookie HTTPCookie_localtype;
Define_Module_Class(panda3d.core, HTTPCookie, HTTPCookie_localtype, HTTPCookie);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPCookie = &Dtool_HTTPCookie;
static void Dtool_PyModuleClassInit_HTTPCookie(PyObject *module);
bool Dtool_ConstCoerce_HTTPCookie(PyObject *args, HTTPCookie const *&coerced, bool &manage);
bool Dtool_Coerce_HTTPCookie(PyObject *args, HTTPCookie *&coerced, bool &manage);

/**
 * Forward declarations for top-level class HTTPClient
 */
typedef HTTPClient HTTPClient_localtype;
Define_Module_ClassRef(panda3d.core, HTTPClient, HTTPClient_localtype, HTTPClient);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPClient = &Dtool_HTTPClient;
static void Dtool_PyModuleClassInit_HTTPClient(PyObject *module);

/**
 * Forward declarations for top-level class HTTPEntityTag
 */
typedef HTTPEntityTag HTTPEntityTag_localtype;
Define_Module_Class(panda3d.core, HTTPEntityTag, HTTPEntityTag_localtype, HTTPEntityTag);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPEntityTag = &Dtool_HTTPEntityTag;
static void Dtool_PyModuleClassInit_HTTPEntityTag(PyObject *module);
bool Dtool_ConstCoerce_HTTPEntityTag(PyObject *args, HTTPEntityTag const *&coerced, bool &manage);
bool Dtool_Coerce_HTTPEntityTag(PyObject *args, HTTPEntityTag *&coerced, bool &manage);

/**
 * Forward declarations for top-level class DocumentSpec
 */
typedef DocumentSpec DocumentSpec_localtype;
Define_Module_Class(panda3d.core, DocumentSpec, DocumentSpec_localtype, DocumentSpec);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DocumentSpec = &Dtool_DocumentSpec;
static void Dtool_PyModuleClassInit_DocumentSpec(PyObject *module);
bool Dtool_ConstCoerce_DocumentSpec(PyObject *args, DocumentSpec const *&coerced, bool &manage);
bool Dtool_Coerce_DocumentSpec(PyObject *args, DocumentSpec *&coerced, bool &manage);

/**
 * Forward declarations for top-level class HTTPChannel
 */
typedef HTTPChannel HTTPChannel_localtype;
Define_Module_ClassRef(panda3d.core, HTTPChannel, HTTPChannel_localtype, HTTPChannel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPChannel = &Dtool_HTTPChannel;
static void Dtool_PyModuleClassInit_HTTPChannel(PyObject *module);

/**
 * Forward declarations for top-level class Decompressor
 */
typedef Decompressor Decompressor_localtype;
Define_Module_Class(panda3d.core, Decompressor, Decompressor_localtype, Decompressor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Decompressor = &Dtool_Decompressor;
static void Dtool_PyModuleClassInit_Decompressor(PyObject *module);

/**
 * Forward declarations for top-level class DownloadDb
 */
typedef DownloadDb DownloadDb_localtype;
Define_Module_Class(panda3d.core, DownloadDb, DownloadDb_localtype, DownloadDb);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DownloadDb = &Dtool_DownloadDb;
static void Dtool_PyModuleClassInit_DownloadDb(PyObject *module);
bool Dtool_ConstCoerce_DownloadDb(PyObject *args, DownloadDb const *&coerced, bool &manage);
bool Dtool_Coerce_DownloadDb(PyObject *args, DownloadDb *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Extractor
 */
typedef Extractor Extractor_localtype;
Define_Module_Class(panda3d.core, Extractor, Extractor_localtype, Extractor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Extractor = &Dtool_Extractor;
static void Dtool_PyModuleClassInit_Extractor(PyObject *module);

/**
 * Forward declarations for top-level class MultiplexStream
 */
typedef MultiplexStream MultiplexStream_localtype;
Define_Module_Class(panda3d.core, MultiplexStream, MultiplexStream_localtype, MultiplexStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MultiplexStream = &Dtool_MultiplexStream;
static void Dtool_PyModuleClassInit_MultiplexStream(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileHTTP
 */
typedef VirtualFileHTTP VirtualFileHTTP_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileHTTP, VirtualFileHTTP_localtype, VirtualFileHTTP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileHTTP = &Dtool_VirtualFileHTTP;
static void Dtool_PyModuleClassInit_VirtualFileHTTP(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMountHTTP
 */
typedef VirtualFileMountHTTP VirtualFileMountHTTP_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountHTTP, VirtualFileMountHTTP_localtype, VirtualFileMountHTTP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountHTTP = &Dtool_VirtualFileMountHTTP;
static void Dtool_PyModuleClassInit_VirtualFileMountHTTP(PyObject *module);
bool Dtool_ConstCoerce_VirtualFileMountHTTP(PyObject *args, CPT(VirtualFileMountHTTP) &coerced);
bool Dtool_Coerce_VirtualFileMountHTTP(PyObject *args, PT(VirtualFileMountHTTP) &coerced);

/**
 * Forward declarations for top-level class Patcher
 */
typedef Patcher Patcher_localtype;
Define_Module_Class(panda3d.core, Patcher, Patcher_localtype, Patcher);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Patcher = &Dtool_Patcher;
static void Dtool_PyModuleClassInit_Patcher(PyObject *module);
bool Dtool_ConstCoerce_Patcher(PyObject *args, Patcher const *&coerced, bool &manage);
bool Dtool_Coerce_Patcher(PyObject *args, Patcher *&coerced, bool &manage);

/**
 * Forward declarations for top-level class StringStream
 */
typedef StringStream StringStream_localtype;
Define_Module_Class(panda3d.core, StringStream, StringStream_localtype, StringStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StringStream = &Dtool_StringStream;
static void Dtool_PyModuleClassInit_StringStream(PyObject *module);
bool Dtool_ConstCoerce_StringStream(PyObject *args, StringStream const *&coerced, bool &manage);
bool Dtool_Coerce_StringStream(PyObject *args, StringStream *&coerced, bool &manage);

/**
 * Extern declarations for imported classes
 */
// ios_base
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ios_base;
#else
extern struct Dtool_PyTypedObject Dtool_ios_base;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ios_base = &Dtool_ios_base;
#endif
// ios
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ios;
#else
extern struct Dtool_PyTypedObject Dtool_ios;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ios = &Dtool_ios;
#endif
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// istream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_istream;
#else
extern struct Dtool_PyTypedObject Dtool_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_istream = &Dtool_istream;
#endif
// iostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_iostream;
#else
extern struct Dtool_PyTypedObject Dtool_iostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_iostream = &Dtool_iostream;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// Ramfile
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Ramfile;
#else
extern struct Dtool_PyTypedObject Dtool_Ramfile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Ramfile = &Dtool_Ramfile;
#endif
// HashVal
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_HashVal;
#else
extern struct Dtool_PyTypedObject Dtool_HashVal;
static struct Dtool_PyTypedObject *const Dtool_Ptr_HashVal = &Dtool_HashVal;
#endif
// Buffer
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Buffer;
#else
extern struct Dtool_PyTypedObject Dtool_Buffer;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Buffer = &Dtool_Buffer;
#endif
// VirtualFileMount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_VirtualFileMount;
#else
extern struct Dtool_PyTypedObject Dtool_VirtualFileMount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMount = &Dtool_VirtualFileMount;
#endif
// VirtualFile
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_VirtualFile;
#else
extern struct Dtool_PyTypedObject Dtool_VirtualFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFile = &Dtool_VirtualFile;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * unsigned long int check_crc(Filename name)
 */
static PyObject *Dtool_check_crc_409(PyObject *, PyObject *arg) {
  // 1-unsigned long int check_crc(Filename name)
  Filename arg_local;
  Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "check_crc", "Filename");
  }
  unsigned long int return_value = check_crc(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_crc(Filename name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_check_crc_409_comment =
  "C++ Interface:\n"
  "check_crc(Filename name)\n";
#else
static const char *Dtool_check_crc_409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * unsigned long int check_adler(Filename name)
 */
static PyObject *Dtool_check_adler_410(PyObject *, PyObject *arg) {
  // 1-unsigned long int check_adler(Filename name)
  Filename arg_local;
  Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "check_adler", "Filename");
  }
  unsigned long int return_value = check_adler(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_adler(Filename name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_check_adler_410_comment =
  "C++ Interface:\n"
  "check_adler(Filename name)\n";
#else
static const char *Dtool_check_adler_410_comment = NULL;
#endif

/**
 * Python wrappers for functions of class SSReader
 */
/**
 * Python function wrapper for:
 * inline bool SSReader::receive_datagram(Datagram &dg)
 */
static PyObject *Dtool_SSReader_receive_datagram_3(PyObject *self, PyObject *arg) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSReader, (void **)&local_this, "SSReader.receive_datagram")) {
    return NULL;
  }
  // 1-inline bool SSReader::receive_datagram(Datagram &dg)
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SSReader.receive_datagram", "Datagram");
  }
  bool return_value = (*local_this).receive_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "receive_datagram(const SSReader self, Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SSReader_receive_datagram_3_comment =
  "C++ Interface:\n"
  "receive_datagram(const SSReader self, Datagram dg)\n"
  "\n"
  "/**\n"
  " * Receives a datagram over the socket by expecting a little-endian 16-bit\n"
  " * byte count as a prefix.  If the socket stream is non-blocking, may return\n"
  " * false if the data is not available; otherwise, returns false only if the\n"
  " * socket closes.\n"
  " */";
#else
static const char *Dtool_SSReader_receive_datagram_3_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool SSReader::is_closed(void) = 0
 */
static PyObject *Dtool_SSReader_is_closed_4(PyObject *self, PyObject *) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSReader, (void **)&local_this, "SSReader.is_closed")) {
    return NULL;
  }
  // 1-virtual bool SSReader::is_closed(void) = 0
  bool return_value = (*local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSReader_is_closed_4_comment =
  "C++ Interface:\n"
  "is_closed(const SSReader self)\n";
#else
static const char *Dtool_SSReader_is_closed_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void SSReader::close(void) = 0
 */
static PyObject *Dtool_SSReader_close_5(PyObject *self, PyObject *) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSReader, (void **)&local_this, "SSReader.close")) {
    return NULL;
  }
  // 1-virtual void SSReader::close(void) = 0
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SSReader_close_5_comment =
  "C++ Interface:\n"
  "close(const SSReader self)\n";
#else
static const char *Dtool_SSReader_close_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SSReader::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_SSReader_set_tcp_header_size_6(PyObject *self, PyObject *arg) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSReader, (void **)&local_this, "SSReader.set_tcp_header_size")) {
    return NULL;
  }
  // 1-inline void SSReader::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tcp_header_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const SSReader self, int tcp_header_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SSReader_set_tcp_header_size_6_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const SSReader self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size for datagrams.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_SSReader_set_tcp_header_size_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SSReader::get_tcp_header_size(void) const
 */
static PyObject *Dtool_SSReader_get_tcp_header_size_7(PyObject *self, PyObject *) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SSReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SSReader::get_tcp_header_size(void) const
  int return_value = (*(const SSReader*)local_this).get_tcp_header_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSReader_get_tcp_header_size_7_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(SSReader self)\n"
  "\n"
  "/**\n"
  " * Returns the header size for datagrams.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_SSReader_get_tcp_header_size_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ISocketStream *SSReader::downcast_to_ISocketStream(void)
 */
static PyObject *Dtool_SSReader_downcast_to_ISocketStream_26(PyObject *self, PyObject *) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSReader, (void **)&local_this, "SSReader.downcast_to_ISocketStream")) {
    return NULL;
  }
  // 1-ISocketStream *SSReader::downcast_to_ISocketStream(void)
  ISocketStream *return_value = (ISocketStream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ISocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SSReader_downcast_to_ISocketStream_26_comment =
  "C++ Interface:\n"
  "downcast_to_ISocketStream(const SSReader self)\n"
  "\n"
  "downcast from SSReader to ISocketStream";
#else
static const char *Dtool_SSReader_downcast_to_ISocketStream_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SocketStream *SSReader::downcast_to_SocketStream(void)
 */
static PyObject *Dtool_SSReader_downcast_to_SocketStream_47(PyObject *self, PyObject *) {
  SSReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSReader, (void **)&local_this, "SSReader.downcast_to_SocketStream")) {
    return NULL;
  }
  // 1-SocketStream *SSReader::downcast_to_SocketStream(void)
  SocketStream *return_value = (SocketStream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SSReader_downcast_to_SocketStream_47_comment =
  "C++ Interface:\n"
  "downcast_to_SocketStream(const SSReader self)\n"
  "\n"
  "downcast from SSReader to SocketStream";
#else
static const char *Dtool_SSReader_downcast_to_SocketStream_47_comment = NULL;
#endif

static int Dtool_Init_SSReader(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_SSReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SSReader) {
    printf("SSReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SSReader *local_this = (SSReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SSReader) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SSReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SSReader) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SSWriter
 */
/**
 * Python function wrapper for:
 * bool SSWriter::send_datagram(Datagram const &dg)
 */
static PyObject *Dtool_SSWriter_send_datagram_10(PyObject *self, PyObject *arg) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.send_datagram")) {
    return NULL;
  }
  // 1-bool SSWriter::send_datagram(Datagram const &dg)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SSWriter.send_datagram", "Datagram");
  }
  bool return_value = (*local_this).send_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_datagram(const SSWriter self, const Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_send_datagram_10_comment =
  "C++ Interface:\n"
  "send_datagram(const SSWriter self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " * Transmits the indicated datagram over the socket by prepending it with a\n"
  " * little-endian 16-bit byte count.  Does not return until the data is sent or\n"
  " * the connection is closed, even if the socket stream is non-blocking.\n"
  " */";
#else
static const char *Dtool_SSWriter_send_datagram_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool SSWriter::is_closed(void) = 0
 */
static PyObject *Dtool_SSWriter_is_closed_11(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.is_closed")) {
    return NULL;
  }
  // 1-virtual bool SSWriter::is_closed(void) = 0
  bool return_value = (*local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_is_closed_11_comment =
  "C++ Interface:\n"
  "is_closed(const SSWriter self)\n";
#else
static const char *Dtool_SSWriter_is_closed_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void SSWriter::close(void) = 0
 */
static PyObject *Dtool_SSWriter_close_12(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.close")) {
    return NULL;
  }
  // 1-virtual void SSWriter::close(void) = 0
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_close_12_comment =
  "C++ Interface:\n"
  "close(const SSWriter self)\n";
#else
static const char *Dtool_SSWriter_close_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SSWriter::set_collect_tcp(bool collect_tcp)
 */
static PyObject *Dtool_SSWriter_set_collect_tcp_13(PyObject *self, PyObject *arg) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.set_collect_tcp")) {
    return NULL;
  }
  // 1-inline void SSWriter::set_collect_tcp(bool collect_tcp)
  (*local_this).set_collect_tcp((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp(const SSWriter self, bool collect_tcp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_set_collect_tcp_13_comment =
  "C++ Interface:\n"
  "set_collect_tcp(const SSWriter self, bool collect_tcp)\n"
  "\n"
  "/**\n"
  " * Enables or disables \"collect-tcp\" mode.  In this mode, individual TCP\n"
  " * packets are not sent immediately, but rather they are collected together\n"
  " * and accumulated to be sent periodically as one larger TCP packet.  This\n"
  " * cuts down on overhead from the TCP/IP protocol, especially if many small\n"
  " * packets need to be sent on the same connection, but it introduces\n"
  " * additional latency (since packets must be held before they can be sent).\n"
  " *\n"
  " * See set_collect_tcp_interval() to specify the interval of time for which to\n"
  " * hold packets before sending them.\n"
  " *\n"
  " * If you enable this mode, you may also need to periodically call\n"
  " * consider_flush() to flush the queue if no packets have been sent recently.\n"
  " */";
#else
static const char *Dtool_SSWriter_set_collect_tcp_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SSWriter::get_collect_tcp(void) const
 */
static PyObject *Dtool_SSWriter_get_collect_tcp_14(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SSWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SSWriter::get_collect_tcp(void) const
  bool return_value = (*(const SSWriter*)local_this).get_collect_tcp();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_get_collect_tcp_14_comment =
  "C++ Interface:\n"
  "get_collect_tcp(SSWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of \"collect-tcp\" mode.  See set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SSWriter_get_collect_tcp_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SSWriter::set_collect_tcp_interval(double interval)
 */
static PyObject *Dtool_SSWriter_set_collect_tcp_interval_15(PyObject *self, PyObject *arg) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.set_collect_tcp_interval")) {
    return NULL;
  }
  // 1-inline void SSWriter::set_collect_tcp_interval(double interval)
  if (PyNumber_Check(arg)) {
    (*local_this).set_collect_tcp_interval(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp_interval(const SSWriter self, double interval)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_set_collect_tcp_interval_15_comment =
  "C++ Interface:\n"
  "set_collect_tcp_interval(const SSWriter self, double interval)\n"
  "\n"
  "/**\n"
  " * Specifies the interval in time, in seconds, for which to hold TCP packets\n"
  " * before sending all of the recently received packets at once.  This only has\n"
  " * meaning if \"collect-tcp\" mode is enabled; see set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SSWriter_set_collect_tcp_interval_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double SSWriter::get_collect_tcp_interval(void) const
 */
static PyObject *Dtool_SSWriter_get_collect_tcp_interval_16(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SSWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double SSWriter::get_collect_tcp_interval(void) const
  double return_value = (*(const SSWriter*)local_this).get_collect_tcp_interval();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_get_collect_tcp_interval_16_comment =
  "C++ Interface:\n"
  "get_collect_tcp_interval(SSWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the interval in time, in seconds, for which to hold TCP packets\n"
  " * before sending all of the recently received packets at once.  This only has\n"
  " * meaning if \"collect-tcp\" mode is enabled; see set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_SSWriter_get_collect_tcp_interval_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SSWriter::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_SSWriter_set_tcp_header_size_17(PyObject *self, PyObject *arg) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.set_tcp_header_size")) {
    return NULL;
  }
  // 1-inline void SSWriter::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tcp_header_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const SSWriter self, int tcp_header_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_set_tcp_header_size_17_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const SSWriter self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size for datagrams.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_SSWriter_set_tcp_header_size_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SSWriter::get_tcp_header_size(void) const
 */
static PyObject *Dtool_SSWriter_get_tcp_header_size_18(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SSWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SSWriter::get_tcp_header_size(void) const
  int return_value = (*(const SSWriter*)local_this).get_tcp_header_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_get_tcp_header_size_18_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(SSWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the header size for datagrams.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_SSWriter_get_tcp_header_size_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SSWriter::consider_flush(void)
 */
static PyObject *Dtool_SSWriter_consider_flush_19(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.consider_flush")) {
    return NULL;
  }
  // 1-inline bool SSWriter::consider_flush(void)
  bool return_value = (*local_this).consider_flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_consider_flush_19_comment =
  "C++ Interface:\n"
  "consider_flush(const SSWriter self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data if enough time has elapsed.  This only\n"
  " * has meaning if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_SSWriter_consider_flush_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SSWriter::flush(void)
 */
static PyObject *Dtool_SSWriter_flush_20(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.flush")) {
    return NULL;
  }
  // 1-inline bool SSWriter::flush(void)
  bool return_value = (*local_this).flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_flush_20_comment =
  "C++ Interface:\n"
  "flush(const SSWriter self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data now.  This only has meaning if\n"
  " * set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_SSWriter_flush_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OSocketStream *SSWriter::downcast_to_OSocketStream(void)
 */
static PyObject *Dtool_SSWriter_downcast_to_OSocketStream_37(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.downcast_to_OSocketStream")) {
    return NULL;
  }
  // 1-OSocketStream *SSWriter::downcast_to_OSocketStream(void)
  OSocketStream *return_value = (OSocketStream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OSocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_downcast_to_OSocketStream_37_comment =
  "C++ Interface:\n"
  "downcast_to_OSocketStream(const SSWriter self)\n"
  "\n"
  "downcast from SSWriter to OSocketStream";
#else
static const char *Dtool_SSWriter_downcast_to_OSocketStream_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SocketStream *SSWriter::downcast_to_SocketStream(void)
 */
static PyObject *Dtool_SSWriter_downcast_to_SocketStream_49(PyObject *self, PyObject *) {
  SSWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SSWriter, (void **)&local_this, "SSWriter.downcast_to_SocketStream")) {
    return NULL;
  }
  // 1-SocketStream *SSWriter::downcast_to_SocketStream(void)
  SocketStream *return_value = (SocketStream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SSWriter_downcast_to_SocketStream_49_comment =
  "C++ Interface:\n"
  "downcast_to_SocketStream(const SSWriter self)\n"
  "\n"
  "downcast from SSWriter to SocketStream";
#else
static const char *Dtool_SSWriter_downcast_to_SocketStream_49_comment = NULL;
#endif

static int Dtool_Init_SSWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_SSWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SSWriter) {
    printf("SSWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SSWriter *local_this = (SSWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SSWriter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SSWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SSWriter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ISocketStream
 */
/**
 * Python function wrapper for:
 * virtual bool ISocketStream::is_closed(void) = 0
 */
static PyObject *Dtool_ISocketStream_is_closed_29(PyObject *self, PyObject *) {
  ISocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISocketStream, (void **)&local_this, "ISocketStream.is_closed")) {
    return NULL;
  }
  // 1-virtual bool ISocketStream::is_closed(void) = 0
  bool return_value = (*local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ISocketStream_is_closed_29_comment =
  "C++ Interface:\n"
  "is_closed(const ISocketStream self)\n";
#else
static const char *Dtool_ISocketStream_is_closed_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void ISocketStream::close(void) = 0
 */
static PyObject *Dtool_ISocketStream_close_30(PyObject *self, PyObject *) {
  ISocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISocketStream, (void **)&local_this, "ISocketStream.close")) {
    return NULL;
  }
  // 1-virtual void ISocketStream::close(void) = 0
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ISocketStream_close_30_comment =
  "C++ Interface:\n"
  "close(const ISocketStream self)\n";
#else
static const char *Dtool_ISocketStream_close_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual ISocketStream::ReadState ISocketStream::get_read_state(void) = 0
 */
static PyObject *Dtool_ISocketStream_get_read_state_31(PyObject *self, PyObject *) {
  ISocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISocketStream, (void **)&local_this, "ISocketStream.get_read_state")) {
    return NULL;
  }
  // 1-virtual ISocketStream::ReadState ISocketStream::get_read_state(void) = 0
  ISocketStream::ReadState return_value = (*local_this).get_read_state();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ISocketStream_get_read_state_31_comment =
  "C++ Interface:\n"
  "get_read_state(const ISocketStream self)\n";
#else
static const char *Dtool_ISocketStream_get_read_state_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * istream *ISocketStream::upcast_to_istream(void)
 */
static PyObject *Dtool_ISocketStream_upcast_to_istream_23(PyObject *self, PyObject *) {
  ISocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISocketStream, (void **)&local_this, "ISocketStream.upcast_to_istream")) {
    return NULL;
  }
  // 1-istream *ISocketStream::upcast_to_istream(void)
  istream *return_value = (istream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ISocketStream_upcast_to_istream_23_comment =
  "C++ Interface:\n"
  "upcast_to_istream(const ISocketStream self)\n"
  "\n"
  "upcast from ISocketStream to istream";
#else
static const char *Dtool_ISocketStream_upcast_to_istream_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SSReader *ISocketStream::upcast_to_SSReader(void)
 */
static PyObject *Dtool_ISocketStream_upcast_to_SSReader_25(PyObject *self, PyObject *) {
  ISocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISocketStream, (void **)&local_this, "ISocketStream.upcast_to_SSReader")) {
    return NULL;
  }
  // 1-SSReader *ISocketStream::upcast_to_SSReader(void)
  SSReader *return_value = (SSReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SSReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ISocketStream_upcast_to_SSReader_25_comment =
  "C++ Interface:\n"
  "upcast_to_SSReader(const ISocketStream self)\n"
  "\n"
  "upcast from ISocketStream to SSReader";
#else
static const char *Dtool_ISocketStream_upcast_to_SSReader_25_comment = NULL;
#endif

static int Dtool_Init_ISocketStream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ISocketStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ISocketStream) {
    printf("ISocketStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ISocketStream *local_this = (ISocketStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ISocketStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SSReader) {
    return (SSReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ISocketStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ISocketStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SSReader) {
    SSReader* other_this = (SSReader*)from_this;
    return (ISocketStream*)other_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (ISocketStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OSocketStream
 */
/**
 * Python function wrapper for:
 * virtual bool OSocketStream::is_closed(void) = 0
 */
static PyObject *Dtool_OSocketStream_is_closed_38(PyObject *self, PyObject *) {
  OSocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSocketStream, (void **)&local_this, "OSocketStream.is_closed")) {
    return NULL;
  }
  // 1-virtual bool OSocketStream::is_closed(void) = 0
  bool return_value = (*local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OSocketStream_is_closed_38_comment =
  "C++ Interface:\n"
  "is_closed(const OSocketStream self)\n";
#else
static const char *Dtool_OSocketStream_is_closed_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void OSocketStream::close(void) = 0
 */
static PyObject *Dtool_OSocketStream_close_39(PyObject *self, PyObject *) {
  OSocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSocketStream, (void **)&local_this, "OSocketStream.close")) {
    return NULL;
  }
  // 1-virtual void OSocketStream::close(void) = 0
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OSocketStream_close_39_comment =
  "C++ Interface:\n"
  "close(const OSocketStream self)\n";
#else
static const char *Dtool_OSocketStream_close_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool OSocketStream::flush(void)
 */
static PyObject *Dtool_OSocketStream_flush_40(PyObject *self, PyObject *) {
  OSocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSocketStream, (void **)&local_this, "OSocketStream.flush")) {
    return NULL;
  }
  // 1-inline bool OSocketStream::flush(void)
  bool return_value = (*local_this).flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OSocketStream_flush_40_comment =
  "C++ Interface:\n"
  "flush(const OSocketStream self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data now.  This only has meaning if\n"
  " * set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_OSocketStream_flush_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ostream *OSocketStream::upcast_to_ostream(void)
 */
static PyObject *Dtool_OSocketStream_upcast_to_ostream_34(PyObject *self, PyObject *) {
  OSocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSocketStream, (void **)&local_this, "OSocketStream.upcast_to_ostream")) {
    return NULL;
  }
  // 1-ostream *OSocketStream::upcast_to_ostream(void)
  ostream *return_value = (ostream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OSocketStream_upcast_to_ostream_34_comment =
  "C++ Interface:\n"
  "upcast_to_ostream(const OSocketStream self)\n"
  "\n"
  "upcast from OSocketStream to ostream";
#else
static const char *Dtool_OSocketStream_upcast_to_ostream_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SSWriter *OSocketStream::upcast_to_SSWriter(void)
 */
static PyObject *Dtool_OSocketStream_upcast_to_SSWriter_36(PyObject *self, PyObject *) {
  OSocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSocketStream, (void **)&local_this, "OSocketStream.upcast_to_SSWriter")) {
    return NULL;
  }
  // 1-SSWriter *OSocketStream::upcast_to_SSWriter(void)
  SSWriter *return_value = (SSWriter *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SSWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OSocketStream_upcast_to_SSWriter_36_comment =
  "C++ Interface:\n"
  "upcast_to_SSWriter(const OSocketStream self)\n"
  "\n"
  "upcast from OSocketStream to SSWriter";
#else
static const char *Dtool_OSocketStream_upcast_to_SSWriter_36_comment = NULL;
#endif

static int Dtool_Init_OSocketStream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_OSocketStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OSocketStream) {
    printf("OSocketStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OSocketStream *local_this = (OSocketStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OSocketStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SSWriter) {
    return (SSWriter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OSocketStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OSocketStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SSWriter) {
    SSWriter* other_this = (SSWriter*)from_this;
    return (OSocketStream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (OSocketStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SocketStream
 */
/**
 * Python function wrapper for:
 * virtual bool SocketStream::is_closed(void) = 0
 */
static PyObject *Dtool_SocketStream_is_closed_50(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.is_closed")) {
    return NULL;
  }
  // 1-virtual bool SocketStream::is_closed(void) = 0
  bool return_value = (*local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_is_closed_50_comment =
  "C++ Interface:\n"
  "is_closed(const SocketStream self)\n";
#else
static const char *Dtool_SocketStream_is_closed_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void SocketStream::close(void) = 0
 */
static PyObject *Dtool_SocketStream_close_51(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.close")) {
    return NULL;
  }
  // 1-virtual void SocketStream::close(void) = 0
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_close_51_comment =
  "C++ Interface:\n"
  "close(const SocketStream self)\n";
#else
static const char *Dtool_SocketStream_close_51_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void SocketStream::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_SocketStream_set_tcp_header_size_52(PyObject *self, PyObject *arg) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.set_tcp_header_size")) {
    return NULL;
  }
  // 1-inline void SocketStream::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tcp_header_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const SocketStream self, int tcp_header_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_set_tcp_header_size_52_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const SocketStream self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size for datagrams.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_SocketStream_set_tcp_header_size_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int SocketStream::get_tcp_header_size(void) const
 */
static PyObject *Dtool_SocketStream_get_tcp_header_size_53(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SocketStream, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int SocketStream::get_tcp_header_size(void) const
  int return_value = (*(const SocketStream*)local_this).get_tcp_header_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_get_tcp_header_size_53_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(SocketStream self)\n"
  "\n"
  "/**\n"
  " * Returns the header size for datagrams.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_SocketStream_get_tcp_header_size_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SocketStream::flush(void)
 */
static PyObject *Dtool_SocketStream_flush_54(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.flush")) {
    return NULL;
  }
  // 1-inline bool SocketStream::flush(void)
  bool return_value = (*local_this).flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_flush_54_comment =
  "C++ Interface:\n"
  "flush(const SocketStream self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data now.  This only has meaning if\n"
  " * set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_SocketStream_flush_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * iostream *SocketStream::upcast_to_iostream(void)
 */
static PyObject *Dtool_SocketStream_upcast_to_iostream_44(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.upcast_to_iostream")) {
    return NULL;
  }
  // 1-iostream *SocketStream::upcast_to_iostream(void)
  iostream *return_value = (iostream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_upcast_to_iostream_44_comment =
  "C++ Interface:\n"
  "upcast_to_iostream(const SocketStream self)\n"
  "\n"
  "upcast from SocketStream to iostream";
#else
static const char *Dtool_SocketStream_upcast_to_iostream_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SSReader *SocketStream::upcast_to_SSReader(void)
 */
static PyObject *Dtool_SocketStream_upcast_to_SSReader_46(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.upcast_to_SSReader")) {
    return NULL;
  }
  // 1-SSReader *SocketStream::upcast_to_SSReader(void)
  SSReader *return_value = (SSReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SSReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_upcast_to_SSReader_46_comment =
  "C++ Interface:\n"
  "upcast_to_SSReader(const SocketStream self)\n"
  "\n"
  "upcast from SocketStream to SSReader";
#else
static const char *Dtool_SocketStream_upcast_to_SSReader_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SSWriter *SocketStream::upcast_to_SSWriter(void)
 */
static PyObject *Dtool_SocketStream_upcast_to_SSWriter_48(PyObject *self, PyObject *) {
  SocketStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SocketStream, (void **)&local_this, "SocketStream.upcast_to_SSWriter")) {
    return NULL;
  }
  // 1-SSWriter *SocketStream::upcast_to_SSWriter(void)
  SSWriter *return_value = (SSWriter *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SSWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SocketStream_upcast_to_SSWriter_48_comment =
  "C++ Interface:\n"
  "upcast_to_SSWriter(const SocketStream self)\n"
  "\n"
  "upcast from SocketStream to SSWriter";
#else
static const char *Dtool_SocketStream_upcast_to_SSWriter_48_comment = NULL;
#endif

static int Dtool_Init_SocketStream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_SocketStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SocketStream) {
    printf("SocketStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SocketStream *local_this = (SocketStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SocketStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_SSReader) {
    return (SSReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_SSWriter) {
    return (SSWriter *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_iostream) {
    return (iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *)(iostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SocketStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SocketStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_SSReader) {
    SSReader* other_this = (SSReader*)from_this;
    return (SocketStream*)other_this;
  }
  if (from_type == Dtool_Ptr_SSWriter) {
    SSWriter* other_this = (SSWriter*)from_this;
    return (SocketStream*)other_this;
  }
  if (from_type == Dtool_Ptr_iostream) {
    iostream* other_this = (iostream*)from_this;
    return (SocketStream*)other_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (SocketStream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (SocketStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class URLSpec
 */
/**
 * Python function wrapper for:
 * inline void URLSpec::operator =(std::string const &url)
 */
static PyObject *Dtool_URLSpec_operator_58(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.assign")) {
    return NULL;
  }
  // 1-inline void URLSpec::operator =(std::string const &url)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).operator =(std::string(param1_str, param1_len));
    URLSpec *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const URLSpec self, str url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_operator_58_comment =
  "C++ Interface:\n"
  "assign(const URLSpec self, str url)\n";
#else
static const char *Dtool_URLSpec_operator_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int URLSpec::compare_to(URLSpec const &other) const
 */
static PyObject *Dtool_URLSpec_compare_to_62(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-int URLSpec::compare_to(URLSpec const &other) const
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "URLSpec.compare_to", "URLSpec");
  }
  int return_value = (*(const URLSpec*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(URLSpec self, const URLSpec other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_compare_to_62_comment =
  "C++ Interface:\n"
  "compare_to(URLSpec self, const URLSpec other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this URLSpec sorts before the other one,\n"
  " * greater than zero if it sorts after, or zero if they are equivalent.\n"
  " */";
#else
static const char *Dtool_URLSpec_compare_to_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t URLSpec::get_hash(void) const
 */
static PyObject *Dtool_URLSpec_get_hash_63(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t URLSpec::get_hash(void) const
  std::size_t return_value = (*(const URLSpec*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_hash_63_comment =
  "C++ Interface:\n"
  "get_hash(URLSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_URLSpec_get_hash_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_scheme(void) const
 */
static PyObject *Dtool_URLSpec_has_scheme_64(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_scheme(void) const
  bool return_value = (*(const URLSpec*)local_this).has_scheme();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_scheme_64_comment =
  "C++ Interface:\n"
  "has_scheme(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL specifies a scheme (e.g.  \"http:\"), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_scheme_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_authority(void) const
 */
static PyObject *Dtool_URLSpec_has_authority_65(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_authority(void) const
  bool return_value = (*(const URLSpec*)local_this).has_authority();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_authority_65_comment =
  "C++ Interface:\n"
  "has_authority(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL specifies an authority (this includes username,\n"
  " * server, and/or port), false otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_authority_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_username(void) const
 */
static PyObject *Dtool_URLSpec_has_username_66(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_username(void) const
  bool return_value = (*(const URLSpec*)local_this).has_username();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_username_66_comment =
  "C++ Interface:\n"
  "has_username(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL specifies a username (and/or password), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_username_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_server(void) const
 */
static PyObject *Dtool_URLSpec_has_server_67(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_server(void) const
  bool return_value = (*(const URLSpec*)local_this).has_server();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_server_67_comment =
  "C++ Interface:\n"
  "has_server(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL specifies a server name, false otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_server_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_port(void) const
 */
static PyObject *Dtool_URLSpec_has_port_68(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_port(void) const
  bool return_value = (*(const URLSpec*)local_this).has_port();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_port_68_comment =
  "C++ Interface:\n"
  "has_port(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL specifies a port number, false otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_port_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_path(void) const
 */
static PyObject *Dtool_URLSpec_has_path_69(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_path(void) const
  bool return_value = (*(const URLSpec*)local_this).has_path();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_path_69_comment =
  "C++ Interface:\n"
  "has_path(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL includes a path specification (that is, the\n"
  " * particular filename on the server to retrieve), false otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_path_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::has_query(void) const
 */
static PyObject *Dtool_URLSpec_has_query_70(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::has_query(void) const
  bool return_value = (*(const URLSpec*)local_this).has_query();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_has_query_70_comment =
  "C++ Interface:\n"
  "has_query(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL includes a query specification, false otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_has_query_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string URLSpec::get_scheme(void) const
 */
static PyObject *Dtool_URLSpec_get_scheme_71(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string URLSpec::get_scheme(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_scheme();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_scheme_71_comment =
  "C++ Interface:\n"
  "get_scheme(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the scheme specified by the URL, or empty string if no scheme is\n"
  " * specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_scheme_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string URLSpec::get_authority(void) const
 */
static PyObject *Dtool_URLSpec_get_authority_72(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string URLSpec::get_authority(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_authority();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_authority_72_comment =
  "C++ Interface:\n"
  "get_authority(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the authority specified by the URL (this includes username, server,\n"
  " * and/or port), or empty string if no authority is specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_authority_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string URLSpec::get_username(void) const
 */
static PyObject *Dtool_URLSpec_get_username_73(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string URLSpec::get_username(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_username();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_username_73_comment =
  "C++ Interface:\n"
  "get_username(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the username specified by the URL, if any.  This might also include\n"
  " * a password, e.g.  \"username:password\", although putting a password on the\n"
  " * URL is probably a bad idea.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_username_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string URLSpec::get_server(void) const
 */
static PyObject *Dtool_URLSpec_get_server_74(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string URLSpec::get_server(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_server();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_server_74_comment =
  "C++ Interface:\n"
  "get_server(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the server name specified by the URL, if any.  In case of an IPv6\n"
  " * address, does not include the enclosing brackets.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_server_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string URLSpec::get_port_str(void) const
 */
static PyObject *Dtool_URLSpec_get_port_str_75(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string URLSpec::get_port_str(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_port_str();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_port_str_75_comment =
  "C++ Interface:\n"
  "get_port_str(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the port specified by the URL as a string, or the empty string if\n"
  " * no port is specified.  Compare this with get_port(), which returns a\n"
  " * default port number if no port is specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_port_str_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * uint16_t URLSpec::get_port(void) const
 */
static PyObject *Dtool_URLSpec_get_port_76(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-uint16_t URLSpec::get_port(void) const
  uint16_t return_value = (*(const URLSpec*)local_this).get_port();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_port_76_comment =
  "C++ Interface:\n"
  "get_port(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the port number specified by the URL, or the default port if not\n"
  " * specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_port_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string URLSpec::get_server_and_port(void) const
 */
static PyObject *Dtool_URLSpec_get_server_and_port_77(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string URLSpec::get_server_and_port(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_server_and_port();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_server_and_port_77_comment =
  "C++ Interface:\n"
  "get_server_and_port(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns a string consisting of the server name, followed by a colon,\n"
  " * followed by the port number.  If the port number is not explicitly given in\n"
  " * the URL, this string will include the implicit port number.\n"
  " * If the server is an IPv6 address, it will be enclosed in square brackets.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_server_and_port_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool URLSpec::is_default_port(void) const
 */
static PyObject *Dtool_URLSpec_is_default_port_78(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool URLSpec::is_default_port(void) const
  bool return_value = (*(const URLSpec*)local_this).is_default_port();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_is_default_port_78_comment =
  "C++ Interface:\n"
  "is_default_port(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the port number encoded in this URL is the default port\n"
  " * number for the scheme (or if there is no port number), or false if it is a\n"
  " * nonstandard port.\n"
  " */";
#else
static const char *Dtool_URLSpec_is_default_port_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int URLSpec::get_default_port_for_scheme(std::string const &scheme)
 */
static PyObject *Dtool_URLSpec_get_default_port_for_scheme_79(PyObject *, PyObject *arg) {
  // 1-static int URLSpec::get_default_port_for_scheme(std::string const &scheme)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    int return_value = URLSpec::get_default_port_for_scheme(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_default_port_for_scheme(str scheme)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_default_port_for_scheme_79_comment =
  "C++ Interface:\n"
  "get_default_port_for_scheme(str scheme)\n"
  "\n"
  "/**\n"
  " * Returns the default port number for the indicated scheme, or 0 if there is\n"
  " * no known default.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_default_port_for_scheme_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string URLSpec::get_path(void) const
 */
static PyObject *Dtool_URLSpec_get_path_80(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string URLSpec::get_path(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_path();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_path_80_comment =
  "C++ Interface:\n"
  "get_path(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the path specified by the URL, or \"/\" if no path is specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_path_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string URLSpec::get_query(void) const
 */
static PyObject *Dtool_URLSpec_get_query_81(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string URLSpec::get_query(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_query();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_query_81_comment =
  "C++ Interface:\n"
  "get_query(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the query specified by the URL, or empty string if no query is\n"
  " * specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_query_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string URLSpec::get_path_and_query(void) const
 */
static PyObject *Dtool_URLSpec_get_path_and_query_82(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string URLSpec::get_path_and_query(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_path_and_query();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_path_and_query_82_comment =
  "C++ Interface:\n"
  "get_path_and_query(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the path (or \"/\" if no path is specified), followed by the query if\n"
  " * it is specified.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_path_and_query_82_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::is_ssl(void) const
 */
static PyObject *Dtool_URLSpec_is_ssl_83(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::is_ssl(void) const
  bool return_value = (*(const URLSpec*)local_this).is_ssl();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_is_ssl_83_comment =
  "C++ Interface:\n"
  "is_ssl(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if the URL's scheme specifies an SSL-secured protocol such as\n"
  " * https, or false otherwise.\n"
  " */";
#else
static const char *Dtool_URLSpec_is_ssl_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &URLSpec::get_url(void) const
 */
static PyObject *Dtool_URLSpec_get_url_84(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &URLSpec::get_url(void) const
  std::string const &return_value = (*(const URLSpec*)local_this).get_url();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_get_url_84_comment =
  "C++ Interface:\n"
  "get_url(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the complete URL specification.\n"
  " */";
#else
static const char *Dtool_URLSpec_get_url_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_scheme(std::string const &scheme)
 */
static PyObject *Dtool_URLSpec_set_scheme_85(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_scheme")) {
    return NULL;
  }
  // 1-void URLSpec::set_scheme(std::string const &scheme)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_scheme(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scheme(const URLSpec self, str scheme)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_scheme_85_comment =
  "C++ Interface:\n"
  "set_scheme(const URLSpec self, str scheme)\n"
  "\n"
  "/**\n"
  " * Replaces the scheme part of the URL specification.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_scheme_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_authority(std::string const &authority)
 */
static PyObject *Dtool_URLSpec_set_authority_86(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_authority")) {
    return NULL;
  }
  // 1-void URLSpec::set_authority(std::string const &authority)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_authority(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_authority(const URLSpec self, str authority)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_authority_86_comment =
  "C++ Interface:\n"
  "set_authority(const URLSpec self, str authority)\n"
  "\n"
  "/**\n"
  " * Replaces the authority part of the URL specification.  This includes the\n"
  " * username, server, and port.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_authority_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_username(std::string const &username)
 */
static PyObject *Dtool_URLSpec_set_username_87(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_username")) {
    return NULL;
  }
  // 1-void URLSpec::set_username(std::string const &username)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_username(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_username(const URLSpec self, str username)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_username_87_comment =
  "C++ Interface:\n"
  "set_username(const URLSpec self, str username)\n"
  "\n"
  "/**\n"
  " * Replaces the username part of the URL specification.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_username_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_server(std::string const &server)
 */
static PyObject *Dtool_URLSpec_set_server_88(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_server")) {
    return NULL;
  }
  // 1-void URLSpec::set_server(std::string const &server)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_server(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server(const URLSpec self, str server)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_server_88_comment =
  "C++ Interface:\n"
  "set_server(const URLSpec self, str server)\n"
  "\n"
  "/**\n"
  " * Replaces the server part of the URL specification.\n"
  " * Unlike set_server_and_port, this method does not require IPv6 addresses to\n"
  " * be enclosed in square brackets.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_server_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_port(std::string const &port)
 * void URLSpec::set_port(uint16_t port)
 */
static PyObject *Dtool_URLSpec_set_port_89(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_port")) {
    return NULL;
  }
  {
    // -2 void URLSpec::set_port(std::string const &port)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (*local_this).set_port(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 void URLSpec::set_port(uint16_t port)
    if (PyLongOrInt_Check(arg)) {
      long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned short integer",
                            param1);
      }
#endif
      (*local_this).set_port((uint16_t)param1);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void URLSpec::set_port(std::string const &port)
  // No coercion possible: void URLSpec::set_port(uint16_t port)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_port(const URLSpec self, str port)\n"
      "set_port(const URLSpec self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_port_89_comment =
  "C++ Interface:\n"
  "set_port(const URLSpec self, str port)\n"
  "set_port(const URLSpec self, int port)\n"
  "\n"
  "/**\n"
  " * Replaces the port part of the URL specification.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the port part of the URL specification, given a numeric port\n"
  " * number.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_port_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_server_and_port(std::string const &server_and_port)
 */
static PyObject *Dtool_URLSpec_set_server_and_port_90(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_server_and_port")) {
    return NULL;
  }
  // 1-void URLSpec::set_server_and_port(std::string const &server_and_port)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_server_and_port(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_and_port(const URLSpec self, str server_and_port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_server_and_port_90_comment =
  "C++ Interface:\n"
  "set_server_and_port(const URLSpec self, str server_and_port)\n"
  "\n"
  "/**\n"
  " * Replaces the server and port parts of the URL specification simultaneously.\n"
  " * The input string should be of the form \"server:port\", or just \"server\" to\n"
  " * make the port number implicit.\n"
  " * Any IPv6 address must be enclosed in square brackets.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_server_and_port_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_path(std::string const &path)
 */
static PyObject *Dtool_URLSpec_set_path_91(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_path")) {
    return NULL;
  }
  // 1-void URLSpec::set_path(std::string const &path)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_path(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_path(const URLSpec self, str path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_path_91_comment =
  "C++ Interface:\n"
  "set_path(const URLSpec self, str path)\n"
  "\n"
  "/**\n"
  " * Replaces the path part of the URL specification.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_path_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_query(std::string const &query)
 */
static PyObject *Dtool_URLSpec_set_query_92(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_query")) {
    return NULL;
  }
  // 1-void URLSpec::set_query(std::string const &query)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_query(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_query(const URLSpec self, str query)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_query_92_comment =
  "C++ Interface:\n"
  "set_query(const URLSpec self, str query)\n"
  "\n"
  "/**\n"
  " * Replaces the query part of the URL specification.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_query_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::set_url(std::string const &url, bool server_name_expected = false)
 */
static PyObject *Dtool_URLSpec_set_url_93(PyObject *self, PyObject *args, PyObject *kwds) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.set_url")) {
    return NULL;
  }
  // 1-void URLSpec::set_url(std::string const &url, bool server_name_expected = false)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"url", "server_name_expected", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:set_url", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    (*local_this).set_url(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_url(const URLSpec self, str url, bool server_name_expected)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_set_url_93_comment =
  "C++ Interface:\n"
  "set_url(const URLSpec self, str url, bool server_name_expected)\n"
  "\n"
  "/**\n"
  " * Completely replaces the URL with the indicated string.  If\n"
  " * server_name_expected is true, it is a hint that an undecorated URL is\n"
  " * probably a server name, not a local filename.\n"
  " */";
#else
static const char *Dtool_URLSpec_set_url_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline char const *URLSpec::c_str(void) const
 */
static PyObject *Dtool_URLSpec_c_str_95(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char const *URLSpec::c_str(void) const
  char const *return_value = (*(const URLSpec*)local_this).c_str();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_c_str_95_comment =
  "C++ Interface:\n"
  "c_str(URLSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_URLSpec_c_str_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool URLSpec::empty(void) const
 */
static PyObject *Dtool_URLSpec_empty_96(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool URLSpec::empty(void) const
  bool return_value = (*(const URLSpec*)local_this).empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_empty_96_comment =
  "C++ Interface:\n"
  "empty(URLSpec self)\n"
  "\n"
  "/**\n"
  " * Returns false if the URLSpec is valid (not empty), or true if it is an\n"
  " * empty string.\n"
  " */";
#else
static const char *Dtool_URLSpec_empty_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t URLSpec::length(void) const
 */
static PyObject *Dtool_URLSpec_length_98(PyObject *self, PyObject *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t URLSpec::length(void) const
  std::size_t return_value = (*(const URLSpec*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_length_98_comment =
  "C++ Interface:\n"
  "length(URLSpec self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_URLSpec_length_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool URLSpec::input(istream &in)
 */
static PyObject *Dtool_URLSpec_input_101(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.input")) {
    return NULL;
  }
  // 1-bool URLSpec::input(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "URLSpec.input", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).input(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input(const URLSpec self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_input_101_comment =
  "C++ Interface:\n"
  "input(const URLSpec self, istream in)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_URLSpec_input_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void URLSpec::output(ostream &out) const
 */
static PyObject *Dtool_URLSpec_output_102(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-void URLSpec::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "URLSpec.output", false, true);
  if (arg_this != NULL) {
    (*(const URLSpec*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(URLSpec self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_output_102_comment =
  "C++ Interface:\n"
  "output(URLSpec self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_URLSpec_output_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string URLSpec::quote(std::string const &source, std::string const &safe = "/")
 */
static PyObject *Dtool_URLSpec_quote_103(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static std::string URLSpec::quote(std::string const &source, std::string const &safe = "/")
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  const char *param1_str = "/";
  Py_ssize_t param1_len = 1;
  static const char *keyword_list[] = {"source", "safe", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:quote", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    std::string return_value = URLSpec::quote(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quote(str source, str safe)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_quote_103_comment =
  "C++ Interface:\n"
  "quote(str source, str safe)\n"
  "\n"
  "/**\n"
  " * Returns the source string with all \"unsafe\" characters quoted, making a\n"
  " * string suitable for placing in a URL.  Letters, digits, and the underscore,\n"
  " * comma, period, and hyphen characters, as well as any included in the safe\n"
  " * string, are left alone; all others are converted to hex representation.\n"
  " */";
#else
static const char *Dtool_URLSpec_quote_103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string URLSpec::quote_plus(std::string const &source, std::string const &safe = "/")
 */
static PyObject *Dtool_URLSpec_quote_plus_104(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static std::string URLSpec::quote_plus(std::string const &source, std::string const &safe = "/")
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  const char *param1_str = "/";
  Py_ssize_t param1_len = 1;
  static const char *keyword_list[] = {"source", "safe", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:quote_plus", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    std::string return_value = URLSpec::quote_plus(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quote_plus(str source, str safe)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_quote_plus_104_comment =
  "C++ Interface:\n"
  "quote_plus(str source, str safe)\n"
  "\n"
  "/**\n"
  " * Behaves like quote() with the additional behavior of replacing spaces with\n"
  " * plus signs.\n"
  " */";
#else
static const char *Dtool_URLSpec_quote_plus_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string URLSpec::unquote(std::string const &source)
 */
static PyObject *Dtool_URLSpec_unquote_105(PyObject *, PyObject *arg) {
  // 1-static std::string URLSpec::unquote(std::string const &source)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = URLSpec::unquote(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unquote(str source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_unquote_105_comment =
  "C++ Interface:\n"
  "unquote(str source)\n"
  "\n"
  "/**\n"
  " * Reverses the operation of quote(): converts escaped characters of the form\n"
  " * \"%xx\" to their ascii equivalent.\n"
  " */";
#else
static const char *Dtool_URLSpec_unquote_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string URLSpec::unquote_plus(std::string const &source)
 */
static PyObject *Dtool_URLSpec_unquote_plus_106(PyObject *, PyObject *arg) {
  // 1-static std::string URLSpec::unquote_plus(std::string const &source)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = URLSpec::unquote_plus(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unquote_plus(str source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_URLSpec_unquote_plus_106_comment =
  "C++ Interface:\n"
  "unquote_plus(str source)\n"
  "\n"
  "/**\n"
  " * Reverses the operation of quote_plus(): converts escaped characters of the\n"
  " * form \"%xx\" to their ascii equivalent, and also converts plus signs to\n"
  " * spaces.\n"
  " */";
#else
static const char *Dtool_URLSpec_unquote_plus_106_comment = NULL;
#endif

static PyObject *Dtool_URLSpec_scheme_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-std::string URLSpec::get_scheme(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_scheme();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_scheme_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.scheme")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete scheme attribute");
    return -1;
  }
  // 1-void URLSpec::set_scheme(std::string const &scheme)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_scheme(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scheme(const URLSpec self, str scheme)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_authority_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string URLSpec::get_authority(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_authority();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_authority_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.authority")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete authority attribute");
    return -1;
  }
  // 1-void URLSpec::set_authority(std::string const &authority)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_authority(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_authority(const URLSpec self, str authority)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_username_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string URLSpec::get_username(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_username();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_username_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.username")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete username attribute");
    return -1;
  }
  // 1-void URLSpec::set_username(std::string const &username)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_username(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_username(const URLSpec self, str username)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_server_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string URLSpec::get_server(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_server();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_server_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.server")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete server attribute");
    return -1;
  }
  // 1-void URLSpec::set_server(std::string const &server)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_server(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_server(const URLSpec self, str server)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_port_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-uint16_t URLSpec::get_port(void) const
  uint16_t return_value = (*(const URLSpec*)local_this).get_port();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_port_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.port")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete port attribute");
    return -1;
  }
  {
    // -2 void URLSpec::set_port(std::string const &port)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (*local_this).set_port(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    PyErr_Clear();
  }

  {
    // -2 void URLSpec::set_port(uint16_t port)
    if (PyLongOrInt_Check(arg)) {
      long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param1);
        return -1;
      }
#endif
      (*local_this).set_port((uint16_t)param1);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: void URLSpec::set_port(std::string const &port)
  // No coercion possible: void URLSpec::set_port(uint16_t port)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_port(const URLSpec self, str port)\n"
      "set_port(const URLSpec self, int port)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_server_and_port_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-std::string URLSpec::get_server_and_port(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_server_and_port();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_server_and_port_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.server_and_port")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete server_and_port attribute");
    return -1;
  }
  // 1-void URLSpec::set_server_and_port(std::string const &server_and_port)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_server_and_port(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_server_and_port(const URLSpec self, str server_and_port)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_path_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-std::string URLSpec::get_path(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_path();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_path_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.path")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete path attribute");
    return -1;
  }
  // 1-void URLSpec::set_path(std::string const &path)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_path(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_path(const URLSpec self, str path)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_query_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string URLSpec::get_query(void) const
  std::string return_value = (*(const URLSpec*)local_this).get_query();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_URLSpec_query_Setter(PyObject *self, PyObject *arg, void *) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_URLSpec, (void **)&local_this, "URLSpec.query")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete query attribute");
    return -1;
  }
  // 1-void URLSpec::set_query(std::string const &query)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_query(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_query(const URLSpec self, str query)\n");
  }
  return -1;
}

static PyObject *Dtool_URLSpec_ssl_Getter(PyObject *self, void *) {
  const URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool URLSpec::is_ssl(void) const
  bool return_value = (*(const URLSpec*)local_this).is_ssl();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * URLSpec::URLSpec(void)
 * inline URLSpec::URLSpec(URLSpec const &) = default
 * URLSpec::URLSpec(URLSpec const &url, Filename const &path)
 * inline URLSpec::URLSpec(std::string const &url, bool server_name_expected = false)
 */
static int Dtool_Init_URLSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-URLSpec::URLSpec(void)
      URLSpec *return_value = new URLSpec();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_URLSpec, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"url", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:URLSpec", (char **)keyword_list, &param0_str, &param0_len)) {
          URLSpec *return_value = new URLSpec(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_URLSpec, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
      {
        // -2 inline URLSpec::URLSpec(URLSpec const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:URLSpec", (char **)keyword_list, &param0)) {
          URLSpec const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_URLSpec(param0, param0_this, param0_manage)) {
            URLSpec *return_value = new URLSpec(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_URLSpec, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      {
        // -2 URLSpec::URLSpec(URLSpec const &url, Filename const &path)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"url", "path", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:URLSpec", (char **)keyword_list, &param0, &param1)) {
          URLSpec const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_URLSpec, (void **)&param0_this);
          Filename const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            URLSpec *return_value = new URLSpec(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_URLSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        static const char *keyword_list[] = {"url", "server_name_expected", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:URLSpec", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
          URLSpec *return_value = new URLSpec(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_URLSpec, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 URLSpec::URLSpec(URLSpec const &url, Filename const &path)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"url", "path", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:URLSpec", (char **)keyword_list, &param0, &param1)) {
          URLSpec const *param0_this;
          bool param0_manage = false;
          Filename param1_local;
          Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if (Dtool_ConstCoerce_URLSpec(param0, param0_this, param0_manage) && (param1_this != NULL)) {
            URLSpec *return_value = new URLSpec(*param0_this, *param1_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_URLSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "URLSpec() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "URLSpec()\n"
      "URLSpec(str url)\n"
      "URLSpec(const URLSpec url, const Filename path)\n"
      "URLSpec(str url, bool server_name_expected)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_URLSpec(PyObject *args, URLSpec const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_URLSpec, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      URLSpec *return_value = new URLSpec(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 URLSpec::URLSpec(URLSpec const &url, Filename const &path)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "URLSpec", 2, 2, &param0, &param1)) {
          URLSpec const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_URLSpec, (void **)&param0_this);
          Filename const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            URLSpec *return_value = new URLSpec(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:URLSpec", &param0_str, &param0_len, &param1)) {
          URLSpec *return_value = new URLSpec(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_URLSpec(PyObject *args, URLSpec *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_URLSpec, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      URLSpec *return_value = new URLSpec(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 URLSpec::URLSpec(URLSpec const &url, Filename const &path)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "URLSpec", 2, 2, &param0, &param1)) {
          URLSpec const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_URLSpec, (void **)&param0_this);
          Filename const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
          if (param0_this != NULL && param1_this != NULL) {
            URLSpec *return_value = new URLSpec(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline URLSpec::URLSpec(std::string const &url, bool server_name_expected)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:URLSpec", &param0_str, &param0_len, &param1)) {
          URLSpec *return_value = new URLSpec(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_URLSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_URLSpec) {
    printf("URLSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  URLSpec *local_this = (URLSpec *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_URLSpec) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_URLSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_URLSpec) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HTTPEnum
 */
/**
 * Python function wrapper for:
 * inline HTTPEnum::HTTPEnum(void) = default
 * inline HTTPEnum::HTTPEnum(HTTPEnum const &) = default
 */
static int Dtool_Init_HTTPEnum(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline HTTPEnum::HTTPEnum(void) = default
      HTTPEnum *return_value = new HTTPEnum();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEnum, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline HTTPEnum::HTTPEnum(HTTPEnum const &) = default
      HTTPEnum const *arg_this = (HTTPEnum *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPEnum, 0, "HTTPEnum.HTTPEnum", true, true);
      if (arg_this != NULL) {
        HTTPEnum *return_value = new HTTPEnum(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEnum, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HTTPEnum() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HTTPEnum()\n"
      "HTTPEnum(const HTTPEnum param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_HTTPEnum(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HTTPEnum) {
    printf("HTTPEnum ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HTTPEnum *local_this = (HTTPEnum *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HTTPEnum) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HTTPEnum(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HTTPEnum) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HTTPDate
 */
/**
 * Python function wrapper for:
 * inline void HTTPDate::operator =(HTTPDate const &copy)
 */
static PyObject *Dtool_HTTPDate_operator_129(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPDate, (void **)&local_this, "HTTPDate.assign")) {
    return NULL;
  }
  // 1-inline void HTTPDate::operator =(HTTPDate const &copy)
  HTTPDate const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPDate.assign", "HTTPDate");
  }
  (*local_this).operator =(*arg_this);
  HTTPDate *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const HTTPDate self, const HTTPDate copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_operator_129_comment =
  "C++ Interface:\n"
  "assign(const HTTPDate self, const HTTPDate copy)\n";
#else
static const char *Dtool_HTTPDate_operator_129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline HTTPDate HTTPDate::now(void)
 */
static PyObject *Dtool_HTTPDate_now_130(PyObject *, PyObject *) {
  // 1-static inline HTTPDate HTTPDate::now(void)
  HTTPDate *return_value = new HTTPDate(HTTPDate::now());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_now_130_comment =
  "C++ Interface:\n"
  "now()\n"
  "\n"
  "/**\n"
  " * Returns an HTTPDate that represents the current time and date.\n"
  " */";
#else
static const char *Dtool_HTTPDate_now_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPDate::is_valid(void) const
 */
static PyObject *Dtool_HTTPDate_is_valid_131(PyObject *self, PyObject *) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPDate::is_valid(void) const
  bool return_value = (*(const HTTPDate*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_is_valid_131_comment =
  "C++ Interface:\n"
  "is_valid(HTTPDate self)\n"
  "\n"
  "/**\n"
  " * Returns true if the date is meaningful, or false if it is -1 (which\n"
  " * generally indicates the source string could not be parsed.)\n"
  " */";
#else
static const char *Dtool_HTTPDate_is_valid_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPDate::get_string(void) const
 */
static PyObject *Dtool_HTTPDate_get_string_132(PyObject *self, PyObject *) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPDate::get_string(void) const
  std::string return_value = (*(const HTTPDate*)local_this).get_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_get_string_132_comment =
  "C++ Interface:\n"
  "get_string(HTTPDate self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPDate_get_string_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline time_t HTTPDate::get_time(void) const
 */
static PyObject *Dtool_HTTPDate_get_time_133(PyObject *self, PyObject *) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline time_t HTTPDate::get_time(void) const
  time_t return_value = (*(const HTTPDate*)local_this).get_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_get_time_133_comment =
  "C++ Interface:\n"
  "get_time(HTTPDate self)\n"
  "\n"
  "/**\n"
  " * Returns the date as a C time_t value.\n"
  " */";
#else
static const char *Dtool_HTTPDate_get_time_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int HTTPDate::compare_to(HTTPDate const &other) const
 */
static PyObject *Dtool_HTTPDate_compare_to_138(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int HTTPDate::compare_to(HTTPDate const &other) const
  HTTPDate const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPDate.compare_to", "HTTPDate");
  }
  int return_value = (*(const HTTPDate*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(HTTPDate self, const HTTPDate other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_compare_to_138_comment =
  "C++ Interface:\n"
  "compare_to(HTTPDate self, const HTTPDate other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this HTTPDate sorts before the other\n"
  " * one, greater than zero if it sorts after, or zero if they are equivalent.\n"
  " */";
#else
static const char *Dtool_HTTPDate_compare_to_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPDate::input(istream &in)
 */
static PyObject *Dtool_HTTPDate_input_143(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPDate, (void **)&local_this, "HTTPDate.input")) {
    return NULL;
  }
  // 1-bool HTTPDate::input(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "HTTPDate.input", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).input(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input(const HTTPDate self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_input_143_comment =
  "C++ Interface:\n"
  "input(const HTTPDate self, istream in)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPDate_input_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPDate::output(ostream &out) const
 */
static PyObject *Dtool_HTTPDate_output_144(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HTTPDate::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HTTPDate.output", false, true);
  if (arg_this != NULL) {
    (*(const HTTPDate*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(HTTPDate self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPDate_output_144_comment =
  "C++ Interface:\n"
  "output(HTTPDate self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPDate_output_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPDate::HTTPDate(void)
 * inline HTTPDate::HTTPDate(HTTPDate const &copy)
 * HTTPDate::HTTPDate(std::string const &format)
 * inline HTTPDate::HTTPDate(time_t time)
 */
static int Dtool_Init_HTTPDate(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline HTTPDate::HTTPDate(void)
      HTTPDate *return_value = new HTTPDate();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPDate, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline HTTPDate::HTTPDate(HTTPDate const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:HTTPDate", (char **)keyword_list, &param0)) {
          HTTPDate const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_HTTPDate, (void **)&param0_this);
          if (param0_this != NULL) {
            HTTPDate *return_value = new HTTPDate(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPDate, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 HTTPDate::HTTPDate(std::string const &format)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"format", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:HTTPDate", (char **)keyword_list, &param0_str, &param0_len)) {
          HTTPDate *return_value = new HTTPDate(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPDate, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline HTTPDate::HTTPDate(time_t time)
        long param0;
        static const char *keyword_list[] = {"time", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:HTTPDate", (char **)keyword_list, &param0)) {
          HTTPDate *return_value = new HTTPDate((time_t)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPDate, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline HTTPDate::HTTPDate(HTTPDate const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:HTTPDate", (char **)keyword_list, &param0)) {
          HTTPDate const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_HTTPDate(param0, param0_this, param0_manage)) {
            HTTPDate *return_value = new HTTPDate(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPDate, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: HTTPDate::HTTPDate(std::string const &format)
      // No coercion possible: inline HTTPDate::HTTPDate(time_t time)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HTTPDate() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HTTPDate()\n"
      "HTTPDate(const HTTPDate copy)\n"
      "HTTPDate(str format)\n"
      "HTTPDate(int time)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HTTPDate(PyObject *args, HTTPDate const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HTTPDate, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 HTTPDate::HTTPDate(std::string const &format)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        HTTPDate *return_value = new HTTPDate(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline HTTPDate::HTTPDate(time_t time)
      if (PyLongOrInt_Check(arg)) {
        HTTPDate *return_value = new HTTPDate(PyLongOrInt_AS_LONG(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  }
  return false;
}

bool Dtool_Coerce_HTTPDate(PyObject *args, HTTPDate *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HTTPDate, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 HTTPDate::HTTPDate(std::string const &format)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        HTTPDate *return_value = new HTTPDate(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline HTTPDate::HTTPDate(time_t time)
      if (PyLongOrInt_Check(arg)) {
        HTTPDate *return_value = new HTTPDate(PyLongOrInt_AS_LONG(arg));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_HTTPDate(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HTTPDate) {
    printf("HTTPDate ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HTTPDate *local_this = (HTTPDate *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HTTPDate) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HTTPDate(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HTTPDate) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HTTPCookie
 */
/**
 * Python function wrapper for:
 * inline void HTTPCookie::set_name(std::string const &name)
 */
static PyObject *Dtool_HTTPCookie_set_name_149(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.set_name")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const HTTPCookie self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_set_name_149_comment =
  "C++ Interface:\n"
  "set_name(const HTTPCookie self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_set_name_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPCookie::get_name(void) const
 */
static PyObject *Dtool_HTTPCookie_get_name_150(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPCookie::get_name(void) const
  std::string const &return_value = (*(const HTTPCookie*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_get_name_150_comment =
  "C++ Interface:\n"
  "get_name(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the cookie.  This is the key value specified by the\n"
  " * server.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_get_name_150_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPCookie::set_value(std::string const &value)
 */
static PyObject *Dtool_HTTPCookie_set_value_151(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.set_value")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::set_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const HTTPCookie self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_set_value_151_comment =
  "C++ Interface:\n"
  "set_value(const HTTPCookie self, str value)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_set_value_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPCookie::get_value(void) const
 */
static PyObject *Dtool_HTTPCookie_get_value_152(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPCookie::get_value(void) const
  std::string const &return_value = (*(const HTTPCookie*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_get_value_152_comment =
  "C++ Interface:\n"
  "get_value(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Returns the value of the cookie.  This is the arbitrary string associated\n"
  " * with the cookie's name, as specified by the server.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_get_value_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPCookie::set_domain(std::string const &domain)
 */
static PyObject *Dtool_HTTPCookie_set_domain_153(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.set_domain")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::set_domain(std::string const &domain)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_domain(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_domain(const HTTPCookie self, str domain)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_set_domain_153_comment =
  "C++ Interface:\n"
  "set_domain(const HTTPCookie self, str domain)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_set_domain_153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPCookie::get_domain(void) const
 */
static PyObject *Dtool_HTTPCookie_get_domain_154(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPCookie::get_domain(void) const
  std::string const &return_value = (*(const HTTPCookie*)local_this).get_domain();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_get_domain_154_comment =
  "C++ Interface:\n"
  "get_domain(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_get_domain_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPCookie::set_path(std::string const &path)
 */
static PyObject *Dtool_HTTPCookie_set_path_155(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.set_path")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::set_path(std::string const &path)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_path(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_path(const HTTPCookie self, str path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_set_path_155_comment =
  "C++ Interface:\n"
  "set_path(const HTTPCookie self, str path)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_set_path_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPCookie::get_path(void) const
 */
static PyObject *Dtool_HTTPCookie_get_path_156(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPCookie::get_path(void) const
  std::string const &return_value = (*(const HTTPCookie*)local_this).get_path();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_get_path_156_comment =
  "C++ Interface:\n"
  "get_path(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Returns the prefix of the URL paths on the server for which this cookie\n"
  " * will be sent.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_get_path_156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPCookie::set_expires(HTTPDate const &expires)
 */
static PyObject *Dtool_HTTPCookie_set_expires_157(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.set_expires")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::set_expires(HTTPDate const &expires)
  HTTPDate const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPCookie.set_expires", "HTTPDate");
  }
  (*local_this).set_expires(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_expires(const HTTPCookie self, const HTTPDate expires)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_set_expires_157_comment =
  "C++ Interface:\n"
  "set_expires(const HTTPCookie self, const HTTPDate expires)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_set_expires_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPCookie::clear_expires(void)
 */
static PyObject *Dtool_HTTPCookie_clear_expires_158(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.clear_expires")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::clear_expires(void)
  (*local_this).clear_expires();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_clear_expires_158_comment =
  "C++ Interface:\n"
  "clear_expires(const HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Removes the expiration date on the cookie.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_clear_expires_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPCookie::has_expires(void) const
 */
static PyObject *Dtool_HTTPCookie_has_expires_159(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPCookie::has_expires(void) const
  bool return_value = (*(const HTTPCookie*)local_this).has_expires();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_has_expires_159_comment =
  "C++ Interface:\n"
  "has_expires(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Returns true if the cookie has an expiration date, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_has_expires_159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPDate HTTPCookie::get_expires(void) const
 */
static PyObject *Dtool_HTTPCookie_get_expires_160(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPDate HTTPCookie::get_expires(void) const
  HTTPDate *return_value = new HTTPDate((*(const HTTPCookie*)local_this).get_expires());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_get_expires_160_comment =
  "C++ Interface:\n"
  "get_expires(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Returns the expiration date of the cookie if it is set, or an invalid date\n"
  " * if it is not.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_get_expires_160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPCookie::set_secure(bool flag)
 */
static PyObject *Dtool_HTTPCookie_set_secure_161(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.set_secure")) {
    return NULL;
  }
  // 1-inline void HTTPCookie::set_secure(bool flag)
  (*local_this).set_secure((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_secure(const HTTPCookie self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_set_secure_161_comment =
  "C++ Interface:\n"
  "set_secure(const HTTPCookie self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_set_secure_161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPCookie::get_secure(void) const
 */
static PyObject *Dtool_HTTPCookie_get_secure_162(PyObject *self, PyObject *) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPCookie::get_secure(void) const
  bool return_value = (*(const HTTPCookie*)local_this).get_secure();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_get_secure_162_comment =
  "C++ Interface:\n"
  "get_secure(HTTPCookie self)\n"
  "\n"
  "/**\n"
  " * Returns true if the server has indicated this is a \"secure\" cookie which\n"
  " * should only be sent over an HTTPS channel.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_get_secure_162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPCookie::update_from(HTTPCookie const &other)
 */
static PyObject *Dtool_HTTPCookie_update_from_164(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.update_from")) {
    return NULL;
  }
  // 1-void HTTPCookie::update_from(HTTPCookie const &other)
  HTTPCookie const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPCookie.update_from", "HTTPCookie");
  }
  (*local_this).update_from(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_from(const HTTPCookie self, const HTTPCookie other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_update_from_164_comment =
  "C++ Interface:\n"
  "update_from(const HTTPCookie self, const HTTPCookie other)\n"
  "\n"
  "/**\n"
  " * Assuming the operator < method, above, has already evaluated these two\n"
  " * cookies as equal, then assign the remaining values (value, expiration date,\n"
  " * secure flag) from the indicated cookie.  This is guaranteed not to change\n"
  " * the ordering of the cookie in a set, and so can be used to update an\n"
  " * existing cookie within a set with new values.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_update_from_164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPCookie::parse_set_cookie(std::string const &format, URLSpec const &url)
 */
static PyObject *Dtool_HTTPCookie_parse_set_cookie_165(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPCookie, (void **)&local_this, "HTTPCookie.parse_set_cookie")) {
    return NULL;
  }
  // 1-bool HTTPCookie::parse_set_cookie(std::string const &format, URLSpec const &url)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"format", "url", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:parse_set_cookie", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    URLSpec const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "HTTPCookie.parse_set_cookie", "URLSpec");
    }
    bool return_value = (*local_this).parse_set_cookie(std::string(param1_str, param1_len), *param2_this);
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_set_cookie(const HTTPCookie self, str format, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_parse_set_cookie_165_comment =
  "C++ Interface:\n"
  "parse_set_cookie(const HTTPCookie self, str format, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Separates out the parameter/value pairs of the Set-Cookie header and\n"
  " * assigns the values of the cookie appropriate.  Returns true if the header\n"
  " * is parsed correctly, false if something is not understood.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_parse_set_cookie_165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPCookie::is_expired(HTTPDate const &now = HTTPDate::now()) const
 */
static PyObject *Dtool_HTTPCookie_is_expired_166(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool HTTPCookie::is_expired(HTTPDate const &now) const
      bool return_value = (*(const HTTPCookie*)local_this).is_expired();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "now");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'now' (pos 1) not found");
      }
      // 1-inline bool HTTPCookie::is_expired(HTTPDate const &now) const
      HTTPDate const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "HTTPCookie.is_expired", "HTTPDate");
      }
      bool return_value = (*(const HTTPCookie*)local_this).is_expired(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_expired() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_expired(HTTPCookie self)\n"
      "is_expired(HTTPCookie self, const HTTPDate now)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_is_expired_166_comment =
  "C++ Interface:\n"
  "is_expired(HTTPCookie self)\n"
  "is_expired(HTTPCookie self, const HTTPDate now)\n"
  "\n"
  "/**\n"
  " * Returns true if the cookie's expiration date is before the indicated date,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_is_expired_166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPCookie::matches_url(URLSpec const &url) const
 */
static PyObject *Dtool_HTTPCookie_matches_url_167(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool HTTPCookie::matches_url(URLSpec const &url) const
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPCookie.matches_url", "URLSpec");
  }
  bool return_value = (*(const HTTPCookie*)local_this).matches_url(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_url(HTTPCookie self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_matches_url_167_comment =
  "C++ Interface:\n"
  "matches_url(HTTPCookie self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Returns true if the cookie is appropriate to send with the indicated URL\n"
  " * request, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPCookie_matches_url_167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPCookie::output(ostream &out) const
 */
static PyObject *Dtool_HTTPCookie_output_168(PyObject *self, PyObject *arg) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HTTPCookie::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HTTPCookie.output", false, true);
  if (arg_this != NULL) {
    (*(const HTTPCookie*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(HTTPCookie self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPCookie_output_168_comment =
  "C++ Interface:\n"
  "output(HTTPCookie self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPCookie_output_168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPCookie::HTTPCookie(void)
 * inline HTTPCookie::HTTPCookie(HTTPCookie const &) = default
 * inline HTTPCookie::HTTPCookie(std::string const &format, URLSpec const &url)
 * inline HTTPCookie::HTTPCookie(std::string const &name, std::string const &path, std::string const &domain)
 */
static int Dtool_Init_HTTPCookie(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline HTTPCookie::HTTPCookie(void)
      HTTPCookie *return_value = new HTTPCookie();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPCookie, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline HTTPCookie::HTTPCookie(HTTPCookie const &) = default
      HTTPCookie const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "HTTPCookie.HTTPCookie", "HTTPCookie");
        return -1;
      }
      HTTPCookie *return_value = new HTTPCookie(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPCookie, true, false);
    }
    break;
  case 2:
    {
      // 1-inline HTTPCookie::HTTPCookie(std::string const &format, URLSpec const &url)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"format", "url", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:HTTPCookie", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        URLSpec const *param1_this;
        bool param1_manage = false;
        if (!Dtool_ConstCoerce_URLSpec(param1, param1_this, param1_manage)) {
          Dtool_Raise_ArgTypeError(param1, 1, "HTTPCookie.HTTPCookie", "URLSpec");
          return -1;
        }
        HTTPCookie *return_value = new HTTPCookie(std::string(param0_str, param0_len), *param1_this);
        if (param1_manage) {
          delete param1_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPCookie, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline HTTPCookie::HTTPCookie(std::string const &name, std::string const &path, std::string const &domain)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"name", "path", "domain", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:HTTPCookie", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len)) {
        HTTPCookie *return_value = new HTTPCookie(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPCookie, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HTTPCookie() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HTTPCookie()\n"
      "HTTPCookie(const HTTPCookie param0)\n"
      "HTTPCookie(str format, const URLSpec url)\n"
      "HTTPCookie(str name, str path, str domain)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HTTPCookie(PyObject *args, HTTPCookie const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HTTPCookie, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline HTTPCookie::HTTPCookie(std::string const &format, URLSpec const &url)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:HTTPCookie", &param0_str, &param0_len, &param1)) {
          URLSpec const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_URLSpec, (void **)&param1_this);
          if (param1_this != NULL) {
            HTTPCookie *return_value = new HTTPCookie(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline HTTPCookie::HTTPCookie(std::string const &name, std::string const &path, std::string const &domain)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        if (PyArg_ParseTuple(args, "s#s#s#:HTTPCookie", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len)) {
          HTTPCookie *return_value = new HTTPCookie(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_HTTPCookie(PyObject *args, HTTPCookie *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HTTPCookie, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline HTTPCookie::HTTPCookie(std::string const &format, URLSpec const &url)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:HTTPCookie", &param0_str, &param0_len, &param1)) {
          URLSpec const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_URLSpec, (void **)&param1_this);
          if (param1_this != NULL) {
            HTTPCookie *return_value = new HTTPCookie(std::string(param0_str, param0_len), *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline HTTPCookie::HTTPCookie(std::string const &name, std::string const &path, std::string const &domain)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        if (PyArg_ParseTuple(args, "s#s#s#:HTTPCookie", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len)) {
          HTTPCookie *return_value = new HTTPCookie(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_HTTPCookie(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HTTPCookie) {
    printf("HTTPCookie ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HTTPCookie *local_this = (HTTPCookie *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HTTPCookie) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HTTPCookie(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HTTPCookie) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HTTPClient
 */
/**
 * Python function wrapper for:
 * void HTTPClient::operator =(HTTPClient const &copy)
 */
static PyObject *Dtool_HTTPClient_operator_172(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.assign")) {
    return NULL;
  }
  // 1-void HTTPClient::operator =(HTTPClient const &copy)
  HTTPClient const *arg_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPClient, 1, "HTTPClient.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    HTTPClient *return_value = local_this;
    if (return_value != (HTTPClient *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (HTTPClient *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPClient, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const HTTPClient self, const HTTPClient copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_operator_172_comment =
  "C++ Interface:\n"
  "assign(const HTTPClient self, const HTTPClient copy)\n";
#else
static const char *Dtool_HTTPClient_operator_172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void HTTPClient::init_random_seed(void)
 */
static PyObject *Dtool_HTTPClient_init_random_seed_173(PyObject *, PyObject *) {
  // 1-static void HTTPClient::init_random_seed(void)
  HTTPClient::init_random_seed();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_init_random_seed_173_comment =
  "C++ Interface:\n"
  "init_random_seed()\n"
  "\n"
  "/**\n"
  " * This may be called once, presumably at the beginning of an application, to\n"
  " * initialize OpenSSL's random seed.  On Windows, it is particularly important\n"
  " * to call this at startup if you are going to be performing any https\n"
  " * operations or otherwise use encryption, since the Windows algorithm for\n"
  " * getting a random seed takes 2-3 seconds at startup, but can take 30 seconds\n"
  " * or more after you have opened a 3-D graphics window and started rendering.\n"
  " *\n"
  " * There is no harm in calling this method multiple times, or in not calling\n"
  " * it at all.\n"
  " */";
#else
static const char *Dtool_HTTPClient_init_random_seed_173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::set_proxy_spec(std::string const &proxy_spec)
 */
static PyObject *Dtool_HTTPClient_set_proxy_spec_174(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_proxy_spec")) {
    return NULL;
  }
  // 1-void HTTPClient::set_proxy_spec(std::string const &proxy_spec)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_proxy_spec(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_proxy_spec(const HTTPClient self, str proxy_spec)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_proxy_spec_174_comment =
  "C++ Interface:\n"
  "set_proxy_spec(const HTTPClient self, str proxy_spec)\n"
  "\n"
  "/**\n"
  " * Specifies the complete set of proxies to use for all schemes.  This is\n"
  " * either a semicolon-delimited set of hostname:ports, or a semicolon-\n"
  " * delimited set of pairs of the form \"scheme=hostname:port\", or a\n"
  " * combination.  Use the keyword DIRECT, or an empty string, to represent a\n"
  " * direct connection.  A particular scheme and/or proxy host may be listed\n"
  " * more than once.  This is a convenience function that can be used in place\n"
  " * of explicit calls to add_proxy() for each scheme/proxy pair.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_proxy_spec_174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPClient::get_proxy_spec(void) const
 */
static PyObject *Dtool_HTTPClient_get_proxy_spec_175(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPClient::get_proxy_spec(void) const
  std::string return_value = (*(const HTTPClient*)local_this).get_proxy_spec();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_proxy_spec_175_comment =
  "C++ Interface:\n"
  "get_proxy_spec(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns the complete set of proxies to use for all schemes.  This is a\n"
  " * string of the form specified by set_proxy_spec(), above.  Note that the\n"
  " * string returned by this function may not be exactly the same as the string\n"
  " * passed into set_proxy_spec(), since the string is regenerated from the\n"
  " * internal storage structures and may therefore be reordered.\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_proxy_spec_175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::set_direct_host_spec(std::string const &direct_host_spec)
 */
static PyObject *Dtool_HTTPClient_set_direct_host_spec_176(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_direct_host_spec")) {
    return NULL;
  }
  // 1-void HTTPClient::set_direct_host_spec(std::string const &direct_host_spec)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_direct_host_spec(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direct_host_spec(const HTTPClient self, str direct_host_spec)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_direct_host_spec_176_comment =
  "C++ Interface:\n"
  "set_direct_host_spec(const HTTPClient self, str direct_host_spec)\n"
  "\n"
  "/**\n"
  " * Specifies the set of hosts that should be connected to directly, without\n"
  " * using a proxy.  This is a semicolon-separated list of hostnames that may\n"
  " * contain wildcard characters (\"*\").\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_direct_host_spec_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPClient::get_direct_host_spec(void) const
 */
static PyObject *Dtool_HTTPClient_get_direct_host_spec_177(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPClient::get_direct_host_spec(void) const
  std::string return_value = (*(const HTTPClient*)local_this).get_direct_host_spec();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_direct_host_spec_177_comment =
  "C++ Interface:\n"
  "get_direct_host_spec(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns the set of hosts that should be connected to directly, without\n"
  " * using a proxy, as a semicolon-separated list of hostnames that may contain\n"
  " * wildcard characters (\"*\").\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_direct_host_spec_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_try_all_direct(bool try_all_direct)
 */
static PyObject *Dtool_HTTPClient_set_try_all_direct_178(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_try_all_direct")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_try_all_direct(bool try_all_direct)
  (*local_this).set_try_all_direct((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_try_all_direct(const HTTPClient self, bool try_all_direct)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_try_all_direct_178_comment =
  "C++ Interface:\n"
  "set_try_all_direct(const HTTPClient self, bool try_all_direct)\n"
  "\n"
  "/**\n"
  " * If this is set true, then after a connection attempt through a proxy fails,\n"
  " * we always try a direct connection, regardless of whether the host is listed\n"
  " * on the direct_host_spec list.  If this is false, a direct attempt is not\n"
  " * made when we have a proxy in effect, even if the proxy fails.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_try_all_direct_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPClient::get_try_all_direct(void) const
 */
static PyObject *Dtool_HTTPClient_get_try_all_direct_179(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPClient::get_try_all_direct(void) const
  bool return_value = (*(const HTTPClient*)local_this).get_try_all_direct();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_try_all_direct_179_comment =
  "C++ Interface:\n"
  "get_try_all_direct(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns whether a failed connection through a proxy will be followed up by\n"
  " * a direct connection attempt, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_try_all_direct_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::clear_proxy(void)
 */
static PyObject *Dtool_HTTPClient_clear_proxy_180(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.clear_proxy")) {
    return NULL;
  }
  // 1-void HTTPClient::clear_proxy(void)
  (*local_this).clear_proxy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_clear_proxy_180_comment =
  "C++ Interface:\n"
  "clear_proxy(const HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Resets the proxy spec to empty.  Subsequent calls to add_proxy() may be\n"
  " * made to build up the set of proxy servers.\n"
  " */";
#else
static const char *Dtool_HTTPClient_clear_proxy_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::add_proxy(std::string const &scheme, URLSpec const &proxy)
 */
static PyObject *Dtool_HTTPClient_add_proxy_181(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.add_proxy")) {
    return NULL;
  }
  // 1-void HTTPClient::add_proxy(std::string const &scheme, URLSpec const &proxy)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"scheme", "proxy", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:add_proxy", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    URLSpec const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "HTTPClient.add_proxy", "URLSpec");
    }
    (*local_this).add_proxy(std::string(param1_str, param1_len), *param2_this);
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_proxy(const HTTPClient self, str scheme, const URLSpec proxy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_add_proxy_181_comment =
  "C++ Interface:\n"
  "add_proxy(const HTTPClient self, str scheme, const URLSpec proxy)\n"
  "\n"
  "/**\n"
  " * Adds the indicated proxy host as a proxy for communications on the given\n"
  " * scheme.  Usually the scheme is \"http\" or \"https\".  It may be the empty\n"
  " * string to indicate a general proxy.  The proxy string may be the empty URL\n"
  " * to indicate a direct connection.\n"
  " */";
#else
static const char *Dtool_HTTPClient_add_proxy_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::clear_direct_host(void)
 */
static PyObject *Dtool_HTTPClient_clear_direct_host_182(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.clear_direct_host")) {
    return NULL;
  }
  // 1-void HTTPClient::clear_direct_host(void)
  (*local_this).clear_direct_host();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_clear_direct_host_182_comment =
  "C++ Interface:\n"
  "clear_direct_host(const HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Resets the set of direct hosts to empty.  Subsequent calls to\n"
  " * add_direct_host() may be made to build up the list of hosts that do not\n"
  " * require a proxy connection.\n"
  " */";
#else
static const char *Dtool_HTTPClient_clear_direct_host_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::add_direct_host(std::string const &hostname)
 */
static PyObject *Dtool_HTTPClient_add_direct_host_183(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.add_direct_host")) {
    return NULL;
  }
  // 1-void HTTPClient::add_direct_host(std::string const &hostname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_direct_host(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_direct_host(const HTTPClient self, str hostname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_add_direct_host_183_comment =
  "C++ Interface:\n"
  "add_direct_host(const HTTPClient self, str hostname)\n"
  "\n"
  "/**\n"
  " * Adds the indicated name to the set of hostnames that are connected to\n"
  " * directly, without using a proxy.  This name may be either a DNS name or an\n"
  " * IP address, and it may include the * as a wildcard character.\n"
  " */";
#else
static const char *Dtool_HTTPClient_add_direct_host_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPClient::get_proxies_for_url(URLSpec const &url) const
 */
static PyObject *Dtool_HTTPClient_get_proxies_for_url_184(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPClient::get_proxies_for_url(URLSpec const &url) const
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.get_proxies_for_url", "URLSpec");
  }
  std::string return_value = (*(const HTTPClient*)local_this).get_proxies_for_url(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_proxies_for_url(HTTPClient self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_proxies_for_url_184_comment =
  "C++ Interface:\n"
  "get_proxies_for_url(HTTPClient self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Fills up the indicated vector with the list of URLSpec objects, in the\n"
  " * order in which they should be tried, that are appropriate proxies to try\n"
  " * for the indicated URL.  The empty URL is returned for a direct connection.\n"
  " *\n"
  " * It is the user's responsibility to empty this vector before calling this\n"
  " * method; otherwise, the proxy URL's will simply be appended to the existing\n"
  " * list.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns a semicolon-delimited list of proxies, in the order in which they\n"
  " * should be tried, that are appropriate for the indicated URL.  The keyword\n"
  " * DIRECT indicates a direct connection should be tried.\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_proxies_for_url_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::set_username(std::string const &server, std::string const &realm, std::string const &username)
 */
static PyObject *Dtool_HTTPClient_set_username_185(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_username")) {
    return NULL;
  }
  // 1-void HTTPClient::set_username(std::string const &server, std::string const &realm, std::string const &username)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"server", "realm", "username", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:set_username", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
    (*local_this).set_username(std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_username(const HTTPClient self, str server, str realm, str username)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_username_185_comment =
  "C++ Interface:\n"
  "set_username(const HTTPClient self, str server, str realm, str username)\n"
  "\n"
  "/**\n"
  " * Specifies the username:password string corresponding to a particular server\n"
  " * and/or realm, when demanded by the server.  Either or both of the server or\n"
  " * realm may be empty; if so, they match anything.  Also, the server may be\n"
  " * set to the special string \"*proxy\", which will match any proxy server.\n"
  " *\n"
  " * If the username is set to the empty string, this clears the password for\n"
  " * the particular server/realm pair.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_username_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPClient::get_username(std::string const &server, std::string const &realm) const
 */
static PyObject *Dtool_HTTPClient_get_username_186(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPClient::get_username(std::string const &server, std::string const &realm) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"server", "realm", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_username", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    std::string return_value = (*(const HTTPClient*)local_this).get_username(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_username(HTTPClient self, str server, str realm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_username_186_comment =
  "C++ Interface:\n"
  "get_username(HTTPClient self, str server, str realm)\n"
  "\n"
  "/**\n"
  " * Returns the username:password string set for this server/realm pair, or\n"
  " * empty string if nothing has been set.  See set_username().\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_username_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::set_cookie(HTTPCookie const &cookie)
 */
static PyObject *Dtool_HTTPClient_set_cookie_187(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_cookie")) {
    return NULL;
  }
  // 1-void HTTPClient::set_cookie(HTTPCookie const &cookie)
  HTTPCookie const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.set_cookie", "HTTPCookie");
  }
  (*local_this).set_cookie(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cookie(const HTTPClient self, const HTTPCookie cookie)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_cookie_187_comment =
  "C++ Interface:\n"
  "set_cookie(const HTTPClient self, const HTTPCookie cookie)\n"
  "\n"
  "/**\n"
  " * Stores the indicated cookie in the client's list of cookies, as if it had\n"
  " * been received from a server.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_cookie_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::clear_cookie(HTTPCookie const &cookie)
 */
static PyObject *Dtool_HTTPClient_clear_cookie_188(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.clear_cookie")) {
    return NULL;
  }
  // 1-bool HTTPClient::clear_cookie(HTTPCookie const &cookie)
  HTTPCookie const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.clear_cookie", "HTTPCookie");
  }
  bool return_value = (*local_this).clear_cookie(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_cookie(const HTTPClient self, const HTTPCookie cookie)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_clear_cookie_188_comment =
  "C++ Interface:\n"
  "clear_cookie(const HTTPClient self, const HTTPCookie cookie)\n"
  "\n"
  "/**\n"
  " * Removes the cookie with the matching domain/path/name from the client's\n"
  " * list of cookies.  Returns true if it was removed, false if the cookie was\n"
  " * not matched.\n"
  " */";
#else
static const char *Dtool_HTTPClient_clear_cookie_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::clear_all_cookies(void)
 */
static PyObject *Dtool_HTTPClient_clear_all_cookies_189(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.clear_all_cookies")) {
    return NULL;
  }
  // 1-void HTTPClient::clear_all_cookies(void)
  (*local_this).clear_all_cookies();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_clear_all_cookies_189_comment =
  "C++ Interface:\n"
  "clear_all_cookies(const HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Removes the all stored cookies from the client.\n"
  " */";
#else
static const char *Dtool_HTTPClient_clear_all_cookies_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::has_cookie(HTTPCookie const &cookie) const
 */
static PyObject *Dtool_HTTPClient_has_cookie_190(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool HTTPClient::has_cookie(HTTPCookie const &cookie) const
  HTTPCookie const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.has_cookie", "HTTPCookie");
  }
  bool return_value = (*(const HTTPClient*)local_this).has_cookie(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_cookie(HTTPClient self, const HTTPCookie cookie)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_has_cookie_190_comment =
  "C++ Interface:\n"
  "has_cookie(HTTPClient self, const HTTPCookie cookie)\n"
  "\n"
  "/**\n"
  " * Returns true if there is a cookie in the client matching the given cookie's\n"
  " * domain/path/name, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPClient_has_cookie_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * HTTPCookie HTTPClient::get_cookie(HTTPCookie const &cookie) const
 */
static PyObject *Dtool_HTTPClient_get_cookie_191(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-HTTPCookie HTTPClient::get_cookie(HTTPCookie const &cookie) const
  HTTPCookie const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.get_cookie", "HTTPCookie");
  }
  HTTPCookie *return_value = new HTTPCookie((*(const HTTPClient*)local_this).get_cookie(*arg_this));
  if (arg_manage) {
    delete arg_this;
  }
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPCookie, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_cookie(HTTPClient self, const HTTPCookie cookie)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_cookie_191_comment =
  "C++ Interface:\n"
  "get_cookie(HTTPClient self, const HTTPCookie cookie)\n"
  "\n"
  "/**\n"
  " * Looks up and returns the cookie in the client matching the given cookie's\n"
  " * domain/path/name.  If there is no matching cookie, returns an empty cookie.\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_cookie_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::copy_cookies_from(HTTPClient const &other)
 */
static PyObject *Dtool_HTTPClient_copy_cookies_from_192(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.copy_cookies_from")) {
    return NULL;
  }
  // 1-void HTTPClient::copy_cookies_from(HTTPClient const &other)
  HTTPClient const *arg_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPClient, 1, "HTTPClient.copy_cookies_from", true, true);
  if (arg_this != NULL) {
    (*local_this).copy_cookies_from(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_cookies_from(const HTTPClient self, const HTTPClient other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_copy_cookies_from_192_comment =
  "C++ Interface:\n"
  "copy_cookies_from(const HTTPClient self, const HTTPClient other)\n"
  "\n"
  "/**\n"
  " * Copies all the cookies from the indicated HTTPClient into this one.\n"
  " * Existing cookies in this client are not affected, unless they are shadowed\n"
  " * by the new cookies.\n"
  " */";
#else
static const char *Dtool_HTTPClient_copy_cookies_from_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::write_cookies(ostream &out) const
 */
static PyObject *Dtool_HTTPClient_write_cookies_193(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HTTPClient::write_cookies(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HTTPClient.write_cookies", false, true);
  if (arg_this != NULL) {
    (*(const HTTPClient*)local_this).write_cookies(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_cookies(HTTPClient self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_write_cookies_193_comment =
  "C++ Interface:\n"
  "write_cookies(HTTPClient self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the complete list of cookies stored on the client, for all domains,\n"
  " * including the expired cookies (which will normally not be sent back to a\n"
  " * host).\n"
  " */";
#else
static const char *Dtool_HTTPClient_write_cookies_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::send_cookies(ostream &out, URLSpec const &url)
 */
static PyObject *Dtool_HTTPClient_send_cookies_194(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.send_cookies")) {
    return NULL;
  }
  // 1-void HTTPClient::send_cookies(ostream &out, URLSpec const &url)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"out", "url", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:send_cookies", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "HTTPClient.send_cookies", false, true);
    URLSpec const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "HTTPClient.send_cookies", "URLSpec");
    }
    if (param1_this != NULL) {
      (*local_this).send_cookies(*param1_this, *param2_this);
      if (param2_manage) {
        delete param2_this;
      }
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_cookies(const HTTPClient self, ostream out, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_send_cookies_194_comment =
  "C++ Interface:\n"
  "send_cookies(const HTTPClient self, ostream out, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Writes to the indicated ostream a \"Cookie\" header line for sending the\n"
  " * cookies appropriate to the indicated URL along with an HTTP request.  This\n"
  " * also removes expired cookies.\n"
  " */";
#else
static const char *Dtool_HTTPClient_send_cookies_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_client_certificate_filename(Filename const &filename)
 */
static PyObject *Dtool_HTTPClient_set_client_certificate_filename_195(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_client_certificate_filename")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_client_certificate_filename(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.set_client_certificate_filename", "Filename");
  }
  (*local_this).set_client_certificate_filename(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_certificate_filename(const HTTPClient self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_client_certificate_filename_195_comment =
  "C++ Interface:\n"
  "set_client_certificate_filename(const HTTPClient self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Sets the filename of the pem-formatted file that will be read for the\n"
  " * client public and private keys if an SSL server requests a certificate.\n"
  " * Either this or set_client_certificate_pem() may be used to specify a client\n"
  " * certificate.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_client_certificate_filename_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_client_certificate_pem(std::string const &pem)
 */
static PyObject *Dtool_HTTPClient_set_client_certificate_pem_196(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_client_certificate_pem")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_client_certificate_pem(std::string const &pem)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_client_certificate_pem(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_certificate_pem(const HTTPClient self, str pem)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_client_certificate_pem_196_comment =
  "C++ Interface:\n"
  "set_client_certificate_pem(const HTTPClient self, str pem)\n"
  "\n"
  "/**\n"
  " * Sets the pem-formatted contents of the certificate that will be parsed for\n"
  " * the client public and private keys if an SSL server requests a certificate.\n"
  " * Either this or set_client_certificate_filename() may be used to specify a\n"
  " * client certificate.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_client_certificate_pem_196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_client_certificate_passphrase(std::string const &passphrase)
 */
static PyObject *Dtool_HTTPClient_set_client_certificate_passphrase_197(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_client_certificate_passphrase")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_client_certificate_passphrase(std::string const &passphrase)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_client_certificate_passphrase(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_certificate_passphrase(const HTTPClient self, str passphrase)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_client_certificate_passphrase_197_comment =
  "C++ Interface:\n"
  "set_client_certificate_passphrase(const HTTPClient self, str passphrase)\n"
  "\n"
  "/**\n"
  " * Sets the passphrase used to decrypt the private key in the certificate\n"
  " * named by set_client_certificate_filename() or set_client_certificate_pem().\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_client_certificate_passphrase_197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::load_client_certificate(void)
 */
static PyObject *Dtool_HTTPClient_load_client_certificate_198(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.load_client_certificate")) {
    return NULL;
  }
  // 1-bool HTTPClient::load_client_certificate(void)
  bool return_value = (*local_this).load_client_certificate();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_load_client_certificate_198_comment =
  "C++ Interface:\n"
  "load_client_certificate(const HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Attempts to load the certificate named by set_client_certificate_filename()\n"
  " * immediately, and returns true if successful, false otherwise.\n"
  " *\n"
  " * Normally this need not be explicitly called, since it will be called\n"
  " * automatically if the server requests a certificate, but it may be useful to\n"
  " * determine ahead of time if the certificate can be loaded correctly.\n"
  " */";
#else
static const char *Dtool_HTTPClient_load_client_certificate_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::add_preapproved_server_certificate_filename(URLSpec const &url, Filename const &filename)
 */
static PyObject *Dtool_HTTPClient_add_preapproved_server_certificate_filename_199(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.add_preapproved_server_certificate_filename")) {
    return NULL;
  }
  // 1-bool HTTPClient::add_preapproved_server_certificate_filename(URLSpec const &url, Filename const &filename)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"url", "filename", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_preapproved_server_certificate_filename", (char **)keyword_list, &param1, &param2)) {
    URLSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPClient.add_preapproved_server_certificate_filename", "URLSpec");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "HTTPClient.add_preapproved_server_certificate_filename", "Filename");
    }
    bool return_value = (*local_this).add_preapproved_server_certificate_filename(*param1_this, *param2_this);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_preapproved_server_certificate_filename(const HTTPClient self, const URLSpec url, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_add_preapproved_server_certificate_filename_199_comment =
  "C++ Interface:\n"
  "add_preapproved_server_certificate_filename(const HTTPClient self, const URLSpec url, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Adds the certificate defined in the indicated PEM filename as a \"pre-\n"
  " * approved\" certificate for the indicated server, defined by the hostname and\n"
  " * port (only) from the given URL.\n"
  " *\n"
  " * If the server offers this particular certificate on a secure connection, it\n"
  " * will be accepted without question.  This is particularly useful for\n"
  " * communicating with a server using a known self-signed certificate.\n"
  " *\n"
  " * See also the similar add_preapproved_server_certificate_pem(), and the\n"
  " * weaker add_preapproved_server_certificate_name().\n"
  " */";
#else
static const char *Dtool_HTTPClient_add_preapproved_server_certificate_filename_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::add_preapproved_server_certificate_pem(URLSpec const &url, std::string const &pem)
 */
static PyObject *Dtool_HTTPClient_add_preapproved_server_certificate_pem_200(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.add_preapproved_server_certificate_pem")) {
    return NULL;
  }
  // 1-bool HTTPClient::add_preapproved_server_certificate_pem(URLSpec const &url, std::string const &pem)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"url", "pem", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add_preapproved_server_certificate_pem", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    URLSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPClient.add_preapproved_server_certificate_pem", "URLSpec");
    }
    bool return_value = (*local_this).add_preapproved_server_certificate_pem(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_preapproved_server_certificate_pem(const HTTPClient self, const URLSpec url, str pem)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_add_preapproved_server_certificate_pem_200_comment =
  "C++ Interface:\n"
  "add_preapproved_server_certificate_pem(const HTTPClient self, const URLSpec url, str pem)\n"
  "\n"
  "/**\n"
  " * Adds the certificate defined in the indicated data string, formatted as a\n"
  " * PEM block, as a \"pre-approved\" certificate for the indicated server,\n"
  " * defined by the hostname and port (only) from the given URL.\n"
  " *\n"
  " * If the server offers this particular certificate on a secure connection, it\n"
  " * will be accepted without question.  This is particularly useful for\n"
  " * communicating with a server using a known self-signed certificate.\n"
  " *\n"
  " * See also the similar add_preapproved_server_certificate_filename(), and the\n"
  " * weaker add_preapproved_server_certificate_name().\n"
  " */";
#else
static const char *Dtool_HTTPClient_add_preapproved_server_certificate_pem_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::add_preapproved_server_certificate_name(URLSpec const &url, std::string const &name)
 */
static PyObject *Dtool_HTTPClient_add_preapproved_server_certificate_name_201(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.add_preapproved_server_certificate_name")) {
    return NULL;
  }
  // 1-bool HTTPClient::add_preapproved_server_certificate_name(URLSpec const &url, std::string const &name)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"url", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add_preapproved_server_certificate_name", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    URLSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPClient.add_preapproved_server_certificate_name", "URLSpec");
    }
    bool return_value = (*local_this).add_preapproved_server_certificate_name(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_preapproved_server_certificate_name(const HTTPClient self, const URLSpec url, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_add_preapproved_server_certificate_name_201_comment =
  "C++ Interface:\n"
  "add_preapproved_server_certificate_name(const HTTPClient self, const URLSpec url, str name)\n"
  "\n"
  "/**\n"
  " * Adds the certificate *name* only, as a \"pre-approved\" certificate name for\n"
  " * the indicated server, defined by the hostname and port (only) from the\n"
  " * given URL.\n"
  " *\n"
  " * This is a weaker function than\n"
  " * add_preapproved_server_certificate_filename().  This checks only the\n"
  " * subject name of the certificate, without checking for a particular\n"
  " * certificate by key.  This means that a variety of server certificates may\n"
  " * match the indicated name.\n"
  " *\n"
  " * Because this is a weaker verification, it only applies to server\n"
  " * certificates that are signed by a recognized certificate authority.  Thus,\n"
  " * it cannot be used to pre-approve self-signed certificates, but it can be\n"
  " * used to accept a server certificate offered by a different hostname than\n"
  " * the one in the cert itself.\n"
  " *\n"
  " * The certificate name should be formatted in the form\n"
  " * type0=value0/type1=value1/type2=...\n"
  " */";
#else
static const char *Dtool_HTTPClient_add_preapproved_server_certificate_name_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::clear_preapproved_server_certificates(URLSpec const &url)
 */
static PyObject *Dtool_HTTPClient_clear_preapproved_server_certificates_202(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.clear_preapproved_server_certificates")) {
    return NULL;
  }
  // 1-void HTTPClient::clear_preapproved_server_certificates(URLSpec const &url)
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.clear_preapproved_server_certificates", "URLSpec");
  }
  (*local_this).clear_preapproved_server_certificates(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_preapproved_server_certificates(const HTTPClient self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_clear_preapproved_server_certificates_202_comment =
  "C++ Interface:\n"
  "clear_preapproved_server_certificates(const HTTPClient self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Removes all preapproved server certificates for the indicated server and\n"
  " * port.\n"
  " */";
#else
static const char *Dtool_HTTPClient_clear_preapproved_server_certificates_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPClient::clear_all_preapproved_server_certificates(void)
 */
static PyObject *Dtool_HTTPClient_clear_all_preapproved_server_certificates_203(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.clear_all_preapproved_server_certificates")) {
    return NULL;
  }
  // 1-void HTTPClient::clear_all_preapproved_server_certificates(void)
  (*local_this).clear_all_preapproved_server_certificates();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_clear_all_preapproved_server_certificates_203_comment =
  "C++ Interface:\n"
  "clear_all_preapproved_server_certificates(const HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Removes all preapproved server certificates for all servers.\n"
  " */";
#else
static const char *Dtool_HTTPClient_clear_all_preapproved_server_certificates_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_http_version(HTTPEnum::HTTPVersion version)
 */
static PyObject *Dtool_HTTPClient_set_http_version_204(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_http_version")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_http_version(HTTPEnum::HTTPVersion version)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_http_version((HTTPEnum::HTTPVersion)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_http_version(const HTTPClient self, int version)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_http_version_204_comment =
  "C++ Interface:\n"
  "set_http_version(const HTTPClient self, int version)\n"
  "\n"
  "/**\n"
  " * Specifies the version of HTTP that the client uses to identify itself to\n"
  " * the server.  The default is HV_11, or HTTP 1.0; you can set this to HV_10\n"
  " * (HTTP 1.0) to request the server use the older interface.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_http_version_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPEnum::HTTPVersion HTTPClient::get_http_version(void) const
 */
static PyObject *Dtool_HTTPClient_get_http_version_205(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPEnum::HTTPVersion HTTPClient::get_http_version(void) const
  HTTPEnum::HTTPVersion return_value = (*(const HTTPClient*)local_this).get_http_version();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_http_version_205_comment =
  "C++ Interface:\n"
  "get_http_version(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns the client's current setting for HTTP version.  See\n"
  " * set_http_version().\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_http_version_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPClient::get_http_version_string(void) const
 */
static PyObject *Dtool_HTTPClient_get_http_version_string_206(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPClient::get_http_version_string(void) const
  std::string return_value = (*(const HTTPClient*)local_this).get_http_version_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_http_version_string_206_comment =
  "C++ Interface:\n"
  "get_http_version_string(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns the current HTTP version setting as a string, e.g.  \"HTTP/1.0\" or\n"
  " * \"HTTP/1.1\".\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_http_version_string_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static HTTPEnum::HTTPVersion HTTPClient::parse_http_version_string(std::string const &version)
 */
static PyObject *Dtool_HTTPClient_parse_http_version_string_207(PyObject *, PyObject *arg) {
  // 1-static HTTPEnum::HTTPVersion HTTPClient::parse_http_version_string(std::string const &version)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    HTTPEnum::HTTPVersion return_value = HTTPClient::parse_http_version_string(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_http_version_string(str version)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_parse_http_version_string_207_comment =
  "C++ Interface:\n"
  "parse_http_version_string(str version)\n"
  "\n"
  "/**\n"
  " * Matches the string representing a particular HTTP version against any of\n"
  " * the known versions and returns the appropriate enumerated value, or\n"
  " * HV_other if the version is unknown.\n"
  " */";
#else
static const char *Dtool_HTTPClient_parse_http_version_string_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPClient::load_certificates(Filename const &filename)
 */
static PyObject *Dtool_HTTPClient_load_certificates_208(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.load_certificates")) {
    return NULL;
  }
  // 1-bool HTTPClient::load_certificates(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.load_certificates", "Filename");
  }
  bool return_value = (*local_this).load_certificates(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates(const HTTPClient self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_load_certificates_208_comment =
  "C++ Interface:\n"
  "load_certificates(const HTTPClient self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Reads the certificate(s) (delimited by -----BEGIN CERTIFICATE----- and\n"
  " * -----END CERTIFICATE-----) from the indicated file and makes them known as\n"
  " * trusted public keys for validating future connections.  Returns true on\n"
  " * success, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPClient_load_certificates_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_verify_ssl(HTTPClient::VerifySSL verify_ssl)
 */
static PyObject *Dtool_HTTPClient_set_verify_ssl_210(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_verify_ssl")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_verify_ssl(HTTPClient::VerifySSL verify_ssl)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_verify_ssl((HTTPClient::VerifySSL)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_verify_ssl(const HTTPClient self, int verify_ssl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_verify_ssl_210_comment =
  "C++ Interface:\n"
  "set_verify_ssl(const HTTPClient self, int verify_ssl)\n"
  "\n"
  "/**\n"
  " * Specifies whether the client will insist on verifying the identity of the\n"
  " * servers it connects to via SSL (that is, https).\n"
  " *\n"
  " * The parameter value is an enumerated type which indicates the level of\n"
  " * security to which the client will insist upon.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_verify_ssl_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPClient::VerifySSL HTTPClient::get_verify_ssl(void) const
 */
static PyObject *Dtool_HTTPClient_get_verify_ssl_211(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPClient::VerifySSL HTTPClient::get_verify_ssl(void) const
  HTTPClient::VerifySSL return_value = (*(const HTTPClient*)local_this).get_verify_ssl();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_verify_ssl_211_comment =
  "C++ Interface:\n"
  "get_verify_ssl(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns whether the client will insist on verifying the identity of the\n"
  " * servers it connects to via SSL (that is, https).  See set_verify_ssl().\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_verify_ssl_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPClient::set_cipher_list(std::string const &cipher_list)
 */
static PyObject *Dtool_HTTPClient_set_cipher_list_212(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.set_cipher_list")) {
    return NULL;
  }
  // 1-inline void HTTPClient::set_cipher_list(std::string const &cipher_list)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_cipher_list(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cipher_list(const HTTPClient self, str cipher_list)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_set_cipher_list_212_comment =
  "C++ Interface:\n"
  "set_cipher_list(const HTTPClient self, str cipher_list)\n"
  "\n"
  "/**\n"
  " * Specifies the set of ciphers that are to be made available for SSL\n"
  " * connections.  This is a string as described in the ciphers(1) man page of\n"
  " * the OpenSSL documentation (or see\n"
  " * http://www.openssl.org/docs/apps/ciphers.html ).  If this is not specified,\n"
  " * the default is provided by the Config file.  You may also specify \"DEFAULT\"\n"
  " * to use the built-in OpenSSL default value.\n"
  " */";
#else
static const char *Dtool_HTTPClient_set_cipher_list_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPClient::get_cipher_list(void) const
 */
static PyObject *Dtool_HTTPClient_get_cipher_list_213(PyObject *self, PyObject *) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPClient, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPClient::get_cipher_list(void) const
  std::string const &return_value = (*(const HTTPClient*)local_this).get_cipher_list();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_cipher_list_213_comment =
  "C++ Interface:\n"
  "get_cipher_list(HTTPClient self)\n"
  "\n"
  "/**\n"
  " * Returns the set of ciphers as set by set_cipher_list().  See\n"
  " * set_cipher_list().\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_cipher_list_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< HTTPChannel > HTTPClient::make_channel(bool persistent_connection)
 */
static PyObject *Dtool_HTTPClient_make_channel_214(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.make_channel")) {
    return NULL;
  }
  // 1-PointerTo< HTTPChannel > HTTPClient::make_channel(bool persistent_connection)
  PointerTo< HTTPChannel > return_value = (*local_this).make_channel((PyObject_IsTrue(arg) != 0));
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  HTTPChannel *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_HTTPChannel, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_channel(const HTTPClient self, bool persistent_connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_make_channel_214_comment =
  "C++ Interface:\n"
  "make_channel(const HTTPClient self, bool persistent_connection)\n"
  "\n"
  "/**\n"
  " * Returns a new HTTPChannel object that may be used for reading multiple\n"
  " * documents using the same connection, for greater network efficiency than\n"
  " * calling HTTPClient::get_document() repeatedly (which would force a new\n"
  " * connection for each document).\n"
  " *\n"
  " * Also, HTTPChannel has some additional, less common interface methods than\n"
  " * the basic interface methods that exist on HTTPClient; if you wish to call\n"
  " * any of these methods you must first obtain an HTTPChannel.\n"
  " *\n"
  " * Pass true for persistent_connection to gain this network efficiency.  If,\n"
  " * on the other hand, your intention is to use the channel to retrieve only\n"
  " * one document, then pass false to inform the server that we will be dropping\n"
  " * the connection after the first document.\n"
  " */";
#else
static const char *Dtool_HTTPClient_make_channel_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< HTTPChannel > HTTPClient::post_form(URLSpec const &url, std::string const &body)
 */
static PyObject *Dtool_HTTPClient_post_form_215(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.post_form")) {
    return NULL;
  }
  // 1-PointerTo< HTTPChannel > HTTPClient::post_form(URLSpec const &url, std::string const &body)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"url", "body", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:post_form", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    URLSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_URLSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPClient.post_form", "URLSpec");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< HTTPChannel > return_value = (*local_this).post_form(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    HTTPChannel *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_HTTPChannel, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "post_form(const HTTPClient self, const URLSpec url, str body)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_post_form_215_comment =
  "C++ Interface:\n"
  "post_form(const HTTPClient self, const URLSpec url, str body)\n"
  "\n"
  "/**\n"
  " * Posts form data to a particular URL and retrieves the response.  Returns a\n"
  " * new HTTPChannel object whether the document is successfully read or not;\n"
  " * you can test is_valid() and get_return_code() to determine whether the\n"
  " * document was retrieved.\n"
  " */";
#else
static const char *Dtool_HTTPClient_post_form_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< HTTPChannel > HTTPClient::get_document(URLSpec const &url)
 */
static PyObject *Dtool_HTTPClient_get_document_216(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.get_document")) {
    return NULL;
  }
  // 1-PointerTo< HTTPChannel > HTTPClient::get_document(URLSpec const &url)
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.get_document", "URLSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< HTTPChannel > return_value = (*local_this).get_document(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  HTTPChannel *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_HTTPChannel, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_document(const HTTPClient self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_document_216_comment =
  "C++ Interface:\n"
  "get_document(const HTTPClient self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Opens the named document for reading.  Returns a new HTTPChannel object\n"
  " * whether the document is successfully read or not; you can test is_valid()\n"
  " * and get_return_code() to determine whether the document was retrieved.\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_document_216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< HTTPChannel > HTTPClient::get_header(URLSpec const &url)
 */
static PyObject *Dtool_HTTPClient_get_header_217(PyObject *self, PyObject *arg) {
  HTTPClient *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPClient, (void **)&local_this, "HTTPClient.get_header")) {
    return NULL;
  }
  // 1-PointerTo< HTTPChannel > HTTPClient::get_header(URLSpec const &url)
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPClient.get_header", "URLSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< HTTPChannel > return_value = (*local_this).get_header(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  HTTPChannel *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_HTTPChannel, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_header(const HTTPClient self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_header_217_comment =
  "C++ Interface:\n"
  "get_header(const HTTPClient self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Like get_document(), except only the header associated with the document is\n"
  " * retrieved.  This may be used to test for existence of the document; it\n"
  " * might also return the size of the document (if the server gives us this\n"
  " * information).\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_header_217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string HTTPClient::base64_encode(std::string const &s)
 */
static PyObject *Dtool_HTTPClient_base64_encode_218(PyObject *, PyObject *arg) {
  // 1-static inline std::string HTTPClient::base64_encode(std::string const &s)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = HTTPClient::base64_encode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "base64_encode(str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_base64_encode_218_comment =
  "C++ Interface:\n"
  "base64_encode(str s)\n"
  "\n"
  "/**\n"
  " * Implements HTTPAuthorization::base64_encode().  This is provided here just\n"
  " * as a convenient place to publish it for access by the scripting language;\n"
  " * C++ code should probably use HTTPAuthorization directly.\n"
  " */";
#else
static const char *Dtool_HTTPClient_base64_encode_218_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string HTTPClient::base64_decode(std::string const &s)
 */
static PyObject *Dtool_HTTPClient_base64_decode_219(PyObject *, PyObject *arg) {
  // 1-static inline std::string HTTPClient::base64_decode(std::string const &s)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = HTTPClient::base64_decode(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "base64_decode(str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_base64_decode_219_comment =
  "C++ Interface:\n"
  "base64_decode(str s)\n"
  "\n"
  "/**\n"
  " * Implements HTTPAuthorization::base64_decode().  This is provided here just\n"
  " * as a convenient place to publish it for access by the scripting language;\n"
  " * C++ code should probably use HTTPAuthorization directly.\n"
  " */";
#else
static const char *Dtool_HTTPClient_base64_decode_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static HTTPClient *HTTPClient::get_global_ptr(void)
 */
static PyObject *Dtool_HTTPClient_get_global_ptr_220(PyObject *, PyObject *) {
  // 1-static HTTPClient *HTTPClient::get_global_ptr(void)
  HTTPClient *return_value = HTTPClient::get_global_ptr();
  if (return_value != (HTTPClient *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (HTTPClient *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPClient, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPClient_get_global_ptr_220_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the default global HTTPClient.\n"
  " */";
#else
static const char *Dtool_HTTPClient_get_global_ptr_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * HTTPClient::HTTPClient(void)
 * HTTPClient::HTTPClient(HTTPClient const &copy)
 */
static int Dtool_Init_HTTPClient(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-HTTPClient::HTTPClient(void)
      HTTPClient *return_value = new HTTPClient();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPClient, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-HTTPClient::HTTPClient(HTTPClient const &copy)
      HTTPClient const *arg_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPClient, 0, "HTTPClient.HTTPClient", true, true);
      if (arg_this != NULL) {
        HTTPClient *return_value = new HTTPClient(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPClient, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HTTPClient() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HTTPClient()\n"
      "HTTPClient(const HTTPClient copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_HTTPClient(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HTTPClient) {
    printf("HTTPClient ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HTTPClient *local_this = (HTTPClient *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HTTPClient) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HTTPClient(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HTTPClient) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HTTPClient*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HTTPEntityTag
 */
/**
 * Python function wrapper for:
 * inline void HTTPEntityTag::operator =(HTTPEntityTag const &copy)
 */
static PyObject *Dtool_HTTPEntityTag_operator_223(PyObject *self, PyObject *arg) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPEntityTag, (void **)&local_this, "HTTPEntityTag.assign")) {
    return NULL;
  }
  // 1-inline void HTTPEntityTag::operator =(HTTPEntityTag const &copy)
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPEntityTag.assign", "HTTPEntityTag");
  }
  (*local_this).operator =(*arg_this);
  HTTPEntityTag *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPEntityTag, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const HTTPEntityTag self, const HTTPEntityTag copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_operator_223_comment =
  "C++ Interface:\n"
  "assign(const HTTPEntityTag self, const HTTPEntityTag copy)\n";
#else
static const char *Dtool_HTTPEntityTag_operator_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPEntityTag::is_weak(void) const
 */
static PyObject *Dtool_HTTPEntityTag_is_weak_224(PyObject *self, PyObject *) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPEntityTag::is_weak(void) const
  bool return_value = (*(const HTTPEntityTag*)local_this).is_weak();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_is_weak_224_comment =
  "C++ Interface:\n"
  "is_weak(HTTPEntityTag self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entity tag is marked as \"weak\". A consistent weak\n"
  " * entity tag does not guarantee that its resource has not changed in any way,\n"
  " * but it does promise that the resource has not changed in any semantically\n"
  " * meaningful way.\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_is_weak_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPEntityTag::get_tag(void) const
 */
static PyObject *Dtool_HTTPEntityTag_get_tag_225(PyObject *self, PyObject *) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPEntityTag::get_tag(void) const
  std::string const &return_value = (*(const HTTPEntityTag*)local_this).get_tag();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_get_tag_225_comment =
  "C++ Interface:\n"
  "get_tag(HTTPEntityTag self)\n"
  "\n"
  "/**\n"
  " * Returns the tag as a literal string.\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_get_tag_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPEntityTag::get_string(void) const
 */
static PyObject *Dtool_HTTPEntityTag_get_string_226(PyObject *self, PyObject *) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPEntityTag::get_string(void) const
  std::string return_value = (*(const HTTPEntityTag*)local_this).get_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_get_string_226_comment =
  "C++ Interface:\n"
  "get_string(HTTPEntityTag self)\n"
  "\n"
  "/**\n"
  " * Returns the entity tag formatted for sending to an HTTP server (the tag is\n"
  " * quoted, with a conditional W prefix).\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_get_string_226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPEntityTag::strong_equiv(HTTPEntityTag const &other) const
 */
static PyObject *Dtool_HTTPEntityTag_strong_equiv_227(PyObject *self, PyObject *arg) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPEntityTag::strong_equiv(HTTPEntityTag const &other) const
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPEntityTag.strong_equiv", "HTTPEntityTag");
  }
  bool return_value = (*(const HTTPEntityTag*)local_this).strong_equiv(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "strong_equiv(HTTPEntityTag self, const HTTPEntityTag other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_strong_equiv_227_comment =
  "C++ Interface:\n"
  "strong_equiv(HTTPEntityTag self, const HTTPEntityTag other)\n"
  "\n"
  "/**\n"
  " * Returns true if the two tags have \"strong\" equivalence: they are the same\n"
  " * tag, and both are \"strong\".\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_strong_equiv_227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPEntityTag::weak_equiv(HTTPEntityTag const &other) const
 */
static PyObject *Dtool_HTTPEntityTag_weak_equiv_228(PyObject *self, PyObject *arg) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPEntityTag::weak_equiv(HTTPEntityTag const &other) const
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPEntityTag.weak_equiv", "HTTPEntityTag");
  }
  bool return_value = (*(const HTTPEntityTag*)local_this).weak_equiv(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "weak_equiv(HTTPEntityTag self, const HTTPEntityTag other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_weak_equiv_228_comment =
  "C++ Interface:\n"
  "weak_equiv(HTTPEntityTag self, const HTTPEntityTag other)\n"
  "\n"
  "/**\n"
  " * Returns true if the two tags have \"weak\" equivalence: they are the same\n"
  " * tag, and one or both may be \"weak\".\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_weak_equiv_228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int HTTPEntityTag::compare_to(HTTPEntityTag const &other) const
 */
static PyObject *Dtool_HTTPEntityTag_compare_to_232(PyObject *self, PyObject *arg) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int HTTPEntityTag::compare_to(HTTPEntityTag const &other) const
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPEntityTag.compare_to", "HTTPEntityTag");
  }
  int return_value = (*(const HTTPEntityTag*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(HTTPEntityTag self, const HTTPEntityTag other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_compare_to_232_comment =
  "C++ Interface:\n"
  "compare_to(HTTPEntityTag self, const HTTPEntityTag other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this HTTPEntityTag sorts before the\n"
  " * other one, greater than zero if it sorts after, or zero if they are\n"
  " * equivalent.\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_compare_to_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPEntityTag::output(ostream &out) const
 */
static PyObject *Dtool_HTTPEntityTag_output_233(PyObject *self, PyObject *arg) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void HTTPEntityTag::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HTTPEntityTag.output", false, true);
  if (arg_this != NULL) {
    (*(const HTTPEntityTag*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(HTTPEntityTag self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPEntityTag_output_233_comment =
  "C++ Interface:\n"
  "output(HTTPEntityTag self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HTTPEntityTag_output_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPEntityTag::HTTPEntityTag(void)
 * inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &copy)
 * inline HTTPEntityTag::HTTPEntityTag(bool weak, std::string const &tag)
 * HTTPEntityTag::HTTPEntityTag(std::string const &text)
 */
static int Dtool_Init_HTTPEntityTag(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline HTTPEntityTag::HTTPEntityTag(void)
      HTTPEntityTag *return_value = new HTTPEntityTag();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEntityTag, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:HTTPEntityTag", (char **)keyword_list, &param0)) {
          HTTPEntityTag const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_HTTPEntityTag, (void **)&param0_this);
          if (param0_this != NULL) {
            HTTPEntityTag *return_value = new HTTPEntityTag(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEntityTag, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 HTTPEntityTag::HTTPEntityTag(std::string const &text)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"text", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:HTTPEntityTag", (char **)keyword_list, &param0_str, &param0_len)) {
          HTTPEntityTag *return_value = new HTTPEntityTag(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEntityTag, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline HTTPEntityTag::HTTPEntityTag(HTTPEntityTag const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:HTTPEntityTag", (char **)keyword_list, &param0)) {
          HTTPEntityTag const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_HTTPEntityTag(param0, param0_this, param0_manage)) {
            HTTPEntityTag *return_value = new HTTPEntityTag(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEntityTag, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: HTTPEntityTag::HTTPEntityTag(std::string const &text)
    }
    break;
  case 2:
    {
      // 1-inline HTTPEntityTag::HTTPEntityTag(bool weak, std::string const &tag)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"weak", "tag", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:HTTPEntityTag", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        HTTPEntityTag *return_value = new HTTPEntityTag((PyObject_IsTrue(param0) != 0), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPEntityTag, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HTTPEntityTag() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HTTPEntityTag()\n"
      "HTTPEntityTag(const HTTPEntityTag copy)\n"
      "HTTPEntityTag(str text)\n"
      "HTTPEntityTag(bool weak, str tag)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_HTTPEntityTag(PyObject *args, HTTPEntityTag const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HTTPEntityTag, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HTTPEntityTag::HTTPEntityTag(std::string const &text)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      HTTPEntityTag *return_value = new HTTPEntityTag(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline HTTPEntityTag::HTTPEntityTag(bool weak, std::string const &tag)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:HTTPEntityTag", &param0, &param1_str, &param1_len)) {
        HTTPEntityTag *return_value = new HTTPEntityTag((PyObject_IsTrue(param0) != 0), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_HTTPEntityTag(PyObject *args, HTTPEntityTag *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_HTTPEntityTag, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-HTTPEntityTag::HTTPEntityTag(std::string const &text)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      HTTPEntityTag *return_value = new HTTPEntityTag(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline HTTPEntityTag::HTTPEntityTag(bool weak, std::string const &tag)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:HTTPEntityTag", &param0, &param1_str, &param1_len)) {
        HTTPEntityTag *return_value = new HTTPEntityTag((PyObject_IsTrue(param0) != 0), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_HTTPEntityTag(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HTTPEntityTag) {
    printf("HTTPEntityTag ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HTTPEntityTag *local_this = (HTTPEntityTag *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HTTPEntityTag) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HTTPEntityTag(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HTTPEntityTag) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DocumentSpec
 */
/**
 * Python function wrapper for:
 * inline void DocumentSpec::operator =(DocumentSpec const &copy)
 */
static PyObject *Dtool_DocumentSpec_operator_237(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.assign")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::operator =(DocumentSpec const &copy)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.assign", "DocumentSpec");
  }
  (*local_this).operator =(*arg_this);
  DocumentSpec *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DocumentSpec, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const DocumentSpec self, const DocumentSpec copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_operator_237_comment =
  "C++ Interface:\n"
  "assign(const DocumentSpec self, const DocumentSpec copy)\n";
#else
static const char *Dtool_DocumentSpec_operator_237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DocumentSpec::compare_to(DocumentSpec const &other) const
 */
static PyObject *Dtool_DocumentSpec_compare_to_241(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DocumentSpec::compare_to(DocumentSpec const &other) const
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.compare_to", "DocumentSpec");
  }
  int return_value = (*(const DocumentSpec*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(DocumentSpec self, const DocumentSpec other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_compare_to_241_comment =
  "C++ Interface:\n"
  "compare_to(DocumentSpec self, const DocumentSpec other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DocumentSpec_compare_to_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::set_url(URLSpec const &url)
 */
static PyObject *Dtool_DocumentSpec_set_url_242(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.set_url")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::set_url(URLSpec const &url)
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.set_url", "URLSpec");
  }
  (*local_this).set_url(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_url(const DocumentSpec self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_set_url_242_comment =
  "C++ Interface:\n"
  "set_url(const DocumentSpec self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Changes the URL of the DocumentSpec without modifying its other properties.\n"
  " * Normally this would be a strange thing to do, because the tag and date are\n"
  " * usually strongly associated with the URL.  To get a DocumentSpec pointing\n"
  " * to a new URL, you would normally create a new DocumentSpec object.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_set_url_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline URLSpec const &DocumentSpec::get_url(void) const
 */
static PyObject *Dtool_DocumentSpec_get_url_243(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline URLSpec const &DocumentSpec::get_url(void) const
  URLSpec const *return_value = &((*(const DocumentSpec*)local_this).get_url());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_get_url_243_comment =
  "C++ Interface:\n"
  "get_url(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Retrieves the URL of the DocumentSpec.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_get_url_243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::set_tag(HTTPEntityTag const &tag)
 */
static PyObject *Dtool_DocumentSpec_set_tag_244(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.set_tag")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::set_tag(HTTPEntityTag const &tag)
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.set_tag", "HTTPEntityTag");
  }
  (*local_this).set_tag(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag(const DocumentSpec self, const HTTPEntityTag tag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_set_tag_244_comment =
  "C++ Interface:\n"
  "set_tag(const DocumentSpec self, const HTTPEntityTag tag)\n"
  "\n"
  "/**\n"
  " * Changes the identity tag associated with the DocumentSpec.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_set_tag_244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DocumentSpec::has_tag(void) const
 */
static PyObject *Dtool_DocumentSpec_has_tag_245(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DocumentSpec::has_tag(void) const
  bool return_value = (*(const DocumentSpec*)local_this).has_tag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_has_tag_245_comment =
  "C++ Interface:\n"
  "has_tag(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if an identity tag is associated with the DocumentSpec.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_has_tag_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPEntityTag const &DocumentSpec::get_tag(void) const
 */
static PyObject *Dtool_DocumentSpec_get_tag_246(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPEntityTag const &DocumentSpec::get_tag(void) const
  HTTPEntityTag const *return_value = &((*(const DocumentSpec*)local_this).get_tag());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPEntityTag, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_get_tag_246_comment =
  "C++ Interface:\n"
  "get_tag(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the identity tag associated with the DocumentSpec, if there is one.\n"
  " * It is an error to call this if has_tag() returns false.\n"
  " *\n"
  " * The identity tag is set by the HTTP server to uniquely refer to a\n"
  " * particular version of a document.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_get_tag_246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::clear_tag(void)
 */
static PyObject *Dtool_DocumentSpec_clear_tag_247(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.clear_tag")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::clear_tag(void)
  (*local_this).clear_tag();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_clear_tag_247_comment =
  "C++ Interface:\n"
  "clear_tag(const DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Removes the identity tag associated with the DocumentSpec, if there is one.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_clear_tag_247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::set_date(HTTPDate const &date)
 */
static PyObject *Dtool_DocumentSpec_set_date_248(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.set_date")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::set_date(HTTPDate const &date)
  HTTPDate const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.set_date", "HTTPDate");
  }
  (*local_this).set_date(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_date(const DocumentSpec self, const HTTPDate date)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_set_date_248_comment =
  "C++ Interface:\n"
  "set_date(const DocumentSpec self, const HTTPDate date)\n"
  "\n"
  "/**\n"
  " * Changes the last-modified date associated with the DocumentSpec.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_set_date_248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DocumentSpec::has_date(void) const
 */
static PyObject *Dtool_DocumentSpec_has_date_249(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool DocumentSpec::has_date(void) const
  bool return_value = (*(const DocumentSpec*)local_this).has_date();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_has_date_249_comment =
  "C++ Interface:\n"
  "has_date(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Returns true if a last-modified date is associated with the DocumentSpec.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_has_date_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPDate const &DocumentSpec::get_date(void) const
 */
static PyObject *Dtool_DocumentSpec_get_date_250(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPDate const &DocumentSpec::get_date(void) const
  HTTPDate const *return_value = &((*(const DocumentSpec*)local_this).get_date());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_get_date_250_comment =
  "C++ Interface:\n"
  "get_date(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the last-modified date associated with the DocumentSpec, if there\n"
  " * is one.  It is an error to call this if has_date() returns false.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_get_date_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::clear_date(void)
 */
static PyObject *Dtool_DocumentSpec_clear_date_251(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.clear_date")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::clear_date(void)
  (*local_this).clear_date();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_clear_date_251_comment =
  "C++ Interface:\n"
  "clear_date(const DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Removes the last-modified date associated with the DocumentSpec, if there\n"
  " * is one.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_clear_date_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode)
 */
static PyObject *Dtool_DocumentSpec_set_request_mode_253(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.set_request_mode")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_request_mode((DocumentSpec::RequestMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_request_mode(const DocumentSpec self, int request_mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_set_request_mode_253_comment =
  "C++ Interface:\n"
  "set_request_mode(const DocumentSpec self, int request_mode)\n"
  "\n"
  "/**\n"
  " * Sets the request mode of this DocumentSpec.  This is only relevant when\n"
  " * using the DocumentSpec to generate a request (for instance, in\n"
  " * HTTPChannel).  This specifies whether the document request will ask the\n"
  " * server for a newer version than the indicated version, or the exact\n"
  " * version, neither, or either.\n"
  " *\n"
  " * The possible values are:\n"
  " *\n"
  " * RM_any: ignore date and tag (if specified), and retrieve any document that\n"
  " * matches the URL.  For a subrange request, if the document matches the\n"
  " * version indicated exactly, retrieve the subrange only; otherwise, retrieve\n"
  " * the entire document.\n"
  " *\n"
  " * RM_equal: request only the precise version of the document that matches the\n"
  " * particular date and/or tag exactly, if specified; fail if this version is\n"
  " * not available.\n"
  " *\n"
  " * RM_newer: request any document that is newer than the version indicated by\n"
  " * the particular date and/or tag; fail if only that version (or older\n"
  " * versions) are available.\n"
  " *\n"
  " * RM_newer_or_equal: request any document that matches the version indicated\n"
  " * by the particular date and/or tag, or is a newer version; fail if only\n"
  " * older versions are available.\n"
  " *\n"
  " * In any of the above, you may specify either or both of the last-modified\n"
  " * date and the identity tag, whichever is known to the client.\n"
  " *\n"
  " * The default mode is RM_any.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_set_request_mode_253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const
 */
static PyObject *Dtool_DocumentSpec_get_request_mode_254(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const
  DocumentSpec::RequestMode return_value = (*(const DocumentSpec*)local_this).get_request_mode();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_get_request_mode_254_comment =
  "C++ Interface:\n"
  "get_request_mode(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the request mode of this DocumentSpec.  See set_request_mode().\n"
  " */";
#else
static const char *Dtool_DocumentSpec_get_request_mode_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control)
 */
static PyObject *Dtool_DocumentSpec_set_cache_control_256(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.set_cache_control")) {
    return NULL;
  }
  // 1-inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_cache_control((DocumentSpec::CacheControl)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_control(const DocumentSpec self, int cache_control)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_set_cache_control_256_comment =
  "C++ Interface:\n"
  "set_cache_control(const DocumentSpec self, int cache_control)\n"
  "\n"
  "/**\n"
  " * Specifies what kind of cached value is acceptable for this document.\n"
  " * Warning: some HTTP proxies may not respect this setting and may return a\n"
  " * cached result anyway.\n"
  " *\n"
  " * CC_allow_cache: the normal HTTP behavior; the server may return a cached\n"
  " * value if it believes it is valid.\n"
  " *\n"
  " * CC_revalidate: a proxy is forced to contact the origin server and verify\n"
  " * that is cached value is in fact still valid before it returns it.\n"
  " *\n"
  " * CC_no_cache: a proxy must not return its cached value at all, but is forced\n"
  " * to go all the way back to the origin server for the official document.\n"
  " *\n"
  " * The default mode is CC_allow_cache.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_set_cache_control_256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const
 */
static PyObject *Dtool_DocumentSpec_get_cache_control_257(PyObject *self, PyObject *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const
  DocumentSpec::CacheControl return_value = (*(const DocumentSpec*)local_this).get_cache_control();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_get_cache_control_257_comment =
  "C++ Interface:\n"
  "get_cache_control(DocumentSpec self)\n"
  "\n"
  "/**\n"
  " * Returns the request mode of this DocumentSpec.  See set_cache_control().\n"
  " */";
#else
static const char *Dtool_DocumentSpec_get_cache_control_257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DocumentSpec::input(istream &in)
 */
static PyObject *Dtool_DocumentSpec_input_258(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.input")) {
    return NULL;
  }
  // 1-bool DocumentSpec::input(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "DocumentSpec.input", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).input(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input(const DocumentSpec self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_input_258_comment =
  "C++ Interface:\n"
  "input(const DocumentSpec self, istream in)\n"
  "\n"
  "/**\n"
  " * Can be used to read in the DocumentSpec from a stream generated either by\n"
  " * output() or write().  Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_DocumentSpec_input_258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DocumentSpec::output(ostream &out) const
 */
static PyObject *Dtool_DocumentSpec_output_259(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DocumentSpec::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DocumentSpec.output", false, true);
  if (arg_this != NULL) {
    (*(const DocumentSpec*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DocumentSpec self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_output_259_comment =
  "C++ Interface:\n"
  "output(DocumentSpec self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DocumentSpec_output_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DocumentSpec::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DocumentSpec_write_260(PyObject *self, PyObject *args, PyObject *kwds) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DocumentSpec::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DocumentSpec.write", false, true);
    if (param1_this != NULL) {
      (*(const DocumentSpec*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DocumentSpec self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DocumentSpec_write_260_comment =
  "C++ Interface:\n"
  "write(DocumentSpec self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DocumentSpec_write_260_comment = NULL;
#endif

static PyObject *Dtool_DocumentSpec_url_Getter(PyObject *self, void *) {
  const DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline URLSpec const &DocumentSpec::get_url(void) const
  URLSpec const *return_value = &((*(const DocumentSpec*)local_this).get_url());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, true);
}

static int Dtool_DocumentSpec_url_Setter(PyObject *self, PyObject *arg, void *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.url")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete url attribute");
    return -1;
  }
  // 1-inline void DocumentSpec::set_url(URLSpec const &url)
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.set_url", "URLSpec");
    return -1;
  }
  (*local_this).set_url(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_url(const DocumentSpec self, const URLSpec url)\n");
  }
  return -1;
}

static PyObject *Dtool_DocumentSpec_tag_Getter(PyObject *self, void *) {
  const DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_tag()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline HTTPEntityTag const &DocumentSpec::get_tag(void) const
  HTTPEntityTag const *return_value = &((*(const DocumentSpec*)local_this).get_tag());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPEntityTag, false, true);
}

static int Dtool_DocumentSpec_tag_Setter(PyObject *self, PyObject *arg, void *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.tag")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete tag attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_tag();
    return 0;
  }
  // 1-inline void DocumentSpec::set_tag(HTTPEntityTag const &tag)
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.set_tag", "HTTPEntityTag");
    return -1;
  }
  (*local_this).set_tag(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tag(const DocumentSpec self, const HTTPEntityTag tag)\n");
  }
  return -1;
}

static PyObject *Dtool_DocumentSpec_date_Getter(PyObject *self, void *) {
  const DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_date()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline HTTPDate const &DocumentSpec::get_date(void) const
  HTTPDate const *return_value = &((*(const DocumentSpec*)local_this).get_date());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, false, true);
}

static int Dtool_DocumentSpec_date_Setter(PyObject *self, PyObject *arg, void *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.date")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete date attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_date();
    return 0;
  }
  // 1-inline void DocumentSpec::set_date(HTTPDate const &date)
  HTTPDate const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.set_date", "HTTPDate");
    return -1;
  }
  (*local_this).set_date(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_date(const DocumentSpec self, const HTTPDate date)\n");
  }
  return -1;
}

static PyObject *Dtool_DocumentSpec_request_mode_Getter(PyObject *self, void *) {
  const DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DocumentSpec::RequestMode DocumentSpec::get_request_mode(void) const
  DocumentSpec::RequestMode return_value = (*(const DocumentSpec*)local_this).get_request_mode();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DocumentSpec_request_mode_Setter(PyObject *self, PyObject *arg, void *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.request_mode")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete request_mode attribute");
    return -1;
  }
  // 1-inline void DocumentSpec::set_request_mode(DocumentSpec::RequestMode request_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_request_mode((DocumentSpec::RequestMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_request_mode(const DocumentSpec self, int request_mode)\n");
  }
  return -1;
}

static PyObject *Dtool_DocumentSpec_cache_control_Getter(PyObject *self, void *) {
  const DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DocumentSpec::CacheControl DocumentSpec::get_cache_control(void) const
  DocumentSpec::CacheControl return_value = (*(const DocumentSpec*)local_this).get_cache_control();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DocumentSpec_cache_control_Setter(PyObject *self, PyObject *arg, void *) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DocumentSpec, (void **)&local_this, "DocumentSpec.cache_control")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete cache_control attribute");
    return -1;
  }
  // 1-inline void DocumentSpec::set_cache_control(DocumentSpec::CacheControl cache_control)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_cache_control((DocumentSpec::CacheControl)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_control(const DocumentSpec self, int cache_control)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline DocumentSpec::DocumentSpec(void)
 * inline DocumentSpec::DocumentSpec(DocumentSpec const &copy)
 * inline DocumentSpec::DocumentSpec(URLSpec const &url)
 * inline DocumentSpec::DocumentSpec(std::string const &url)
 */
static int Dtool_Init_DocumentSpec(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DocumentSpec::DocumentSpec(void)
      DocumentSpec *return_value = new DocumentSpec();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DocumentSpec, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline DocumentSpec::DocumentSpec(URLSpec const &url)
        PyObject *param0;
        static const char *keyword_list[] = {"url", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DocumentSpec", (char **)keyword_list, &param0)) {
          URLSpec const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_URLSpec, (void **)&param0_this);
          if (param0_this != NULL) {
            DocumentSpec *return_value = new DocumentSpec(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DocumentSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DocumentSpec::DocumentSpec(DocumentSpec const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DocumentSpec", (char **)keyword_list, &param0)) {
          DocumentSpec const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_DocumentSpec, (void **)&param0_this);
          if (param0_this != NULL) {
            DocumentSpec *return_value = new DocumentSpec(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DocumentSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DocumentSpec::DocumentSpec(std::string const &url)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"url", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:DocumentSpec", (char **)keyword_list, &param0_str, &param0_len)) {
          DocumentSpec *return_value = new DocumentSpec(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DocumentSpec, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline DocumentSpec::DocumentSpec(URLSpec const &url)
        PyObject *param0;
        static const char *keyword_list[] = {"url", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DocumentSpec", (char **)keyword_list, &param0)) {
          URLSpec const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_URLSpec(param0, param0_this, param0_manage)) {
            DocumentSpec *return_value = new DocumentSpec(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DocumentSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DocumentSpec::DocumentSpec(DocumentSpec const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DocumentSpec", (char **)keyword_list, &param0)) {
          DocumentSpec const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_DocumentSpec(param0, param0_this, param0_manage)) {
            DocumentSpec *return_value = new DocumentSpec(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DocumentSpec, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline DocumentSpec::DocumentSpec(std::string const &url)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DocumentSpec() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DocumentSpec()\n"
      "DocumentSpec(const URLSpec url)\n"
      "DocumentSpec(const DocumentSpec copy)\n"
      "DocumentSpec(str url)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DocumentSpec(PyObject *args, DocumentSpec const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DocumentSpec, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline DocumentSpec::DocumentSpec(URLSpec const &url)
      URLSpec const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_URLSpec, (void **)&arg_this);
      if (arg_this != NULL) {
        DocumentSpec *return_value = new DocumentSpec(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline DocumentSpec::DocumentSpec(std::string const &url)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        DocumentSpec *return_value = new DocumentSpec(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

  }
  return false;
}

bool Dtool_Coerce_DocumentSpec(PyObject *args, DocumentSpec *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DocumentSpec, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline DocumentSpec::DocumentSpec(URLSpec const &url)
      URLSpec const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_URLSpec, (void **)&arg_this);
      if (arg_this != NULL) {
        DocumentSpec *return_value = new DocumentSpec(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

    {
      // -2 inline DocumentSpec::DocumentSpec(std::string const &url)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        DocumentSpec *return_value = new DocumentSpec(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

  }
  return false;
}

static void *Dtool_UpcastInterface_DocumentSpec(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DocumentSpec) {
    printf("DocumentSpec ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DocumentSpec *local_this = (DocumentSpec *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DocumentSpec) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DocumentSpec(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DocumentSpec) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HTTPChannel
 */
/**
 * Python function wrapper for:
 * inline HTTPClient *HTTPChannel::get_client(void) const
 */
static PyObject *Dtool_HTTPChannel_get_client_273(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPClient *HTTPChannel::get_client(void) const
  HTTPClient *return_value = (*(const HTTPChannel*)local_this).get_client();
  if (return_value != (HTTPClient *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (HTTPClient *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPClient, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_client_273_comment =
  "C++ Interface:\n"
  "get_client(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the HTTPClient object that owns this channel.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_client_273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::is_valid(void) const
 */
static PyObject *Dtool_HTTPChannel_is_valid_274(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::is_valid(void) const
  bool return_value = (*(const HTTPChannel*)local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_is_valid_274_comment =
  "C++ Interface:\n"
  "is_valid(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns true if the last-requested document was successfully retrieved and\n"
  " * is ready to be read, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_is_valid_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::is_connection_ready(void) const
 */
static PyObject *Dtool_HTTPChannel_is_connection_ready_275(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::is_connection_ready(void) const
  bool return_value = (*(const HTTPChannel*)local_this).is_connection_ready();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_is_connection_ready_275_comment =
  "C++ Interface:\n"
  "is_connection_ready(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns true if a connection has been established to the named server in a\n"
  " * previous call to connect_to() or begin_connect_to(), false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_is_connection_ready_275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline URLSpec const &HTTPChannel::get_url(void) const
 */
static PyObject *Dtool_HTTPChannel_get_url_276(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline URLSpec const &HTTPChannel::get_url(void) const
  URLSpec const *return_value = &((*(const HTTPChannel*)local_this).get_url());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, true);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_url_276_comment =
  "C++ Interface:\n"
  "get_url(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the URL that was used to retrieve the most recent document:\n"
  " * whatever URL was last passed to get_document() or get_header().  If a\n"
  " * redirect has transparently occurred, this will return the new, redirected\n"
  " * URL (the actual URL at which the document was located).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_url_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DocumentSpec const &HTTPChannel::get_document_spec(void) const
 */
static PyObject *Dtool_HTTPChannel_get_document_spec_277(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DocumentSpec const &HTTPChannel::get_document_spec(void) const
  DocumentSpec const *return_value = &((*(const HTTPChannel*)local_this).get_document_spec());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DocumentSpec, false, true);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_document_spec_277_comment =
  "C++ Interface:\n"
  "get_document_spec(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the DocumentSpec associated with the most recent document.  This\n"
  " * includes its actual URL (following redirects) along with the identity tag\n"
  " * and last-modified date, if supplied by the server.\n"
  " *\n"
  " * This structure may be saved and used to retrieve the same version of the\n"
  " * document later, or to conditionally retrieve a newer version if it is\n"
  " * available.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_document_spec_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPEnum::HTTPVersion HTTPChannel::get_http_version(void) const
 */
static PyObject *Dtool_HTTPChannel_get_http_version_278(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPEnum::HTTPVersion HTTPChannel::get_http_version(void) const
  HTTPEnum::HTTPVersion return_value = (*(const HTTPChannel*)local_this).get_http_version();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_http_version_278_comment =
  "C++ Interface:\n"
  "get_http_version(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the HTTP version number returned by the server, as one of the\n"
  " * HTTPClient enumerated types, e.g.  HTTPClient::HV_11.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_http_version_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPChannel::get_http_version_string(void) const
 */
static PyObject *Dtool_HTTPChannel_get_http_version_string_279(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPChannel::get_http_version_string(void) const
  std::string const &return_value = (*(const HTTPChannel*)local_this).get_http_version_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_http_version_string_279_comment =
  "C++ Interface:\n"
  "get_http_version_string(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the HTTP version number returned by the server, formatted as a\n"
  " * string, e.g.  \"HTTP/1.1\".\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_http_version_string_279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int HTTPChannel::get_status_code(void) const
 */
static PyObject *Dtool_HTTPChannel_get_status_code_280(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int HTTPChannel::get_status_code(void) const
  int return_value = (*(const HTTPChannel*)local_this).get_status_code();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_status_code_280_comment =
  "C++ Interface:\n"
  "get_status_code(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the HTML return code from the document retrieval request.  This\n"
  " * will be in the 200 range if the document is successfully retrieved, or some\n"
  " * other value in the case of an error.\n"
  " *\n"
  " * Some proxy errors during an https-over-proxy request would return the same\n"
  " * status code as a different error that occurred on the host server.  To\n"
  " * differentiate these cases, status codes that are returned by the proxy\n"
  " * during the CONNECT phase (except code 407) are incremented by 1000.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_status_code_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPChannel::get_status_string(void) const
 */
static PyObject *Dtool_HTTPChannel_get_status_string_281(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPChannel::get_status_string(void) const
  std::string return_value = (*(const HTTPChannel*)local_this).get_status_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_status_string_281_comment =
  "C++ Interface:\n"
  "get_status_string(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the string as returned by the server describing the status code for\n"
  " * humans.  This may or may not be meaningful.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_status_string_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPChannel::get_www_realm(void) const
 */
static PyObject *Dtool_HTTPChannel_get_www_realm_282(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPChannel::get_www_realm(void) const
  std::string const &return_value = (*(const HTTPChannel*)local_this).get_www_realm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_www_realm_282_comment =
  "C++ Interface:\n"
  "get_www_realm(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * If the document failed to connect because of a 401 (Authorization\n"
  " * required), this method will return the \"realm\" returned by the server in\n"
  " * which the requested document must be authenticated.  This string may be\n"
  " * presented to the user to request an associated username and password (which\n"
  " * then should be stored in HTTPClient::set_username()).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_www_realm_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &HTTPChannel::get_proxy_realm(void) const
 */
static PyObject *Dtool_HTTPChannel_get_proxy_realm_283(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &HTTPChannel::get_proxy_realm(void) const
  std::string const &return_value = (*(const HTTPChannel*)local_this).get_proxy_realm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_proxy_realm_283_comment =
  "C++ Interface:\n"
  "get_proxy_realm(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * If the document failed to connect because of a 407 (Proxy authorization\n"
  " * required), this method will return the \"realm\" returned by the proxy.  This\n"
  " * string may be presented to the user to request an associated username and\n"
  " * password (which then should be stored in HTTPClient::set_username()).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_proxy_realm_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline URLSpec const &HTTPChannel::get_redirect(void) const
 */
static PyObject *Dtool_HTTPChannel_get_redirect_284(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline URLSpec const &HTTPChannel::get_redirect(void) const
  URLSpec const *return_value = &((*(const HTTPChannel*)local_this).get_redirect());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, true);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_redirect_284_comment =
  "C++ Interface:\n"
  "get_redirect(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * If the document failed with a redirect code (300 series), this will\n"
  " * generally contain the new URL the server wants us to try.  In many cases,\n"
  " * the client will automatically follow redirects; if these are successful the\n"
  " * client will return a successful code and get_redirect() will return empty,\n"
  " * but get_url() will return the new, redirected URL.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_redirect_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HTTPChannel::get_header_value(std::string const &key) const
 */
static PyObject *Dtool_HTTPChannel_get_header_value_285(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HTTPChannel::get_header_value(std::string const &key) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    std::string return_value = (*(const HTTPChannel*)local_this).get_header_value(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_header_value(HTTPChannel self, str key)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_header_value_285_comment =
  "C++ Interface:\n"
  "get_header_value(HTTPChannel self, str key)\n"
  "\n"
  "/**\n"
  " * Returns the HTML header value associated with the indicated key, or empty\n"
  " * string if the key was not defined in the message returned by the server.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_header_value_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int HTTPChannel::get_num_redirect_steps(void) const
 */
static PyObject *Dtool_HTTPChannel_get_num_redirect_steps_286(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int HTTPChannel::get_num_redirect_steps(void) const
  int return_value = (*(const HTTPChannel*)local_this).get_num_redirect_steps();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_num_redirect_steps_286_comment =
  "C++ Interface:\n"
  "get_num_redirect_steps(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * If the document automatically followed one or more redirects, this will\n"
  " * return the number of redirects that were automatically followed.  Use\n"
  " * get_redirect_step() to retrieve each URL in sequence.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_num_redirect_steps_286_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline URLSpec const &HTTPChannel::get_redirect_step(int n) const
 */
static PyObject *Dtool_HTTPChannel_get_redirect_step_287(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline URLSpec const &HTTPChannel::get_redirect_step(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    URLSpec const *return_value = &((*(const HTTPChannel*)local_this).get_redirect_step((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_redirect_step(HTTPChannel self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_redirect_step_287_comment =
  "C++ Interface:\n"
  "get_redirect_step(HTTPChannel self, int n)\n"
  "\n"
  "/**\n"
  " * Use in conjunction with get_num_redirect_steps() to extract the chain of\n"
  " * URL's that the channel was automatically redirected through to arrive at\n"
  " * the final document.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_redirect_step_287_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_persistent_connection(bool persistent_connection)
 */
static PyObject *Dtool_HTTPChannel_set_persistent_connection_289(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_persistent_connection")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_persistent_connection(bool persistent_connection)
  (*local_this).set_persistent_connection((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_persistent_connection(const HTTPChannel self, bool persistent_connection)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_persistent_connection_289_comment =
  "C++ Interface:\n"
  "set_persistent_connection(const HTTPChannel self, bool persistent_connection)\n"
  "\n"
  "/**\n"
  " * Indicates whether the HTTPChannel should try to keep the connection to the\n"
  " * server open and reuse that connection for multiple documents, or whether it\n"
  " * should close the connection and open a new one for each request.  Set this\n"
  " * true to keep the connections around when possible, false to recycle them.\n"
  " *\n"
  " * It makes most sense to set this false when the HTTPChannel will be used\n"
  " * only once to retrieve a single document, true when you will be using the\n"
  " * same HTTPChannel object to retrieve multiple documents.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_persistent_connection_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_persistent_connection(void) const
 */
static PyObject *Dtool_HTTPChannel_get_persistent_connection_290(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_persistent_connection(void) const
  bool return_value = (*(const HTTPChannel*)local_this).get_persistent_connection();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_persistent_connection_290_comment =
  "C++ Interface:\n"
  "get_persistent_connection(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns whether the HTTPChannel should try to keep the connection to the\n"
  " * server open and reuse that connection for multiple documents, or whether it\n"
  " * should close the connection and open a new one for each request.  See\n"
  " * set_persistent_connection().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_persistent_connection_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPChannel::will_close_connection(void) const
 */
static PyObject *Dtool_HTTPChannel_will_close_connection_291(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool HTTPChannel::will_close_connection(void) const
  bool return_value = (*(const HTTPChannel*)local_this).will_close_connection();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_will_close_connection_291_comment =
  "C++ Interface:\n"
  "will_close_connection(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns true if the server has indicated it will close the connection after\n"
  " * this document has been read, or false if it will remain open (and future\n"
  " * documents may be requested on the same connection).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_will_close_connection_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_allow_proxy(bool allow_proxy)
 */
static PyObject *Dtool_HTTPChannel_set_allow_proxy_292(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_allow_proxy")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_allow_proxy(bool allow_proxy)
  (*local_this).set_allow_proxy((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_allow_proxy(const HTTPChannel self, bool allow_proxy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_allow_proxy_292_comment =
  "C++ Interface:\n"
  "set_allow_proxy(const HTTPChannel self, bool allow_proxy)\n"
  "\n"
  "/**\n"
  " * If this is true (the normal case), the HTTPClient will be consulted for\n"
  " * information about the proxy to be used for each connection via this\n"
  " * HTTPChannel.  If this has been set to false by the user, then all\n"
  " * connections will be made directly, regardless of the proxy settings\n"
  " * indicated on the HTTPClient.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_allow_proxy_292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_allow_proxy(void) const
 */
static PyObject *Dtool_HTTPChannel_get_allow_proxy_293(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_allow_proxy(void) const
  bool return_value = (*(const HTTPChannel*)local_this).get_allow_proxy();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_allow_proxy_293_comment =
  "C++ Interface:\n"
  "get_allow_proxy(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * If this is true (the normal case), the HTTPClient will be consulted for\n"
  " * information about the proxy to be used for each connection via this\n"
  " * HTTPChannel.  If this has been set to false by the user, then all\n"
  " * connections will be made directly, regardless of the proxy settings\n"
  " * indicated on the HTTPClient.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_allow_proxy_293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_proxy_tunnel(bool proxy_tunnel)
 */
static PyObject *Dtool_HTTPChannel_set_proxy_tunnel_294(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_proxy_tunnel")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_proxy_tunnel(bool proxy_tunnel)
  (*local_this).set_proxy_tunnel((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_proxy_tunnel(const HTTPChannel self, bool proxy_tunnel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_proxy_tunnel_294_comment =
  "C++ Interface:\n"
  "set_proxy_tunnel(const HTTPChannel self, bool proxy_tunnel)\n"
  "\n"
  "/**\n"
  " * Normally, a proxy is itself asked for ordinary URL's, and the proxy decides\n"
  " * whether to hand the client a cached version of the document or to contact\n"
  " * the server for a fresh version.  The proxy may also modify the headers and\n"
  " * transfer encoding on the way.\n"
  " *\n"
  " * If this is set to true, then instead of asking for URL's from the proxy, we\n"
  " * will ask the proxy to open a connection to the server (for instance, on\n"
  " * port 80); if the proxy honors this request, then we contact the server\n"
  " * directly through this connection to retrieve the document.  If the proxy\n"
  " * does not honor the connect request, then the retrieve operation fails.\n"
  " *\n"
  " * SSL connections (e.g.  https), and connections through a Socks proxy, are\n"
  " * always tunneled, regardless of the setting of this flag.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_proxy_tunnel_294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_proxy_tunnel(void) const
 */
static PyObject *Dtool_HTTPChannel_get_proxy_tunnel_295(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_proxy_tunnel(void) const
  bool return_value = (*(const HTTPChannel*)local_this).get_proxy_tunnel();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_proxy_tunnel_295_comment =
  "C++ Interface:\n"
  "get_proxy_tunnel(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns true if connections always tunnel through a proxy, or false (the\n"
  " * normal case) if we allow the proxy to serve up documents.  See\n"
  " * set_proxy_tunnel().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_proxy_tunnel_295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_connect_timeout(double timeout_seconds)
 */
static PyObject *Dtool_HTTPChannel_set_connect_timeout_296(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_connect_timeout")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_connect_timeout(double timeout_seconds)
  if (PyNumber_Check(arg)) {
    (*local_this).set_connect_timeout(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_connect_timeout(const HTTPChannel self, double timeout_seconds)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_connect_timeout_296_comment =
  "C++ Interface:\n"
  "set_connect_timeout(const HTTPChannel self, double timeout_seconds)\n"
  "\n"
  "/**\n"
  " * Sets the maximum length of time, in seconds, that the channel will wait\n"
  " * before giving up on establishing a TCP connection.\n"
  " *\n"
  " * At present, this is used only for the nonblocking interfaces (e.g.\n"
  " * begin_get_document(), begin_connect_to()), but it is used whether\n"
  " * set_blocking_connect() is true or false.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_connect_timeout_296_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double HTTPChannel::get_connect_timeout(void) const
 */
static PyObject *Dtool_HTTPChannel_get_connect_timeout_297(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double HTTPChannel::get_connect_timeout(void) const
  double return_value = (*(const HTTPChannel*)local_this).get_connect_timeout();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_connect_timeout_297_comment =
  "C++ Interface:\n"
  "get_connect_timeout(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the length of time, in seconds, to wait for a new nonblocking\n"
  " * socket to connect.  See set_connect_timeout().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_connect_timeout_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_blocking_connect(bool blocking_connect)
 */
static PyObject *Dtool_HTTPChannel_set_blocking_connect_298(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_blocking_connect")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_blocking_connect(bool blocking_connect)
  (*local_this).set_blocking_connect((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blocking_connect(const HTTPChannel self, bool blocking_connect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_blocking_connect_298_comment =
  "C++ Interface:\n"
  "set_blocking_connect(const HTTPChannel self, bool blocking_connect)\n"
  "\n"
  "/**\n"
  " * If this flag is true, a socket connect will block even for nonblocking I/O\n"
  " * calls like begin_get_document(), begin_connect_to(), etc.  If false, a\n"
  " * socket connect will not block for nonblocking I/O calls, but will block for\n"
  " * blocking I/O calls (get_document(), connect_to(), etc.).\n"
  " *\n"
  " * Setting this true is useful when you want to use non-blocking I/O once you\n"
  " * have established the connection, but you don't want to bother with polling\n"
  " * for the initial connection.  It's also useful when you don't particularly\n"
  " * care about non-blocking I/O, but you need to respect timeouts like\n"
  " * connect_timeout and http_timeout.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_blocking_connect_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_blocking_connect(void) const
 */
static PyObject *Dtool_HTTPChannel_get_blocking_connect_299(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_blocking_connect(void) const
  bool return_value = (*(const HTTPChannel*)local_this).get_blocking_connect();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_blocking_connect_299_comment =
  "C++ Interface:\n"
  "get_blocking_connect(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * If this flag is true, a socket connect will block even for nonblocking I/O\n"
  " * calls like begin_get_document(), begin_connect_to(), etc.  If false, a\n"
  " * socket connect will not block for nonblocking I/O calls, but will block for\n"
  " * blocking I/O calls (get_document(), connect_to(), etc.).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_blocking_connect_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_http_timeout(double timeout_seconds)
 */
static PyObject *Dtool_HTTPChannel_set_http_timeout_300(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_http_timeout")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_http_timeout(double timeout_seconds)
  if (PyNumber_Check(arg)) {
    (*local_this).set_http_timeout(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_http_timeout(const HTTPChannel self, double timeout_seconds)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_http_timeout_300_comment =
  "C++ Interface:\n"
  "set_http_timeout(const HTTPChannel self, double timeout_seconds)\n"
  "\n"
  "/**\n"
  " * Sets the maximum length of time, in seconds, that the channel will wait for\n"
  " * the HTTP server to finish sending its response to our request.\n"
  " *\n"
  " * The timer starts counting after the TCP connection has been established\n"
  " * (see set_connect_timeout(), above) and the request has been sent.\n"
  " *\n"
  " * At present, this is used only for the nonblocking interfaces (e.g.\n"
  " * begin_get_document(), begin_connect_to()), but it is used whether\n"
  " * set_blocking_connect() is true or false.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_http_timeout_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double HTTPChannel::get_http_timeout(void) const
 */
static PyObject *Dtool_HTTPChannel_get_http_timeout_301(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double HTTPChannel::get_http_timeout(void) const
  double return_value = (*(const HTTPChannel*)local_this).get_http_timeout();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_http_timeout_301_comment =
  "C++ Interface:\n"
  "get_http_timeout(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the length of time, in seconds, to wait for the HTTP server to\n"
  " * respond to our request.  See set_http_timeout().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_http_timeout_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_skip_body_size(std::size_t skip_body_size)
 */
static PyObject *Dtool_HTTPChannel_set_skip_body_size_302(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_skip_body_size")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_skip_body_size(std::size_t skip_body_size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_skip_body_size", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_skip_body_size((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_skip_body_size(const HTTPChannel self, int skip_body_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_skip_body_size_302_comment =
  "C++ Interface:\n"
  "set_skip_body_size(const HTTPChannel self, int skip_body_size)\n"
  "\n"
  "/**\n"
  " * Specifies the maximum number of bytes in a received (but unwanted) body\n"
  " * that will be skipped past, in order to reset to a new request.\n"
  " *\n"
  " * That is, if this HTTPChannel requests a file via get_document(), but does\n"
  " * not call download_to_ram(), download_to_file(), or open_read_body(), and\n"
  " * instead immediately requests a new file, then the HTTPChannel has a choice\n"
  " * whether to skip past the unwanted document, or to close the connection and\n"
  " * open a new one.  If the number of bytes to skip is more than this\n"
  " * threshold, the connection will be closed; otherwise, the data will simply\n"
  " * be read and discarded.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_skip_body_size_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_skip_body_size(void) const
 */
static PyObject *Dtool_HTTPChannel_get_skip_body_size_303(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_skip_body_size(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_skip_body_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_skip_body_size_303_comment =
  "C++ Interface:\n"
  "get_skip_body_size(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of bytes in a received (but unwanted) body that\n"
  " * will be skipped past, in order to reset to a new request.  See\n"
  " * set_skip_body_size().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_skip_body_size_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_idle_timeout(double idle_timeout)
 */
static PyObject *Dtool_HTTPChannel_set_idle_timeout_304(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_idle_timeout")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_idle_timeout(double idle_timeout)
  if (PyNumber_Check(arg)) {
    (*local_this).set_idle_timeout(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_idle_timeout(const HTTPChannel self, double idle_timeout)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_idle_timeout_304_comment =
  "C++ Interface:\n"
  "set_idle_timeout(const HTTPChannel self, double idle_timeout)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of time, in seconds, in which a previously-established\n"
  " * connection is allowed to remain open and unused.  If a previous connection\n"
  " * has remained unused for at least this number of seconds, it will be closed\n"
  " * and a new connection will be opened; otherwise, the same connection will be\n"
  " * reused for the next request (for this particular HTTPChannel).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_idle_timeout_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double HTTPChannel::get_idle_timeout(void) const
 */
static PyObject *Dtool_HTTPChannel_get_idle_timeout_305(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double HTTPChannel::get_idle_timeout(void) const
  double return_value = (*(const HTTPChannel*)local_this).get_idle_timeout();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_idle_timeout_305_comment =
  "C++ Interface:\n"
  "get_idle_timeout(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time, in seconds, in which an previously-established\n"
  " * connection is allowed to remain open and unused.  See set_idle_timeout().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_idle_timeout_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_download_throttle(bool download_throttle)
 */
static PyObject *Dtool_HTTPChannel_set_download_throttle_306(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_download_throttle")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_download_throttle(bool download_throttle)
  (*local_this).set_download_throttle((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_download_throttle(const HTTPChannel self, bool download_throttle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_download_throttle_306_comment =
  "C++ Interface:\n"
  "set_download_throttle(const HTTPChannel self, bool download_throttle)\n"
  "\n"
  "/**\n"
  " * Specifies whether nonblocking downloads (via download_to_file() or\n"
  " * download_to_ram()) will be limited so as not to use all available\n"
  " * bandwidth.\n"
  " *\n"
  " * If this is true, when a download has been started on this channel it will\n"
  " * be invoked no more frequently than get_max_updates_per_second(), and the\n"
  " * total bandwidth used by the download will be no more than\n"
  " * get_max_bytes_per_second().  If this is false, downloads will proceed as\n"
  " * fast as the server can send the data.\n"
  " *\n"
  " * This only has effect on the nonblocking I/O methods like\n"
  " * begin_get_document(), etc.  The blocking methods like get_document() always\n"
  " * use as much CPU and bandwidth as they can get.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_download_throttle_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_download_throttle(void) const
 */
static PyObject *Dtool_HTTPChannel_get_download_throttle_307(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_download_throttle(void) const
  bool return_value = (*(const HTTPChannel*)local_this).get_download_throttle();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_download_throttle_307_comment =
  "C++ Interface:\n"
  "get_download_throttle(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns whether the nonblocking downloads will be bandwidth-limited.  See\n"
  " * set_download_throttle().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_download_throttle_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_max_bytes_per_second(double max_bytes_per_second)
 */
static PyObject *Dtool_HTTPChannel_set_max_bytes_per_second_308(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_max_bytes_per_second")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_max_bytes_per_second(double max_bytes_per_second)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_bytes_per_second(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_bytes_per_second(const HTTPChannel self, double max_bytes_per_second)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_max_bytes_per_second_308_comment =
  "C++ Interface:\n"
  "set_max_bytes_per_second(const HTTPChannel self, double max_bytes_per_second)\n"
  "\n"
  "/**\n"
  " * When bandwidth throttling is in effect (see set_download_throttle()), this\n"
  " * specifies the maximum number of bytes per second that may be consumed by\n"
  " * this channel.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_max_bytes_per_second_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double HTTPChannel::get_max_bytes_per_second(void) const
 */
static PyObject *Dtool_HTTPChannel_get_max_bytes_per_second_309(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double HTTPChannel::get_max_bytes_per_second(void) const
  double return_value = (*(const HTTPChannel*)local_this).get_max_bytes_per_second();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_max_bytes_per_second_309_comment =
  "C++ Interface:\n"
  "get_max_bytes_per_second(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of bytes per second that may be consumed by this\n"
  " * channel when get_download_throttle() is true.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_max_bytes_per_second_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_max_updates_per_second(double max_updates_per_second)
 */
static PyObject *Dtool_HTTPChannel_set_max_updates_per_second_310(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_max_updates_per_second")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_max_updates_per_second(double max_updates_per_second)
  if (PyNumber_Check(arg)) {
    (*local_this).set_max_updates_per_second(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_updates_per_second(const HTTPChannel self, double max_updates_per_second)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_max_updates_per_second_310_comment =
  "C++ Interface:\n"
  "set_max_updates_per_second(const HTTPChannel self, double max_updates_per_second)\n"
  "\n"
  "/**\n"
  " * When bandwidth throttling is in effect (see set_download_throttle()), this\n"
  " * specifies the maximum number of times per second that run() will attempt to\n"
  " * do any downloading at all.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_max_updates_per_second_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double HTTPChannel::get_max_updates_per_second(void) const
 */
static PyObject *Dtool_HTTPChannel_get_max_updates_per_second_311(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double HTTPChannel::get_max_updates_per_second(void) const
  double return_value = (*(const HTTPChannel*)local_this).get_max_updates_per_second();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_max_updates_per_second_311_comment =
  "C++ Interface:\n"
  "get_max_updates_per_second(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of times per second that run() will do anything\n"
  " * at all, when get_download_throttle() is true.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_max_updates_per_second_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::set_expected_file_size(std::size_t file_size)
 */
static PyObject *Dtool_HTTPChannel_set_expected_file_size_312(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.set_expected_file_size")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::set_expected_file_size(std::size_t file_size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_expected_file_size", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_expected_file_size((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_expected_file_size(const HTTPChannel self, int file_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_set_expected_file_size_312_comment =
  "C++ Interface:\n"
  "set_expected_file_size(const HTTPChannel self, int file_size)\n"
  "\n"
  "/**\n"
  " * This may be called immediately after a call to get_document() or some\n"
  " * related function to specify the expected size of the document we are\n"
  " * retrieving, if we happen to know.  This is used as the return value to\n"
  " * get_file_size() only in the case that the server does not tell us the\n"
  " * actual file size.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_set_expected_file_size_312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * streamsize HTTPChannel::get_file_size(void) const
 */
static PyObject *Dtool_HTTPChannel_get_file_size_313(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-streamsize HTTPChannel::get_file_size(void) const
  streamsize return_value = (*(const HTTPChannel*)local_this).get_file_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_file_size_313_comment =
  "C++ Interface:\n"
  "get_file_size(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the file, if it is known.  Returns the value set by\n"
  " * set_expected_file_size() if the file size is not known, or 0 if this value\n"
  " * was not set.\n"
  " *\n"
  " * If the file is dynamically generated, the size may not be available until a\n"
  " * read has started (e.g.  open_read_body() has been called); and even then it\n"
  " * may increase as more of the file is read due to the nature of HTTP/1.1\n"
  " * requests which can change their minds midstream about how much data they're\n"
  " * sending you.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_file_size_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::is_file_size_known(void) const
 */
static PyObject *Dtool_HTTPChannel_is_file_size_known_314(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::is_file_size_known(void) const
  bool return_value = (*(const HTTPChannel*)local_this).is_file_size_known();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_is_file_size_known_314_comment =
  "C++ Interface:\n"
  "is_file_size_known(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns true if the size of the file we are currently retrieving was told\n"
  " * us by the server and thus is reliably known, or false if the size reported\n"
  " * by get_file_size() represents an educated guess (possibly as set by\n"
  " * set_expected_file_size(), or as inferred from a chunked transfer encoding\n"
  " * in progress).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_is_file_size_known_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_first_byte_requested(void) const
 */
static PyObject *Dtool_HTTPChannel_get_first_byte_requested_315(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_first_byte_requested(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_first_byte_requested();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_first_byte_requested_315_comment =
  "C++ Interface:\n"
  "get_first_byte_requested(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the first byte of the file requested by the request.  This will\n"
  " * normally be 0 to indicate that the file is being requested from the\n"
  " * beginning, but if the file was requested via a get_subdocument() call, this\n"
  " * will contain the first_byte parameter from that call.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_first_byte_requested_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_last_byte_requested(void) const
 */
static PyObject *Dtool_HTTPChannel_get_last_byte_requested_316(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_last_byte_requested(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_last_byte_requested();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_last_byte_requested_316_comment =
  "C++ Interface:\n"
  "get_last_byte_requested(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the last byte of the file requested by the request.  This will\n"
  " * normally be 0 to indicate that the file is being requested to its last\n"
  " * byte, but if the file was requested via a get_subdocument() call, this will\n"
  " * contain the last_byte parameter from that call.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_last_byte_requested_316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_first_byte_delivered(void) const
 */
static PyObject *Dtool_HTTPChannel_get_first_byte_delivered_317(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_first_byte_delivered(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_first_byte_delivered();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_first_byte_delivered_317_comment =
  "C++ Interface:\n"
  "get_first_byte_delivered(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the first byte of the file (that will be) delivered by the server\n"
  " * in response to the current request.  Normally, this is the same as\n"
  " * get_first_byte_requested(), but some servers will ignore a subdocument\n"
  " * request and always return the whole file, in which case this value will be\n"
  " * 0, regardless of what was requested to get_subdocument().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_first_byte_delivered_317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_last_byte_delivered(void) const
 */
static PyObject *Dtool_HTTPChannel_get_last_byte_delivered_318(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_last_byte_delivered(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_last_byte_delivered();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_last_byte_delivered_318_comment =
  "C++ Interface:\n"
  "get_last_byte_delivered(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the last byte of the file (that will be) delivered by the server in\n"
  " * response to the current request.  Normally, this is the same as\n"
  " * get_last_byte_requested(), but some servers will ignore a subdocument\n"
  " * request and always return the whole file, in which case this value will be\n"
  " * 0, regardless of what was requested to get_subdocument().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_last_byte_delivered_318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPChannel::write_headers(ostream &out) const
 */
static PyObject *Dtool_HTTPChannel_write_headers_319(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HTTPChannel::write_headers(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HTTPChannel.write_headers", false, true);
  if (arg_this != NULL) {
    (*(const HTTPChannel*)local_this).write_headers(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_headers(HTTPChannel self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_write_headers_319_comment =
  "C++ Interface:\n"
  "write_headers(HTTPChannel self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs a list of all headers defined by the server to the indicated output\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_write_headers_319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::reset(void)
 */
static PyObject *Dtool_HTTPChannel_reset_320(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.reset")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_reset_320_comment =
  "C++ Interface:\n"
  "reset(const HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Stops whatever file transaction is currently in progress, closes the\n"
  " * connection, and resets to begin anew.  You shouldn't ever need to call\n"
  " * this, since the channel should be able to reset itself cleanly between\n"
  " * requests, but it is provided in case you are an especially nervous type.\n"
  " *\n"
  " * Don't call this after every request unless you set\n"
  " * set_persistent_connection() to false, since calling reset() rudely closes\n"
  " * the connection regardless of whether we have told the server we intend to\n"
  " * keep it open or not.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_reset_320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::preserve_status(void)
 */
static PyObject *Dtool_HTTPChannel_preserve_status_321(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.preserve_status")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::preserve_status(void)
  (*local_this).preserve_status();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_preserve_status_321_comment =
  "C++ Interface:\n"
  "preserve_status(const HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Preserves the previous status code (presumably a failure) from the previous\n"
  " * connection attempt.  If the subsequent connection attempt also fails, the\n"
  " * returned status code will be the better of the previous code and the\n"
  " * current code.\n"
  " *\n"
  " * This can be called to daisy-chain subsequent attempts to download the same\n"
  " * document from different servers.  After all servers have been attempted,\n"
  " * the final status code will reflect the attempt that most nearly succeeded.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_preserve_status_321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::clear_extra_headers(void)
 */
static PyObject *Dtool_HTTPChannel_clear_extra_headers_322(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.clear_extra_headers")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::clear_extra_headers(void)
  (*local_this).clear_extra_headers();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_clear_extra_headers_322_comment =
  "C++ Interface:\n"
  "clear_extra_headers(const HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Resets the extra headers that were previously added via calls to\n"
  " * send_extra_header().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_clear_extra_headers_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::send_extra_header(std::string const &key, std::string const &value)
 */
static PyObject *Dtool_HTTPChannel_send_extra_header_323(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.send_extra_header")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::send_extra_header(std::string const &key, std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"key", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:send_extra_header", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    (*local_this).send_extra_header(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_extra_header(const HTTPChannel self, str key, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_send_extra_header_323_comment =
  "C++ Interface:\n"
  "send_extra_header(const HTTPChannel self, str key, str value)\n"
  "\n"
  "/**\n"
  " * Specifies an additional key: value pair that is added into the header sent\n"
  " * to the server with the next request.  This is passed along with no\n"
  " * interpretation by the HTTPChannel code.  You may call this repeatedly to\n"
  " * append multiple headers.\n"
  " *\n"
  " * This is persistent for one request only; it must be set again for each new\n"
  " * request.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_send_extra_header_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_document(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_get_document_324(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.get_document")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_document(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.get_document", "DocumentSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).get_document(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_document(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_document_324_comment =
  "C++ Interface:\n"
  "get_document(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Opens the named document for reading, if available.  Returns true if\n"
  " * successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_document_324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_subdocument(DocumentSpec const &url, std::size_t first_byte, std::size_t last_byte)
 */
static PyObject *Dtool_HTTPChannel_get_subdocument_325(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.get_subdocument")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_subdocument(DocumentSpec const &url, std::size_t first_byte, std::size_t last_byte)
  PyObject *param1;
  Py_ssize_t param2;
  Py_ssize_t param3;
  static const char *keyword_list[] = {"url", "first_byte", "last_byte", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Onn:get_subdocument", (char **)keyword_list, &param1, &param2, &param3)) {
    DocumentSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_DocumentSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPChannel.get_subdocument", "DocumentSpec");
    }
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
#ifndef NDEBUG
    if (param3 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param3);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).get_subdocument(*param1_this, (std::size_t)param2, (std::size_t)param3);
    if (param1_manage) {
      delete param1_this;
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdocument(const HTTPChannel self, const DocumentSpec url, int first_byte, int last_byte)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_subdocument_325_comment =
  "C++ Interface:\n"
  "get_subdocument(const HTTPChannel self, const DocumentSpec url, int first_byte, int last_byte)\n"
  "\n"
  "/**\n"
  " * Retrieves only the specified byte range of the indicated document.  If\n"
  " * last_byte is 0, it stands for the last byte of the document.  When a\n"
  " * subdocument is requested, get_file_size() and get_bytes_downloaded() will\n"
  " * report the number of bytes of the subdocument, not of the complete\n"
  " * document.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_subdocument_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_header(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_get_header_326(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.get_header")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_header(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.get_header", "DocumentSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).get_header(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_header(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_header_326_comment =
  "C++ Interface:\n"
  "get_header(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Like get_document(), except only the header associated with the document is\n"
  " * retrieved.  This may be used to test for existence of the document; it\n"
  " * might also return the size of the document (if the server gives us this\n"
  " * information).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_header_326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::post_form(DocumentSpec const &url, std::string const &body)
 */
static PyObject *Dtool_HTTPChannel_post_form_327(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.post_form")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::post_form(DocumentSpec const &url, std::string const &body)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"url", "body", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:post_form", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DocumentSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_DocumentSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPChannel.post_form", "DocumentSpec");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).post_form(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "post_form(const HTTPChannel self, const DocumentSpec url, str body)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_post_form_327_comment =
  "C++ Interface:\n"
  "post_form(const HTTPChannel self, const DocumentSpec url, str body)\n"
  "\n"
  "/**\n"
  " * Posts form data to a particular URL and retrieves the response.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_post_form_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::put_document(DocumentSpec const &url, std::string const &body)
 */
static PyObject *Dtool_HTTPChannel_put_document_328(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.put_document")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::put_document(DocumentSpec const &url, std::string const &body)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"url", "body", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:put_document", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DocumentSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_DocumentSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPChannel.put_document", "DocumentSpec");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).put_document(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put_document(const HTTPChannel self, const DocumentSpec url, str body)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_put_document_328_comment =
  "C++ Interface:\n"
  "put_document(const HTTPChannel self, const DocumentSpec url, str body)\n"
  "\n"
  "/**\n"
  " * Uploads the indicated body to the server to replace the indicated URL, if\n"
  " * the server allows this.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_put_document_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::delete_document(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_delete_document_329(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.delete_document")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::delete_document(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.delete_document", "DocumentSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).delete_document(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_document(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_delete_document_329_comment =
  "C++ Interface:\n"
  "delete_document(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Requests the server to remove the indicated URL.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_delete_document_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_trace(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_get_trace_330(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.get_trace")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_trace(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.get_trace", "DocumentSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).get_trace(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_trace(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_trace_330_comment =
  "C++ Interface:\n"
  "get_trace(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Sends a TRACE message to the server, which should return back the same\n"
  " * message as the server received it, allowing inspection of proxy hops, etc.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_trace_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::connect_to(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_connect_to_331(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.connect_to")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::connect_to(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.connect_to", "DocumentSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).connect_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "connect_to(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_connect_to_331_comment =
  "C++ Interface:\n"
  "connect_to(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Establish a direct connection to the server and port indicated by the URL,\n"
  " * but do not issue any HTTP requests.  If successful, the connection may then\n"
  " * be taken to use for whatever purposes you like by calling get_connection().\n"
  " *\n"
  " * This establishes a blocking I/O socket.  Also see begin_connect_to().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_connect_to_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::get_options(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_get_options_332(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.get_options")) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::get_options(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.get_options", "DocumentSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).get_options(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_options(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_options_332_comment =
  "C++ Interface:\n"
  "get_options(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Sends an OPTIONS message to the server, which should query the available\n"
  " * options, possibly in relation to a specified URL.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_options_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::begin_get_document(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_begin_get_document_333(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.begin_get_document")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::begin_get_document(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.begin_get_document", "DocumentSpec");
  }
  (*local_this).begin_get_document(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_get_document(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_begin_get_document_333_comment =
  "C++ Interface:\n"
  "begin_get_document(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Begins a non-blocking request to retrieve a given document.  This method\n"
  " * will return immediately, even before a connection to the server has\n"
  " * necessarily been established; you must then call run() from time to time\n"
  " * until the return value of run() is false.  Then you may check is_valid()\n"
  " * and get_status_code() to determine the status of your request.\n"
  " *\n"
  " * If a previous request had been pending, that request is discarded.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_begin_get_document_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::begin_get_subdocument(DocumentSpec const &url, std::size_t first_byte, std::size_t last_byte)
 */
static PyObject *Dtool_HTTPChannel_begin_get_subdocument_334(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.begin_get_subdocument")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::begin_get_subdocument(DocumentSpec const &url, std::size_t first_byte, std::size_t last_byte)
  PyObject *param1;
  Py_ssize_t param2;
  Py_ssize_t param3;
  static const char *keyword_list[] = {"url", "first_byte", "last_byte", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Onn:begin_get_subdocument", (char **)keyword_list, &param1, &param2, &param3)) {
    DocumentSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_DocumentSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPChannel.begin_get_subdocument", "DocumentSpec");
    }
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
#ifndef NDEBUG
    if (param3 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param3);
    }
#endif
    (*local_this).begin_get_subdocument(*param1_this, (std::size_t)param2, (std::size_t)param3);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_get_subdocument(const HTTPChannel self, const DocumentSpec url, int first_byte, int last_byte)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_begin_get_subdocument_334_comment =
  "C++ Interface:\n"
  "begin_get_subdocument(const HTTPChannel self, const DocumentSpec url, int first_byte, int last_byte)\n"
  "\n"
  "/**\n"
  " * Begins a non-blocking request to retrieve only the specified byte range of\n"
  " * the indicated document.  If last_byte is 0, it stands for the last byte of\n"
  " * the document.  When a subdocument is requested, get_file_size() and\n"
  " * get_bytes_downloaded() will report the number of bytes of the subdocument,\n"
  " * not of the complete document.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_begin_get_subdocument_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::begin_get_header(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_begin_get_header_335(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.begin_get_header")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::begin_get_header(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.begin_get_header", "DocumentSpec");
  }
  (*local_this).begin_get_header(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_get_header(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_begin_get_header_335_comment =
  "C++ Interface:\n"
  "begin_get_header(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Begins a non-blocking request to retrieve a given header.  See\n"
  " * begin_get_document() and get_header().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_begin_get_header_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::begin_post_form(DocumentSpec const &url, std::string const &body)
 */
static PyObject *Dtool_HTTPChannel_begin_post_form_336(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.begin_post_form")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::begin_post_form(DocumentSpec const &url, std::string const &body)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"url", "body", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:begin_post_form", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DocumentSpec const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_DocumentSpec(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPChannel.begin_post_form", "DocumentSpec");
    }
    (*local_this).begin_post_form(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_post_form(const HTTPChannel self, const DocumentSpec url, str body)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_begin_post_form_336_comment =
  "C++ Interface:\n"
  "begin_post_form(const HTTPChannel self, const DocumentSpec url, str body)\n"
  "\n"
  "/**\n"
  " * Posts form data to a particular URL and retrieves the response, all using\n"
  " * non-blocking I/O.  See begin_get_document() and post_form().\n"
  " *\n"
  " * It is important to note that you *must* call run() repeatedly after calling\n"
  " * this method until run() returns false, and you may not call any other\n"
  " * document posting or retrieving methods using the HTTPChannel object in the\n"
  " * interim, or your form data may not get posted.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_begin_post_form_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPChannel::run(void)
 */
static PyObject *Dtool_HTTPChannel_run_337(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.run")) {
    return NULL;
  }
  // 1-bool HTTPChannel::run(void)
  bool return_value = (*local_this).run();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_run_337_comment =
  "C++ Interface:\n"
  "run(const HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * This must be called from time to time when non-blocking I/O is in use.  It\n"
  " * checks for data coming in on the socket and writes data out to the socket\n"
  " * when possible, and does whatever processing is required towards completing\n"
  " * the current task.\n"
  " *\n"
  " * The return value is true if the task is still pending (and run() will need\n"
  " * to be called again in the future), or false if the current task is\n"
  " * complete.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_run_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HTTPChannel::begin_connect_to(DocumentSpec const &url)
 */
static PyObject *Dtool_HTTPChannel_begin_connect_to_338(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.begin_connect_to")) {
    return NULL;
  }
  // 1-inline void HTTPChannel::begin_connect_to(DocumentSpec const &url)
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HTTPChannel.begin_connect_to", "DocumentSpec");
  }
  (*local_this).begin_connect_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "begin_connect_to(const HTTPChannel self, const DocumentSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_begin_connect_to_338_comment =
  "C++ Interface:\n"
  "begin_connect_to(const HTTPChannel self, const DocumentSpec url)\n"
  "\n"
  "/**\n"
  " * Begins a non-blocking request to establish a direct connection to the\n"
  " * server and port indicated by the URL.  No HTTP requests will be issued\n"
  " * beyond what is necessary to establish the connection.  When run() has\n"
  " * finished, you may call is_connection_ready() to determine if the connection\n"
  " * was successfully established.\n"
  " *\n"
  " * If successful, the connection may then be taken to use for whatever\n"
  " * purposes you like by calling get_connection().\n"
  " *\n"
  " * This establishes a nonblocking I/O socket.  Also see connect_to().\n"
  " */";
#else
static const char *Dtool_HTTPChannel_begin_connect_to_338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ISocketStream *HTTPChannel::open_read_body(void)
 */
static PyObject *Dtool_HTTPChannel_open_read_body_339(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.open_read_body")) {
    return NULL;
  }
  // 1-ISocketStream *HTTPChannel::open_read_body(void)
  ISocketStream *return_value = (*local_this).open_read_body();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ISocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_open_read_body_339_comment =
  "C++ Interface:\n"
  "open_read_body(const HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns a newly-allocated istream suitable for reading the body of the\n"
  " * document.  This may only be called immediately after a call to\n"
  " * get_document() or post_form(), or after a call to run() has returned false.\n"
  " *\n"
  " * Note that, in nonblocking mode, the returned stream may report an early\n"
  " * EOF, even before the actual end of file.  When this happens, you should\n"
  " * call stream->is_closed() to determine whether you should attempt to read\n"
  " * some more later.\n"
  " *\n"
  " * The user is responsible for passing the returned istream to\n"
  " * close_read_body() later.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_open_read_body_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HTTPChannel::close_read_body(istream *stream) const
 */
static PyObject *Dtool_HTTPChannel_close_read_body_340(PyObject *self, PyObject *arg) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HTTPChannel::close_read_body(istream *stream) const
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "HTTPChannel.close_read_body", false, true);
  if (arg_this != NULL) {
    (*(const HTTPChannel*)local_this).close_read_body(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_body(HTTPChannel self, istream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_close_read_body_340_comment =
  "C++ Interface:\n"
  "close_read_body(HTTPChannel self, istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_body().  This really\n"
  " * just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_close_read_body_340_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes = true)
 */
static PyObject *Dtool_HTTPChannel_download_to_file_341(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.download_to_file")) {
    return NULL;
  }
  // 1-bool HTTPChannel::download_to_file(Filename const &filename, bool subdocument_resumes = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"filename", "subdocument_resumes", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:download_to_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "HTTPChannel.download_to_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).download_to_file(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "download_to_file(const HTTPChannel self, const Filename filename, bool subdocument_resumes)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_download_to_file_341_comment =
  "C++ Interface:\n"
  "download_to_file(const HTTPChannel self, const Filename filename, bool subdocument_resumes)\n"
  "\n"
  "/**\n"
  " * Specifies the name of a file to download the resulting document to.  This\n"
  " * should be called immediately after get_document() or begin_get_document()\n"
  " * or related functions.\n"
  " *\n"
  " * In the case of the blocking I/O methods like get_document(), this function\n"
  " * will download the entire document to the file and return true if it was\n"
  " * successfully downloaded, false otherwise.\n"
  " *\n"
  " * In the case of non-blocking I/O methods like begin_get_document(), this\n"
  " * function simply indicates an intention to download to the indicated file.\n"
  " * It returns true if the file can be opened for writing, false otherwise, but\n"
  " * the contents will not be completely downloaded until run() has returned\n"
  " * false.  At this time, it is possible that a communications error will have\n"
  " * left a partial file, so is_download_complete() may be called to test this.\n"
  " *\n"
  " * If subdocument_resumes is true and the document in question was previously\n"
  " * requested as a subdocument (i.e.  get_subdocument() with a first_byte value\n"
  " * greater than zero), this will automatically seek to the appropriate byte\n"
  " * within the file for writing the output.  In this case, the file must\n"
  " * already exist and must have at least first_byte bytes in it.  If\n"
  " * subdocument_resumes is false, a subdocument will always be downloaded\n"
  " * beginning at the first byte of the file.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_download_to_file_341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes = true)
 */
static PyObject *Dtool_HTTPChannel_download_to_ram_342(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.download_to_ram")) {
    return NULL;
  }
  // 1-bool HTTPChannel::download_to_ram(Ramfile *ramfile, bool subdocument_resumes = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"ramfile", "subdocument_resumes", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:download_to_ram", (char **)keyword_list, &param1, &param2)) {
    Ramfile *param1_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Ramfile, 1, "HTTPChannel.download_to_ram", false, true);
    if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*local_this).download_to_ram(param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "download_to_ram(const HTTPChannel self, Ramfile ramfile, bool subdocument_resumes)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_download_to_ram_342_comment =
  "C++ Interface:\n"
  "download_to_ram(const HTTPChannel self, Ramfile ramfile, bool subdocument_resumes)\n"
  "\n"
  "/**\n"
  " * Specifies a Ramfile object to download the resulting document to.  This\n"
  " * should be called immediately after get_document() or begin_get_document()\n"
  " * or related functions.\n"
  " *\n"
  " * In the case of the blocking I/O methods like get_document(), this function\n"
  " * will download the entire document to the Ramfile and return true if it was\n"
  " * successfully downloaded, false otherwise.\n"
  " *\n"
  " * In the case of non-blocking I/O methods like begin_get_document(), this\n"
  " * function simply indicates an intention to download to the indicated\n"
  " * Ramfile.  It returns true if the file can be opened for writing, false\n"
  " * otherwise, but the contents will not be completely downloaded until run()\n"
  " * has returned false.  At this time, it is possible that a communications\n"
  " * error will have left a partial file, so is_download_complete() may be\n"
  " * called to test this.\n"
  " *\n"
  " * If subdocument_resumes is true and the document in question was previously\n"
  " * requested as a subdocument (i.e.  get_subdocument() with a first_byte value\n"
  " * greater than zero), this will automatically seek to the appropriate byte\n"
  " * within the Ramfile for writing the output.  In this case, the Ramfile must\n"
  " * already have at least first_byte bytes in it.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_download_to_ram_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HTTPChannel::download_to_stream(ostream *strm, bool subdocument_resumes = true)
 */
static PyObject *Dtool_HTTPChannel_download_to_stream_343(PyObject *self, PyObject *args, PyObject *kwds) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.download_to_stream")) {
    return NULL;
  }
  // 1-bool HTTPChannel::download_to_stream(ostream *strm, bool subdocument_resumes = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"strm", "subdocument_resumes", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:download_to_stream", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "HTTPChannel.download_to_stream", false, true);
    if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*local_this).download_to_stream(param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "download_to_stream(const HTTPChannel self, ostream strm, bool subdocument_resumes)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_download_to_stream_343_comment =
  "C++ Interface:\n"
  "download_to_stream(const HTTPChannel self, ostream strm, bool subdocument_resumes)\n"
  "\n"
  "/**\n"
  " * Specifies the name of an ostream to download the resulting document to.\n"
  " * This should be called immediately after get_document() or\n"
  " * begin_get_document() or related functions.\n"
  " *\n"
  " * In the case of the blocking I/O methods like get_document(), this function\n"
  " * will download the entire document to the file and return true if it was\n"
  " * successfully downloaded, false otherwise.\n"
  " *\n"
  " * In the case of non-blocking I/O methods like begin_get_document(), this\n"
  " * function simply indicates an intention to download to the indicated file.\n"
  " * It returns true if the file can be opened for writing, false otherwise, but\n"
  " * the contents will not be completely downloaded until run() has returned\n"
  " * false.  At this time, it is possible that a communications error will have\n"
  " * left a partial file, so is_download_complete() may be called to test this.\n"
  " *\n"
  " * If subdocument_resumes is true and the document in question was previously\n"
  " * requested as a subdocument (i.e.  get_subdocument() with a first_byte value\n"
  " * greater than zero), this will automatically seek to the appropriate byte\n"
  " * within the file for writing the output.  In this case, the file must\n"
  " * already exist and must have at least first_byte bytes in it.  If\n"
  " * subdocument_resumes is false, a subdocument will always be downloaded\n"
  " * beginning at the first byte of the file.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_download_to_stream_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SocketStream *HTTPChannel::get_connection(void)
 */
static PyObject *Dtool_HTTPChannel_get_connection_344(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HTTPChannel, (void **)&local_this, "HTTPChannel.get_connection")) {
    return NULL;
  }
  // 1-SocketStream *HTTPChannel::get_connection(void)
  SocketStream *return_value = (*local_this).get_connection();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_connection_344_comment =
  "C++ Interface:\n"
  "get_connection(const HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the connection that was established via a previous call to\n"
  " * connect_to() or begin_connect_to(), or NULL if the connection attempt\n"
  " * failed or if those methods have not recently been called.\n"
  " *\n"
  " * This stream has been allocated from the free store.  It is the user's\n"
  " * responsibility to delete this pointer when finished with it.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_connection_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_bytes_downloaded(void) const
 */
static PyObject *Dtool_HTTPChannel_get_bytes_downloaded_345(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_bytes_downloaded(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_bytes_downloaded();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_bytes_downloaded_345_comment =
  "C++ Interface:\n"
  "get_bytes_downloaded(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes downloaded during the last (or current)\n"
  " * download_to_file() or download_to_ram operation().  This can be used in\n"
  " * conjunction with get_file_size() to report the percent complete (but be\n"
  " * careful, since get_file_size() may return 0 if the server has not told us\n"
  " * the size of the file).\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_bytes_downloaded_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t HTTPChannel::get_bytes_requested(void) const
 */
static PyObject *Dtool_HTTPChannel_get_bytes_requested_346(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t HTTPChannel::get_bytes_requested(void) const
  std::size_t return_value = (*(const HTTPChannel*)local_this).get_bytes_requested();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_bytes_requested_346_comment =
  "C++ Interface:\n"
  "get_bytes_requested(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * When download throttling is in effect (set_download_throttle() has been set\n"
  " * to true) and non-blocking I/O methods (like begin_get_document()) are used,\n"
  " * this returns the number of bytes \"requested\" from the server so far: that\n"
  " * is, the theoretical maximum value for get_bytes_downloaded(), if the server\n"
  " * has been keeping up with our demand.\n"
  " *\n"
  " * If this number is less than get_bytes_downloaded(), then the server has not\n"
  " * been supplying bytes fast enough to meet our own download throttle rate.\n"
  " *\n"
  " * When download throttling is not in effect, or when the blocking I/O methods\n"
  " * (like get_document(), etc.) are used, this returns 0.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_get_bytes_requested_346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool HTTPChannel::is_download_complete(void) const
 */
static PyObject *Dtool_HTTPChannel_is_download_complete_347(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool HTTPChannel::is_download_complete(void) const
  bool return_value = (*(const HTTPChannel*)local_this).is_download_complete();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_is_download_complete_347_comment =
  "C++ Interface:\n"
  "is_download_complete(HTTPChannel self)\n"
  "\n"
  "/**\n"
  " * Returns true when a download_to() or download_to_ram() has executed and the\n"
  " * file has been fully downloaded.  If this still returns false after\n"
  " * processing has completed, there was an error in transmission.\n"
  " *\n"
  " * Note that simply testing is_download_complete() does not prove that the\n"
  " * requested document was successfully retrieved--you might have just\n"
  " * downloaded the \"404 not found\" stub (for instance) that a server would\n"
  " * provide in response to some error condition.  You should also check\n"
  " * is_valid() to prove that the file you expected has been successfully\n"
  " * retrieved.\n"
  " */";
#else
static const char *Dtool_HTTPChannel_is_download_complete_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle HTTPChannel::get_class_type(void)
 */
static PyObject *Dtool_HTTPChannel_get_class_type_348(PyObject *, PyObject *) {
  // 1-static TypeHandle HTTPChannel::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(HTTPChannel::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HTTPChannel_get_class_type_348_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_HTTPChannel_get_class_type_348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HTTPChannel::HTTPChannel(HTTPChannel const &) = default
 */
static int Dtool_Init_HTTPChannel(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "HTTPChannel() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline HTTPChannel::HTTPChannel(HTTPChannel const &) = default
  HTTPChannel const *arg_this = (HTTPChannel *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPChannel, 0, "HTTPChannel.HTTPChannel", true, true);
  if (arg_this != NULL) {
    HTTPChannel *return_value = new HTTPChannel(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HTTPChannel, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HTTPChannel(const HTTPChannel param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_HTTPChannel_get_redirect_steps(PyObject *self, PyObject *) {
  HTTPChannel *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPChannel, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_redirect_steps();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_HTTPChannel_get_redirect_step_287(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_HTTPChannel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HTTPChannel) {
    printf("HTTPChannel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HTTPChannel *local_this = (HTTPChannel *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HTTPChannel) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HTTPChannel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HTTPChannel) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HTTPChannel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (HTTPChannel*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (HTTPChannel*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Decompressor
 */
/**
 * Python function wrapper for:
 * int Decompressor::initiate(Filename const &source_file)
 * int Decompressor::initiate(Filename const &source_file, Filename const &dest_file)
 */
static PyObject *Dtool_Decompressor_initiate_353(PyObject *self, PyObject *args, PyObject *kwds) {
  Decompressor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Decompressor, (void **)&local_this, "Decompressor.initiate")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "source_file");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'source_file' (pos 1) not found");
      }
      // 1-int Decompressor::initiate(Filename const &source_file)
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Decompressor.initiate", "Filename");
      }
      int return_value = (*local_this).initiate(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 2:
    {
      // 1-int Decompressor::initiate(Filename const &source_file, Filename const &dest_file)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"source_file", "dest_file", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:initiate", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Decompressor.initiate", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Decompressor.initiate", "Filename");
        }
        int return_value = (*local_this).initiate(*param1_this, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "initiate() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initiate(const Decompressor self, const Filename source_file)\n"
      "initiate(const Decompressor self, const Filename source_file, const Filename dest_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Decompressor_initiate_353_comment =
  "C++ Interface:\n"
  "initiate(const Decompressor self, const Filename source_file)\n"
  "initiate(const Decompressor self, const Filename source_file, const Filename dest_file)\n"
  "\n"
  "/**\n"
  " * Begins a background decompression of the named file (whose filename must\n"
  " * end in \".pz\") to a new file without the .pz extension.  The source file is\n"
  " * removed after successful completion.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Begins a background decompression from the named source file to the named\n"
  " * destination file.  The source file is removed after successful completion.\n"
  " */";
#else
static const char *Dtool_Decompressor_initiate_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Decompressor::run(void)
 */
static PyObject *Dtool_Decompressor_run_354(PyObject *self, PyObject *) {
  Decompressor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Decompressor, (void **)&local_this, "Decompressor.run")) {
    return NULL;
  }
  // 1-int Decompressor::run(void)
  int return_value = (*local_this).run();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Decompressor_run_354_comment =
  "C++ Interface:\n"
  "run(const Decompressor self)\n"
  "\n"
  "/**\n"
  " * Called each frame to do the next bit of work in the background task.\n"
  " * Returns EU_ok if a chunk is completed but there is more to go, or\n"
  " * EU_success when we're all done.  Any other return value indicates an error.\n"
  " */";
#else
static const char *Dtool_Decompressor_run_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Decompressor::decompress(Filename const &source_file)
 * bool Decompressor::decompress(Ramfile &source_and_dest_file)
 */
static PyObject *Dtool_Decompressor_decompress_355(PyObject *self, PyObject *arg) {
  Decompressor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Decompressor, (void **)&local_this, "Decompressor.decompress")) {
    return NULL;
  }
  {
    // -2 bool Decompressor::decompress(Filename const &source_file)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).decompress(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Decompressor::decompress(Ramfile &source_and_dest_file)
    Ramfile *arg_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Ramfile, 1, "Decompressor.decompress", false, false);
    if (arg_this != NULL) {
      bool return_value = (*local_this).decompress(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Decompressor::decompress(Filename const &source_file)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
      bool return_value = (*local_this).decompress(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Decompressor::decompress(Ramfile &source_and_dest_file)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress(const Decompressor self, const Filename source_file)\n"
      "decompress(const Decompressor self, Ramfile source_and_dest_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Decompressor_decompress_355_comment =
  "C++ Interface:\n"
  "decompress(const Decompressor self, const Filename source_file)\n"
  "decompress(const Decompressor self, Ramfile source_and_dest_file)\n"
  "\n"
  "/**\n"
  " * Performs a foreground decompression of the named file; does not return\n"
  " * until the decompression is complete.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Does an in-memory decompression of the indicated Ramfile.  The decompressed\n"
  " * contents are written back into the same Ramfile on completion.\n"
  " */";
#else
static const char *Dtool_Decompressor_decompress_355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Decompressor::get_progress(void) const
 */
static PyObject *Dtool_Decompressor_get_progress_356(PyObject *self, PyObject *) {
  Decompressor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Decompressor, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Decompressor::get_progress(void) const
  PN_stdfloat return_value = (*(const Decompressor*)local_this).get_progress();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Decompressor_get_progress_356_comment =
  "C++ Interface:\n"
  "get_progress(Decompressor self)\n"
  "\n"
  "/**\n"
  " * Returns the ratio through the decompression step in the background.\n"
  " */";
#else
static const char *Dtool_Decompressor_get_progress_356_comment = NULL;
#endif

static PyObject *Dtool_Decompressor_progress_Getter(PyObject *self, void *) {
  const Decompressor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Decompressor, (void **)&local_this)) {
    return NULL;
  }

  // 1-PN_stdfloat Decompressor::get_progress(void) const
  PN_stdfloat return_value = (*(const Decompressor*)local_this).get_progress();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * Decompressor::Decompressor(void)
 * inline Decompressor::Decompressor(Decompressor const &) = default
 */
static int Dtool_Init_Decompressor(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Decompressor::Decompressor(void)
      Decompressor *return_value = new Decompressor();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Decompressor, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Decompressor::Decompressor(Decompressor const &) = default
      Decompressor const *arg_this = (Decompressor *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Decompressor, 0, "Decompressor.Decompressor", true, true);
      if (arg_this != NULL) {
        Decompressor *return_value = new Decompressor(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Decompressor, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Decompressor() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Decompressor()\n"
      "Decompressor(const Decompressor param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Decompressor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Decompressor) {
    printf("Decompressor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Decompressor *local_this = (Decompressor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Decompressor) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Decompressor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Decompressor) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DownloadDb
 */
/**
 * Python function wrapper for:
 * void DownloadDb::output(ostream &out) const
 */
static PyObject *Dtool_DownloadDb_output_364(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DownloadDb::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DownloadDb.output", false, true);
  if (arg_this != NULL) {
    (*(const DownloadDb*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DownloadDb self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_output_364_comment =
  "C++ Interface:\n"
  "output(DownloadDb self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_output_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::write(ostream &out) const
 */
static PyObject *Dtool_DownloadDb_write_365(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DownloadDb::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DownloadDb.write", false, true);
  if (arg_this != NULL) {
    (*(const DownloadDb*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DownloadDb self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_write_365_comment =
  "C++ Interface:\n"
  "write(DownloadDb self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_write_365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::write_version_map(ostream &out) const
 */
static PyObject *Dtool_DownloadDb_write_version_map_366(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DownloadDb::write_version_map(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DownloadDb.write_version_map", false, true);
  if (arg_this != NULL) {
    (*(const DownloadDb*)local_this).write_version_map(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_version_map(DownloadDb self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_write_version_map_366_comment =
  "C++ Interface:\n"
  "write_version_map(DownloadDb self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_write_version_map_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::write_client_db(Filename &file)
 */
static PyObject *Dtool_DownloadDb_write_client_db_367(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.write_client_db")) {
    return NULL;
  }
  // 1-bool DownloadDb::write_client_db(Filename &file)
  Filename arg_local;
  Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DownloadDb.write_client_db", "Filename");
  }
  bool return_value = (*local_this).write_client_db(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_client_db(const DownloadDb self, Filename file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_write_client_db_367_comment =
  "C++ Interface:\n"
  "write_client_db(const DownloadDb self, Filename file)\n"
  "\n"
  "// Write a database file\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_write_client_db_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::write_server_db(Filename &file)
 */
static PyObject *Dtool_DownloadDb_write_server_db_368(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.write_server_db")) {
    return NULL;
  }
  // 1-bool DownloadDb::write_server_db(Filename &file)
  Filename arg_local;
  Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DownloadDb.write_server_db", "Filename");
  }
  bool return_value = (*local_this).write_server_db(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_server_db(const DownloadDb self, Filename file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_write_server_db_368_comment =
  "C++ Interface:\n"
  "write_server_db(const DownloadDb self, Filename file)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_write_server_db_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DownloadDb::get_client_num_multifiles(void) const
 */
static PyObject *Dtool_DownloadDb_get_client_num_multifiles_369(PyObject *self, PyObject *) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DownloadDb::get_client_num_multifiles(void) const
  int return_value = (*(const DownloadDb*)local_this).get_client_num_multifiles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_client_num_multifiles_369_comment =
  "C++ Interface:\n"
  "get_client_num_multifiles(DownloadDb self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_client_num_multifiles_369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DownloadDb::get_server_num_multifiles(void) const
 */
static PyObject *Dtool_DownloadDb_get_server_num_multifiles_370(PyObject *self, PyObject *) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DownloadDb::get_server_num_multifiles(void) const
  int return_value = (*(const DownloadDb*)local_this).get_server_num_multifiles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_num_multifiles_370_comment =
  "C++ Interface:\n"
  "get_server_num_multifiles(DownloadDb self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_num_multifiles_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DownloadDb::get_client_multifile_name(int index) const
 */
static PyObject *Dtool_DownloadDb_get_client_multifile_name_371(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DownloadDb::get_client_multifile_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const DownloadDb*)local_this).get_client_multifile_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_client_multifile_name(DownloadDb self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_client_multifile_name_371_comment =
  "C++ Interface:\n"
  "get_client_multifile_name(DownloadDb self, int index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_client_multifile_name_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DownloadDb::get_server_multifile_name(int index) const
 */
static PyObject *Dtool_DownloadDb_get_server_multifile_name_372(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DownloadDb::get_server_multifile_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const DownloadDb*)local_this).get_server_multifile_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_server_multifile_name(DownloadDb self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_multifile_name_372_comment =
  "C++ Interface:\n"
  "get_server_multifile_name(DownloadDb self, int index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_multifile_name_372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DownloadDb::get_client_multifile_size(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_client_multifile_size_373(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DownloadDb::get_client_multifile_size(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const DownloadDb*)local_this).get_client_multifile_size(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_client_multifile_size(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_client_multifile_size_373_comment =
  "C++ Interface:\n"
  "get_client_multifile_size(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_client_multifile_size_373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DownloadDb::set_client_multifile_size(std::string mfname, int size)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_size_374(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_size")) {
    return NULL;
  }
  // 1-inline void DownloadDb::set_client_multifile_size(std::string mfname, int size)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"mfname", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_client_multifile_size", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    (*local_this).set_client_multifile_size(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_size(const DownloadDb self, str mfname, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_size_374_comment =
  "C++ Interface:\n"
  "set_client_multifile_size(const DownloadDb self, str mfname, int size)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_size_374_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DownloadDb::set_client_multifile_delta_size(std::string mfname, int size)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_delta_size_375(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_delta_size")) {
    return NULL;
  }
  // 1-inline int DownloadDb::set_client_multifile_delta_size(std::string mfname, int size)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"mfname", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_client_multifile_delta_size", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    int return_value = (*local_this).set_client_multifile_delta_size(std::string(param1_str, param1_len), (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_delta_size(const DownloadDb self, str mfname, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_delta_size_375_comment =
  "C++ Interface:\n"
  "set_client_multifile_delta_size(const DownloadDb self, str mfname, int size)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_delta_size_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DownloadDb::get_server_multifile_size(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_server_multifile_size_376(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DownloadDb::get_server_multifile_size(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const DownloadDb*)local_this).get_server_multifile_size(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_server_multifile_size(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_multifile_size_376_comment =
  "C++ Interface:\n"
  "get_server_multifile_size(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_multifile_size_376_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DownloadDb::set_server_multifile_size(std::string mfname, int size)
 */
static PyObject *Dtool_DownloadDb_set_server_multifile_size_377(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_server_multifile_size")) {
    return NULL;
  }
  // 1-inline void DownloadDb::set_server_multifile_size(std::string mfname, int size)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"mfname", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_server_multifile_size", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    (*local_this).set_server_multifile_size(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_multifile_size(const DownloadDb self, str mfname, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_server_multifile_size_377_comment =
  "C++ Interface:\n"
  "set_server_multifile_size(const DownloadDb self, str mfname, int size)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_server_multifile_size_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Phase DownloadDb::get_client_multifile_phase(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_client_multifile_phase_378(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Phase DownloadDb::get_client_multifile_phase(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    Phase return_value = (*(const DownloadDb*)local_this).get_client_multifile_phase(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_client_multifile_phase(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_client_multifile_phase_378_comment =
  "C++ Interface:\n"
  "get_client_multifile_phase(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_client_multifile_phase_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Phase DownloadDb::get_server_multifile_phase(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_server_multifile_phase_379(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Phase DownloadDb::get_server_multifile_phase(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    Phase return_value = (*(const DownloadDb*)local_this).get_server_multifile_phase(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_server_multifile_phase(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_multifile_phase_379_comment =
  "C++ Interface:\n"
  "get_server_multifile_phase(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_multifile_phase_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DownloadDb::set_client_multifile_incomplete(std::string mfname)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_incomplete_380(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_incomplete")) {
    return NULL;
  }
  // 1-inline void DownloadDb::set_client_multifile_incomplete(std::string mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_client_multifile_incomplete(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_incomplete(const DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_incomplete_380_comment =
  "C++ Interface:\n"
  "set_client_multifile_incomplete(const DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_incomplete_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DownloadDb::set_client_multifile_complete(std::string mfname)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_complete_381(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_complete")) {
    return NULL;
  }
  // 1-inline void DownloadDb::set_client_multifile_complete(std::string mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_client_multifile_complete(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_complete(const DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_complete_381_comment =
  "C++ Interface:\n"
  "set_client_multifile_complete(const DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_complete_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DownloadDb::set_client_multifile_decompressed(std::string mfname)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_decompressed_382(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_decompressed")) {
    return NULL;
  }
  // 1-inline void DownloadDb::set_client_multifile_decompressed(std::string mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_client_multifile_decompressed(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_decompressed(const DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_decompressed_382_comment =
  "C++ Interface:\n"
  "set_client_multifile_decompressed(const DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_decompressed_382_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DownloadDb::set_client_multifile_extracted(std::string mfname)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_extracted_383(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_extracted")) {
    return NULL;
  }
  // 1-inline void DownloadDb::set_client_multifile_extracted(std::string mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_client_multifile_extracted(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_extracted(const DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_extracted_383_comment =
  "C++ Interface:\n"
  "set_client_multifile_extracted(const DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_extracted_383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int DownloadDb::get_server_num_files(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_server_num_files_384(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int DownloadDb::get_server_num_files(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const DownloadDb*)local_this).get_server_num_files(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_server_num_files(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_num_files_384_comment =
  "C++ Interface:\n"
  "get_server_num_files(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_num_files_384_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DownloadDb::get_server_file_name(std::string mfname, int index) const
 */
static PyObject *Dtool_DownloadDb_get_server_file_name_385(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DownloadDb::get_server_file_name(std::string mfname, int index) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"mfname", "index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:get_server_file_name", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    std::string return_value = (*(const DownloadDb*)local_this).get_server_file_name(std::string(param1_str, param1_len), (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_server_file_name(DownloadDb self, str mfname, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_file_name_385_comment =
  "C++ Interface:\n"
  "get_server_file_name(DownloadDb self, str mfname, int index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_file_name_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::client_multifile_exists(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_client_multifile_exists_386(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DownloadDb::client_multifile_exists(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const DownloadDb*)local_this).client_multifile_exists(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_multifile_exists(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_client_multifile_exists_386_comment =
  "C++ Interface:\n"
  "client_multifile_exists(DownloadDb self, str mfname)\n"
  "\n"
  "// Queries from the Launcher\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_client_multifile_exists_386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::client_multifile_complete(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_client_multifile_complete_387(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DownloadDb::client_multifile_complete(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const DownloadDb*)local_this).client_multifile_complete(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_multifile_complete(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_client_multifile_complete_387_comment =
  "C++ Interface:\n"
  "client_multifile_complete(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " * A multifile is complete when it is completely downloaded.  Note: it may\n"
  " * already be decompressed or extracted and it is still complete\n"
  " */";
#else
static const char *Dtool_DownloadDb_client_multifile_complete_387_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::client_multifile_decompressed(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_client_multifile_decompressed_388(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DownloadDb::client_multifile_decompressed(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const DownloadDb*)local_this).client_multifile_decompressed(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_multifile_decompressed(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_client_multifile_decompressed_388_comment =
  "C++ Interface:\n"
  "client_multifile_decompressed(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_client_multifile_decompressed_388_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::client_multifile_extracted(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_client_multifile_extracted_389(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DownloadDb::client_multifile_extracted(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const DownloadDb*)local_this).client_multifile_extracted(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "client_multifile_extracted(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_client_multifile_extracted_389_comment =
  "C++ Interface:\n"
  "client_multifile_extracted(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_client_multifile_extracted_389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * HashVal DownloadDb::get_client_multifile_hash(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_client_multifile_hash_390(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-HashVal DownloadDb::get_client_multifile_hash(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    HashVal *return_value = new HashVal((*(const DownloadDb*)local_this).get_client_multifile_hash(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_client_multifile_hash(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_client_multifile_hash_390_comment =
  "C++ Interface:\n"
  "get_client_multifile_hash(DownloadDb self, str mfname)\n"
  "\n"
  "// Ask what version (told with the hash) this multifile is\n"
  "\n"
  "/**\n"
  " * Return the hash value of the file we are working on\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_client_multifile_hash_390_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::set_client_multifile_hash(std::string mfname, HashVal val)
 */
static PyObject *Dtool_DownloadDb_set_client_multifile_hash_391(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_client_multifile_hash")) {
    return NULL;
  }
  // 1-void DownloadDb::set_client_multifile_hash(std::string mfname, HashVal val)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"mfname", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_client_multifile_hash", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_HashVal, 2, "DownloadDb.set_client_multifile_hash", true, true);
    if (param2_this != NULL) {
      (*local_this).set_client_multifile_hash(std::string(param1_str, param1_len), *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_multifile_hash(const DownloadDb self, str mfname, HashVal val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_client_multifile_hash_391_comment =
  "C++ Interface:\n"
  "set_client_multifile_hash(const DownloadDb self, str mfname, HashVal val)\n"
  "\n"
  "/**\n"
  " * Set the hash value of file we are working on\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_client_multifile_hash_391_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * HashVal DownloadDb::get_server_multifile_hash(std::string mfname) const
 */
static PyObject *Dtool_DownloadDb_get_server_multifile_hash_392(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-HashVal DownloadDb::get_server_multifile_hash(std::string mfname) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    HashVal *return_value = new HashVal((*(const DownloadDb*)local_this).get_server_multifile_hash(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_server_multifile_hash(DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_server_multifile_hash_392_comment =
  "C++ Interface:\n"
  "get_server_multifile_hash(DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " * Return the hash value of the server file\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_server_multifile_hash_392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::set_server_multifile_hash(std::string mfname, HashVal val)
 */
static PyObject *Dtool_DownloadDb_set_server_multifile_hash_393(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_server_multifile_hash")) {
    return NULL;
  }
  // 1-void DownloadDb::set_server_multifile_hash(std::string mfname, HashVal val)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"mfname", "val", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_server_multifile_hash", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    HashVal *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_HashVal, 2, "DownloadDb.set_server_multifile_hash", true, true);
    if (param2_this != NULL) {
      (*local_this).set_server_multifile_hash(std::string(param1_str, param1_len), *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_multifile_hash(const DownloadDb self, str mfname, HashVal val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_server_multifile_hash_393_comment =
  "C++ Interface:\n"
  "set_server_multifile_hash(const DownloadDb self, str mfname, HashVal val)\n"
  "\n"
  "/**\n"
  " * Set the hash value of file we are working on\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_server_multifile_hash_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::delete_client_multifile(std::string mfname)
 */
static PyObject *Dtool_DownloadDb_delete_client_multifile_394(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.delete_client_multifile")) {
    return NULL;
  }
  // 1-void DownloadDb::delete_client_multifile(std::string mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).delete_client_multifile(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_client_multifile(const DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_delete_client_multifile_394_comment =
  "C++ Interface:\n"
  "delete_client_multifile(const DownloadDb self, str mfname)\n"
  "\n"
  "// Operations on multifiles\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_delete_client_multifile_394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::add_client_multifile(std::string server_mfname)
 */
static PyObject *Dtool_DownloadDb_add_client_multifile_395(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.add_client_multifile")) {
    return NULL;
  }
  // 1-void DownloadDb::add_client_multifile(std::string server_mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_client_multifile(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_client_multifile(const DownloadDb self, str server_mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_add_client_multifile_395_comment =
  "C++ Interface:\n"
  "add_client_multifile(const DownloadDb self, str server_mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_add_client_multifile_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::expand_client_multifile(std::string mfname)
 */
static PyObject *Dtool_DownloadDb_expand_client_multifile_396(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.expand_client_multifile")) {
    return NULL;
  }
  // 1-void DownloadDb::expand_client_multifile(std::string mfname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).expand_client_multifile(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_client_multifile(const DownloadDb self, str mfname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_expand_client_multifile_396_comment =
  "C++ Interface:\n"
  "expand_client_multifile(const DownloadDb self, str mfname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_expand_client_multifile_396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::create_new_server_db(void)
 */
static PyObject *Dtool_DownloadDb_create_new_server_db_397(PyObject *self, PyObject *) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.create_new_server_db")) {
    return NULL;
  }
  // 1-void DownloadDb::create_new_server_db(void)
  (*local_this).create_new_server_db();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_create_new_server_db_397_comment =
  "C++ Interface:\n"
  "create_new_server_db(const DownloadDb self)\n"
  "\n"
  "// Server side operations to create multifile records\n"
  "\n"
  "/**\n"
  " * Used on the server side makefiles to create a new clean server db\n"
  " */";
#else
static const char *Dtool_DownloadDb_create_new_server_db_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::server_add_multifile(std::string mfname, Phase phase, int size, int status)
 */
static PyObject *Dtool_DownloadDb_server_add_multifile_398(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.server_add_multifile")) {
    return NULL;
  }
  // 1-void DownloadDb::server_add_multifile(std::string mfname, Phase phase, int size, int status)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  float param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"mfname", "phase", "size", "status", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#fii:server_add_multifile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4)) {
    (*local_this).server_add_multifile(std::string(param1_str, param1_len), (Phase)param2, (int)param3, (int)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "server_add_multifile(const DownloadDb self, str mfname, float phase, int size, int status)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_server_add_multifile_398_comment =
  "C++ Interface:\n"
  "server_add_multifile(const DownloadDb self, str mfname, float phase, int size, int status)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_server_add_multifile_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::server_add_file(std::string mfname, std::string fname)
 */
static PyObject *Dtool_DownloadDb_server_add_file_399(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.server_add_file")) {
    return NULL;
  }
  // 1-void DownloadDb::server_add_file(std::string mfname, std::string fname)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"mfname", "fname", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:server_add_file", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    (*local_this).server_add_file(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "server_add_file(const DownloadDb self, str mfname, str fname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_server_add_file_399_comment =
  "C++ Interface:\n"
  "server_add_file(const DownloadDb self, str mfname, str fname)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DownloadDb_server_add_file_399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::add_version(Filename const &name, HashVal const &hash, int version)
 */
static PyObject *Dtool_DownloadDb_add_version_402(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.add_version")) {
    return NULL;
  }
  // 1-void DownloadDb::add_version(Filename const &name, HashVal const &hash, int version)
  PyObject *param1;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"name", "hash", "version", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:add_version", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DownloadDb.add_version", "Filename");
    }
    HashVal const *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_HashVal, 2, "DownloadDb.add_version", true, true);
    if (param2_this != NULL) {
      (*local_this).add_version(*param1_this, *param2_this, (int)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_version(const DownloadDb self, const Filename name, const HashVal hash, int version)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_add_version_402_comment =
  "C++ Interface:\n"
  "add_version(const DownloadDb self, const Filename name, const HashVal hash, int version)\n"
  "\n"
  "/**\n"
  " * Appends a new version of the file onto the end of the list, or changes the\n"
  " * hash associated with a version previously added.\n"
  " *\n"
  " * Note: version numbers start at 1\n"
  " */";
#else
static const char *Dtool_DownloadDb_add_version_402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::insert_new_version(Filename const &name, HashVal const &hash)
 */
static PyObject *Dtool_DownloadDb_insert_new_version_403(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.insert_new_version")) {
    return NULL;
  }
  // 1-void DownloadDb::insert_new_version(Filename const &name, HashVal const &hash)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "hash", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:insert_new_version", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DownloadDb.insert_new_version", "Filename");
    }
    HashVal const *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_HashVal, 2, "DownloadDb.insert_new_version", true, true);
    if (param2_this != NULL) {
      (*local_this).insert_new_version(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_new_version(const DownloadDb self, const Filename name, const HashVal hash)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_insert_new_version_403_comment =
  "C++ Interface:\n"
  "insert_new_version(const DownloadDb self, const Filename name, const HashVal hash)\n"
  "\n"
  "/**\n"
  " * Inserts a new version 1 copy of the file, sliding all the other versions up\n"
  " * by one.\n"
  " */";
#else
static const char *Dtool_DownloadDb_insert_new_version_403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DownloadDb::has_version(Filename const &name) const
 */
static PyObject *Dtool_DownloadDb_has_version_404(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DownloadDb::has_version(Filename const &name) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DownloadDb.has_version", "Filename");
  }
  bool return_value = (*(const DownloadDb*)local_this).has_version(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_version(DownloadDb self, const Filename name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_has_version_404_comment =
  "C++ Interface:\n"
  "has_version(DownloadDb self, const Filename name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated file has version information, false\n"
  " * otherwise.  Some files recorded in the database may not bother to track\n"
  " * versions.\n"
  " */";
#else
static const char *Dtool_DownloadDb_has_version_404_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DownloadDb::get_num_versions(Filename const &name) const
 */
static PyObject *Dtool_DownloadDb_get_num_versions_405(PyObject *self, PyObject *arg) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DownloadDb::get_num_versions(Filename const &name) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DownloadDb.get_num_versions", "Filename");
  }
  int return_value = (*(const DownloadDb*)local_this).get_num_versions(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_versions(DownloadDb self, const Filename name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_num_versions_405_comment =
  "C++ Interface:\n"
  "get_num_versions(DownloadDb self, const Filename name)\n"
  "\n"
  "/**\n"
  " * Returns the number of versions stored for the indicated file.\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_num_versions_405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DownloadDb::set_num_versions(Filename const &name, int num_versions)
 */
static PyObject *Dtool_DownloadDb_set_num_versions_406(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DownloadDb, (void **)&local_this, "DownloadDb.set_num_versions")) {
    return NULL;
  }
  // 1-void DownloadDb::set_num_versions(Filename const &name, int num_versions)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"name", "num_versions", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_num_versions", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DownloadDb.set_num_versions", "Filename");
    }
    (*local_this).set_num_versions(*param1_this, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_versions(const DownloadDb self, const Filename name, int num_versions)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_set_num_versions_406_comment =
  "C++ Interface:\n"
  "set_num_versions(const DownloadDb self, const Filename name, int num_versions)\n"
  "\n"
  "/**\n"
  " * Reduces the number of versions of a particular file stored in the ddb by\n"
  " * throwing away all versions higher than the indicated index.\n"
  " */";
#else
static const char *Dtool_DownloadDb_set_num_versions_406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int DownloadDb::get_version(Filename const &name, HashVal const &hash) const
 */
static PyObject *Dtool_DownloadDb_get_version_407(PyObject *self, PyObject *args, PyObject *kwds) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-int DownloadDb::get_version(Filename const &name, HashVal const &hash) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "hash", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_version", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DownloadDb.get_version", "Filename");
    }
    HashVal const *param2_this = (HashVal *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_HashVal, 2, "DownloadDb.get_version", true, true);
    if (param2_this != NULL) {
      int return_value = (*(const DownloadDb*)local_this).get_version(*param1_this, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_version(DownloadDb self, const Filename name, const HashVal hash)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_version_407_comment =
  "C++ Interface:\n"
  "get_version(DownloadDb self, const Filename name, const HashVal hash)\n"
  "\n"
  "/**\n"
  " * Returns the version number of this particular file, determined by looking\n"
  " * up the hash generated from the file.  Returns -1 if the version number\n"
  " * cannot be determined.\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_version_407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * HashVal const &DownloadDb::get_hash(Filename const &name, int version) const
 */
static PyObject *Dtool_DownloadDb_get_hash_408(PyObject *self, PyObject *args) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }
  // 1-HashVal const &DownloadDb::get_hash(Filename const &name, int version) const
  PyObject *param1;
  int param2;
  if (PyArg_ParseTuple(args, "Oi:get_hash", &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DownloadDb.get_hash", "Filename");
    }
    HashVal const *return_value = &((*(const DownloadDb*)local_this).get_hash(*param1_this, (int)param2));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hash(DownloadDb self, const Filename name, int version)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DownloadDb_get_hash_408_comment =
  "C++ Interface:\n"
  "get_hash(DownloadDb self, const Filename name, int version)\n"
  "\n"
  "/**\n"
  " * Returns the MD5 hash associated with the indicated version of the indicated\n"
  " * file.\n"
  " */";
#else
static const char *Dtool_DownloadDb_get_hash_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DownloadDb::DownloadDb(void)
 * inline DownloadDb::DownloadDb(DownloadDb const &) = default
 * DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
 * DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
 */
static int Dtool_Init_DownloadDb(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DownloadDb::DownloadDb(void)
      DownloadDb *return_value = new DownloadDb();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DownloadDb, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline DownloadDb::DownloadDb(DownloadDb const &) = default
      DownloadDb const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_DownloadDb(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "DownloadDb.DownloadDb", "DownloadDb");
        return -1;
      }
      DownloadDb *return_value = new DownloadDb(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DownloadDb, true, false);
    }
    break;
  case 2:
    {
      {
        // -2 DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"server_file", "client_file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:DownloadDb", (char **)keyword_list, &param0, &param1)) {
          Ramfile *param0_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Ramfile, 0, "DownloadDb.DownloadDb", false, false);
          Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Filename, 1, "DownloadDb.DownloadDb", false, false);
          if (param0_this != NULL && param1_this != NULL) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DownloadDb, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"server_file", "client_file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:DownloadDb", (char **)keyword_list, &param0, &param1)) {
          Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Filename, 0, "DownloadDb.DownloadDb", false, false);
          Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Filename, 1, "DownloadDb.DownloadDb", false, false);
          if (param0_this != NULL && param1_this != NULL) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DownloadDb, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"server_file", "client_file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:DownloadDb", (char **)keyword_list, &param0, &param1)) {
          Ramfile *param0_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Ramfile, 0, "DownloadDb.DownloadDb", false, false);
          Filename param1_local;
          Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if (param0_this != NULL && (param1_this != NULL)) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DownloadDb, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"server_file", "client_file", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:DownloadDb", (char **)keyword_list, &param0, &param1)) {
          Filename param0_local;
          Filename *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          Filename param1_local;
          Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
          if ((param0_this != NULL) && (param1_this != NULL)) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DownloadDb, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DownloadDb() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DownloadDb()\n"
      "DownloadDb(const DownloadDb param0)\n"
      "DownloadDb(Ramfile server_file, Filename client_file)\n"
      "DownloadDb(Filename server_file, Filename client_file)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DownloadDb(PyObject *args, DownloadDb const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DownloadDb, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "DownloadDb", 2, 2, &param0, &param1)) {
          Ramfile *param0_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Ramfile, 0, "DownloadDb.DownloadDb", false, false);
          Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Filename, 1, "DownloadDb.DownloadDb", false, false);
          if (param0_this != NULL && param1_this != NULL) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "DownloadDb", 2, 2, &param0, &param1)) {
          Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Filename, 0, "DownloadDb.DownloadDb", false, false);
          Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Filename, 1, "DownloadDb.DownloadDb", false, false);
          if (param0_this != NULL && param1_this != NULL) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_DownloadDb(PyObject *args, DownloadDb *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DownloadDb, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      {
        // -2 DownloadDb::DownloadDb(Ramfile &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "DownloadDb", 2, 2, &param0, &param1)) {
          Ramfile *param0_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Ramfile, 0, "DownloadDb.DownloadDb", false, false);
          Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Filename, 1, "DownloadDb.DownloadDb", false, false);
          if (param0_this != NULL && param1_this != NULL) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DownloadDb::DownloadDb(Filename &server_file, Filename &client_file)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "DownloadDb", 2, 2, &param0, &param1)) {
          Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Filename, 0, "DownloadDb.DownloadDb", false, false);
          Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Filename, 1, "DownloadDb.DownloadDb", false, false);
          if (param0_this != NULL && param1_this != NULL) {
            DownloadDb *return_value = new DownloadDb(*param0_this, *param1_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_DownloadDb(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DownloadDb) {
    printf("DownloadDb ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DownloadDb *local_this = (DownloadDb *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DownloadDb) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DownloadDb(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DownloadDb) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Extractor
 */
/**
 * Python function wrapper for:
 * bool Extractor::set_multifile(Filename const &multifile_name)
 */
static PyObject *Dtool_Extractor_set_multifile_414(PyObject *self, PyObject *arg) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.set_multifile")) {
    return NULL;
  }
  // 1-bool Extractor::set_multifile(Filename const &multifile_name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Extractor.set_multifile", "Filename");
  }
  bool return_value = (*local_this).set_multifile(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multifile(const Extractor self, const Filename multifile_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Extractor_set_multifile_414_comment =
  "C++ Interface:\n"
  "set_multifile(const Extractor self, const Filename multifile_name)\n"
  "\n"
  "/**\n"
  " * Specifies the filename of the Multifile that the Extractor will read.\n"
  " * Returns true on success, false if the mulifile name is invalid.\n"
  " */";
#else
static const char *Dtool_Extractor_set_multifile_414_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Extractor::set_extract_dir(Filename const &extract_dir)
 */
static PyObject *Dtool_Extractor_set_extract_dir_415(PyObject *self, PyObject *arg) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.set_extract_dir")) {
    return NULL;
  }
  // 1-void Extractor::set_extract_dir(Filename const &extract_dir)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Extractor.set_extract_dir", "Filename");
  }
  (*local_this).set_extract_dir(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extract_dir(const Extractor self, const Filename extract_dir)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Extractor_set_extract_dir_415_comment =
  "C++ Interface:\n"
  "set_extract_dir(const Extractor self, const Filename extract_dir)\n"
  "\n"
  "/**\n"
  " * Specifies the directory into which all extracted subfiles will be written.\n"
  " * Relative paths of subfiles within the Multifile will be written as relative\n"
  " * paths to this directory.\n"
  " */";
#else
static const char *Dtool_Extractor_set_extract_dir_415_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Extractor::reset(void)
 */
static PyObject *Dtool_Extractor_reset_416(PyObject *self, PyObject *) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.reset")) {
    return NULL;
  }
  // 1-void Extractor::reset(void)
  (*local_this).reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Extractor_reset_416_comment =
  "C++ Interface:\n"
  "reset(const Extractor self)\n"
  "\n"
  "/**\n"
  " * Interrupts the Extractor in the middle of its business and makes it ready\n"
  " * to accept a new list of subfiles to extract.\n"
  " */";
#else
static const char *Dtool_Extractor_reset_416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Extractor::request_subfile(Filename const &subfile_name)
 */
static PyObject *Dtool_Extractor_request_subfile_417(PyObject *self, PyObject *arg) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.request_subfile")) {
    return NULL;
  }
  // 1-bool Extractor::request_subfile(Filename const &subfile_name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Extractor.request_subfile", "Filename");
  }
  bool return_value = (*local_this).request_subfile(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "request_subfile(const Extractor self, const Filename subfile_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Extractor_request_subfile_417_comment =
  "C++ Interface:\n"
  "request_subfile(const Extractor self, const Filename subfile_name)\n"
  "\n"
  "/**\n"
  " * Requests a particular subfile to be extracted when step() or run() is\n"
  " * called.  Returns true if the subfile exists, false otherwise.\n"
  " */";
#else
static const char *Dtool_Extractor_request_subfile_417_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Extractor::request_all_subfiles(void)
 */
static PyObject *Dtool_Extractor_request_all_subfiles_418(PyObject *self, PyObject *) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.request_all_subfiles")) {
    return NULL;
  }
  // 1-int Extractor::request_all_subfiles(void)
  int return_value = (*local_this).request_all_subfiles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Extractor_request_all_subfiles_418_comment =
  "C++ Interface:\n"
  "request_all_subfiles(const Extractor self)\n"
  "\n"
  "/**\n"
  " * Requests all subfiles in the Multifile to be extracted.  Returns the number\n"
  " * requested.\n"
  " */";
#else
static const char *Dtool_Extractor_request_all_subfiles_418_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Extractor::step(void)
 */
static PyObject *Dtool_Extractor_step_419(PyObject *self, PyObject *) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.step")) {
    return NULL;
  }
  // 1-int Extractor::step(void)
  int return_value = (*local_this).step();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Extractor_step_419_comment =
  "C++ Interface:\n"
  "step(const Extractor self)\n"
  "\n"
  "/**\n"
  " * After all of the requests have been made via request_file() or\n"
  " * request_all_subfiles(), call step() repeatedly until it stops returning\n"
  " * EU_ok.\n"
  " *\n"
  " * step() extracts the next small unit of data from the Multifile.  Returns\n"
  " * EU_ok if progress is continuing, EU_error_abort if there is a problem, or\n"
  " * EU_success when the last piece has been extracted.\n"
  " *\n"
  " * Also see run().\n"
  " */";
#else
static const char *Dtool_Extractor_step_419_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat Extractor::get_progress(void) const
 */
static PyObject *Dtool_Extractor_get_progress_420(PyObject *self, PyObject *) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Extractor, (void **)&local_this)) {
    return NULL;
  }
  // 1-PN_stdfloat Extractor::get_progress(void) const
  PN_stdfloat return_value = (*(const Extractor*)local_this).get_progress();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Extractor_get_progress_420_comment =
  "C++ Interface:\n"
  "get_progress(Extractor self)\n"
  "\n"
  "/**\n"
  " * Returns the fraction of the Multifile extracted so far.\n"
  " */";
#else
static const char *Dtool_Extractor_get_progress_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Extractor::run(void)
 */
static PyObject *Dtool_Extractor_run_421(PyObject *self, PyObject *) {
  Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Extractor, (void **)&local_this, "Extractor.run")) {
    return NULL;
  }
  // 1-bool Extractor::run(void)
  bool return_value = (*local_this).run();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Extractor_run_421_comment =
  "C++ Interface:\n"
  "run(const Extractor self)\n"
  "\n"
  "/**\n"
  " * A convenience function to extract the Multifile all at once, when you don't\n"
  " * care about doing it in the background.\n"
  " *\n"
  " * First, call request_file() or request_all_files() to specify the files you\n"
  " * would like to extract, then call run() to do the extraction.  Also see\n"
  " * step() for when you would like the extraction to happen as a background\n"
  " * task.\n"
  " */";
#else
static const char *Dtool_Extractor_run_421_comment = NULL;
#endif

static PyObject *Dtool_Extractor_progress_Getter(PyObject *self, void *) {
  const Extractor *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Extractor, (void **)&local_this)) {
    return NULL;
  }

  // 1-PN_stdfloat Extractor::get_progress(void) const
  PN_stdfloat return_value = (*(const Extractor*)local_this).get_progress();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * Extractor::Extractor(void)
 */
static int Dtool_Init_Extractor(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Extractor() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-Extractor::Extractor(void)
  Extractor *return_value = new Extractor();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Extractor, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Extractor()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Extractor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Extractor) {
    printf("Extractor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Extractor *local_this = (Extractor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Extractor) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Extractor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Extractor) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MultiplexStream
 */
/**
 * Python function wrapper for:
 * inline void MultiplexStream::add_ostream(ostream *out, bool delete_later = false)
 */
static PyObject *Dtool_MultiplexStream_add_ostream_425(PyObject *self, PyObject *args, PyObject *kwds) {
  MultiplexStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultiplexStream, (void **)&local_this, "MultiplexStream.add_ostream")) {
    return NULL;
  }
  // 1-inline void MultiplexStream::add_ostream(ostream *out, bool delete_later = false)
  PyObject *param1;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"out", "delete_later", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:add_ostream", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "MultiplexStream.add_ostream", false, true);
    if (param1_this != NULL) {
      (*local_this).add_ostream(param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ostream(const MultiplexStream self, ostream out, bool delete_later)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultiplexStream_add_ostream_425_comment =
  "C++ Interface:\n"
  "add_ostream(const MultiplexStream self, ostream out, bool delete_later)\n"
  "\n"
  "/**\n"
  " * Adds the indicated generic ostream to the multiplex output.  The ostream\n"
  " * will receive whatever data is sent to the pipe.\n"
  " */";
#else
static const char *Dtool_MultiplexStream_add_ostream_425_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MultiplexStream::add_standard_output(void)
 */
static PyObject *Dtool_MultiplexStream_add_standard_output_427(PyObject *self, PyObject *) {
  MultiplexStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultiplexStream, (void **)&local_this, "MultiplexStream.add_standard_output")) {
    return NULL;
  }
  // 1-inline void MultiplexStream::add_standard_output(void)
  (*local_this).add_standard_output();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MultiplexStream_add_standard_output_427_comment =
  "C++ Interface:\n"
  "add_standard_output(const MultiplexStream self)\n"
  "\n"
  "/**\n"
  " * Adds the standard output channel.\n"
  " */";
#else
static const char *Dtool_MultiplexStream_add_standard_output_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool MultiplexStream::add_file(Filename file)
 */
static PyObject *Dtool_MultiplexStream_add_file_428(PyObject *self, PyObject *arg) {
  MultiplexStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultiplexStream, (void **)&local_this, "MultiplexStream.add_file")) {
    return NULL;
  }
  // 1-inline bool MultiplexStream::add_file(Filename file)
  Filename arg_local;
  Filename *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "MultiplexStream.add_file", "Filename");
  }
  bool return_value = (*local_this).add_file(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_file(const MultiplexStream self, Filename file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MultiplexStream_add_file_428_comment =
  "C++ Interface:\n"
  "add_file(const MultiplexStream self, Filename file)\n"
  "\n"
  "/**\n"
  " * Adds the given file to the multiplex output.  The file is opened in append\n"
  " * mode with line buffering.  Returns false if the file cannot be opened.\n"
  " */";
#else
static const char *Dtool_MultiplexStream_add_file_428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MultiplexStream::add_system_debug(void)
 */
static PyObject *Dtool_MultiplexStream_add_system_debug_429(PyObject *self, PyObject *) {
  MultiplexStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultiplexStream, (void **)&local_this, "MultiplexStream.add_system_debug")) {
    return NULL;
  }
  // 1-inline void MultiplexStream::add_system_debug(void)
  (*local_this).add_system_debug();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MultiplexStream_add_system_debug_429_comment =
  "C++ Interface:\n"
  "add_system_debug(const MultiplexStream self)\n"
  "\n"
  "/**\n"
  " * Adds the system debug output the the multiplex output.  This may map to a\n"
  " * syslog or some such os-specific output system.  It may do nothing on a\n"
  " * particular system.\n"
  " *\n"
  " * Presently, this maps only to OutputDebugString() on Windows.\n"
  " */";
#else
static const char *Dtool_MultiplexStream_add_system_debug_429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void MultiplexStream::flush(void)
 */
static PyObject *Dtool_MultiplexStream_flush_430(PyObject *self, PyObject *) {
  MultiplexStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MultiplexStream, (void **)&local_this, "MultiplexStream.flush")) {
    return NULL;
  }
  // 1-inline void MultiplexStream::flush(void)
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MultiplexStream_flush_430_comment =
  "C++ Interface:\n"
  "flush(const MultiplexStream self)\n"
  "\n"
  "/**\n"
  " * Forces out all output that hasn't yet been written.\n"
  " */";
#else
static const char *Dtool_MultiplexStream_flush_430_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline MultiplexStream::MultiplexStream(void)
 */
static int Dtool_Init_MultiplexStream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "MultiplexStream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline MultiplexStream::MultiplexStream(void)
  MultiplexStream *return_value = new MultiplexStream();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MultiplexStream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MultiplexStream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MultiplexStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MultiplexStream) {
    printf("MultiplexStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MultiplexStream *local_this = (MultiplexStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MultiplexStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MultiplexStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MultiplexStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (MultiplexStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileHTTP
 */
/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileHTTP::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileHTTP_get_class_type_434(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileHTTP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileHTTP::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileHTTP_get_class_type_434_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileHTTP_get_class_type_434_comment = NULL;
#endif

static int Dtool_Init_VirtualFileHTTP(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileHTTP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileHTTP) {
    printf("VirtualFileHTTP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileHTTP *local_this = (VirtualFileHTTP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileHTTP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFile) {
    return (VirtualFile *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileHTTP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileHTTP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileHTTP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileHTTP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileHTTP*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    VirtualFile* other_this = (VirtualFile*)from_this;
    return (VirtualFileHTTP*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileMountHTTP
 */
/**
 * Python function wrapper for:
 * inline HTTPClient *VirtualFileMountHTTP::get_http_client(void) const
 */
static PyObject *Dtool_VirtualFileMountHTTP_get_http_client_438(PyObject *self, PyObject *) {
  VirtualFileMountHTTP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMountHTTP, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HTTPClient *VirtualFileMountHTTP::get_http_client(void) const
  HTTPClient *return_value = (*(const VirtualFileMountHTTP*)local_this).get_http_client();
  if (return_value != (HTTPClient *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (HTTPClient *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPClient, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountHTTP_get_http_client_438_comment =
  "C++ Interface:\n"
  "get_http_client(VirtualFileMountHTTP self)\n"
  "\n"
  "/**\n"
  " * Returns the HTTPClient object that services this mount point.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountHTTP_get_http_client_438_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline URLSpec const &VirtualFileMountHTTP::get_root(void) const
 */
static PyObject *Dtool_VirtualFileMountHTTP_get_root_439(PyObject *self, PyObject *) {
  VirtualFileMountHTTP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMountHTTP, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline URLSpec const &VirtualFileMountHTTP::get_root(void) const
  URLSpec const *return_value = &((*(const VirtualFileMountHTTP*)local_this).get_root());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_URLSpec, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountHTTP_get_root_439_comment =
  "C++ Interface:\n"
  "get_root(VirtualFileMountHTTP self)\n"
  "\n"
  "/**\n"
  " * Returns the URL that represents the root of this mount point.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountHTTP_get_root_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileMountHTTP::reload_vfs_mount_url(void)
 */
static PyObject *Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440(PyObject *, PyObject *) {
  // 1-static void VirtualFileMountHTTP::reload_vfs_mount_url(void)
  VirtualFileMountHTTP::reload_vfs_mount_url();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440_comment =
  "C++ Interface:\n"
  "reload_vfs_mount_url()\n"
  "\n"
  "/**\n"
  " * Reads all of the vfs-mount-url lines in the Config.prc file and replaces\n"
  " * the mount settings to match them.\n"
  " *\n"
  " * This will mount any url's mentioned in the config file, and unmount and\n"
  " * unmount any url's no longer mentioned in the config file.  Normally, it is\n"
  " * called automatically at startup, and need not be called again, unless you\n"
  " * have fiddled with some config settings.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountHTTP::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountHTTP_get_class_type_441(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountHTTP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileMountHTTP::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountHTTP_get_class_type_441_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountHTTP_get_class_type_441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http = HTTPClient::get_global_ptr())
 */
static int Dtool_Init_VirtualFileMountHTTP(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "root");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'root' (pos 1) not found");
        return -1;
      }
      // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
      URLSpec const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "VirtualFileMountHTTP.VirtualFileMountHTTP", "URLSpec");
        return -1;
      }
      VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountHTTP, true, false);
    }
    break;
  case 2:
    {
      // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"root", "http", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:VirtualFileMountHTTP", (char **)keyword_list, &param0, &param1)) {
        URLSpec const *param0_this;
        bool param0_manage = false;
        if (!Dtool_ConstCoerce_URLSpec(param0, param0_this, param0_manage)) {
          Dtool_Raise_ArgTypeError(param0, 0, "VirtualFileMountHTTP.VirtualFileMountHTTP", "URLSpec");
          return -1;
        }
        HTTPClient *param1_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_HTTPClient, 1, "VirtualFileMountHTTP.VirtualFileMountHTTP", false, true);
        if (param1_this != NULL) {
          VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*param0_this, param1_this);
          if (param0_manage) {
            delete param0_this;
          }
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountHTTP, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountHTTP() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountHTTP(const URLSpec root)\n"
      "VirtualFileMountHTTP(const URLSpec root, HTTPClient http)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VirtualFileMountHTTP(PyObject *args, CPT(VirtualFileMountHTTP) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualFileMountHTTP, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
    URLSpec const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_URLSpec, (void **)&arg_this);
    if (arg_this != NULL) {
      VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "VirtualFileMountHTTP", 2, 2, &param0, &param1)) {
        URLSpec const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_URLSpec, (void **)&param0_this);
        HTTPClient *param1_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_HTTPClient, 1, "VirtualFileMountHTTP.VirtualFileMountHTTP", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_VirtualFileMountHTTP(PyObject *args, PT(VirtualFileMountHTTP) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualFileMountHTTP, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
    URLSpec const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_URLSpec, (void **)&arg_this);
    if (arg_this != NULL) {
      VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-VirtualFileMountHTTP::VirtualFileMountHTTP(URLSpec const &root, HTTPClient *http)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "VirtualFileMountHTTP", 2, 2, &param0, &param1)) {
        URLSpec const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_URLSpec, (void **)&param0_this);
        HTTPClient *param1_this = (HTTPClient *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_HTTPClient, 1, "VirtualFileMountHTTP.VirtualFileMountHTTP", false, false);
        if (param0_this != NULL && param1_this != NULL) {
          VirtualFileMountHTTP *return_value = new VirtualFileMountHTTP(*param0_this, param1_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_VirtualFileMountHTTP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileMountHTTP) {
    printf("VirtualFileMountHTTP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileMountHTTP *local_this = (VirtualFileMountHTTP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileMountHTTP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileMountHTTP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountHTTP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountHTTP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountHTTP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountHTTP*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountHTTP*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Patcher
 */
/**
 * Python function wrapper for:
 * int Patcher::initiate(Filename &patch, Filename &infile)
 */
static PyObject *Dtool_Patcher_initiate_445(PyObject *self, PyObject *args, PyObject *kwds) {
  Patcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patcher, (void **)&local_this, "Patcher.initiate")) {
    return NULL;
  }
  // 1-int Patcher::initiate(Filename &patch, Filename &infile)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"patch", "infile", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:initiate", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Patcher.initiate", "Filename");
    }
    Filename param2_local;
    Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Patcher.initiate", "Filename");
    }
    int return_value = (*local_this).initiate(*param1_this, *param2_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initiate(const Patcher self, Filename patch, Filename infile)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patcher_initiate_445_comment =
  "C++ Interface:\n"
  "initiate(const Patcher self, Filename patch, Filename infile)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patcher_initiate_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Patcher::run(void)
 */
static PyObject *Dtool_Patcher_run_446(PyObject *self, PyObject *) {
  Patcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patcher, (void **)&local_this, "Patcher.run")) {
    return NULL;
  }
  // 1-int Patcher::run(void)
  int return_value = (*local_this).run();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patcher_run_446_comment =
  "C++ Interface:\n"
  "run(const Patcher self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patcher_run_446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Patcher::get_progress(void) const
 */
static PyObject *Dtool_Patcher_get_progress_447(PyObject *self, PyObject *) {
  Patcher *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patcher, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat Patcher::get_progress(void) const
  PN_stdfloat return_value = (*(const Patcher*)local_this).get_progress();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patcher_get_progress_447_comment =
  "C++ Interface:\n"
  "get_progress(Patcher self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patcher_get_progress_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Patcher::Patcher(void)
 * inline Patcher::Patcher(Patcher const &) = default
 * Patcher::Patcher(PointerTo< Buffer > buffer)
 */
static int Dtool_Init_Patcher(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Patcher::Patcher(void)
      Patcher *return_value = new Patcher();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patcher, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Patcher::Patcher(Patcher const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Patcher", (char **)keyword_list, &param0)) {
          Patcher const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Patcher, (void **)&param0_this);
          if (param0_this != NULL) {
            Patcher *return_value = new Patcher(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patcher, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 Patcher::Patcher(PointerTo< Buffer > buffer)
        PyObject *param0;
        static const char *keyword_list[] = {"buffer", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Patcher", (char **)keyword_list, &param0)) {
          Buffer *param0_this = (Buffer *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Buffer, 0, "Patcher.Patcher", false, false);
          if (param0_this != NULL) {
            Patcher *return_value = new Patcher(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patcher, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline Patcher::Patcher(Patcher const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Patcher", (char **)keyword_list, &param0)) {
          Patcher const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_Patcher(param0, param0_this, param0_manage)) {
            Patcher *return_value = new Patcher(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patcher, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: Patcher::Patcher(PointerTo< Buffer > buffer)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Patcher() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Patcher()\n"
      "Patcher(const Patcher param0)\n"
      "Patcher(Buffer buffer)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Patcher(PyObject *args, Patcher const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Patcher, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Patcher::Patcher(PointerTo< Buffer > buffer)
    Buffer *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Patcher.Patcher", false, false);
    if (arg_this != NULL) {
      Patcher *return_value = new Patcher(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Patcher(PyObject *args, Patcher *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Patcher, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Patcher::Patcher(PointerTo< Buffer > buffer)
    Buffer *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Patcher.Patcher", false, false);
    if (arg_this != NULL) {
      Patcher *return_value = new Patcher(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Patcher(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Patcher) {
    printf("Patcher ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Patcher *local_this = (Patcher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Patcher) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Patcher(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Patcher) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StringStream
 */
/**
 * Python function wrapper for:
 * inline void StringStream::clear_data(void)
 */
static PyObject *Dtool_StringStream_clear_data_450(PyObject *self, PyObject *) {
  StringStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.clear_data")) {
    return NULL;
  }
  // 1-inline void StringStream::clear_data(void)
  (*local_this).clear_data();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StringStream_clear_data_450_comment =
  "C++ Interface:\n"
  "clear_data(const StringStream self)\n"
  "\n"
  "/**\n"
  " * Empties the buffer.\n"
  " */";
#else
static const char *Dtool_StringStream_clear_data_450_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t StringStream::get_data_size(void)
 */
static PyObject *Dtool_StringStream_get_data_size_451(PyObject *self, PyObject *) {
  StringStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.get_data_size")) {
    return NULL;
  }
  // 1-inline std::size_t StringStream::get_data_size(void)
  std::size_t return_value = (*local_this).get_data_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StringStream_get_data_size_451_comment =
  "C++ Interface:\n"
  "get_data_size(const StringStream self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters available to be read from the data stream.\n"
  " */";
#else
static const char *Dtool_StringStream_get_data_size_451_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *StringStream::get_data(void)
 */
static PyObject *Dtool_StringStream_get_data_452(PyObject *self, PyObject *) {
  StringStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.get_data")) {
    return NULL;
  }
  // 1-PyObject *StringStream::get_data(void)
  PyObject *return_value = invoke_extension(local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StringStream_get_data_452_comment =
  "C++ Interface:\n"
  "get_data(const StringStream self)\n"
  "\n"
  "/**\n"
  " * Returns the contents of the data stream as a string.\n"
  " */";
#else
static const char *Dtool_StringStream_get_data_452_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StringStream::set_data(PyObject *data)
 */
static PyObject *Dtool_StringStream_set_data_453(PyObject *self, PyObject *arg) {
  StringStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.set_data")) {
    return NULL;
  }
  // 1-void StringStream::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const StringStream self, object data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StringStream_set_data_453_comment =
  "C++ Interface:\n"
  "set_data(const StringStream self, object data)\n"
  "\n"
  "/**\n"
  " * Replaces the contents of the data stream.  This implicitly reseeks to 0.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the contents of the data stream.  This implicitly reseeks to 0.\n"
  " */";
#else
static const char *Dtool_StringStream_set_data_453_comment = NULL;
#endif

static PyObject *Dtool_StringStream_data_Getter(PyObject *self, void *) {
  StringStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.data")) {
    return NULL;
  }

  // 1-PyObject *StringStream::get_data(void)
  PyObject *return_value = invoke_extension(local_this).get_data();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_StringStream_data_Setter(PyObject *self, PyObject *arg, void *) {
  StringStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.data")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete data attribute");
    return -1;
  }
  // 1-void StringStream::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_data(const StringStream self, object data)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline StringStream::StringStream(void)
 * StringStream::StringStream(PyObject *source)
 */
static int Dtool_Init_StringStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StringStream::StringStream(void)
      StringStream *return_value = new StringStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StringStream, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "source");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'source' (pos 1) not found");
        return -1;
      }
      // 1-StringStream::StringStream(PyObject *source)
      StringStream *result = new StringStream;
      invoke_extension(result).__init__(arg);
      StringStream *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StringStream, true, false);
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StringStream() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StringStream()\n"
      "StringStream(object source)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StringStream(PyObject *args, StringStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StringStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-StringStream::StringStream(PyObject *source)
    StringStream *result = new StringStream;
    invoke_extension(result).__init__(arg);
    StringStream *return_value = result;
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      delete return_value;
      return false;
    } else {
      coerced = return_value;
      manage = true;
      return true;
    }
  }
  return false;
}

bool Dtool_Coerce_StringStream(PyObject *args, StringStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StringStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-StringStream::StringStream(PyObject *source)
    StringStream *result = new StringStream;
    invoke_extension(result).__init__(arg);
    StringStream *return_value = result;
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != (PyObject *)NULL) {
      delete return_value;
      return false;
    } else {
      coerced = return_value;
      manage = true;
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_StringStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StringStream) {
    printf("StringStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StringStream *local_this = (StringStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StringStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_iostream) {
    return (iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *)(iostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StringStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StringStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_iostream) {
    iostream* other_this = (iostream*)from_this;
    return (StringStream*)other_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (StringStream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (StringStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for SSReader (SSReader)
 */
static PyMethodDef Dtool_Methods_SSReader[] = {
  {"receive_datagram", &Dtool_SSReader_receive_datagram_3, METH_O, (const char *)Dtool_SSReader_receive_datagram_3_comment},
  {"receiveDatagram", &Dtool_SSReader_receive_datagram_3, METH_O, (const char *)Dtool_SSReader_receive_datagram_3_comment},
  {"is_closed", &Dtool_SSReader_is_closed_4, METH_NOARGS, (const char *)Dtool_SSReader_is_closed_4_comment},
  {"isClosed", &Dtool_SSReader_is_closed_4, METH_NOARGS, (const char *)Dtool_SSReader_is_closed_4_comment},
  {"close", &Dtool_SSReader_close_5, METH_NOARGS, (const char *)Dtool_SSReader_close_5_comment},
  {"set_tcp_header_size", &Dtool_SSReader_set_tcp_header_size_6, METH_O, (const char *)Dtool_SSReader_set_tcp_header_size_6_comment},
  {"setTcpHeaderSize", &Dtool_SSReader_set_tcp_header_size_6, METH_O, (const char *)Dtool_SSReader_set_tcp_header_size_6_comment},
  {"get_tcp_header_size", &Dtool_SSReader_get_tcp_header_size_7, METH_NOARGS, (const char *)Dtool_SSReader_get_tcp_header_size_7_comment},
  {"getTcpHeaderSize", &Dtool_SSReader_get_tcp_header_size_7, METH_NOARGS, (const char *)Dtool_SSReader_get_tcp_header_size_7_comment},
  {"downcast_to_ISocketStream", &Dtool_SSReader_downcast_to_ISocketStream_26, METH_NOARGS, (const char *)Dtool_SSReader_downcast_to_ISocketStream_26_comment},
  {"downcastToISocketStream", &Dtool_SSReader_downcast_to_ISocketStream_26, METH_NOARGS, (const char *)Dtool_SSReader_downcast_to_ISocketStream_26_comment},
  {"downcast_to_SocketStream", &Dtool_SSReader_downcast_to_SocketStream_47, METH_NOARGS, (const char *)Dtool_SSReader_downcast_to_SocketStream_47_comment},
  {"downcastToSocketStream", &Dtool_SSReader_downcast_to_SocketStream_47, METH_NOARGS, (const char *)Dtool_SSReader_downcast_to_SocketStream_47_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SSReader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_SSReader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SSReader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SSReader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SSReader,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An internal class for reading from a socket stream.  This serves as a base\n"
    " * class for both ISocketStream and SocketStream; its purpose is to minimize\n"
    " * redundant code between them.  Do not use it directly.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SSReader,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SSReader,
    PyType_GenericAlloc,
    Dtool_new_SSReader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SSReader,
  Dtool_UpcastInterface_SSReader,
  Dtool_DowncastInterface_SSReader,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SSReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SSReader._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_SSReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SSReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SSReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SSReader);
  }
}

/**
 * Python method tables for SSWriter (SSWriter)
 */
static PyMethodDef Dtool_Methods_SSWriter[] = {
  {"send_datagram", &Dtool_SSWriter_send_datagram_10, METH_O, (const char *)Dtool_SSWriter_send_datagram_10_comment},
  {"sendDatagram", &Dtool_SSWriter_send_datagram_10, METH_O, (const char *)Dtool_SSWriter_send_datagram_10_comment},
  {"is_closed", &Dtool_SSWriter_is_closed_11, METH_NOARGS, (const char *)Dtool_SSWriter_is_closed_11_comment},
  {"isClosed", &Dtool_SSWriter_is_closed_11, METH_NOARGS, (const char *)Dtool_SSWriter_is_closed_11_comment},
  {"close", &Dtool_SSWriter_close_12, METH_NOARGS, (const char *)Dtool_SSWriter_close_12_comment},
  {"set_collect_tcp", &Dtool_SSWriter_set_collect_tcp_13, METH_O, (const char *)Dtool_SSWriter_set_collect_tcp_13_comment},
  {"setCollectTcp", &Dtool_SSWriter_set_collect_tcp_13, METH_O, (const char *)Dtool_SSWriter_set_collect_tcp_13_comment},
  {"get_collect_tcp", &Dtool_SSWriter_get_collect_tcp_14, METH_NOARGS, (const char *)Dtool_SSWriter_get_collect_tcp_14_comment},
  {"getCollectTcp", &Dtool_SSWriter_get_collect_tcp_14, METH_NOARGS, (const char *)Dtool_SSWriter_get_collect_tcp_14_comment},
  {"set_collect_tcp_interval", &Dtool_SSWriter_set_collect_tcp_interval_15, METH_O, (const char *)Dtool_SSWriter_set_collect_tcp_interval_15_comment},
  {"setCollectTcpInterval", &Dtool_SSWriter_set_collect_tcp_interval_15, METH_O, (const char *)Dtool_SSWriter_set_collect_tcp_interval_15_comment},
  {"get_collect_tcp_interval", &Dtool_SSWriter_get_collect_tcp_interval_16, METH_NOARGS, (const char *)Dtool_SSWriter_get_collect_tcp_interval_16_comment},
  {"getCollectTcpInterval", &Dtool_SSWriter_get_collect_tcp_interval_16, METH_NOARGS, (const char *)Dtool_SSWriter_get_collect_tcp_interval_16_comment},
  {"set_tcp_header_size", &Dtool_SSWriter_set_tcp_header_size_17, METH_O, (const char *)Dtool_SSWriter_set_tcp_header_size_17_comment},
  {"setTcpHeaderSize", &Dtool_SSWriter_set_tcp_header_size_17, METH_O, (const char *)Dtool_SSWriter_set_tcp_header_size_17_comment},
  {"get_tcp_header_size", &Dtool_SSWriter_get_tcp_header_size_18, METH_NOARGS, (const char *)Dtool_SSWriter_get_tcp_header_size_18_comment},
  {"getTcpHeaderSize", &Dtool_SSWriter_get_tcp_header_size_18, METH_NOARGS, (const char *)Dtool_SSWriter_get_tcp_header_size_18_comment},
  {"consider_flush", &Dtool_SSWriter_consider_flush_19, METH_NOARGS, (const char *)Dtool_SSWriter_consider_flush_19_comment},
  {"considerFlush", &Dtool_SSWriter_consider_flush_19, METH_NOARGS, (const char *)Dtool_SSWriter_consider_flush_19_comment},
  {"flush", &Dtool_SSWriter_flush_20, METH_NOARGS, (const char *)Dtool_SSWriter_flush_20_comment},
  {"downcast_to_OSocketStream", &Dtool_SSWriter_downcast_to_OSocketStream_37, METH_NOARGS, (const char *)Dtool_SSWriter_downcast_to_OSocketStream_37_comment},
  {"downcastToOSocketStream", &Dtool_SSWriter_downcast_to_OSocketStream_37, METH_NOARGS, (const char *)Dtool_SSWriter_downcast_to_OSocketStream_37_comment},
  {"downcast_to_SocketStream", &Dtool_SSWriter_downcast_to_SocketStream_49, METH_NOARGS, (const char *)Dtool_SSWriter_downcast_to_SocketStream_49_comment},
  {"downcastToSocketStream", &Dtool_SSWriter_downcast_to_SocketStream_49, METH_NOARGS, (const char *)Dtool_SSWriter_downcast_to_SocketStream_49_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SSWriter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_SSWriter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SSWriter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SSWriter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SSWriter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An internal class for writing to a socket stream.  This serves as a base\n"
    " * class for both OSocketStream and SocketStream; its purpose is to minimize\n"
    " * redundant code between them.  Do not use it directly.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SSWriter,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SSWriter,
    PyType_GenericAlloc,
    Dtool_new_SSWriter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SSWriter,
  Dtool_UpcastInterface_SSWriter,
  Dtool_DowncastInterface_SSWriter,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SSWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SSWriter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_SSWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SSWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SSWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SSWriter);
  }
}

/**
 * Python method tables for ISocketStream (ISocketStream)
 */
static PyMethodDef Dtool_Methods_ISocketStream[] = {
  {"is_closed", &Dtool_ISocketStream_is_closed_29, METH_NOARGS, (const char *)Dtool_ISocketStream_is_closed_29_comment},
  {"isClosed", &Dtool_ISocketStream_is_closed_29, METH_NOARGS, (const char *)Dtool_ISocketStream_is_closed_29_comment},
  {"close", &Dtool_ISocketStream_close_30, METH_NOARGS, (const char *)Dtool_ISocketStream_close_30_comment},
  {"get_read_state", &Dtool_ISocketStream_get_read_state_31, METH_NOARGS, (const char *)Dtool_ISocketStream_get_read_state_31_comment},
  {"getReadState", &Dtool_ISocketStream_get_read_state_31, METH_NOARGS, (const char *)Dtool_ISocketStream_get_read_state_31_comment},
  {"upcast_to_istream", &Dtool_ISocketStream_upcast_to_istream_23, METH_NOARGS, (const char *)Dtool_ISocketStream_upcast_to_istream_23_comment},
  {"upcastToIstream", &Dtool_ISocketStream_upcast_to_istream_23, METH_NOARGS, (const char *)Dtool_ISocketStream_upcast_to_istream_23_comment},
  {"upcast_to_SSReader", &Dtool_ISocketStream_upcast_to_SSReader_25, METH_NOARGS, (const char *)Dtool_ISocketStream_upcast_to_SSReader_25_comment},
  {"upcastToSSReader", &Dtool_ISocketStream_upcast_to_SSReader_25, METH_NOARGS, (const char *)Dtool_ISocketStream_upcast_to_SSReader_25_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ISocketStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ISocketStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ISocketStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ISocketStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ISocketStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ISocketStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ISocketStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ISocketStream,
    &Dtool_SequenceMethods_ISocketStream,
    &Dtool_MappingMethods_ISocketStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ISocketStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for istreams implemented in Panda that read from a\n"
    " * (possibly non-blocking) socket.  It adds is_closed(), which can be called\n"
    " * after an eof condition to check whether the socket has been closed, or\n"
    " * whether more data may be available later.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ISocketStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ISocketStream,
    PyType_GenericAlloc,
    Dtool_new_ISocketStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ISocketStream,
  Dtool_UpcastInterface_ISocketStream,
  Dtool_DowncastInterface_ISocketStream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ISocketStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_istream != NULL);
    assert(Dtool_Ptr_istream->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_istream->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_SSReader(NULL);
    Dtool_ISocketStream._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_istream, (PyTypeObject *)&Dtool_SSReader);
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_ISocketStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ISocketStream::ReadState;
    PyDict_SetItemString(dict, "RS_initial", Dtool_WrapValue(ISocketStream::RS_initial));
    PyDict_SetItemString(dict, "RSInitial", Dtool_WrapValue(ISocketStream::RS_initial));
    PyDict_SetItemString(dict, "RS_reading", Dtool_WrapValue(ISocketStream::RS_reading));
    PyDict_SetItemString(dict, "RSReading", Dtool_WrapValue(ISocketStream::RS_reading));
    PyDict_SetItemString(dict, "RS_complete", Dtool_WrapValue(ISocketStream::RS_complete));
    PyDict_SetItemString(dict, "RSComplete", Dtool_WrapValue(ISocketStream::RS_complete));
    PyDict_SetItemString(dict, "RS_error", Dtool_WrapValue(ISocketStream::RS_error));
    PyDict_SetItemString(dict, "RSError", Dtool_WrapValue(ISocketStream::RS_error));
    if (PyType_Ready((PyTypeObject *)&Dtool_ISocketStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ISocketStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ISocketStream);
  }
}

/**
 * Python method tables for OSocketStream (OSocketStream)
 */
static PyMethodDef Dtool_Methods_OSocketStream[] = {
  {"is_closed", &Dtool_OSocketStream_is_closed_38, METH_NOARGS, (const char *)Dtool_OSocketStream_is_closed_38_comment},
  {"isClosed", &Dtool_OSocketStream_is_closed_38, METH_NOARGS, (const char *)Dtool_OSocketStream_is_closed_38_comment},
  {"close", &Dtool_OSocketStream_close_39, METH_NOARGS, (const char *)Dtool_OSocketStream_close_39_comment},
  {"flush", &Dtool_OSocketStream_flush_40, METH_NOARGS, (const char *)Dtool_OSocketStream_flush_40_comment},
  {"upcast_to_ostream", &Dtool_OSocketStream_upcast_to_ostream_34, METH_NOARGS, (const char *)Dtool_OSocketStream_upcast_to_ostream_34_comment},
  {"upcastToOstream", &Dtool_OSocketStream_upcast_to_ostream_34, METH_NOARGS, (const char *)Dtool_OSocketStream_upcast_to_ostream_34_comment},
  {"upcast_to_SSWriter", &Dtool_OSocketStream_upcast_to_SSWriter_36, METH_NOARGS, (const char *)Dtool_OSocketStream_upcast_to_SSWriter_36_comment},
  {"upcastToSSWriter", &Dtool_OSocketStream_upcast_to_SSWriter_36, METH_NOARGS, (const char *)Dtool_OSocketStream_upcast_to_SSWriter_36_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OSocketStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OSocketStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OSocketStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OSocketStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OSocketStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OSocketStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OSocketStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OSocketStream,
    &Dtool_SequenceMethods_OSocketStream,
    &Dtool_MappingMethods_OSocketStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OSocketStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for ostreams that write to a (possibly non-blocking) socket.\n"
    " * It adds is_closed(), which can be called after any write operation fails to\n"
    " * check whether the socket has been closed, or whether more data may be sent\n"
    " * later.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OSocketStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OSocketStream,
    PyType_GenericAlloc,
    Dtool_new_OSocketStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OSocketStream,
  Dtool_UpcastInterface_OSocketStream,
  Dtool_DowncastInterface_OSocketStream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OSocketStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ostream != NULL);
    assert(Dtool_Ptr_ostream->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ostream->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_SSWriter(NULL);
    Dtool_OSocketStream._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_ostream, (PyTypeObject *)&Dtool_SSWriter);
    PyObject *dict = PyDict_New();
    Dtool_OSocketStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OSocketStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OSocketStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OSocketStream);
  }
}

/**
 * Python method tables for SocketStream (SocketStream)
 */
static PyMethodDef Dtool_Methods_SocketStream[] = {
  {"is_closed", &Dtool_SocketStream_is_closed_50, METH_NOARGS, (const char *)Dtool_SocketStream_is_closed_50_comment},
  {"isClosed", &Dtool_SocketStream_is_closed_50, METH_NOARGS, (const char *)Dtool_SocketStream_is_closed_50_comment},
  {"close", &Dtool_SocketStream_close_51, METH_NOARGS, (const char *)Dtool_SocketStream_close_51_comment},
  {"set_tcp_header_size", &Dtool_SocketStream_set_tcp_header_size_52, METH_O, (const char *)Dtool_SocketStream_set_tcp_header_size_52_comment},
  {"setTcpHeaderSize", &Dtool_SocketStream_set_tcp_header_size_52, METH_O, (const char *)Dtool_SocketStream_set_tcp_header_size_52_comment},
  {"get_tcp_header_size", &Dtool_SocketStream_get_tcp_header_size_53, METH_NOARGS, (const char *)Dtool_SocketStream_get_tcp_header_size_53_comment},
  {"getTcpHeaderSize", &Dtool_SocketStream_get_tcp_header_size_53, METH_NOARGS, (const char *)Dtool_SocketStream_get_tcp_header_size_53_comment},
  {"flush", &Dtool_SocketStream_flush_54, METH_NOARGS, (const char *)Dtool_SocketStream_flush_54_comment},
  {"upcast_to_iostream", &Dtool_SocketStream_upcast_to_iostream_44, METH_NOARGS, (const char *)Dtool_SocketStream_upcast_to_iostream_44_comment},
  {"upcastToIostream", &Dtool_SocketStream_upcast_to_iostream_44, METH_NOARGS, (const char *)Dtool_SocketStream_upcast_to_iostream_44_comment},
  {"upcast_to_SSReader", &Dtool_SocketStream_upcast_to_SSReader_46, METH_NOARGS, (const char *)Dtool_SocketStream_upcast_to_SSReader_46_comment},
  {"upcastToSSReader", &Dtool_SocketStream_upcast_to_SSReader_46, METH_NOARGS, (const char *)Dtool_SocketStream_upcast_to_SSReader_46_comment},
  {"upcast_to_SSWriter", &Dtool_SocketStream_upcast_to_SSWriter_48, METH_NOARGS, (const char *)Dtool_SocketStream_upcast_to_SSWriter_48_comment},
  {"upcastToSSWriter", &Dtool_SocketStream_upcast_to_SSWriter_48, METH_NOARGS, (const char *)Dtool_SocketStream_upcast_to_SSWriter_48_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SocketStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SocketStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SocketStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SocketStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SocketStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SocketStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SocketStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SocketStream,
    &Dtool_SequenceMethods_SocketStream,
    &Dtool_MappingMethods_SocketStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SocketStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for iostreams that read and write to a (possibly non-blocking)\n"
    " * socket.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SocketStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SocketStream,
    PyType_GenericAlloc,
    Dtool_new_SocketStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SocketStream,
  Dtool_UpcastInterface_SocketStream,
  Dtool_DowncastInterface_SocketStream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_SocketStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_iostream != NULL);
    assert(Dtool_Ptr_iostream->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_iostream->_Dtool_ModuleClassInit(NULL);
    Dtool_PyModuleClassInit_SSReader(NULL);
    Dtool_PyModuleClassInit_SSWriter(NULL);
    Dtool_SocketStream._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_iostream, (PyTypeObject *)&Dtool_SSReader, (PyTypeObject *)&Dtool_SSWriter);
    PyObject *dict = PyDict_New();
    Dtool_SocketStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SocketStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SocketStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SocketStream);
  }
}

/**
 * Python method tables for URLSpec (URLSpec)
 */
static PyMethodDef Dtool_Methods_URLSpec[] = {
  {"assign", &Dtool_URLSpec_operator_58, METH_O, (const char *)Dtool_URLSpec_operator_58_comment},
  {"compare_to", &Dtool_URLSpec_compare_to_62, METH_O, (const char *)Dtool_URLSpec_compare_to_62_comment},
  {"compareTo", &Dtool_URLSpec_compare_to_62, METH_O, (const char *)Dtool_URLSpec_compare_to_62_comment},
  {"get_hash", &Dtool_URLSpec_get_hash_63, METH_NOARGS, (const char *)Dtool_URLSpec_get_hash_63_comment},
  {"getHash", &Dtool_URLSpec_get_hash_63, METH_NOARGS, (const char *)Dtool_URLSpec_get_hash_63_comment},
  {"has_scheme", &Dtool_URLSpec_has_scheme_64, METH_NOARGS, (const char *)Dtool_URLSpec_has_scheme_64_comment},
  {"hasScheme", &Dtool_URLSpec_has_scheme_64, METH_NOARGS, (const char *)Dtool_URLSpec_has_scheme_64_comment},
  {"has_authority", &Dtool_URLSpec_has_authority_65, METH_NOARGS, (const char *)Dtool_URLSpec_has_authority_65_comment},
  {"hasAuthority", &Dtool_URLSpec_has_authority_65, METH_NOARGS, (const char *)Dtool_URLSpec_has_authority_65_comment},
  {"has_username", &Dtool_URLSpec_has_username_66, METH_NOARGS, (const char *)Dtool_URLSpec_has_username_66_comment},
  {"hasUsername", &Dtool_URLSpec_has_username_66, METH_NOARGS, (const char *)Dtool_URLSpec_has_username_66_comment},
  {"has_server", &Dtool_URLSpec_has_server_67, METH_NOARGS, (const char *)Dtool_URLSpec_has_server_67_comment},
  {"hasServer", &Dtool_URLSpec_has_server_67, METH_NOARGS, (const char *)Dtool_URLSpec_has_server_67_comment},
  {"has_port", &Dtool_URLSpec_has_port_68, METH_NOARGS, (const char *)Dtool_URLSpec_has_port_68_comment},
  {"hasPort", &Dtool_URLSpec_has_port_68, METH_NOARGS, (const char *)Dtool_URLSpec_has_port_68_comment},
  {"has_path", &Dtool_URLSpec_has_path_69, METH_NOARGS, (const char *)Dtool_URLSpec_has_path_69_comment},
  {"hasPath", &Dtool_URLSpec_has_path_69, METH_NOARGS, (const char *)Dtool_URLSpec_has_path_69_comment},
  {"has_query", &Dtool_URLSpec_has_query_70, METH_NOARGS, (const char *)Dtool_URLSpec_has_query_70_comment},
  {"hasQuery", &Dtool_URLSpec_has_query_70, METH_NOARGS, (const char *)Dtool_URLSpec_has_query_70_comment},
  {"get_scheme", &Dtool_URLSpec_get_scheme_71, METH_NOARGS, (const char *)Dtool_URLSpec_get_scheme_71_comment},
  {"getScheme", &Dtool_URLSpec_get_scheme_71, METH_NOARGS, (const char *)Dtool_URLSpec_get_scheme_71_comment},
  {"get_authority", &Dtool_URLSpec_get_authority_72, METH_NOARGS, (const char *)Dtool_URLSpec_get_authority_72_comment},
  {"getAuthority", &Dtool_URLSpec_get_authority_72, METH_NOARGS, (const char *)Dtool_URLSpec_get_authority_72_comment},
  {"get_username", &Dtool_URLSpec_get_username_73, METH_NOARGS, (const char *)Dtool_URLSpec_get_username_73_comment},
  {"getUsername", &Dtool_URLSpec_get_username_73, METH_NOARGS, (const char *)Dtool_URLSpec_get_username_73_comment},
  {"get_server", &Dtool_URLSpec_get_server_74, METH_NOARGS, (const char *)Dtool_URLSpec_get_server_74_comment},
  {"getServer", &Dtool_URLSpec_get_server_74, METH_NOARGS, (const char *)Dtool_URLSpec_get_server_74_comment},
  {"get_port_str", &Dtool_URLSpec_get_port_str_75, METH_NOARGS, (const char *)Dtool_URLSpec_get_port_str_75_comment},
  {"getPortStr", &Dtool_URLSpec_get_port_str_75, METH_NOARGS, (const char *)Dtool_URLSpec_get_port_str_75_comment},
  {"get_port", &Dtool_URLSpec_get_port_76, METH_NOARGS, (const char *)Dtool_URLSpec_get_port_76_comment},
  {"getPort", &Dtool_URLSpec_get_port_76, METH_NOARGS, (const char *)Dtool_URLSpec_get_port_76_comment},
  {"get_server_and_port", &Dtool_URLSpec_get_server_and_port_77, METH_NOARGS, (const char *)Dtool_URLSpec_get_server_and_port_77_comment},
  {"getServerAndPort", &Dtool_URLSpec_get_server_and_port_77, METH_NOARGS, (const char *)Dtool_URLSpec_get_server_and_port_77_comment},
  {"is_default_port", &Dtool_URLSpec_is_default_port_78, METH_NOARGS, (const char *)Dtool_URLSpec_is_default_port_78_comment},
  {"isDefaultPort", &Dtool_URLSpec_is_default_port_78, METH_NOARGS, (const char *)Dtool_URLSpec_is_default_port_78_comment},
  {"get_default_port_for_scheme", &Dtool_URLSpec_get_default_port_for_scheme_79, METH_O | METH_STATIC, (const char *)Dtool_URLSpec_get_default_port_for_scheme_79_comment},
  {"getDefaultPortForScheme", &Dtool_URLSpec_get_default_port_for_scheme_79, METH_O | METH_STATIC, (const char *)Dtool_URLSpec_get_default_port_for_scheme_79_comment},
  {"get_path", &Dtool_URLSpec_get_path_80, METH_NOARGS, (const char *)Dtool_URLSpec_get_path_80_comment},
  {"getPath", &Dtool_URLSpec_get_path_80, METH_NOARGS, (const char *)Dtool_URLSpec_get_path_80_comment},
  {"get_query", &Dtool_URLSpec_get_query_81, METH_NOARGS, (const char *)Dtool_URLSpec_get_query_81_comment},
  {"getQuery", &Dtool_URLSpec_get_query_81, METH_NOARGS, (const char *)Dtool_URLSpec_get_query_81_comment},
  {"get_path_and_query", &Dtool_URLSpec_get_path_and_query_82, METH_NOARGS, (const char *)Dtool_URLSpec_get_path_and_query_82_comment},
  {"getPathAndQuery", &Dtool_URLSpec_get_path_and_query_82, METH_NOARGS, (const char *)Dtool_URLSpec_get_path_and_query_82_comment},
  {"is_ssl", &Dtool_URLSpec_is_ssl_83, METH_NOARGS, (const char *)Dtool_URLSpec_is_ssl_83_comment},
  {"isSsl", &Dtool_URLSpec_is_ssl_83, METH_NOARGS, (const char *)Dtool_URLSpec_is_ssl_83_comment},
  {"get_url", &Dtool_URLSpec_get_url_84, METH_NOARGS, (const char *)Dtool_URLSpec_get_url_84_comment},
  {"getUrl", &Dtool_URLSpec_get_url_84, METH_NOARGS, (const char *)Dtool_URLSpec_get_url_84_comment},
  {"set_scheme", &Dtool_URLSpec_set_scheme_85, METH_O, (const char *)Dtool_URLSpec_set_scheme_85_comment},
  {"setScheme", &Dtool_URLSpec_set_scheme_85, METH_O, (const char *)Dtool_URLSpec_set_scheme_85_comment},
  {"set_authority", &Dtool_URLSpec_set_authority_86, METH_O, (const char *)Dtool_URLSpec_set_authority_86_comment},
  {"setAuthority", &Dtool_URLSpec_set_authority_86, METH_O, (const char *)Dtool_URLSpec_set_authority_86_comment},
  {"set_username", &Dtool_URLSpec_set_username_87, METH_O, (const char *)Dtool_URLSpec_set_username_87_comment},
  {"setUsername", &Dtool_URLSpec_set_username_87, METH_O, (const char *)Dtool_URLSpec_set_username_87_comment},
  {"set_server", &Dtool_URLSpec_set_server_88, METH_O, (const char *)Dtool_URLSpec_set_server_88_comment},
  {"setServer", &Dtool_URLSpec_set_server_88, METH_O, (const char *)Dtool_URLSpec_set_server_88_comment},
  {"set_port", &Dtool_URLSpec_set_port_89, METH_O, (const char *)Dtool_URLSpec_set_port_89_comment},
  {"setPort", &Dtool_URLSpec_set_port_89, METH_O, (const char *)Dtool_URLSpec_set_port_89_comment},
  {"set_server_and_port", &Dtool_URLSpec_set_server_and_port_90, METH_O, (const char *)Dtool_URLSpec_set_server_and_port_90_comment},
  {"setServerAndPort", &Dtool_URLSpec_set_server_and_port_90, METH_O, (const char *)Dtool_URLSpec_set_server_and_port_90_comment},
  {"set_path", &Dtool_URLSpec_set_path_91, METH_O, (const char *)Dtool_URLSpec_set_path_91_comment},
  {"setPath", &Dtool_URLSpec_set_path_91, METH_O, (const char *)Dtool_URLSpec_set_path_91_comment},
  {"set_query", &Dtool_URLSpec_set_query_92, METH_O, (const char *)Dtool_URLSpec_set_query_92_comment},
  {"setQuery", &Dtool_URLSpec_set_query_92, METH_O, (const char *)Dtool_URLSpec_set_query_92_comment},
  {"set_url", (PyCFunction) &Dtool_URLSpec_set_url_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_URLSpec_set_url_93_comment},
  {"setUrl", (PyCFunction) &Dtool_URLSpec_set_url_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_URLSpec_set_url_93_comment},
  {"c_str", &Dtool_URLSpec_c_str_95, METH_NOARGS, (const char *)Dtool_URLSpec_c_str_95_comment},
  {"cStr", &Dtool_URLSpec_c_str_95, METH_NOARGS, (const char *)Dtool_URLSpec_c_str_95_comment},
  {"empty", &Dtool_URLSpec_empty_96, METH_NOARGS, (const char *)Dtool_URLSpec_empty_96_comment},
  {"length", &Dtool_URLSpec_length_98, METH_NOARGS, (const char *)Dtool_URLSpec_length_98_comment},
  {"input", &Dtool_URLSpec_input_101, METH_O, (const char *)Dtool_URLSpec_input_101_comment},
  {"output", &Dtool_URLSpec_output_102, METH_O, (const char *)Dtool_URLSpec_output_102_comment},
  {"quote", (PyCFunction) &Dtool_URLSpec_quote_103, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_URLSpec_quote_103_comment},
  {"quote_plus", (PyCFunction) &Dtool_URLSpec_quote_plus_104, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_URLSpec_quote_plus_104_comment},
  {"quotePlus", (PyCFunction) &Dtool_URLSpec_quote_plus_104, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_URLSpec_quote_plus_104_comment},
  {"unquote", &Dtool_URLSpec_unquote_105, METH_O | METH_STATIC, (const char *)Dtool_URLSpec_unquote_105_comment},
  {"unquote_plus", &Dtool_URLSpec_unquote_plus_106, METH_O | METH_STATIC, (const char *)Dtool_URLSpec_unquote_plus_106_comment},
  {"unquotePlus", &Dtool_URLSpec_unquote_plus_106, METH_O | METH_STATIC, (const char *)Dtool_URLSpec_unquote_plus_106_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// URLSpec slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_URLSpec_operator_typecast_bool_97_nb_bool(PyObject *self) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// URLSpec slot sq_item -> operator []
//////////////////
static PyObject *Dtool_URLSpec_operator_100_sq_item(PyObject *self, Py_ssize_t index) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "URLSpec index out of range");
    return NULL;
  }
  // 1-inline char URLSpec::operator [](std::size_t n) const
  char return_value = (*(const URLSpec*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(URLSpec self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// URLSpec slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_URLSpec_size_99_sq_length(PyObject *self) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// URLSpec slot tp_compare -> compare_to
//////////////////
static int Dtool_URLSpec_compare_to_62_tp_compare(PyObject *self, PyObject *arg) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return -1;
  }

  // 1-int URLSpec::compare_to(URLSpec const &other) const
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "URLSpec.compare_to", "URLSpec");
    return -1;
  }
  int return_value = (*(const URLSpec*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(URLSpec self, const URLSpec other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// URLSpec slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_URLSpec_get_hash_63_tp_hash(PyObject *self) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// URLSpec slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_URLSpec_operator_typecast_94_tp_str(PyObject *self) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &URLSpec::operator typecast(void) const
  std::string const &return_value = (std::string const &)*(const URLSpec*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(URLSpec self)\n");
  }
  return NULL;
}

//////////////////
//  A __repr__ function
//     URLSpec
//////////////////
static PyObject *Dtool_Repr_URLSpec(PyObject *self) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     URLSpec
//////////////////
static PyObject *Dtool_RichCompare_URLSpec(PyObject *self, PyObject *arg, int op) {
  URLSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_URLSpec, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool URLSpec::operator ==(URLSpec const &other) const
      URLSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const URLSpec*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool URLSpec::operator !=(URLSpec const &other) const
      URLSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const URLSpec*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool URLSpec::operator <(URLSpec const &other) const
      URLSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const URLSpec*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_URLSpec_compare_to_62_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_URLSpec[] = {
  {(char *)"scheme", &Dtool_URLSpec_scheme_Getter, &Dtool_URLSpec_scheme_Setter, NULL, NULL},
  {(char *)"authority", &Dtool_URLSpec_authority_Getter, &Dtool_URLSpec_authority_Setter, NULL, NULL},
  {(char *)"username", &Dtool_URLSpec_username_Getter, &Dtool_URLSpec_username_Setter, NULL, NULL},
  {(char *)"server", &Dtool_URLSpec_server_Getter, &Dtool_URLSpec_server_Setter, NULL, NULL},
  {(char *)"port", &Dtool_URLSpec_port_Getter, &Dtool_URLSpec_port_Setter, NULL, NULL},
  {(char *)"server_and_port", &Dtool_URLSpec_server_and_port_Getter, &Dtool_URLSpec_server_and_port_Setter, NULL, NULL},
  {(char *)"path", &Dtool_URLSpec_path_Getter, &Dtool_URLSpec_path_Setter, NULL, NULL},
  {(char *)"query", &Dtool_URLSpec_query_Getter, &Dtool_URLSpec_query_Setter, NULL, NULL},
  {(char *)"ssl", &Dtool_URLSpec_ssl_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_URLSpec = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_URLSpec_operator_typecast_bool_97_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_URLSpec = {
  &Dtool_URLSpec_size_99_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_URLSpec_operator_100_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_URLSpec = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.URLSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_URLSpec,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_URLSpec_compare_to_62_tp_compare,
#endif
    &Dtool_Repr_URLSpec,
    &Dtool_NumberMethods_URLSpec,
    &Dtool_SequenceMethods_URLSpec,
    0, // tp_as_mapping
    &Dtool_URLSpec_get_hash_63_tp_hash,
    0, // tp_call
    &Dtool_Repr_URLSpec,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A container for a URL, e.g.  \"http://server:port/path\".\n"
    " *\n"
    " * The URLSpec object is similar to a Filename in that it contains logic to\n"
    " * identify the various parts of a URL and return (or modify) them separately.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_URLSpec,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_URLSpec,
    0, // tp_members
    Dtool_Properties_URLSpec,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_URLSpec,
    PyType_GenericAlloc,
    Dtool_new_URLSpec,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_URLSpec,
  Dtool_UpcastInterface_URLSpec,
  Dtool_DowncastInterface_URLSpec,
  (CoerceFunction)Dtool_ConstCoerce_URLSpec,
  (CoerceFunction)Dtool_Coerce_URLSpec,
};

static void Dtool_PyModuleClassInit_URLSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_URLSpec._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_URLSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_URLSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(URLSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_URLSpec);
  }
}

/**
 * Python method tables for HTTPEnum (HTTPEnum)
 */
static PyMethodDef Dtool_Methods_HTTPEnum[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_HTTPEnum = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_HTTPEnum = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HTTPEnum",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HTTPEnum,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_HTTPEnum,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is just used as a namespace wrapper for some of the enumerated\n"
    " * types used by various classes within the HTTPClient family.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HTTPEnum,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HTTPEnum,
    PyType_GenericAlloc,
    Dtool_new_HTTPEnum,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HTTPEnum,
  Dtool_UpcastInterface_HTTPEnum,
  Dtool_DowncastInterface_HTTPEnum,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_HTTPEnum(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_HTTPEnum._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_HTTPEnum._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum HTTPEnum::HTTPVersion;
    PyDict_SetItemString(dict, "HV_09", Dtool_WrapValue(HTTPEnum::HV_09));
    PyDict_SetItemString(dict, "HV09", Dtool_WrapValue(HTTPEnum::HV_09));
    PyDict_SetItemString(dict, "HV_10", Dtool_WrapValue(HTTPEnum::HV_10));
    PyDict_SetItemString(dict, "HV10", Dtool_WrapValue(HTTPEnum::HV_10));
    PyDict_SetItemString(dict, "HV_11", Dtool_WrapValue(HTTPEnum::HV_11));
    PyDict_SetItemString(dict, "HV11", Dtool_WrapValue(HTTPEnum::HV_11));
    PyDict_SetItemString(dict, "HV_other", Dtool_WrapValue(HTTPEnum::HV_other));
    PyDict_SetItemString(dict, "HVOther", Dtool_WrapValue(HTTPEnum::HV_other));
    // enum HTTPEnum::Method;
    PyDict_SetItemString(dict, "M_options", Dtool_WrapValue(HTTPEnum::M_options));
    PyDict_SetItemString(dict, "MOptions", Dtool_WrapValue(HTTPEnum::M_options));
    PyDict_SetItemString(dict, "M_get", Dtool_WrapValue(HTTPEnum::M_get));
    PyDict_SetItemString(dict, "MGet", Dtool_WrapValue(HTTPEnum::M_get));
    PyDict_SetItemString(dict, "M_head", Dtool_WrapValue(HTTPEnum::M_head));
    PyDict_SetItemString(dict, "MHead", Dtool_WrapValue(HTTPEnum::M_head));
    PyDict_SetItemString(dict, "M_post", Dtool_WrapValue(HTTPEnum::M_post));
    PyDict_SetItemString(dict, "MPost", Dtool_WrapValue(HTTPEnum::M_post));
    PyDict_SetItemString(dict, "M_put", Dtool_WrapValue(HTTPEnum::M_put));
    PyDict_SetItemString(dict, "MPut", Dtool_WrapValue(HTTPEnum::M_put));
    PyDict_SetItemString(dict, "M_delete", Dtool_WrapValue(HTTPEnum::M_delete));
    PyDict_SetItemString(dict, "MDelete", Dtool_WrapValue(HTTPEnum::M_delete));
    PyDict_SetItemString(dict, "M_trace", Dtool_WrapValue(HTTPEnum::M_trace));
    PyDict_SetItemString(dict, "MTrace", Dtool_WrapValue(HTTPEnum::M_trace));
    PyDict_SetItemString(dict, "M_connect", Dtool_WrapValue(HTTPEnum::M_connect));
    PyDict_SetItemString(dict, "MConnect", Dtool_WrapValue(HTTPEnum::M_connect));
    if (PyType_Ready((PyTypeObject *)&Dtool_HTTPEnum) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HTTPEnum)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HTTPEnum);
  }
}

/**
 * Python method tables for HTTPDate (HTTPDate)
 */
static PyMethodDef Dtool_Methods_HTTPDate[] = {
  {"assign", &Dtool_HTTPDate_operator_129, METH_O, (const char *)Dtool_HTTPDate_operator_129_comment},
  {"now", &Dtool_HTTPDate_now_130, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPDate_now_130_comment},
  {"is_valid", &Dtool_HTTPDate_is_valid_131, METH_NOARGS, (const char *)Dtool_HTTPDate_is_valid_131_comment},
  {"isValid", &Dtool_HTTPDate_is_valid_131, METH_NOARGS, (const char *)Dtool_HTTPDate_is_valid_131_comment},
  {"get_string", &Dtool_HTTPDate_get_string_132, METH_NOARGS, (const char *)Dtool_HTTPDate_get_string_132_comment},
  {"getString", &Dtool_HTTPDate_get_string_132, METH_NOARGS, (const char *)Dtool_HTTPDate_get_string_132_comment},
  {"get_time", &Dtool_HTTPDate_get_time_133, METH_NOARGS, (const char *)Dtool_HTTPDate_get_time_133_comment},
  {"getTime", &Dtool_HTTPDate_get_time_133, METH_NOARGS, (const char *)Dtool_HTTPDate_get_time_133_comment},
  {"compare_to", &Dtool_HTTPDate_compare_to_138, METH_O, (const char *)Dtool_HTTPDate_compare_to_138_comment},
  {"compareTo", &Dtool_HTTPDate_compare_to_138, METH_O, (const char *)Dtool_HTTPDate_compare_to_138_comment},
  {"input", &Dtool_HTTPDate_input_143, METH_O, (const char *)Dtool_HTTPDate_input_143_comment},
  {"output", &Dtool_HTTPDate_output_144, METH_O, (const char *)Dtool_HTTPDate_output_144_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HTTPDate slot nb_add -> operator +
//////////////////
static PyObject *Dtool_HTTPDate_operator_141_nb_add(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_HTTPDate, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline HTTPDate HTTPDate::operator +(int seconds) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    HTTPDate *return_value = new HTTPDate((*(const HTTPDate*)local_this).operator +((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HTTPDate slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_HTTPDate_operator_139_nb_inplace_add(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_HTTPDate, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void HTTPDate::operator +=(int seconds)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator +=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call HTTPDate.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HTTPDate slot nb_inplace_subtract -> operator -=
//////////////////
static PyObject *Dtool_HTTPDate_operator_140_nb_inplace_subtract(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_HTTPDate, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void HTTPDate::operator -=(int seconds)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return NULL;
      }
#endif
      (*local_this).operator -=((int)arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call HTTPDate.__isub__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HTTPDate slot nb_subtract -> operator -
//////////////////
static PyObject *Dtool_HTTPDate_operator_142_nb_subtract(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_HTTPDate, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  {
    // -2 inline int HTTPDate::operator -(HTTPDate const &other) const
    HTTPDate const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_HTTPDate, (void **)&arg_this);
    if (arg_this != NULL) {
      int return_value = (*(const HTTPDate*)local_this).operator -(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline HTTPDate HTTPDate::operator -(int seconds) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      HTTPDate *return_value = new HTTPDate((*(const HTTPDate*)local_this).operator -((int)arg_val));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HTTPDate, true, false);
    }
  }

  {
    // -2 inline int HTTPDate::operator -(HTTPDate const &other) const
    HTTPDate const *arg_this;
    bool arg_manage = false;
    if (Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
      int return_value = (*(const HTTPDate*)local_this).operator -(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline HTTPDate HTTPDate::operator -(int seconds) const
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HTTPDate slot tp_compare -> compare_to
//////////////////
static int Dtool_HTTPDate_compare_to_138_tp_compare(PyObject *self, PyObject *arg) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int HTTPDate::compare_to(HTTPDate const &other) const
  HTTPDate const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "HTTPDate.compare_to", "HTTPDate");
    return -1;
  }
  int return_value = (*(const HTTPDate*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(HTTPDate self, const HTTPDate other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     HTTPDate
//////////////////
static PyObject *Dtool_Repr_HTTPDate(PyObject *self) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     HTTPDate
//////////////////
static PyObject *Dtool_RichCompare_HTTPDate(PyObject *self, PyObject *arg, int op) {
  HTTPDate *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPDate, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool HTTPDate::operator ==(HTTPDate const &other) const
      HTTPDate const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPDate*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool HTTPDate::operator !=(HTTPDate const &other) const
      HTTPDate const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPDate*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool HTTPDate::operator <(HTTPDate const &other) const
      HTTPDate const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPDate*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool HTTPDate::operator >(HTTPDate const &other) const
      HTTPDate const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPDate(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPDate*)local_this).operator >(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_HTTPDate_compare_to_138_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_HTTPDate = {
  &Dtool_HTTPDate_operator_141_nb_add,
  &Dtool_HTTPDate_operator_142_nb_subtract,
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_HTTPDate_operator_139_nb_inplace_add,
  &Dtool_HTTPDate_operator_140_nb_inplace_subtract,
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_HTTPDate = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HTTPDate",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HTTPDate,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_HTTPDate_compare_to_138_tp_compare,
#endif
    &Dtool_Repr_HTTPDate,
    &Dtool_NumberMethods_HTTPDate,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_HTTPDate,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A container for an HTTP-legal time/date indication.  This can accept a\n"
    " * string from an HTTP header and will decode it into a C time_t value;\n"
    " * conversely, it can accept a time_t value and encode it for output as a\n"
    " * string.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_HTTPDate,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HTTPDate,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HTTPDate,
    PyType_GenericAlloc,
    Dtool_new_HTTPDate,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HTTPDate,
  Dtool_UpcastInterface_HTTPDate,
  Dtool_DowncastInterface_HTTPDate,
  (CoerceFunction)Dtool_ConstCoerce_HTTPDate,
  (CoerceFunction)Dtool_Coerce_HTTPDate,
};

static void Dtool_PyModuleClassInit_HTTPDate(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_HTTPDate._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_HTTPDate._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HTTPDate) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HTTPDate)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HTTPDate);
  }
}

/**
 * Python method tables for HTTPCookie (HTTPCookie)
 */
static PyMethodDef Dtool_Methods_HTTPCookie[] = {
  {"set_name", &Dtool_HTTPCookie_set_name_149, METH_O, (const char *)Dtool_HTTPCookie_set_name_149_comment},
  {"setName", &Dtool_HTTPCookie_set_name_149, METH_O, (const char *)Dtool_HTTPCookie_set_name_149_comment},
  {"get_name", &Dtool_HTTPCookie_get_name_150, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_name_150_comment},
  {"getName", &Dtool_HTTPCookie_get_name_150, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_name_150_comment},
  {"set_value", &Dtool_HTTPCookie_set_value_151, METH_O, (const char *)Dtool_HTTPCookie_set_value_151_comment},
  {"setValue", &Dtool_HTTPCookie_set_value_151, METH_O, (const char *)Dtool_HTTPCookie_set_value_151_comment},
  {"get_value", &Dtool_HTTPCookie_get_value_152, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_value_152_comment},
  {"getValue", &Dtool_HTTPCookie_get_value_152, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_value_152_comment},
  {"set_domain", &Dtool_HTTPCookie_set_domain_153, METH_O, (const char *)Dtool_HTTPCookie_set_domain_153_comment},
  {"setDomain", &Dtool_HTTPCookie_set_domain_153, METH_O, (const char *)Dtool_HTTPCookie_set_domain_153_comment},
  {"get_domain", &Dtool_HTTPCookie_get_domain_154, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_domain_154_comment},
  {"getDomain", &Dtool_HTTPCookie_get_domain_154, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_domain_154_comment},
  {"set_path", &Dtool_HTTPCookie_set_path_155, METH_O, (const char *)Dtool_HTTPCookie_set_path_155_comment},
  {"setPath", &Dtool_HTTPCookie_set_path_155, METH_O, (const char *)Dtool_HTTPCookie_set_path_155_comment},
  {"get_path", &Dtool_HTTPCookie_get_path_156, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_path_156_comment},
  {"getPath", &Dtool_HTTPCookie_get_path_156, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_path_156_comment},
  {"set_expires", &Dtool_HTTPCookie_set_expires_157, METH_O, (const char *)Dtool_HTTPCookie_set_expires_157_comment},
  {"setExpires", &Dtool_HTTPCookie_set_expires_157, METH_O, (const char *)Dtool_HTTPCookie_set_expires_157_comment},
  {"clear_expires", &Dtool_HTTPCookie_clear_expires_158, METH_NOARGS, (const char *)Dtool_HTTPCookie_clear_expires_158_comment},
  {"clearExpires", &Dtool_HTTPCookie_clear_expires_158, METH_NOARGS, (const char *)Dtool_HTTPCookie_clear_expires_158_comment},
  {"has_expires", &Dtool_HTTPCookie_has_expires_159, METH_NOARGS, (const char *)Dtool_HTTPCookie_has_expires_159_comment},
  {"hasExpires", &Dtool_HTTPCookie_has_expires_159, METH_NOARGS, (const char *)Dtool_HTTPCookie_has_expires_159_comment},
  {"get_expires", &Dtool_HTTPCookie_get_expires_160, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_expires_160_comment},
  {"getExpires", &Dtool_HTTPCookie_get_expires_160, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_expires_160_comment},
  {"set_secure", &Dtool_HTTPCookie_set_secure_161, METH_O, (const char *)Dtool_HTTPCookie_set_secure_161_comment},
  {"setSecure", &Dtool_HTTPCookie_set_secure_161, METH_O, (const char *)Dtool_HTTPCookie_set_secure_161_comment},
  {"get_secure", &Dtool_HTTPCookie_get_secure_162, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_secure_162_comment},
  {"getSecure", &Dtool_HTTPCookie_get_secure_162, METH_NOARGS, (const char *)Dtool_HTTPCookie_get_secure_162_comment},
  {"update_from", &Dtool_HTTPCookie_update_from_164, METH_O, (const char *)Dtool_HTTPCookie_update_from_164_comment},
  {"updateFrom", &Dtool_HTTPCookie_update_from_164, METH_O, (const char *)Dtool_HTTPCookie_update_from_164_comment},
  {"parse_set_cookie", (PyCFunction) &Dtool_HTTPCookie_parse_set_cookie_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPCookie_parse_set_cookie_165_comment},
  {"parseSetCookie", (PyCFunction) &Dtool_HTTPCookie_parse_set_cookie_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPCookie_parse_set_cookie_165_comment},
  {"is_expired", (PyCFunction) &Dtool_HTTPCookie_is_expired_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPCookie_is_expired_166_comment},
  {"isExpired", (PyCFunction) &Dtool_HTTPCookie_is_expired_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPCookie_is_expired_166_comment},
  {"matches_url", &Dtool_HTTPCookie_matches_url_167, METH_O, (const char *)Dtool_HTTPCookie_matches_url_167_comment},
  {"matchesUrl", &Dtool_HTTPCookie_matches_url_167, METH_O, (const char *)Dtool_HTTPCookie_matches_url_167_comment},
  {"output", &Dtool_HTTPCookie_output_168, METH_O, (const char *)Dtool_HTTPCookie_output_168_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     HTTPCookie
//////////////////
static PyObject *Dtool_Repr_HTTPCookie(PyObject *self) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     HTTPCookie
//////////////////
static PyObject *Dtool_RichCompare_HTTPCookie(PyObject *self, PyObject *arg, int op) {
  HTTPCookie *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPCookie, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_LT:
    {
      // 1-bool HTTPCookie::operator <(HTTPCookie const &other) const
      HTTPCookie const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPCookie(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPCookie*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_HTTPCookie = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_HTTPCookie = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HTTPCookie",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HTTPCookie,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_HTTPCookie,
    &Dtool_NumberMethods_HTTPCookie,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_HTTPCookie,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A cookie sent from an HTTP server to be stored on the client and returned\n"
    " * when the path and/or domain matches.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_HTTPCookie,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HTTPCookie,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HTTPCookie,
    PyType_GenericAlloc,
    Dtool_new_HTTPCookie,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HTTPCookie,
  Dtool_UpcastInterface_HTTPCookie,
  Dtool_DowncastInterface_HTTPCookie,
  (CoerceFunction)Dtool_ConstCoerce_HTTPCookie,
  (CoerceFunction)Dtool_Coerce_HTTPCookie,
};

static void Dtool_PyModuleClassInit_HTTPCookie(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_HTTPCookie._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_HTTPCookie._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HTTPCookie) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HTTPCookie)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HTTPCookie);
  }
}

/**
 * Python method tables for HTTPClient (HTTPClient)
 */
static PyMethodDef Dtool_Methods_HTTPClient[] = {
  {"assign", &Dtool_HTTPClient_operator_172, METH_O, (const char *)Dtool_HTTPClient_operator_172_comment},
  {"init_random_seed", &Dtool_HTTPClient_init_random_seed_173, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPClient_init_random_seed_173_comment},
  {"initRandomSeed", &Dtool_HTTPClient_init_random_seed_173, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPClient_init_random_seed_173_comment},
  {"set_proxy_spec", &Dtool_HTTPClient_set_proxy_spec_174, METH_O, (const char *)Dtool_HTTPClient_set_proxy_spec_174_comment},
  {"setProxySpec", &Dtool_HTTPClient_set_proxy_spec_174, METH_O, (const char *)Dtool_HTTPClient_set_proxy_spec_174_comment},
  {"get_proxy_spec", &Dtool_HTTPClient_get_proxy_spec_175, METH_NOARGS, (const char *)Dtool_HTTPClient_get_proxy_spec_175_comment},
  {"getProxySpec", &Dtool_HTTPClient_get_proxy_spec_175, METH_NOARGS, (const char *)Dtool_HTTPClient_get_proxy_spec_175_comment},
  {"set_direct_host_spec", &Dtool_HTTPClient_set_direct_host_spec_176, METH_O, (const char *)Dtool_HTTPClient_set_direct_host_spec_176_comment},
  {"setDirectHostSpec", &Dtool_HTTPClient_set_direct_host_spec_176, METH_O, (const char *)Dtool_HTTPClient_set_direct_host_spec_176_comment},
  {"get_direct_host_spec", &Dtool_HTTPClient_get_direct_host_spec_177, METH_NOARGS, (const char *)Dtool_HTTPClient_get_direct_host_spec_177_comment},
  {"getDirectHostSpec", &Dtool_HTTPClient_get_direct_host_spec_177, METH_NOARGS, (const char *)Dtool_HTTPClient_get_direct_host_spec_177_comment},
  {"set_try_all_direct", &Dtool_HTTPClient_set_try_all_direct_178, METH_O, (const char *)Dtool_HTTPClient_set_try_all_direct_178_comment},
  {"setTryAllDirect", &Dtool_HTTPClient_set_try_all_direct_178, METH_O, (const char *)Dtool_HTTPClient_set_try_all_direct_178_comment},
  {"get_try_all_direct", &Dtool_HTTPClient_get_try_all_direct_179, METH_NOARGS, (const char *)Dtool_HTTPClient_get_try_all_direct_179_comment},
  {"getTryAllDirect", &Dtool_HTTPClient_get_try_all_direct_179, METH_NOARGS, (const char *)Dtool_HTTPClient_get_try_all_direct_179_comment},
  {"clear_proxy", &Dtool_HTTPClient_clear_proxy_180, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_proxy_180_comment},
  {"clearProxy", &Dtool_HTTPClient_clear_proxy_180, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_proxy_180_comment},
  {"add_proxy", (PyCFunction) &Dtool_HTTPClient_add_proxy_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_proxy_181_comment},
  {"addProxy", (PyCFunction) &Dtool_HTTPClient_add_proxy_181, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_proxy_181_comment},
  {"clear_direct_host", &Dtool_HTTPClient_clear_direct_host_182, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_direct_host_182_comment},
  {"clearDirectHost", &Dtool_HTTPClient_clear_direct_host_182, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_direct_host_182_comment},
  {"add_direct_host", &Dtool_HTTPClient_add_direct_host_183, METH_O, (const char *)Dtool_HTTPClient_add_direct_host_183_comment},
  {"addDirectHost", &Dtool_HTTPClient_add_direct_host_183, METH_O, (const char *)Dtool_HTTPClient_add_direct_host_183_comment},
  {"get_proxies_for_url", &Dtool_HTTPClient_get_proxies_for_url_184, METH_O, (const char *)Dtool_HTTPClient_get_proxies_for_url_184_comment},
  {"getProxiesForUrl", &Dtool_HTTPClient_get_proxies_for_url_184, METH_O, (const char *)Dtool_HTTPClient_get_proxies_for_url_184_comment},
  {"set_username", (PyCFunction) &Dtool_HTTPClient_set_username_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_set_username_185_comment},
  {"setUsername", (PyCFunction) &Dtool_HTTPClient_set_username_185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_set_username_185_comment},
  {"get_username", (PyCFunction) &Dtool_HTTPClient_get_username_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_get_username_186_comment},
  {"getUsername", (PyCFunction) &Dtool_HTTPClient_get_username_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_get_username_186_comment},
  {"set_cookie", &Dtool_HTTPClient_set_cookie_187, METH_O, (const char *)Dtool_HTTPClient_set_cookie_187_comment},
  {"setCookie", &Dtool_HTTPClient_set_cookie_187, METH_O, (const char *)Dtool_HTTPClient_set_cookie_187_comment},
  {"clear_cookie", &Dtool_HTTPClient_clear_cookie_188, METH_O, (const char *)Dtool_HTTPClient_clear_cookie_188_comment},
  {"clearCookie", &Dtool_HTTPClient_clear_cookie_188, METH_O, (const char *)Dtool_HTTPClient_clear_cookie_188_comment},
  {"clear_all_cookies", &Dtool_HTTPClient_clear_all_cookies_189, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_all_cookies_189_comment},
  {"clearAllCookies", &Dtool_HTTPClient_clear_all_cookies_189, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_all_cookies_189_comment},
  {"has_cookie", &Dtool_HTTPClient_has_cookie_190, METH_O, (const char *)Dtool_HTTPClient_has_cookie_190_comment},
  {"hasCookie", &Dtool_HTTPClient_has_cookie_190, METH_O, (const char *)Dtool_HTTPClient_has_cookie_190_comment},
  {"get_cookie", &Dtool_HTTPClient_get_cookie_191, METH_O, (const char *)Dtool_HTTPClient_get_cookie_191_comment},
  {"getCookie", &Dtool_HTTPClient_get_cookie_191, METH_O, (const char *)Dtool_HTTPClient_get_cookie_191_comment},
  {"copy_cookies_from", &Dtool_HTTPClient_copy_cookies_from_192, METH_O, (const char *)Dtool_HTTPClient_copy_cookies_from_192_comment},
  {"copyCookiesFrom", &Dtool_HTTPClient_copy_cookies_from_192, METH_O, (const char *)Dtool_HTTPClient_copy_cookies_from_192_comment},
  {"write_cookies", &Dtool_HTTPClient_write_cookies_193, METH_O, (const char *)Dtool_HTTPClient_write_cookies_193_comment},
  {"writeCookies", &Dtool_HTTPClient_write_cookies_193, METH_O, (const char *)Dtool_HTTPClient_write_cookies_193_comment},
  {"send_cookies", (PyCFunction) &Dtool_HTTPClient_send_cookies_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_send_cookies_194_comment},
  {"sendCookies", (PyCFunction) &Dtool_HTTPClient_send_cookies_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_send_cookies_194_comment},
  {"set_client_certificate_filename", &Dtool_HTTPClient_set_client_certificate_filename_195, METH_O, (const char *)Dtool_HTTPClient_set_client_certificate_filename_195_comment},
  {"setClientCertificateFilename", &Dtool_HTTPClient_set_client_certificate_filename_195, METH_O, (const char *)Dtool_HTTPClient_set_client_certificate_filename_195_comment},
  {"set_client_certificate_pem", &Dtool_HTTPClient_set_client_certificate_pem_196, METH_O, (const char *)Dtool_HTTPClient_set_client_certificate_pem_196_comment},
  {"setClientCertificatePem", &Dtool_HTTPClient_set_client_certificate_pem_196, METH_O, (const char *)Dtool_HTTPClient_set_client_certificate_pem_196_comment},
  {"set_client_certificate_passphrase", &Dtool_HTTPClient_set_client_certificate_passphrase_197, METH_O, (const char *)Dtool_HTTPClient_set_client_certificate_passphrase_197_comment},
  {"setClientCertificatePassphrase", &Dtool_HTTPClient_set_client_certificate_passphrase_197, METH_O, (const char *)Dtool_HTTPClient_set_client_certificate_passphrase_197_comment},
  {"load_client_certificate", &Dtool_HTTPClient_load_client_certificate_198, METH_NOARGS, (const char *)Dtool_HTTPClient_load_client_certificate_198_comment},
  {"loadClientCertificate", &Dtool_HTTPClient_load_client_certificate_198, METH_NOARGS, (const char *)Dtool_HTTPClient_load_client_certificate_198_comment},
  {"add_preapproved_server_certificate_filename", (PyCFunction) &Dtool_HTTPClient_add_preapproved_server_certificate_filename_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_preapproved_server_certificate_filename_199_comment},
  {"addPreapprovedServerCertificateFilename", (PyCFunction) &Dtool_HTTPClient_add_preapproved_server_certificate_filename_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_preapproved_server_certificate_filename_199_comment},
  {"add_preapproved_server_certificate_pem", (PyCFunction) &Dtool_HTTPClient_add_preapproved_server_certificate_pem_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_preapproved_server_certificate_pem_200_comment},
  {"addPreapprovedServerCertificatePem", (PyCFunction) &Dtool_HTTPClient_add_preapproved_server_certificate_pem_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_preapproved_server_certificate_pem_200_comment},
  {"add_preapproved_server_certificate_name", (PyCFunction) &Dtool_HTTPClient_add_preapproved_server_certificate_name_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_preapproved_server_certificate_name_201_comment},
  {"addPreapprovedServerCertificateName", (PyCFunction) &Dtool_HTTPClient_add_preapproved_server_certificate_name_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_add_preapproved_server_certificate_name_201_comment},
  {"clear_preapproved_server_certificates", &Dtool_HTTPClient_clear_preapproved_server_certificates_202, METH_O, (const char *)Dtool_HTTPClient_clear_preapproved_server_certificates_202_comment},
  {"clearPreapprovedServerCertificates", &Dtool_HTTPClient_clear_preapproved_server_certificates_202, METH_O, (const char *)Dtool_HTTPClient_clear_preapproved_server_certificates_202_comment},
  {"clear_all_preapproved_server_certificates", &Dtool_HTTPClient_clear_all_preapproved_server_certificates_203, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_all_preapproved_server_certificates_203_comment},
  {"clearAllPreapprovedServerCertificates", &Dtool_HTTPClient_clear_all_preapproved_server_certificates_203, METH_NOARGS, (const char *)Dtool_HTTPClient_clear_all_preapproved_server_certificates_203_comment},
  {"set_http_version", &Dtool_HTTPClient_set_http_version_204, METH_O, (const char *)Dtool_HTTPClient_set_http_version_204_comment},
  {"setHttpVersion", &Dtool_HTTPClient_set_http_version_204, METH_O, (const char *)Dtool_HTTPClient_set_http_version_204_comment},
  {"get_http_version", &Dtool_HTTPClient_get_http_version_205, METH_NOARGS, (const char *)Dtool_HTTPClient_get_http_version_205_comment},
  {"getHttpVersion", &Dtool_HTTPClient_get_http_version_205, METH_NOARGS, (const char *)Dtool_HTTPClient_get_http_version_205_comment},
  {"get_http_version_string", &Dtool_HTTPClient_get_http_version_string_206, METH_NOARGS, (const char *)Dtool_HTTPClient_get_http_version_string_206_comment},
  {"getHttpVersionString", &Dtool_HTTPClient_get_http_version_string_206, METH_NOARGS, (const char *)Dtool_HTTPClient_get_http_version_string_206_comment},
  {"parse_http_version_string", &Dtool_HTTPClient_parse_http_version_string_207, METH_O | METH_STATIC, (const char *)Dtool_HTTPClient_parse_http_version_string_207_comment},
  {"parseHttpVersionString", &Dtool_HTTPClient_parse_http_version_string_207, METH_O | METH_STATIC, (const char *)Dtool_HTTPClient_parse_http_version_string_207_comment},
  {"load_certificates", &Dtool_HTTPClient_load_certificates_208, METH_O, (const char *)Dtool_HTTPClient_load_certificates_208_comment},
  {"loadCertificates", &Dtool_HTTPClient_load_certificates_208, METH_O, (const char *)Dtool_HTTPClient_load_certificates_208_comment},
  {"set_verify_ssl", &Dtool_HTTPClient_set_verify_ssl_210, METH_O, (const char *)Dtool_HTTPClient_set_verify_ssl_210_comment},
  {"setVerifySsl", &Dtool_HTTPClient_set_verify_ssl_210, METH_O, (const char *)Dtool_HTTPClient_set_verify_ssl_210_comment},
  {"get_verify_ssl", &Dtool_HTTPClient_get_verify_ssl_211, METH_NOARGS, (const char *)Dtool_HTTPClient_get_verify_ssl_211_comment},
  {"getVerifySsl", &Dtool_HTTPClient_get_verify_ssl_211, METH_NOARGS, (const char *)Dtool_HTTPClient_get_verify_ssl_211_comment},
  {"set_cipher_list", &Dtool_HTTPClient_set_cipher_list_212, METH_O, (const char *)Dtool_HTTPClient_set_cipher_list_212_comment},
  {"setCipherList", &Dtool_HTTPClient_set_cipher_list_212, METH_O, (const char *)Dtool_HTTPClient_set_cipher_list_212_comment},
  {"get_cipher_list", &Dtool_HTTPClient_get_cipher_list_213, METH_NOARGS, (const char *)Dtool_HTTPClient_get_cipher_list_213_comment},
  {"getCipherList", &Dtool_HTTPClient_get_cipher_list_213, METH_NOARGS, (const char *)Dtool_HTTPClient_get_cipher_list_213_comment},
  {"make_channel", &Dtool_HTTPClient_make_channel_214, METH_O, (const char *)Dtool_HTTPClient_make_channel_214_comment},
  {"makeChannel", &Dtool_HTTPClient_make_channel_214, METH_O, (const char *)Dtool_HTTPClient_make_channel_214_comment},
  {"post_form", (PyCFunction) &Dtool_HTTPClient_post_form_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_post_form_215_comment},
  {"postForm", (PyCFunction) &Dtool_HTTPClient_post_form_215, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPClient_post_form_215_comment},
  {"get_document", &Dtool_HTTPClient_get_document_216, METH_O, (const char *)Dtool_HTTPClient_get_document_216_comment},
  {"getDocument", &Dtool_HTTPClient_get_document_216, METH_O, (const char *)Dtool_HTTPClient_get_document_216_comment},
  {"get_header", &Dtool_HTTPClient_get_header_217, METH_O, (const char *)Dtool_HTTPClient_get_header_217_comment},
  {"getHeader", &Dtool_HTTPClient_get_header_217, METH_O, (const char *)Dtool_HTTPClient_get_header_217_comment},
  {"base64_encode", &Dtool_HTTPClient_base64_encode_218, METH_O | METH_STATIC, (const char *)Dtool_HTTPClient_base64_encode_218_comment},
  {"base64Encode", &Dtool_HTTPClient_base64_encode_218, METH_O | METH_STATIC, (const char *)Dtool_HTTPClient_base64_encode_218_comment},
  {"base64_decode", &Dtool_HTTPClient_base64_decode_219, METH_O | METH_STATIC, (const char *)Dtool_HTTPClient_base64_decode_219_comment},
  {"base64Decode", &Dtool_HTTPClient_base64_decode_219, METH_O | METH_STATIC, (const char *)Dtool_HTTPClient_base64_decode_219_comment},
  {"get_global_ptr", &Dtool_HTTPClient_get_global_ptr_220, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPClient_get_global_ptr_220_comment},
  {"getGlobalPtr", &Dtool_HTTPClient_get_global_ptr_220, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPClient_get_global_ptr_220_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_HTTPClient = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HTTPClient = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_HTTPClient = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_HTTPClient = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_HTTPClient = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HTTPClient",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HTTPClient,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_HTTPClient,
    &Dtool_SequenceMethods_HTTPClient,
    &Dtool_MappingMethods_HTTPClient,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_HTTPClient,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Handles contacting an HTTP server and retrieving a document.  Each\n"
    " * HTTPClient object represents a separate context, and stores its own list of\n"
    " * cookies, passwords, and certificates; however, a given HTTPClient is\n"
    " * capable of making multiple simultaneous requests to the same or different\n"
    " * servers.\n"
    " *\n"
    " * It is up to the programmer whether one HTTPClient should be used to\n"
    " * retrieve all documents, or a separate one should be created each time.\n"
    " * There is a default, global HTTPClient available in\n"
    " * HTTPClient::get_global_ptr().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HTTPClient,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HTTPClient,
    PyType_GenericAlloc,
    Dtool_new_HTTPClient,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HTTPClient,
  Dtool_UpcastInterface_HTTPClient,
  Dtool_DowncastInterface_HTTPClient,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_HTTPClient(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != NULL);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_HTTPClient._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_HTTPClient._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum HTTPClient::VerifySSL;
    PyDict_SetItemString(dict, "VS_no_verify", Dtool_WrapValue(HTTPClient::VS_no_verify));
    PyDict_SetItemString(dict, "VSNoVerify", Dtool_WrapValue(HTTPClient::VS_no_verify));
    PyDict_SetItemString(dict, "VS_no_date_check", Dtool_WrapValue(HTTPClient::VS_no_date_check));
    PyDict_SetItemString(dict, "VSNoDateCheck", Dtool_WrapValue(HTTPClient::VS_no_date_check));
    PyDict_SetItemString(dict, "VS_normal", Dtool_WrapValue(HTTPClient::VS_normal));
    PyDict_SetItemString(dict, "VSNormal", Dtool_WrapValue(HTTPClient::VS_normal));
    if (PyType_Ready((PyTypeObject *)&Dtool_HTTPClient) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HTTPClient)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HTTPClient);
  }
}

/**
 * Python method tables for HTTPEntityTag (HTTPEntityTag)
 */
static PyMethodDef Dtool_Methods_HTTPEntityTag[] = {
  {"assign", &Dtool_HTTPEntityTag_operator_223, METH_O, (const char *)Dtool_HTTPEntityTag_operator_223_comment},
  {"is_weak", &Dtool_HTTPEntityTag_is_weak_224, METH_NOARGS, (const char *)Dtool_HTTPEntityTag_is_weak_224_comment},
  {"isWeak", &Dtool_HTTPEntityTag_is_weak_224, METH_NOARGS, (const char *)Dtool_HTTPEntityTag_is_weak_224_comment},
  {"get_tag", &Dtool_HTTPEntityTag_get_tag_225, METH_NOARGS, (const char *)Dtool_HTTPEntityTag_get_tag_225_comment},
  {"getTag", &Dtool_HTTPEntityTag_get_tag_225, METH_NOARGS, (const char *)Dtool_HTTPEntityTag_get_tag_225_comment},
  {"get_string", &Dtool_HTTPEntityTag_get_string_226, METH_NOARGS, (const char *)Dtool_HTTPEntityTag_get_string_226_comment},
  {"getString", &Dtool_HTTPEntityTag_get_string_226, METH_NOARGS, (const char *)Dtool_HTTPEntityTag_get_string_226_comment},
  {"strong_equiv", &Dtool_HTTPEntityTag_strong_equiv_227, METH_O, (const char *)Dtool_HTTPEntityTag_strong_equiv_227_comment},
  {"strongEquiv", &Dtool_HTTPEntityTag_strong_equiv_227, METH_O, (const char *)Dtool_HTTPEntityTag_strong_equiv_227_comment},
  {"weak_equiv", &Dtool_HTTPEntityTag_weak_equiv_228, METH_O, (const char *)Dtool_HTTPEntityTag_weak_equiv_228_comment},
  {"weakEquiv", &Dtool_HTTPEntityTag_weak_equiv_228, METH_O, (const char *)Dtool_HTTPEntityTag_weak_equiv_228_comment},
  {"compare_to", &Dtool_HTTPEntityTag_compare_to_232, METH_O, (const char *)Dtool_HTTPEntityTag_compare_to_232_comment},
  {"compareTo", &Dtool_HTTPEntityTag_compare_to_232, METH_O, (const char *)Dtool_HTTPEntityTag_compare_to_232_comment},
  {"output", &Dtool_HTTPEntityTag_output_233, METH_O, (const char *)Dtool_HTTPEntityTag_output_233_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HTTPEntityTag slot tp_compare -> compare_to
//////////////////
static int Dtool_HTTPEntityTag_compare_to_232_tp_compare(PyObject *self, PyObject *arg) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int HTTPEntityTag::compare_to(HTTPEntityTag const &other) const
  HTTPEntityTag const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "HTTPEntityTag.compare_to", "HTTPEntityTag");
    return -1;
  }
  int return_value = (*(const HTTPEntityTag*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(HTTPEntityTag self, const HTTPEntityTag other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     HTTPEntityTag
//////////////////
static PyObject *Dtool_Repr_HTTPEntityTag(PyObject *self) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     HTTPEntityTag
//////////////////
static PyObject *Dtool_RichCompare_HTTPEntityTag(PyObject *self, PyObject *arg, int op) {
  HTTPEntityTag *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HTTPEntityTag, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool HTTPEntityTag::operator ==(HTTPEntityTag const &other) const
      HTTPEntityTag const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPEntityTag*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool HTTPEntityTag::operator !=(HTTPEntityTag const &other) const
      HTTPEntityTag const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPEntityTag*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool HTTPEntityTag::operator <(HTTPEntityTag const &other) const
      HTTPEntityTag const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_HTTPEntityTag(arg, arg_this, arg_manage)) {
        bool return_value = (*(const HTTPEntityTag*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_HTTPEntityTag_compare_to_232_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_HTTPEntityTag = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_HTTPEntityTag = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HTTPEntityTag",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HTTPEntityTag,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_HTTPEntityTag_compare_to_232_tp_compare,
#endif
    &Dtool_Repr_HTTPEntityTag,
    &Dtool_NumberMethods_HTTPEntityTag,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_HTTPEntityTag,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A container for an \"entity tag\" from an HTTP server.  This is used to\n"
    " * identify a particular version of a document or resource, particularly\n"
    " * useful for verifying caches.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_HTTPEntityTag,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HTTPEntityTag,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HTTPEntityTag,
    PyType_GenericAlloc,
    Dtool_new_HTTPEntityTag,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HTTPEntityTag,
  Dtool_UpcastInterface_HTTPEntityTag,
  Dtool_DowncastInterface_HTTPEntityTag,
  (CoerceFunction)Dtool_ConstCoerce_HTTPEntityTag,
  (CoerceFunction)Dtool_Coerce_HTTPEntityTag,
};

static void Dtool_PyModuleClassInit_HTTPEntityTag(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_HTTPEntityTag._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_HTTPEntityTag._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HTTPEntityTag) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HTTPEntityTag)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HTTPEntityTag);
  }
}

/**
 * Python method tables for DocumentSpec (DocumentSpec)
 */
static PyMethodDef Dtool_Methods_DocumentSpec[] = {
  {"assign", &Dtool_DocumentSpec_operator_237, METH_O, (const char *)Dtool_DocumentSpec_operator_237_comment},
  {"compare_to", &Dtool_DocumentSpec_compare_to_241, METH_O, (const char *)Dtool_DocumentSpec_compare_to_241_comment},
  {"compareTo", &Dtool_DocumentSpec_compare_to_241, METH_O, (const char *)Dtool_DocumentSpec_compare_to_241_comment},
  {"set_url", &Dtool_DocumentSpec_set_url_242, METH_O, (const char *)Dtool_DocumentSpec_set_url_242_comment},
  {"setUrl", &Dtool_DocumentSpec_set_url_242, METH_O, (const char *)Dtool_DocumentSpec_set_url_242_comment},
  {"get_url", &Dtool_DocumentSpec_get_url_243, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_url_243_comment},
  {"getUrl", &Dtool_DocumentSpec_get_url_243, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_url_243_comment},
  {"set_tag", &Dtool_DocumentSpec_set_tag_244, METH_O, (const char *)Dtool_DocumentSpec_set_tag_244_comment},
  {"setTag", &Dtool_DocumentSpec_set_tag_244, METH_O, (const char *)Dtool_DocumentSpec_set_tag_244_comment},
  {"has_tag", &Dtool_DocumentSpec_has_tag_245, METH_NOARGS, (const char *)Dtool_DocumentSpec_has_tag_245_comment},
  {"hasTag", &Dtool_DocumentSpec_has_tag_245, METH_NOARGS, (const char *)Dtool_DocumentSpec_has_tag_245_comment},
  {"get_tag", &Dtool_DocumentSpec_get_tag_246, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_tag_246_comment},
  {"getTag", &Dtool_DocumentSpec_get_tag_246, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_tag_246_comment},
  {"clear_tag", &Dtool_DocumentSpec_clear_tag_247, METH_NOARGS, (const char *)Dtool_DocumentSpec_clear_tag_247_comment},
  {"clearTag", &Dtool_DocumentSpec_clear_tag_247, METH_NOARGS, (const char *)Dtool_DocumentSpec_clear_tag_247_comment},
  {"set_date", &Dtool_DocumentSpec_set_date_248, METH_O, (const char *)Dtool_DocumentSpec_set_date_248_comment},
  {"setDate", &Dtool_DocumentSpec_set_date_248, METH_O, (const char *)Dtool_DocumentSpec_set_date_248_comment},
  {"has_date", &Dtool_DocumentSpec_has_date_249, METH_NOARGS, (const char *)Dtool_DocumentSpec_has_date_249_comment},
  {"hasDate", &Dtool_DocumentSpec_has_date_249, METH_NOARGS, (const char *)Dtool_DocumentSpec_has_date_249_comment},
  {"get_date", &Dtool_DocumentSpec_get_date_250, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_date_250_comment},
  {"getDate", &Dtool_DocumentSpec_get_date_250, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_date_250_comment},
  {"clear_date", &Dtool_DocumentSpec_clear_date_251, METH_NOARGS, (const char *)Dtool_DocumentSpec_clear_date_251_comment},
  {"clearDate", &Dtool_DocumentSpec_clear_date_251, METH_NOARGS, (const char *)Dtool_DocumentSpec_clear_date_251_comment},
  {"set_request_mode", &Dtool_DocumentSpec_set_request_mode_253, METH_O, (const char *)Dtool_DocumentSpec_set_request_mode_253_comment},
  {"setRequestMode", &Dtool_DocumentSpec_set_request_mode_253, METH_O, (const char *)Dtool_DocumentSpec_set_request_mode_253_comment},
  {"get_request_mode", &Dtool_DocumentSpec_get_request_mode_254, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_request_mode_254_comment},
  {"getRequestMode", &Dtool_DocumentSpec_get_request_mode_254, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_request_mode_254_comment},
  {"set_cache_control", &Dtool_DocumentSpec_set_cache_control_256, METH_O, (const char *)Dtool_DocumentSpec_set_cache_control_256_comment},
  {"setCacheControl", &Dtool_DocumentSpec_set_cache_control_256, METH_O, (const char *)Dtool_DocumentSpec_set_cache_control_256_comment},
  {"get_cache_control", &Dtool_DocumentSpec_get_cache_control_257, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_cache_control_257_comment},
  {"getCacheControl", &Dtool_DocumentSpec_get_cache_control_257, METH_NOARGS, (const char *)Dtool_DocumentSpec_get_cache_control_257_comment},
  {"input", &Dtool_DocumentSpec_input_258, METH_O, (const char *)Dtool_DocumentSpec_input_258_comment},
  {"output", &Dtool_DocumentSpec_output_259, METH_O, (const char *)Dtool_DocumentSpec_output_259_comment},
  {"write", (PyCFunction) &Dtool_DocumentSpec_write_260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DocumentSpec_write_260_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DocumentSpec slot tp_compare -> compare_to
//////////////////
static int Dtool_DocumentSpec_compare_to_241_tp_compare(PyObject *self, PyObject *arg) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return -1;
  }

  // 1-int DocumentSpec::compare_to(DocumentSpec const &other) const
  DocumentSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DocumentSpec.compare_to", "DocumentSpec");
    return -1;
  }
  int return_value = (*(const DocumentSpec*)local_this).compare_to(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(DocumentSpec self, const DocumentSpec other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     DocumentSpec
//////////////////
static PyObject *Dtool_Repr_DocumentSpec(PyObject *self) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DocumentSpec
//////////////////
static PyObject *Dtool_Str_DocumentSpec(PyObject *self) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     DocumentSpec
//////////////////
static PyObject *Dtool_RichCompare_DocumentSpec(PyObject *self, PyObject *arg, int op) {
  DocumentSpec *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DocumentSpec, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool DocumentSpec::operator ==(DocumentSpec const &other) const
      DocumentSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const DocumentSpec*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool DocumentSpec::operator !=(DocumentSpec const &other) const
      DocumentSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const DocumentSpec*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool DocumentSpec::operator <(DocumentSpec const &other) const
      DocumentSpec const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_DocumentSpec(arg, arg_this, arg_manage)) {
        bool return_value = (*(const DocumentSpec*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_DocumentSpec_compare_to_241_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_DocumentSpec[] = {
  {(char *)"url", &Dtool_DocumentSpec_url_Getter, &Dtool_DocumentSpec_url_Setter, NULL, NULL},
  {(char *)"tag", &Dtool_DocumentSpec_tag_Getter, &Dtool_DocumentSpec_tag_Setter, NULL, NULL},
  {(char *)"date", &Dtool_DocumentSpec_date_Getter, &Dtool_DocumentSpec_date_Setter, NULL, NULL},
  {(char *)"request_mode", &Dtool_DocumentSpec_request_mode_Getter, &Dtool_DocumentSpec_request_mode_Setter, NULL, NULL},
  {(char *)"cache_control", &Dtool_DocumentSpec_cache_control_Getter, &Dtool_DocumentSpec_cache_control_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_DocumentSpec = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DocumentSpec = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DocumentSpec",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DocumentSpec,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_DocumentSpec_compare_to_241_tp_compare,
#endif
    &Dtool_Repr_DocumentSpec,
    &Dtool_NumberMethods_DocumentSpec,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_DocumentSpec,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A descriptor that refers to a particular version of a document.  This\n"
    " * includes the URL of the document and its identity tag and last-modified\n"
    " * dates.\n"
    " *\n"
    " * The DocumentSpec may also be used to request a newer document than a\n"
    " * particular one if available, for instance to refresh a cached document.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_DocumentSpec,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DocumentSpec,
    0, // tp_members
    Dtool_Properties_DocumentSpec,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DocumentSpec,
    PyType_GenericAlloc,
    Dtool_new_DocumentSpec,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DocumentSpec,
  Dtool_UpcastInterface_DocumentSpec,
  Dtool_DowncastInterface_DocumentSpec,
  (CoerceFunction)Dtool_ConstCoerce_DocumentSpec,
  (CoerceFunction)Dtool_Coerce_DocumentSpec,
};

static void Dtool_PyModuleClassInit_DocumentSpec(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DocumentSpec._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_DocumentSpec._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum DocumentSpec::RequestMode;
    PyDict_SetItemString(dict, "RM_any", Dtool_WrapValue(DocumentSpec::RM_any));
    PyDict_SetItemString(dict, "RMAny", Dtool_WrapValue(DocumentSpec::RM_any));
    PyDict_SetItemString(dict, "RM_equal", Dtool_WrapValue(DocumentSpec::RM_equal));
    PyDict_SetItemString(dict, "RMEqual", Dtool_WrapValue(DocumentSpec::RM_equal));
    PyDict_SetItemString(dict, "RM_newer", Dtool_WrapValue(DocumentSpec::RM_newer));
    PyDict_SetItemString(dict, "RMNewer", Dtool_WrapValue(DocumentSpec::RM_newer));
    PyDict_SetItemString(dict, "RM_equal_or_newer", Dtool_WrapValue(DocumentSpec::RM_equal_or_newer));
    PyDict_SetItemString(dict, "RMEqualOrNewer", Dtool_WrapValue(DocumentSpec::RM_equal_or_newer));
    // enum DocumentSpec::CacheControl;
    PyDict_SetItemString(dict, "CC_allow_cache", Dtool_WrapValue(DocumentSpec::CC_allow_cache));
    PyDict_SetItemString(dict, "CCAllowCache", Dtool_WrapValue(DocumentSpec::CC_allow_cache));
    PyDict_SetItemString(dict, "CC_revalidate", Dtool_WrapValue(DocumentSpec::CC_revalidate));
    PyDict_SetItemString(dict, "CCRevalidate", Dtool_WrapValue(DocumentSpec::CC_revalidate));
    PyDict_SetItemString(dict, "CC_no_cache", Dtool_WrapValue(DocumentSpec::CC_no_cache));
    PyDict_SetItemString(dict, "CCNoCache", Dtool_WrapValue(DocumentSpec::CC_no_cache));
    if (PyType_Ready((PyTypeObject *)&Dtool_DocumentSpec) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DocumentSpec)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DocumentSpec);
  }
}

/**
 * Python method tables for HTTPChannel (HTTPChannel)
 */
static PyMethodDef Dtool_Methods_HTTPChannel[] = {
  {"get_client", &Dtool_HTTPChannel_get_client_273, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_client_273_comment},
  {"getClient", &Dtool_HTTPChannel_get_client_273, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_client_273_comment},
  {"is_valid", &Dtool_HTTPChannel_is_valid_274, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_valid_274_comment},
  {"isValid", &Dtool_HTTPChannel_is_valid_274, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_valid_274_comment},
  {"is_connection_ready", &Dtool_HTTPChannel_is_connection_ready_275, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_connection_ready_275_comment},
  {"isConnectionReady", &Dtool_HTTPChannel_is_connection_ready_275, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_connection_ready_275_comment},
  {"get_url", &Dtool_HTTPChannel_get_url_276, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_url_276_comment},
  {"getUrl", &Dtool_HTTPChannel_get_url_276, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_url_276_comment},
  {"get_document_spec", &Dtool_HTTPChannel_get_document_spec_277, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_document_spec_277_comment},
  {"getDocumentSpec", &Dtool_HTTPChannel_get_document_spec_277, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_document_spec_277_comment},
  {"get_http_version", &Dtool_HTTPChannel_get_http_version_278, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_http_version_278_comment},
  {"getHttpVersion", &Dtool_HTTPChannel_get_http_version_278, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_http_version_278_comment},
  {"get_http_version_string", &Dtool_HTTPChannel_get_http_version_string_279, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_http_version_string_279_comment},
  {"getHttpVersionString", &Dtool_HTTPChannel_get_http_version_string_279, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_http_version_string_279_comment},
  {"get_status_code", &Dtool_HTTPChannel_get_status_code_280, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_status_code_280_comment},
  {"getStatusCode", &Dtool_HTTPChannel_get_status_code_280, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_status_code_280_comment},
  {"get_status_string", &Dtool_HTTPChannel_get_status_string_281, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_status_string_281_comment},
  {"getStatusString", &Dtool_HTTPChannel_get_status_string_281, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_status_string_281_comment},
  {"get_www_realm", &Dtool_HTTPChannel_get_www_realm_282, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_www_realm_282_comment},
  {"getWwwRealm", &Dtool_HTTPChannel_get_www_realm_282, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_www_realm_282_comment},
  {"get_proxy_realm", &Dtool_HTTPChannel_get_proxy_realm_283, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_proxy_realm_283_comment},
  {"getProxyRealm", &Dtool_HTTPChannel_get_proxy_realm_283, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_proxy_realm_283_comment},
  {"get_redirect", &Dtool_HTTPChannel_get_redirect_284, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_redirect_284_comment},
  {"getRedirect", &Dtool_HTTPChannel_get_redirect_284, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_redirect_284_comment},
  {"get_header_value", &Dtool_HTTPChannel_get_header_value_285, METH_O, (const char *)Dtool_HTTPChannel_get_header_value_285_comment},
  {"getHeaderValue", &Dtool_HTTPChannel_get_header_value_285, METH_O, (const char *)Dtool_HTTPChannel_get_header_value_285_comment},
  {"get_num_redirect_steps", &Dtool_HTTPChannel_get_num_redirect_steps_286, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_num_redirect_steps_286_comment},
  {"getNumRedirectSteps", &Dtool_HTTPChannel_get_num_redirect_steps_286, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_num_redirect_steps_286_comment},
  {"get_redirect_step", &Dtool_HTTPChannel_get_redirect_step_287, METH_O, (const char *)Dtool_HTTPChannel_get_redirect_step_287_comment},
  {"getRedirectStep", &Dtool_HTTPChannel_get_redirect_step_287, METH_O, (const char *)Dtool_HTTPChannel_get_redirect_step_287_comment},
  {"set_persistent_connection", &Dtool_HTTPChannel_set_persistent_connection_289, METH_O, (const char *)Dtool_HTTPChannel_set_persistent_connection_289_comment},
  {"setPersistentConnection", &Dtool_HTTPChannel_set_persistent_connection_289, METH_O, (const char *)Dtool_HTTPChannel_set_persistent_connection_289_comment},
  {"get_persistent_connection", &Dtool_HTTPChannel_get_persistent_connection_290, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_persistent_connection_290_comment},
  {"getPersistentConnection", &Dtool_HTTPChannel_get_persistent_connection_290, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_persistent_connection_290_comment},
  {"will_close_connection", &Dtool_HTTPChannel_will_close_connection_291, METH_NOARGS, (const char *)Dtool_HTTPChannel_will_close_connection_291_comment},
  {"willCloseConnection", &Dtool_HTTPChannel_will_close_connection_291, METH_NOARGS, (const char *)Dtool_HTTPChannel_will_close_connection_291_comment},
  {"set_allow_proxy", &Dtool_HTTPChannel_set_allow_proxy_292, METH_O, (const char *)Dtool_HTTPChannel_set_allow_proxy_292_comment},
  {"setAllowProxy", &Dtool_HTTPChannel_set_allow_proxy_292, METH_O, (const char *)Dtool_HTTPChannel_set_allow_proxy_292_comment},
  {"get_allow_proxy", &Dtool_HTTPChannel_get_allow_proxy_293, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_allow_proxy_293_comment},
  {"getAllowProxy", &Dtool_HTTPChannel_get_allow_proxy_293, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_allow_proxy_293_comment},
  {"set_proxy_tunnel", &Dtool_HTTPChannel_set_proxy_tunnel_294, METH_O, (const char *)Dtool_HTTPChannel_set_proxy_tunnel_294_comment},
  {"setProxyTunnel", &Dtool_HTTPChannel_set_proxy_tunnel_294, METH_O, (const char *)Dtool_HTTPChannel_set_proxy_tunnel_294_comment},
  {"get_proxy_tunnel", &Dtool_HTTPChannel_get_proxy_tunnel_295, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_proxy_tunnel_295_comment},
  {"getProxyTunnel", &Dtool_HTTPChannel_get_proxy_tunnel_295, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_proxy_tunnel_295_comment},
  {"set_connect_timeout", &Dtool_HTTPChannel_set_connect_timeout_296, METH_O, (const char *)Dtool_HTTPChannel_set_connect_timeout_296_comment},
  {"setConnectTimeout", &Dtool_HTTPChannel_set_connect_timeout_296, METH_O, (const char *)Dtool_HTTPChannel_set_connect_timeout_296_comment},
  {"get_connect_timeout", &Dtool_HTTPChannel_get_connect_timeout_297, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_connect_timeout_297_comment},
  {"getConnectTimeout", &Dtool_HTTPChannel_get_connect_timeout_297, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_connect_timeout_297_comment},
  {"set_blocking_connect", &Dtool_HTTPChannel_set_blocking_connect_298, METH_O, (const char *)Dtool_HTTPChannel_set_blocking_connect_298_comment},
  {"setBlockingConnect", &Dtool_HTTPChannel_set_blocking_connect_298, METH_O, (const char *)Dtool_HTTPChannel_set_blocking_connect_298_comment},
  {"get_blocking_connect", &Dtool_HTTPChannel_get_blocking_connect_299, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_blocking_connect_299_comment},
  {"getBlockingConnect", &Dtool_HTTPChannel_get_blocking_connect_299, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_blocking_connect_299_comment},
  {"set_http_timeout", &Dtool_HTTPChannel_set_http_timeout_300, METH_O, (const char *)Dtool_HTTPChannel_set_http_timeout_300_comment},
  {"setHttpTimeout", &Dtool_HTTPChannel_set_http_timeout_300, METH_O, (const char *)Dtool_HTTPChannel_set_http_timeout_300_comment},
  {"get_http_timeout", &Dtool_HTTPChannel_get_http_timeout_301, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_http_timeout_301_comment},
  {"getHttpTimeout", &Dtool_HTTPChannel_get_http_timeout_301, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_http_timeout_301_comment},
  {"set_skip_body_size", &Dtool_HTTPChannel_set_skip_body_size_302, METH_O, (const char *)Dtool_HTTPChannel_set_skip_body_size_302_comment},
  {"setSkipBodySize", &Dtool_HTTPChannel_set_skip_body_size_302, METH_O, (const char *)Dtool_HTTPChannel_set_skip_body_size_302_comment},
  {"get_skip_body_size", &Dtool_HTTPChannel_get_skip_body_size_303, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_skip_body_size_303_comment},
  {"getSkipBodySize", &Dtool_HTTPChannel_get_skip_body_size_303, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_skip_body_size_303_comment},
  {"set_idle_timeout", &Dtool_HTTPChannel_set_idle_timeout_304, METH_O, (const char *)Dtool_HTTPChannel_set_idle_timeout_304_comment},
  {"setIdleTimeout", &Dtool_HTTPChannel_set_idle_timeout_304, METH_O, (const char *)Dtool_HTTPChannel_set_idle_timeout_304_comment},
  {"get_idle_timeout", &Dtool_HTTPChannel_get_idle_timeout_305, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_idle_timeout_305_comment},
  {"getIdleTimeout", &Dtool_HTTPChannel_get_idle_timeout_305, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_idle_timeout_305_comment},
  {"set_download_throttle", &Dtool_HTTPChannel_set_download_throttle_306, METH_O, (const char *)Dtool_HTTPChannel_set_download_throttle_306_comment},
  {"setDownloadThrottle", &Dtool_HTTPChannel_set_download_throttle_306, METH_O, (const char *)Dtool_HTTPChannel_set_download_throttle_306_comment},
  {"get_download_throttle", &Dtool_HTTPChannel_get_download_throttle_307, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_download_throttle_307_comment},
  {"getDownloadThrottle", &Dtool_HTTPChannel_get_download_throttle_307, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_download_throttle_307_comment},
  {"set_max_bytes_per_second", &Dtool_HTTPChannel_set_max_bytes_per_second_308, METH_O, (const char *)Dtool_HTTPChannel_set_max_bytes_per_second_308_comment},
  {"setMaxBytesPerSecond", &Dtool_HTTPChannel_set_max_bytes_per_second_308, METH_O, (const char *)Dtool_HTTPChannel_set_max_bytes_per_second_308_comment},
  {"get_max_bytes_per_second", &Dtool_HTTPChannel_get_max_bytes_per_second_309, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_max_bytes_per_second_309_comment},
  {"getMaxBytesPerSecond", &Dtool_HTTPChannel_get_max_bytes_per_second_309, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_max_bytes_per_second_309_comment},
  {"set_max_updates_per_second", &Dtool_HTTPChannel_set_max_updates_per_second_310, METH_O, (const char *)Dtool_HTTPChannel_set_max_updates_per_second_310_comment},
  {"setMaxUpdatesPerSecond", &Dtool_HTTPChannel_set_max_updates_per_second_310, METH_O, (const char *)Dtool_HTTPChannel_set_max_updates_per_second_310_comment},
  {"get_max_updates_per_second", &Dtool_HTTPChannel_get_max_updates_per_second_311, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_max_updates_per_second_311_comment},
  {"getMaxUpdatesPerSecond", &Dtool_HTTPChannel_get_max_updates_per_second_311, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_max_updates_per_second_311_comment},
  {"set_expected_file_size", &Dtool_HTTPChannel_set_expected_file_size_312, METH_O, (const char *)Dtool_HTTPChannel_set_expected_file_size_312_comment},
  {"setExpectedFileSize", &Dtool_HTTPChannel_set_expected_file_size_312, METH_O, (const char *)Dtool_HTTPChannel_set_expected_file_size_312_comment},
  {"get_file_size", &Dtool_HTTPChannel_get_file_size_313, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_file_size_313_comment},
  {"getFileSize", &Dtool_HTTPChannel_get_file_size_313, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_file_size_313_comment},
  {"is_file_size_known", &Dtool_HTTPChannel_is_file_size_known_314, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_file_size_known_314_comment},
  {"isFileSizeKnown", &Dtool_HTTPChannel_is_file_size_known_314, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_file_size_known_314_comment},
  {"get_first_byte_requested", &Dtool_HTTPChannel_get_first_byte_requested_315, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_first_byte_requested_315_comment},
  {"getFirstByteRequested", &Dtool_HTTPChannel_get_first_byte_requested_315, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_first_byte_requested_315_comment},
  {"get_last_byte_requested", &Dtool_HTTPChannel_get_last_byte_requested_316, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_last_byte_requested_316_comment},
  {"getLastByteRequested", &Dtool_HTTPChannel_get_last_byte_requested_316, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_last_byte_requested_316_comment},
  {"get_first_byte_delivered", &Dtool_HTTPChannel_get_first_byte_delivered_317, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_first_byte_delivered_317_comment},
  {"getFirstByteDelivered", &Dtool_HTTPChannel_get_first_byte_delivered_317, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_first_byte_delivered_317_comment},
  {"get_last_byte_delivered", &Dtool_HTTPChannel_get_last_byte_delivered_318, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_last_byte_delivered_318_comment},
  {"getLastByteDelivered", &Dtool_HTTPChannel_get_last_byte_delivered_318, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_last_byte_delivered_318_comment},
  {"write_headers", &Dtool_HTTPChannel_write_headers_319, METH_O, (const char *)Dtool_HTTPChannel_write_headers_319_comment},
  {"writeHeaders", &Dtool_HTTPChannel_write_headers_319, METH_O, (const char *)Dtool_HTTPChannel_write_headers_319_comment},
  {"reset", &Dtool_HTTPChannel_reset_320, METH_NOARGS, (const char *)Dtool_HTTPChannel_reset_320_comment},
  {"preserve_status", &Dtool_HTTPChannel_preserve_status_321, METH_NOARGS, (const char *)Dtool_HTTPChannel_preserve_status_321_comment},
  {"preserveStatus", &Dtool_HTTPChannel_preserve_status_321, METH_NOARGS, (const char *)Dtool_HTTPChannel_preserve_status_321_comment},
  {"clear_extra_headers", &Dtool_HTTPChannel_clear_extra_headers_322, METH_NOARGS, (const char *)Dtool_HTTPChannel_clear_extra_headers_322_comment},
  {"clearExtraHeaders", &Dtool_HTTPChannel_clear_extra_headers_322, METH_NOARGS, (const char *)Dtool_HTTPChannel_clear_extra_headers_322_comment},
  {"send_extra_header", (PyCFunction) &Dtool_HTTPChannel_send_extra_header_323, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_send_extra_header_323_comment},
  {"sendExtraHeader", (PyCFunction) &Dtool_HTTPChannel_send_extra_header_323, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_send_extra_header_323_comment},
  {"get_document", &Dtool_HTTPChannel_get_document_324, METH_O, (const char *)Dtool_HTTPChannel_get_document_324_comment},
  {"getDocument", &Dtool_HTTPChannel_get_document_324, METH_O, (const char *)Dtool_HTTPChannel_get_document_324_comment},
  {"get_subdocument", (PyCFunction) &Dtool_HTTPChannel_get_subdocument_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_get_subdocument_325_comment},
  {"getSubdocument", (PyCFunction) &Dtool_HTTPChannel_get_subdocument_325, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_get_subdocument_325_comment},
  {"get_header", &Dtool_HTTPChannel_get_header_326, METH_O, (const char *)Dtool_HTTPChannel_get_header_326_comment},
  {"getHeader", &Dtool_HTTPChannel_get_header_326, METH_O, (const char *)Dtool_HTTPChannel_get_header_326_comment},
  {"post_form", (PyCFunction) &Dtool_HTTPChannel_post_form_327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_post_form_327_comment},
  {"postForm", (PyCFunction) &Dtool_HTTPChannel_post_form_327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_post_form_327_comment},
  {"put_document", (PyCFunction) &Dtool_HTTPChannel_put_document_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_put_document_328_comment},
  {"putDocument", (PyCFunction) &Dtool_HTTPChannel_put_document_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_put_document_328_comment},
  {"delete_document", &Dtool_HTTPChannel_delete_document_329, METH_O, (const char *)Dtool_HTTPChannel_delete_document_329_comment},
  {"deleteDocument", &Dtool_HTTPChannel_delete_document_329, METH_O, (const char *)Dtool_HTTPChannel_delete_document_329_comment},
  {"get_trace", &Dtool_HTTPChannel_get_trace_330, METH_O, (const char *)Dtool_HTTPChannel_get_trace_330_comment},
  {"getTrace", &Dtool_HTTPChannel_get_trace_330, METH_O, (const char *)Dtool_HTTPChannel_get_trace_330_comment},
  {"connect_to", &Dtool_HTTPChannel_connect_to_331, METH_O, (const char *)Dtool_HTTPChannel_connect_to_331_comment},
  {"connectTo", &Dtool_HTTPChannel_connect_to_331, METH_O, (const char *)Dtool_HTTPChannel_connect_to_331_comment},
  {"get_options", &Dtool_HTTPChannel_get_options_332, METH_O, (const char *)Dtool_HTTPChannel_get_options_332_comment},
  {"getOptions", &Dtool_HTTPChannel_get_options_332, METH_O, (const char *)Dtool_HTTPChannel_get_options_332_comment},
  {"begin_get_document", &Dtool_HTTPChannel_begin_get_document_333, METH_O, (const char *)Dtool_HTTPChannel_begin_get_document_333_comment},
  {"beginGetDocument", &Dtool_HTTPChannel_begin_get_document_333, METH_O, (const char *)Dtool_HTTPChannel_begin_get_document_333_comment},
  {"begin_get_subdocument", (PyCFunction) &Dtool_HTTPChannel_begin_get_subdocument_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_begin_get_subdocument_334_comment},
  {"beginGetSubdocument", (PyCFunction) &Dtool_HTTPChannel_begin_get_subdocument_334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_begin_get_subdocument_334_comment},
  {"begin_get_header", &Dtool_HTTPChannel_begin_get_header_335, METH_O, (const char *)Dtool_HTTPChannel_begin_get_header_335_comment},
  {"beginGetHeader", &Dtool_HTTPChannel_begin_get_header_335, METH_O, (const char *)Dtool_HTTPChannel_begin_get_header_335_comment},
  {"begin_post_form", (PyCFunction) &Dtool_HTTPChannel_begin_post_form_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_begin_post_form_336_comment},
  {"beginPostForm", (PyCFunction) &Dtool_HTTPChannel_begin_post_form_336, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_begin_post_form_336_comment},
  {"run", &Dtool_HTTPChannel_run_337, METH_NOARGS, (const char *)Dtool_HTTPChannel_run_337_comment},
  {"begin_connect_to", &Dtool_HTTPChannel_begin_connect_to_338, METH_O, (const char *)Dtool_HTTPChannel_begin_connect_to_338_comment},
  {"beginConnectTo", &Dtool_HTTPChannel_begin_connect_to_338, METH_O, (const char *)Dtool_HTTPChannel_begin_connect_to_338_comment},
  {"open_read_body", &Dtool_HTTPChannel_open_read_body_339, METH_NOARGS, (const char *)Dtool_HTTPChannel_open_read_body_339_comment},
  {"openReadBody", &Dtool_HTTPChannel_open_read_body_339, METH_NOARGS, (const char *)Dtool_HTTPChannel_open_read_body_339_comment},
  {"close_read_body", &Dtool_HTTPChannel_close_read_body_340, METH_O, (const char *)Dtool_HTTPChannel_close_read_body_340_comment},
  {"closeReadBody", &Dtool_HTTPChannel_close_read_body_340, METH_O, (const char *)Dtool_HTTPChannel_close_read_body_340_comment},
  {"download_to_file", (PyCFunction) &Dtool_HTTPChannel_download_to_file_341, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_download_to_file_341_comment},
  {"downloadToFile", (PyCFunction) &Dtool_HTTPChannel_download_to_file_341, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_download_to_file_341_comment},
  {"download_to_ram", (PyCFunction) &Dtool_HTTPChannel_download_to_ram_342, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_download_to_ram_342_comment},
  {"downloadToRam", (PyCFunction) &Dtool_HTTPChannel_download_to_ram_342, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_download_to_ram_342_comment},
  {"download_to_stream", (PyCFunction) &Dtool_HTTPChannel_download_to_stream_343, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_download_to_stream_343_comment},
  {"downloadToStream", (PyCFunction) &Dtool_HTTPChannel_download_to_stream_343, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HTTPChannel_download_to_stream_343_comment},
  {"get_connection", &Dtool_HTTPChannel_get_connection_344, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_connection_344_comment},
  {"getConnection", &Dtool_HTTPChannel_get_connection_344, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_connection_344_comment},
  {"get_bytes_downloaded", &Dtool_HTTPChannel_get_bytes_downloaded_345, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_bytes_downloaded_345_comment},
  {"getBytesDownloaded", &Dtool_HTTPChannel_get_bytes_downloaded_345, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_bytes_downloaded_345_comment},
  {"get_bytes_requested", &Dtool_HTTPChannel_get_bytes_requested_346, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_bytes_requested_346_comment},
  {"getBytesRequested", &Dtool_HTTPChannel_get_bytes_requested_346, METH_NOARGS, (const char *)Dtool_HTTPChannel_get_bytes_requested_346_comment},
  {"is_download_complete", &Dtool_HTTPChannel_is_download_complete_347, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_download_complete_347_comment},
  {"isDownloadComplete", &Dtool_HTTPChannel_is_download_complete_347, METH_NOARGS, (const char *)Dtool_HTTPChannel_is_download_complete_347_comment},
  {"get_class_type", &Dtool_HTTPChannel_get_class_type_348, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPChannel_get_class_type_348_comment},
  {"getClassType", &Dtool_HTTPChannel_get_class_type_348, METH_NOARGS | METH_STATIC, (const char *)Dtool_HTTPChannel_get_class_type_348_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_redirect_steps", (PyCFunction) &MakeSeq_HTTPChannel_get_redirect_steps, METH_NOARGS, NULL},
  { "getRedirectSteps", (PyCFunction) &MakeSeq_HTTPChannel_get_redirect_steps, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_HTTPChannel = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HTTPChannel = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_HTTPChannel = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_HTTPChannel = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_HTTPChannel = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HTTPChannel",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HTTPChannel,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_HTTPChannel,
    &Dtool_SequenceMethods_HTTPChannel,
    &Dtool_MappingMethods_HTTPChannel,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_HTTPChannel,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single channel of communication from an HTTPClient.  This is similar to\n"
    " * the concept of a 'connection', except that HTTP is technically\n"
    " * connectionless; in fact, a channel may represent one unbroken connection or\n"
    " * it may transparently close and reopen a new connection with each request.\n"
    " *\n"
    " * A channel is conceptually a single thread of I/O. One document at a time\n"
    " * may be requested using a channel; a new document may (in general) not be\n"
    " * requested from the same HTTPChannel until the first document has been fully\n"
    " * retrieved.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HTTPChannel,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HTTPChannel,
    PyType_GenericAlloc,
    Dtool_new_HTTPChannel,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HTTPChannel,
  Dtool_UpcastInterface_HTTPChannel,
  Dtool_DowncastInterface_HTTPChannel,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_HTTPChannel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_HTTPChannel._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = _PyDict_NewPresized(41);
    Dtool_HTTPChannel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum HTTPChannel::StatusCode;
    PyDict_SetItemString(dict, "SC_incomplete", Dtool_WrapValue(HTTPChannel::SC_incomplete));
    PyDict_SetItemString(dict, "SCIncomplete", Dtool_WrapValue(HTTPChannel::SC_incomplete));
    PyDict_SetItemString(dict, "SC_internal_error", Dtool_WrapValue(HTTPChannel::SC_internal_error));
    PyDict_SetItemString(dict, "SCInternalError", Dtool_WrapValue(HTTPChannel::SC_internal_error));
    PyDict_SetItemString(dict, "SC_no_connection", Dtool_WrapValue(HTTPChannel::SC_no_connection));
    PyDict_SetItemString(dict, "SCNoConnection", Dtool_WrapValue(HTTPChannel::SC_no_connection));
    PyDict_SetItemString(dict, "SC_timeout", Dtool_WrapValue(HTTPChannel::SC_timeout));
    PyDict_SetItemString(dict, "SCTimeout", Dtool_WrapValue(HTTPChannel::SC_timeout));
    PyDict_SetItemString(dict, "SC_lost_connection", Dtool_WrapValue(HTTPChannel::SC_lost_connection));
    PyDict_SetItemString(dict, "SCLostConnection", Dtool_WrapValue(HTTPChannel::SC_lost_connection));
    PyDict_SetItemString(dict, "SC_non_http_response", Dtool_WrapValue(HTTPChannel::SC_non_http_response));
    PyDict_SetItemString(dict, "SCNonHttpResponse", Dtool_WrapValue(HTTPChannel::SC_non_http_response));
    PyDict_SetItemString(dict, "SC_invalid_http", Dtool_WrapValue(HTTPChannel::SC_invalid_http));
    PyDict_SetItemString(dict, "SCInvalidHttp", Dtool_WrapValue(HTTPChannel::SC_invalid_http));
    PyDict_SetItemString(dict, "SC_socks_invalid_version", Dtool_WrapValue(HTTPChannel::SC_socks_invalid_version));
    PyDict_SetItemString(dict, "SCSocksInvalidVersion", Dtool_WrapValue(HTTPChannel::SC_socks_invalid_version));
    PyDict_SetItemString(dict, "SC_socks_no_acceptable_login_method", Dtool_WrapValue(HTTPChannel::SC_socks_no_acceptable_login_method));
    PyDict_SetItemString(dict, "SCSocksNoAcceptableLoginMethod", Dtool_WrapValue(HTTPChannel::SC_socks_no_acceptable_login_method));
    PyDict_SetItemString(dict, "SC_socks_refused", Dtool_WrapValue(HTTPChannel::SC_socks_refused));
    PyDict_SetItemString(dict, "SCSocksRefused", Dtool_WrapValue(HTTPChannel::SC_socks_refused));
    PyDict_SetItemString(dict, "SC_socks_no_connection", Dtool_WrapValue(HTTPChannel::SC_socks_no_connection));
    PyDict_SetItemString(dict, "SCSocksNoConnection", Dtool_WrapValue(HTTPChannel::SC_socks_no_connection));
    PyDict_SetItemString(dict, "SC_ssl_internal_failure", Dtool_WrapValue(HTTPChannel::SC_ssl_internal_failure));
    PyDict_SetItemString(dict, "SCSslInternalFailure", Dtool_WrapValue(HTTPChannel::SC_ssl_internal_failure));
    PyDict_SetItemString(dict, "SC_ssl_no_handshake", Dtool_WrapValue(HTTPChannel::SC_ssl_no_handshake));
    PyDict_SetItemString(dict, "SCSslNoHandshake", Dtool_WrapValue(HTTPChannel::SC_ssl_no_handshake));
    PyDict_SetItemString(dict, "SC_http_error_watermark", Dtool_WrapValue(HTTPChannel::SC_http_error_watermark));
    PyDict_SetItemString(dict, "SCHttpErrorWatermark", Dtool_WrapValue(HTTPChannel::SC_http_error_watermark));
    PyDict_SetItemString(dict, "SC_ssl_invalid_server_certificate", Dtool_WrapValue(HTTPChannel::SC_ssl_invalid_server_certificate));
    PyDict_SetItemString(dict, "SCSslInvalidServerCertificate", Dtool_WrapValue(HTTPChannel::SC_ssl_invalid_server_certificate));
    PyDict_SetItemString(dict, "SC_ssl_self_signed_server_certificate", Dtool_WrapValue(HTTPChannel::SC_ssl_self_signed_server_certificate));
    PyDict_SetItemString(dict, "SCSslSelfSignedServerCertificate", Dtool_WrapValue(HTTPChannel::SC_ssl_self_signed_server_certificate));
    PyDict_SetItemString(dict, "SC_ssl_unexpected_server", Dtool_WrapValue(HTTPChannel::SC_ssl_unexpected_server));
    PyDict_SetItemString(dict, "SCSslUnexpectedServer", Dtool_WrapValue(HTTPChannel::SC_ssl_unexpected_server));
    PyDict_SetItemString(dict, "SC_download_open_error", Dtool_WrapValue(HTTPChannel::SC_download_open_error));
    PyDict_SetItemString(dict, "SCDownloadOpenError", Dtool_WrapValue(HTTPChannel::SC_download_open_error));
    PyDict_SetItemString(dict, "SC_download_write_error", Dtool_WrapValue(HTTPChannel::SC_download_write_error));
    PyDict_SetItemString(dict, "SCDownloadWriteError", Dtool_WrapValue(HTTPChannel::SC_download_write_error));
    PyDict_SetItemString(dict, "SC_download_invalid_range", Dtool_WrapValue(HTTPChannel::SC_download_invalid_range));
    PyDict_SetItemString(dict, "SCDownloadInvalidRange", Dtool_WrapValue(HTTPChannel::SC_download_invalid_range));
    if (PyType_Ready((PyTypeObject *)&Dtool_HTTPChannel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HTTPChannel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HTTPChannel);
  }
}

/**
 * Python method tables for Decompressor (Decompressor)
 */
static PyMethodDef Dtool_Methods_Decompressor[] = {
  {"initiate", (PyCFunction) &Dtool_Decompressor_initiate_353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Decompressor_initiate_353_comment},
  {"run", &Dtool_Decompressor_run_354, METH_NOARGS, (const char *)Dtool_Decompressor_run_354_comment},
  {"decompress", &Dtool_Decompressor_decompress_355, METH_O, (const char *)Dtool_Decompressor_decompress_355_comment},
  {"get_progress", &Dtool_Decompressor_get_progress_356, METH_NOARGS, (const char *)Dtool_Decompressor_get_progress_356_comment},
  {"getProgress", &Dtool_Decompressor_get_progress_356, METH_NOARGS, (const char *)Dtool_Decompressor_get_progress_356_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_Decompressor[] = {
  {(char *)"progress", &Dtool_Decompressor_progress_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Decompressor = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Decompressor = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Decompressor",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Decompressor,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Decompressor,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This manages run-time decompression of a zlib-compressed stream, as a\n"
    " * background or foreground task.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Decompressor,
    0, // tp_members
    Dtool_Properties_Decompressor,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Decompressor,
    PyType_GenericAlloc,
    Dtool_new_Decompressor,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Decompressor,
  Dtool_UpcastInterface_Decompressor,
  Dtool_DowncastInterface_Decompressor,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Decompressor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Decompressor._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Decompressor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Decompressor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Decompressor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Decompressor);
  }
}

/**
 * Python method tables for DownloadDb (DownloadDb)
 */
static PyMethodDef Dtool_Methods_DownloadDb[] = {
  {"output", &Dtool_DownloadDb_output_364, METH_O, (const char *)Dtool_DownloadDb_output_364_comment},
  {"write", &Dtool_DownloadDb_write_365, METH_O, (const char *)Dtool_DownloadDb_write_365_comment},
  {"write_version_map", &Dtool_DownloadDb_write_version_map_366, METH_O, (const char *)Dtool_DownloadDb_write_version_map_366_comment},
  {"writeVersionMap", &Dtool_DownloadDb_write_version_map_366, METH_O, (const char *)Dtool_DownloadDb_write_version_map_366_comment},
  {"write_client_db", &Dtool_DownloadDb_write_client_db_367, METH_O, (const char *)Dtool_DownloadDb_write_client_db_367_comment},
  {"writeClientDb", &Dtool_DownloadDb_write_client_db_367, METH_O, (const char *)Dtool_DownloadDb_write_client_db_367_comment},
  {"write_server_db", &Dtool_DownloadDb_write_server_db_368, METH_O, (const char *)Dtool_DownloadDb_write_server_db_368_comment},
  {"writeServerDb", &Dtool_DownloadDb_write_server_db_368, METH_O, (const char *)Dtool_DownloadDb_write_server_db_368_comment},
  {"get_client_num_multifiles", &Dtool_DownloadDb_get_client_num_multifiles_369, METH_NOARGS, (const char *)Dtool_DownloadDb_get_client_num_multifiles_369_comment},
  {"getClientNumMultifiles", &Dtool_DownloadDb_get_client_num_multifiles_369, METH_NOARGS, (const char *)Dtool_DownloadDb_get_client_num_multifiles_369_comment},
  {"get_server_num_multifiles", &Dtool_DownloadDb_get_server_num_multifiles_370, METH_NOARGS, (const char *)Dtool_DownloadDb_get_server_num_multifiles_370_comment},
  {"getServerNumMultifiles", &Dtool_DownloadDb_get_server_num_multifiles_370, METH_NOARGS, (const char *)Dtool_DownloadDb_get_server_num_multifiles_370_comment},
  {"get_client_multifile_name", &Dtool_DownloadDb_get_client_multifile_name_371, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_name_371_comment},
  {"getClientMultifileName", &Dtool_DownloadDb_get_client_multifile_name_371, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_name_371_comment},
  {"get_server_multifile_name", &Dtool_DownloadDb_get_server_multifile_name_372, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_name_372_comment},
  {"getServerMultifileName", &Dtool_DownloadDb_get_server_multifile_name_372, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_name_372_comment},
  {"get_client_multifile_size", &Dtool_DownloadDb_get_client_multifile_size_373, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_size_373_comment},
  {"getClientMultifileSize", &Dtool_DownloadDb_get_client_multifile_size_373, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_size_373_comment},
  {"set_client_multifile_size", (PyCFunction) &Dtool_DownloadDb_set_client_multifile_size_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_client_multifile_size_374_comment},
  {"setClientMultifileSize", (PyCFunction) &Dtool_DownloadDb_set_client_multifile_size_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_client_multifile_size_374_comment},
  {"set_client_multifile_delta_size", (PyCFunction) &Dtool_DownloadDb_set_client_multifile_delta_size_375, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_client_multifile_delta_size_375_comment},
  {"setClientMultifileDeltaSize", (PyCFunction) &Dtool_DownloadDb_set_client_multifile_delta_size_375, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_client_multifile_delta_size_375_comment},
  {"get_server_multifile_size", &Dtool_DownloadDb_get_server_multifile_size_376, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_size_376_comment},
  {"getServerMultifileSize", &Dtool_DownloadDb_get_server_multifile_size_376, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_size_376_comment},
  {"set_server_multifile_size", (PyCFunction) &Dtool_DownloadDb_set_server_multifile_size_377, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_server_multifile_size_377_comment},
  {"setServerMultifileSize", (PyCFunction) &Dtool_DownloadDb_set_server_multifile_size_377, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_server_multifile_size_377_comment},
  {"get_client_multifile_phase", &Dtool_DownloadDb_get_client_multifile_phase_378, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_phase_378_comment},
  {"getClientMultifilePhase", &Dtool_DownloadDb_get_client_multifile_phase_378, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_phase_378_comment},
  {"get_server_multifile_phase", &Dtool_DownloadDb_get_server_multifile_phase_379, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_phase_379_comment},
  {"getServerMultifilePhase", &Dtool_DownloadDb_get_server_multifile_phase_379, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_phase_379_comment},
  {"set_client_multifile_incomplete", &Dtool_DownloadDb_set_client_multifile_incomplete_380, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_incomplete_380_comment},
  {"setClientMultifileIncomplete", &Dtool_DownloadDb_set_client_multifile_incomplete_380, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_incomplete_380_comment},
  {"set_client_multifile_complete", &Dtool_DownloadDb_set_client_multifile_complete_381, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_complete_381_comment},
  {"setClientMultifileComplete", &Dtool_DownloadDb_set_client_multifile_complete_381, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_complete_381_comment},
  {"set_client_multifile_decompressed", &Dtool_DownloadDb_set_client_multifile_decompressed_382, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_decompressed_382_comment},
  {"setClientMultifileDecompressed", &Dtool_DownloadDb_set_client_multifile_decompressed_382, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_decompressed_382_comment},
  {"set_client_multifile_extracted", &Dtool_DownloadDb_set_client_multifile_extracted_383, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_extracted_383_comment},
  {"setClientMultifileExtracted", &Dtool_DownloadDb_set_client_multifile_extracted_383, METH_O, (const char *)Dtool_DownloadDb_set_client_multifile_extracted_383_comment},
  {"get_server_num_files", &Dtool_DownloadDb_get_server_num_files_384, METH_O, (const char *)Dtool_DownloadDb_get_server_num_files_384_comment},
  {"getServerNumFiles", &Dtool_DownloadDb_get_server_num_files_384, METH_O, (const char *)Dtool_DownloadDb_get_server_num_files_384_comment},
  {"get_server_file_name", (PyCFunction) &Dtool_DownloadDb_get_server_file_name_385, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_get_server_file_name_385_comment},
  {"getServerFileName", (PyCFunction) &Dtool_DownloadDb_get_server_file_name_385, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_get_server_file_name_385_comment},
  {"client_multifile_exists", &Dtool_DownloadDb_client_multifile_exists_386, METH_O, (const char *)Dtool_DownloadDb_client_multifile_exists_386_comment},
  {"clientMultifileExists", &Dtool_DownloadDb_client_multifile_exists_386, METH_O, (const char *)Dtool_DownloadDb_client_multifile_exists_386_comment},
  {"client_multifile_complete", &Dtool_DownloadDb_client_multifile_complete_387, METH_O, (const char *)Dtool_DownloadDb_client_multifile_complete_387_comment},
  {"clientMultifileComplete", &Dtool_DownloadDb_client_multifile_complete_387, METH_O, (const char *)Dtool_DownloadDb_client_multifile_complete_387_comment},
  {"client_multifile_decompressed", &Dtool_DownloadDb_client_multifile_decompressed_388, METH_O, (const char *)Dtool_DownloadDb_client_multifile_decompressed_388_comment},
  {"clientMultifileDecompressed", &Dtool_DownloadDb_client_multifile_decompressed_388, METH_O, (const char *)Dtool_DownloadDb_client_multifile_decompressed_388_comment},
  {"client_multifile_extracted", &Dtool_DownloadDb_client_multifile_extracted_389, METH_O, (const char *)Dtool_DownloadDb_client_multifile_extracted_389_comment},
  {"clientMultifileExtracted", &Dtool_DownloadDb_client_multifile_extracted_389, METH_O, (const char *)Dtool_DownloadDb_client_multifile_extracted_389_comment},
  {"get_client_multifile_hash", &Dtool_DownloadDb_get_client_multifile_hash_390, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_hash_390_comment},
  {"getClientMultifileHash", &Dtool_DownloadDb_get_client_multifile_hash_390, METH_O, (const char *)Dtool_DownloadDb_get_client_multifile_hash_390_comment},
  {"set_client_multifile_hash", (PyCFunction) &Dtool_DownloadDb_set_client_multifile_hash_391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_client_multifile_hash_391_comment},
  {"setClientMultifileHash", (PyCFunction) &Dtool_DownloadDb_set_client_multifile_hash_391, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_client_multifile_hash_391_comment},
  {"get_server_multifile_hash", &Dtool_DownloadDb_get_server_multifile_hash_392, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_hash_392_comment},
  {"getServerMultifileHash", &Dtool_DownloadDb_get_server_multifile_hash_392, METH_O, (const char *)Dtool_DownloadDb_get_server_multifile_hash_392_comment},
  {"set_server_multifile_hash", (PyCFunction) &Dtool_DownloadDb_set_server_multifile_hash_393, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_server_multifile_hash_393_comment},
  {"setServerMultifileHash", (PyCFunction) &Dtool_DownloadDb_set_server_multifile_hash_393, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_server_multifile_hash_393_comment},
  {"delete_client_multifile", &Dtool_DownloadDb_delete_client_multifile_394, METH_O, (const char *)Dtool_DownloadDb_delete_client_multifile_394_comment},
  {"deleteClientMultifile", &Dtool_DownloadDb_delete_client_multifile_394, METH_O, (const char *)Dtool_DownloadDb_delete_client_multifile_394_comment},
  {"add_client_multifile", &Dtool_DownloadDb_add_client_multifile_395, METH_O, (const char *)Dtool_DownloadDb_add_client_multifile_395_comment},
  {"addClientMultifile", &Dtool_DownloadDb_add_client_multifile_395, METH_O, (const char *)Dtool_DownloadDb_add_client_multifile_395_comment},
  {"expand_client_multifile", &Dtool_DownloadDb_expand_client_multifile_396, METH_O, (const char *)Dtool_DownloadDb_expand_client_multifile_396_comment},
  {"expandClientMultifile", &Dtool_DownloadDb_expand_client_multifile_396, METH_O, (const char *)Dtool_DownloadDb_expand_client_multifile_396_comment},
  {"create_new_server_db", &Dtool_DownloadDb_create_new_server_db_397, METH_NOARGS, (const char *)Dtool_DownloadDb_create_new_server_db_397_comment},
  {"createNewServerDb", &Dtool_DownloadDb_create_new_server_db_397, METH_NOARGS, (const char *)Dtool_DownloadDb_create_new_server_db_397_comment},
  {"server_add_multifile", (PyCFunction) &Dtool_DownloadDb_server_add_multifile_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_server_add_multifile_398_comment},
  {"serverAddMultifile", (PyCFunction) &Dtool_DownloadDb_server_add_multifile_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_server_add_multifile_398_comment},
  {"server_add_file", (PyCFunction) &Dtool_DownloadDb_server_add_file_399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_server_add_file_399_comment},
  {"serverAddFile", (PyCFunction) &Dtool_DownloadDb_server_add_file_399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_server_add_file_399_comment},
  {"add_version", (PyCFunction) &Dtool_DownloadDb_add_version_402, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_add_version_402_comment},
  {"addVersion", (PyCFunction) &Dtool_DownloadDb_add_version_402, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_add_version_402_comment},
  {"insert_new_version", (PyCFunction) &Dtool_DownloadDb_insert_new_version_403, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_insert_new_version_403_comment},
  {"insertNewVersion", (PyCFunction) &Dtool_DownloadDb_insert_new_version_403, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_insert_new_version_403_comment},
  {"has_version", &Dtool_DownloadDb_has_version_404, METH_O, (const char *)Dtool_DownloadDb_has_version_404_comment},
  {"hasVersion", &Dtool_DownloadDb_has_version_404, METH_O, (const char *)Dtool_DownloadDb_has_version_404_comment},
  {"get_num_versions", &Dtool_DownloadDb_get_num_versions_405, METH_O, (const char *)Dtool_DownloadDb_get_num_versions_405_comment},
  {"getNumVersions", &Dtool_DownloadDb_get_num_versions_405, METH_O, (const char *)Dtool_DownloadDb_get_num_versions_405_comment},
  {"set_num_versions", (PyCFunction) &Dtool_DownloadDb_set_num_versions_406, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_num_versions_406_comment},
  {"setNumVersions", (PyCFunction) &Dtool_DownloadDb_set_num_versions_406, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_set_num_versions_406_comment},
  {"get_version", (PyCFunction) &Dtool_DownloadDb_get_version_407, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_get_version_407_comment},
  {"getVersion", (PyCFunction) &Dtool_DownloadDb_get_version_407, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DownloadDb_get_version_407_comment},
  {"get_hash", &Dtool_DownloadDb_get_hash_408, METH_VARARGS, (const char *)Dtool_DownloadDb_get_hash_408_comment},
  {"getHash", &Dtool_DownloadDb_get_hash_408, METH_VARARGS, (const char *)Dtool_DownloadDb_get_hash_408_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DownloadDb
//////////////////
static PyObject *Dtool_Repr_DownloadDb(PyObject *self) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DownloadDb
//////////////////
static PyObject *Dtool_Str_DownloadDb(PyObject *self) {
  DownloadDb *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DownloadDb, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DownloadDb = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DownloadDb = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DownloadDb",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DownloadDb,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DownloadDb,
    &Dtool_NumberMethods_DownloadDb,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DownloadDb,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A listing of files within multifiles for management of client-side\n"
    " * synchronization with a server-provided set of files.\n"
    " *\n"
    " * This class manages one copy of the database for the client, representing\n"
    " * the files on the client system, and another copy for the server,\n"
    " * representing the files the server has available.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DownloadDb,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DownloadDb,
    PyType_GenericAlloc,
    Dtool_new_DownloadDb,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DownloadDb,
  Dtool_UpcastInterface_DownloadDb,
  Dtool_DowncastInterface_DownloadDb,
  (CoerceFunction)Dtool_ConstCoerce_DownloadDb,
  (CoerceFunction)Dtool_Coerce_DownloadDb,
};

static void Dtool_PyModuleClassInit_DownloadDb(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DownloadDb._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_DownloadDb._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum DownloadDb::Status;
    PyDict_SetItemString(dict, "Status_incomplete", Dtool_WrapValue(DownloadDb::Status_incomplete));
    PyDict_SetItemString(dict, "StatusIncomplete", Dtool_WrapValue(DownloadDb::Status_incomplete));
    PyDict_SetItemString(dict, "Status_complete", Dtool_WrapValue(DownloadDb::Status_complete));
    PyDict_SetItemString(dict, "StatusComplete", Dtool_WrapValue(DownloadDb::Status_complete));
    PyDict_SetItemString(dict, "Status_decompressed", Dtool_WrapValue(DownloadDb::Status_decompressed));
    PyDict_SetItemString(dict, "StatusDecompressed", Dtool_WrapValue(DownloadDb::Status_decompressed));
    PyDict_SetItemString(dict, "Status_extracted", Dtool_WrapValue(DownloadDb::Status_extracted));
    PyDict_SetItemString(dict, "StatusExtracted", Dtool_WrapValue(DownloadDb::Status_extracted));
    if (PyType_Ready((PyTypeObject *)&Dtool_DownloadDb) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DownloadDb)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DownloadDb);
  }
}

/**
 * Python method tables for Extractor (Extractor)
 */
static PyMethodDef Dtool_Methods_Extractor[] = {
  {"set_multifile", &Dtool_Extractor_set_multifile_414, METH_O, (const char *)Dtool_Extractor_set_multifile_414_comment},
  {"setMultifile", &Dtool_Extractor_set_multifile_414, METH_O, (const char *)Dtool_Extractor_set_multifile_414_comment},
  {"set_extract_dir", &Dtool_Extractor_set_extract_dir_415, METH_O, (const char *)Dtool_Extractor_set_extract_dir_415_comment},
  {"setExtractDir", &Dtool_Extractor_set_extract_dir_415, METH_O, (const char *)Dtool_Extractor_set_extract_dir_415_comment},
  {"reset", &Dtool_Extractor_reset_416, METH_NOARGS, (const char *)Dtool_Extractor_reset_416_comment},
  {"request_subfile", &Dtool_Extractor_request_subfile_417, METH_O, (const char *)Dtool_Extractor_request_subfile_417_comment},
  {"requestSubfile", &Dtool_Extractor_request_subfile_417, METH_O, (const char *)Dtool_Extractor_request_subfile_417_comment},
  {"request_all_subfiles", &Dtool_Extractor_request_all_subfiles_418, METH_NOARGS, (const char *)Dtool_Extractor_request_all_subfiles_418_comment},
  {"requestAllSubfiles", &Dtool_Extractor_request_all_subfiles_418, METH_NOARGS, (const char *)Dtool_Extractor_request_all_subfiles_418_comment},
  {"step", &Dtool_Extractor_step_419, METH_NOARGS, (const char *)Dtool_Extractor_step_419_comment},
  {"get_progress", &Dtool_Extractor_get_progress_420, METH_NOARGS, (const char *)Dtool_Extractor_get_progress_420_comment},
  {"getProgress", &Dtool_Extractor_get_progress_420, METH_NOARGS, (const char *)Dtool_Extractor_get_progress_420_comment},
  {"run", &Dtool_Extractor_run_421, METH_NOARGS, (const char *)Dtool_Extractor_run_421_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_Extractor[] = {
  {(char *)"progress", &Dtool_Extractor_progress_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Extractor = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Extractor = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Extractor",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Extractor,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Extractor,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class automatically extracts the contents of a Multifile to the\n"
    " * current directory (or to a specified directory) in the background.\n"
    " *\n"
    " * It is designed to limit its use of system resources and run unobtrusively\n"
    " * in the background.  After specifying the files you wish to extract via\n"
    " * repeated calls to request_subfile(), begin the process by calling run()\n"
    " * repeatedly.  Each call to run() extracts another small portion of the\n"
    " * Multifile.  Call run() whenever you have spare cycles until run() returns\n"
    " * EU_success.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Extractor,
    0, // tp_members
    Dtool_Properties_Extractor,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Extractor,
    PyType_GenericAlloc,
    Dtool_new_Extractor,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Extractor,
  Dtool_UpcastInterface_Extractor,
  Dtool_DowncastInterface_Extractor,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Extractor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Extractor._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Extractor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Extractor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Extractor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Extractor);
  }
}

/**
 * Python method tables for MultiplexStream (MultiplexStream)
 */
static PyMethodDef Dtool_Methods_MultiplexStream[] = {
  {"add_ostream", (PyCFunction) &Dtool_MultiplexStream_add_ostream_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MultiplexStream_add_ostream_425_comment},
  {"addOstream", (PyCFunction) &Dtool_MultiplexStream_add_ostream_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MultiplexStream_add_ostream_425_comment},
  {"add_standard_output", &Dtool_MultiplexStream_add_standard_output_427, METH_NOARGS, (const char *)Dtool_MultiplexStream_add_standard_output_427_comment},
  {"addStandardOutput", &Dtool_MultiplexStream_add_standard_output_427, METH_NOARGS, (const char *)Dtool_MultiplexStream_add_standard_output_427_comment},
  {"add_file", &Dtool_MultiplexStream_add_file_428, METH_O, (const char *)Dtool_MultiplexStream_add_file_428_comment},
  {"addFile", &Dtool_MultiplexStream_add_file_428, METH_O, (const char *)Dtool_MultiplexStream_add_file_428_comment},
  {"add_system_debug", &Dtool_MultiplexStream_add_system_debug_429, METH_NOARGS, (const char *)Dtool_MultiplexStream_add_system_debug_429_comment},
  {"addSystemDebug", &Dtool_MultiplexStream_add_system_debug_429, METH_NOARGS, (const char *)Dtool_MultiplexStream_add_system_debug_429_comment},
  {"flush", &Dtool_MultiplexStream_flush_430, METH_NOARGS, (const char *)Dtool_MultiplexStream_flush_430_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MultiplexStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MultiplexStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MultiplexStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MultiplexStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MultiplexStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MultiplexStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MultiplexStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MultiplexStream,
    &Dtool_SequenceMethods_MultiplexStream,
    &Dtool_MappingMethods_MultiplexStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MultiplexStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special ostream that forwards the data that is written to it to\n"
    " * any number of other sources, for instance other ostreams, or explicitly to\n"
    " * a disk file or to system logging utilities.  It's a very handy thing to set\n"
    " * Notify to refer to when running in batch mode.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MultiplexStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MultiplexStream,
    PyType_GenericAlloc,
    Dtool_new_MultiplexStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MultiplexStream,
  Dtool_UpcastInterface_MultiplexStream,
  Dtool_DowncastInterface_MultiplexStream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MultiplexStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ostream != NULL);
    assert(Dtool_Ptr_ostream->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_ostream->_Dtool_ModuleClassInit(NULL);
    Dtool_MultiplexStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ostream);
    PyObject *dict = PyDict_New();
    Dtool_MultiplexStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MultiplexStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MultiplexStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MultiplexStream);
  }
}

/**
 * Python method tables for VirtualFileHTTP (VirtualFileHTTP)
 */
static PyMethodDef Dtool_Methods_VirtualFileHTTP[] = {
  {"get_class_type", &Dtool_VirtualFileHTTP_get_class_type_434, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileHTTP_get_class_type_434_comment},
  {"getClassType", &Dtool_VirtualFileHTTP_get_class_type_434, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileHTTP_get_class_type_434_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileHTTP = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileHTTP = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileHTTP = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileHTTP = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileHTTP = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileHTTP",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileHTTP,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileHTTP,
    &Dtool_SequenceMethods_VirtualFileHTTP,
    &Dtool_MappingMethods_VirtualFileHTTP,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileHTTP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This maps a document retrieved from an HTTPClient into the\n"
    " * VirtualFileSystem, allowing models etc.  to be loaded directly from a web\n"
    " * page.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileHTTP,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileHTTP,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileHTTP,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileHTTP,
  Dtool_UpcastInterface_VirtualFileHTTP,
  Dtool_DowncastInterface_VirtualFileHTTP,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileHTTP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VirtualFile != NULL);
    assert(Dtool_Ptr_VirtualFile->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_VirtualFile->_Dtool_ModuleClassInit(NULL);
    Dtool_VirtualFileHTTP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VirtualFile);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileHTTP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileHTTP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileHTTP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileHTTP);
  }
}

/**
 * Python method tables for VirtualFileMountHTTP (VirtualFileMountHTTP)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountHTTP[] = {
  {"get_http_client", &Dtool_VirtualFileMountHTTP_get_http_client_438, METH_NOARGS, (const char *)Dtool_VirtualFileMountHTTP_get_http_client_438_comment},
  {"getHttpClient", &Dtool_VirtualFileMountHTTP_get_http_client_438, METH_NOARGS, (const char *)Dtool_VirtualFileMountHTTP_get_http_client_438_comment},
  {"get_root", &Dtool_VirtualFileMountHTTP_get_root_439, METH_NOARGS, (const char *)Dtool_VirtualFileMountHTTP_get_root_439_comment},
  {"getRoot", &Dtool_VirtualFileMountHTTP_get_root_439, METH_NOARGS, (const char *)Dtool_VirtualFileMountHTTP_get_root_439_comment},
  {"reload_vfs_mount_url", &Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440_comment},
  {"reloadVfsMountUrl", &Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountHTTP_reload_vfs_mount_url_440_comment},
  {"get_class_type", &Dtool_VirtualFileMountHTTP_get_class_type_441, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountHTTP_get_class_type_441_comment},
  {"getClassType", &Dtool_VirtualFileMountHTTP_get_class_type_441, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountHTTP_get_class_type_441_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountHTTP = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountHTTP = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountHTTP = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountHTTP = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileMountHTTP = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileMountHTTP",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountHTTP,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileMountHTTP,
    &Dtool_SequenceMethods_VirtualFileMountHTTP,
    &Dtool_MappingMethods_VirtualFileMountHTTP,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileMountHTTP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Maps a web page (URL root) into the VirtualFileSystem.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileMountHTTP,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountHTTP,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountHTTP,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountHTTP,
  Dtool_UpcastInterface_VirtualFileMountHTTP,
  Dtool_DowncastInterface_VirtualFileMountHTTP,
  (CoerceFunction)Dtool_ConstCoerce_VirtualFileMountHTTP,
  (CoerceFunction)Dtool_Coerce_VirtualFileMountHTTP,
};

static void Dtool_PyModuleClassInit_VirtualFileMountHTTP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_VirtualFileMount != NULL);
    assert(Dtool_Ptr_VirtualFileMount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_VirtualFileMount->_Dtool_ModuleClassInit(NULL);
    Dtool_VirtualFileMountHTTP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_VirtualFileMount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountHTTP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountHTTP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountHTTP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountHTTP);
  }
}

/**
 * Python method tables for Patcher (Patcher)
 */
static PyMethodDef Dtool_Methods_Patcher[] = {
  {"initiate", (PyCFunction) &Dtool_Patcher_initiate_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patcher_initiate_445_comment},
  {"run", &Dtool_Patcher_run_446, METH_NOARGS, (const char *)Dtool_Patcher_run_446_comment},
  {"get_progress", &Dtool_Patcher_get_progress_447, METH_NOARGS, (const char *)Dtool_Patcher_get_progress_447_comment},
  {"getProgress", &Dtool_Patcher_get_progress_447, METH_NOARGS, (const char *)Dtool_Patcher_get_progress_447_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Patcher = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Patcher = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Patcher",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Patcher,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Patcher,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Applies a patch synchronously\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Patcher,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Patcher,
    PyType_GenericAlloc,
    Dtool_new_Patcher,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Patcher,
  Dtool_UpcastInterface_Patcher,
  Dtool_DowncastInterface_Patcher,
  (CoerceFunction)Dtool_ConstCoerce_Patcher,
  (CoerceFunction)Dtool_Coerce_Patcher,
};

static void Dtool_PyModuleClassInit_Patcher(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Patcher._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Patcher._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Patcher) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Patcher)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Patcher);
  }
}

/**
 * Python method tables for StringStream (StringStream)
 */
static PyMethodDef Dtool_Methods_StringStream[] = {
  {"clear_data", &Dtool_StringStream_clear_data_450, METH_NOARGS, (const char *)Dtool_StringStream_clear_data_450_comment},
  {"clearData", &Dtool_StringStream_clear_data_450, METH_NOARGS, (const char *)Dtool_StringStream_clear_data_450_comment},
  {"get_data_size", &Dtool_StringStream_get_data_size_451, METH_NOARGS, (const char *)Dtool_StringStream_get_data_size_451_comment},
  {"getDataSize", &Dtool_StringStream_get_data_size_451, METH_NOARGS, (const char *)Dtool_StringStream_get_data_size_451_comment},
  {"get_data", &Dtool_StringStream_get_data_452, METH_NOARGS, (const char *)Dtool_StringStream_get_data_452_comment},
  {"getData", &Dtool_StringStream_get_data_452, METH_NOARGS, (const char *)Dtool_StringStream_get_data_452_comment},
  {"set_data", &Dtool_StringStream_set_data_453, METH_O, (const char *)Dtool_StringStream_set_data_453_comment},
  {"setData", &Dtool_StringStream_set_data_453, METH_O, (const char *)Dtool_StringStream_set_data_453_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_StringStream[] = {
  {(char *)"data", &Dtool_StringStream_data_Getter, &Dtool_StringStream_data_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_StringStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StringStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_StringStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_StringStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_StringStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StringStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StringStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StringStream,
    &Dtool_SequenceMethods_StringStream,
    &Dtool_MappingMethods_StringStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_StringStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A bi-directional stream object that reads and writes data to an internal\n"
    " * buffer, which can be retrieved and/or set as a string in Python 2 or a\n"
    " * bytes object in Python 3.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StringStream,
    0, // tp_members
    Dtool_Properties_StringStream,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StringStream,
    PyType_GenericAlloc,
    Dtool_new_StringStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StringStream,
  Dtool_UpcastInterface_StringStream,
  Dtool_DowncastInterface_StringStream,
  (CoerceFunction)Dtool_ConstCoerce_StringStream,
  (CoerceFunction)Dtool_Coerce_StringStream,
};

static void Dtool_PyModuleClassInit_StringStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_iostream != NULL);
    assert(Dtool_Ptr_iostream->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_iostream->_Dtool_ModuleClassInit(NULL);
    Dtool_StringStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_iostream);
    PyObject *dict = PyDict_New();
    Dtool_StringStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StringStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StringStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StringStream);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3downloader_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SSReader", Dtool_SSReader);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SSWriter", Dtool_SSWriter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ISocketStream", Dtool_ISocketStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OSocketStream", Dtool_OSocketStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SocketStream", Dtool_SocketStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("URLSpec", Dtool_URLSpec);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HTTPEnum", Dtool_HTTPEnum);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HTTPDate", Dtool_HTTPDate);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HTTPCookie", Dtool_HTTPCookie);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HTTPClient", Dtool_HTTPClient);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HTTPEntityTag", Dtool_HTTPEntityTag);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DocumentSpec", Dtool_DocumentSpec);
#endif
  Dtool_HTTPChannel._type = HTTPChannel::get_class_type();
  RegisterRuntimeTypedClass(Dtool_HTTPChannel);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Decompressor", Dtool_Decompressor);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DownloadDb", Dtool_DownloadDb);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Extractor", Dtool_Extractor);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MultiplexStream", Dtool_MultiplexStream);
#endif
  Dtool_VirtualFileHTTP._type = VirtualFileHTTP::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileHTTP);
  Dtool_VirtualFileMountHTTP._type = VirtualFileMountHTTP::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileMountHTTP);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Patcher", Dtool_Patcher);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StringStream", Dtool_StringStream);
#endif
}

void Dtool_libp3downloader_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ios_base = LookupNamedClass("ios_base");
  Dtool_Ptr_ios = LookupNamedClass("ios");
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_istream = LookupNamedClass("istream");
  Dtool_Ptr_iostream = LookupNamedClass("iostream");
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_Ramfile = LookupNamedClass("Ramfile");
  Dtool_Ptr_HashVal = LookupNamedClass("HashVal");
  Dtool_Ptr_Buffer = LookupNamedClass("Buffer");
  Dtool_Ptr_VirtualFileMount = LookupRuntimeTypedClass(VirtualFileMount::get_class_type());
  Dtool_Ptr_VirtualFile = LookupRuntimeTypedClass(VirtualFile::get_class_type());
#endif
}

void Dtool_libp3downloader_BuildInstants(PyObject *module) {
  (void) module;
  // SSReader
  Dtool_PyModuleClassInit_SSReader(module);
  PyModule_AddObject(module, "SSReader", (PyObject *)&Dtool_SSReader);
  // SSWriter
  Dtool_PyModuleClassInit_SSWriter(module);
  PyModule_AddObject(module, "SSWriter", (PyObject *)&Dtool_SSWriter);
  // ISocketStream
  Dtool_PyModuleClassInit_ISocketStream(module);
  PyModule_AddObject(module, "ISocketStream", (PyObject *)&Dtool_ISocketStream);
  // OSocketStream
  Dtool_PyModuleClassInit_OSocketStream(module);
  PyModule_AddObject(module, "OSocketStream", (PyObject *)&Dtool_OSocketStream);
  // SocketStream
  Dtool_PyModuleClassInit_SocketStream(module);
  PyModule_AddObject(module, "SocketStream", (PyObject *)&Dtool_SocketStream);
  // URLSpec
  Dtool_PyModuleClassInit_URLSpec(module);
  PyModule_AddObject(module, "URLSpec", (PyObject *)&Dtool_URLSpec);
  // HTTPEnum
  Dtool_PyModuleClassInit_HTTPEnum(module);
  PyModule_AddObject(module, "HTTPEnum", (PyObject *)&Dtool_HTTPEnum);
  // HTTPDate
  Dtool_PyModuleClassInit_HTTPDate(module);
  PyModule_AddObject(module, "HTTPDate", (PyObject *)&Dtool_HTTPDate);
  // HTTPCookie
  Dtool_PyModuleClassInit_HTTPCookie(module);
  PyModule_AddObject(module, "HTTPCookie", (PyObject *)&Dtool_HTTPCookie);
  // HTTPClient
  Dtool_PyModuleClassInit_HTTPClient(module);
  PyModule_AddObject(module, "HTTPClient", (PyObject *)&Dtool_HTTPClient);
  // HTTPEntityTag
  Dtool_PyModuleClassInit_HTTPEntityTag(module);
  PyModule_AddObject(module, "HTTPEntityTag", (PyObject *)&Dtool_HTTPEntityTag);
  // DocumentSpec
  Dtool_PyModuleClassInit_DocumentSpec(module);
  PyModule_AddObject(module, "DocumentSpec", (PyObject *)&Dtool_DocumentSpec);
  // HTTPChannel
  Dtool_PyModuleClassInit_HTTPChannel(module);
  PyModule_AddObject(module, "HTTPChannel", (PyObject *)&Dtool_HTTPChannel);
  // Decompressor
  Dtool_PyModuleClassInit_Decompressor(module);
  PyModule_AddObject(module, "Decompressor", (PyObject *)&Dtool_Decompressor);
  // DownloadDb
  Dtool_PyModuleClassInit_DownloadDb(module);
  PyModule_AddObject(module, "DownloadDb", (PyObject *)&Dtool_DownloadDb);
  // Extractor
  Dtool_PyModuleClassInit_Extractor(module);
  PyModule_AddObject(module, "Extractor", (PyObject *)&Dtool_Extractor);
  // MultiplexStream
  Dtool_PyModuleClassInit_MultiplexStream(module);
  PyModule_AddObject(module, "MultiplexStream", (PyObject *)&Dtool_MultiplexStream);
  // VirtualFileHTTP
  Dtool_PyModuleClassInit_VirtualFileHTTP(module);
  PyModule_AddObject(module, "VirtualFileHTTP", (PyObject *)&Dtool_VirtualFileHTTP);
  // VirtualFileMountHTTP
  Dtool_PyModuleClassInit_VirtualFileMountHTTP(module);
  PyModule_AddObject(module, "VirtualFileMountHTTP", (PyObject *)&Dtool_VirtualFileMountHTTP);
  // Patcher
  Dtool_PyModuleClassInit_Patcher(module);
  PyModule_AddObject(module, "Patcher", (PyObject *)&Dtool_Patcher);
  // StringStream
  Dtool_PyModuleClassInit_StringStream(module);
  PyModule_AddObject(module, "StringStream", (PyObject *)&Dtool_StringStream);
}

static PyMethodDef python_simple_funcs[] = {
  {"check_crc", &Dtool_check_crc_409, METH_O, (const char *)Dtool_check_crc_409_comment},
  {"checkCrc", &Dtool_check_crc_409, METH_O, (const char *)Dtool_check_crc_409_comment},
  {"check_adler", &Dtool_check_adler_410, METH_O, (const char *)Dtool_check_adler_410_comment},
  {"checkAdler", &Dtool_check_adler_410, METH_O, (const char *)Dtool_check_adler_410_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3downloader_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478209694,  /* file_identifier */
  "libp3downloader",  /* library_name */
  "_Rn_",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3downloader.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  948  /* next_index */
};

Configure(_in_configure_libp3downloader);
ConfigureFn(_in_configure_libp3downloader) {
  interrogate_request_module(&_in_module_def);
}

