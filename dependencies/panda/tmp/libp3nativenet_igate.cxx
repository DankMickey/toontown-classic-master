/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/nativenet -Ipanda/src/nativenet -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3nativenet_igate.cxx -od built/pandac/input/libp3nativenet.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/nativenet -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/openssl/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3nativenet buffered_datagramconnection.h buffered_datagramreader.h buffered_datagramwriter.h config_nativenet.h membuffer.h p3nativenet_composite1.cxx ringbuffer.h socket_address.h socket_base.h socket_fdset.h socket_ip.h socket_portable.h socket_selector.h socket_tcp.h socket_tcp_listen.h socket_tcp_ssl.h socket_udp.h socket_udp_incoming.h socket_udp_outgoing.h time_accumulator.h time_base.h time_clock.h time_general.h time_out.h time_span.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3nativenet
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "buffered_datagramconnection.h"
#include "buffered_datagramreader.h"
#include "buffered_datagramwriter.h"
#include "config_nativenet.h"
#include "datagram.h"
#include "membuffer.h"
#include "pandabase.h"
#include "pvector.h"
#include "ringbuffer.h"
#include "socket_address.h"
#include "socket_base.h"
#include "socket_fdset.h"
#include "socket_ip.h"
#include "socket_portable.h"
#include "socket_selector.h"
#include "socket_tcp.h"
#include "socket_tcp_listen.h"
#include "socket_tcp_ssl.h"
#include "socket_udp.h"
#include "socket_udp_incoming.h"
#include "socket_udp_outgoing.h"
#include "time_accumulator.h"
#include "time_base.h"
#include "time_clock.h"
#include "time_general.h"
#include "time_out.h"
#include "time_span.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class Socket_Address
 */
typedef Socket_Address Socket_Address_localtype;
Define_Module_Class(panda3d.core, Socket_Address, Socket_Address_localtype, Socket_Address);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_Address = &Dtool_Socket_Address;
static void Dtool_PyModuleClassInit_Socket_Address(PyObject *module);
bool Dtool_ConstCoerce_Socket_Address(PyObject *args, Socket_Address const *&coerced, bool &manage);
bool Dtool_Coerce_Socket_Address(PyObject *args, Socket_Address *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Socket_IP
 */
typedef Socket_IP Socket_IP_localtype;
Define_Module_Class(panda3d.core, Socket_IP, Socket_IP_localtype, Socket_IP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_IP = &Dtool_Socket_IP;
static void Dtool_PyModuleClassInit_Socket_IP(PyObject *module);
bool Dtool_ConstCoerce_Socket_IP(PyObject *args, Socket_IP const *&coerced, bool &manage);
bool Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Socket_TCP
 */
typedef Socket_TCP Socket_TCP_localtype;
Define_Module_Class(panda3d.core, Socket_TCP, Socket_TCP_localtype, Socket_TCP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_TCP = &Dtool_Socket_TCP;
static void Dtool_PyModuleClassInit_Socket_TCP(PyObject *module);
bool Dtool_ConstCoerce_Socket_TCP(PyObject *args, Socket_TCP const *&coerced, bool &manage);
bool Dtool_Coerce_Socket_TCP(PyObject *args, Socket_TCP *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Socket_TCP_Listen
 */
typedef Socket_TCP_Listen Socket_TCP_Listen_localtype;
Define_Module_Class(panda3d.core, Socket_TCP_Listen, Socket_TCP_Listen_localtype, Socket_TCP_Listen);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_TCP_Listen = &Dtool_Socket_TCP_Listen;
static void Dtool_PyModuleClassInit_Socket_TCP_Listen(PyObject *module);

/**
 * Forward declarations for top-level class Socket_UDP_Incoming
 */
typedef Socket_UDP_Incoming Socket_UDP_Incoming_localtype;
Define_Module_Class(panda3d.core, Socket_UDP_Incoming, Socket_UDP_Incoming_localtype, Socket_UDP_Incoming);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_UDP_Incoming = &Dtool_Socket_UDP_Incoming;
static void Dtool_PyModuleClassInit_Socket_UDP_Incoming(PyObject *module);

/**
 * Forward declarations for top-level class Socket_UDP_Outgoing
 */
typedef Socket_UDP_Outgoing Socket_UDP_Outgoing_localtype;
Define_Module_Class(panda3d.core, Socket_UDP_Outgoing, Socket_UDP_Outgoing_localtype, Socket_UDP_Outgoing);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_UDP_Outgoing = &Dtool_Socket_UDP_Outgoing;
static void Dtool_PyModuleClassInit_Socket_UDP_Outgoing(PyObject *module);

/**
 * Forward declarations for top-level class Socket_fdset
 */
typedef Socket_fdset Socket_fdset_localtype;
Define_Module_Class(panda3d.core, Socket_fdset, Socket_fdset_localtype, Socket_fdset);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_fdset = &Dtool_Socket_fdset;
static void Dtool_PyModuleClassInit_Socket_fdset(PyObject *module);

/**
 * Forward declarations for top-level class Buffered_DatagramConnection
 */
typedef Buffered_DatagramConnection Buffered_DatagramConnection_localtype;
Define_Module_Class(panda3d.core, Buffered_DatagramConnection, Buffered_DatagramConnection_localtype, Buffered_DatagramConnection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Buffered_DatagramConnection = &Dtool_Buffered_DatagramConnection;
static void Dtool_PyModuleClassInit_Buffered_DatagramConnection(PyObject *module);
bool Dtool_ConstCoerce_Buffered_DatagramConnection(PyObject *args, Buffered_DatagramConnection const *&coerced, bool &manage);
bool Dtool_Coerce_Buffered_DatagramConnection(PyObject *args, Buffered_DatagramConnection *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Socket_UDP
 */
typedef Socket_UDP Socket_UDP_localtype;
Define_Module_Class(panda3d.core, Socket_UDP, Socket_UDP_localtype, Socket_UDP);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_UDP = &Dtool_Socket_UDP;
static void Dtool_PyModuleClassInit_Socket_UDP(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class Socket_Address
 */
/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_any_IP(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_any_IP_4(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_any_IP")) {
    return NULL;
  }
  // 1-inline bool Socket_Address::set_any_IP(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = (*local_this).set_any_IP((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_any_IP(const Socket_Address self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_any_IP_4_comment =
  "C++ Interface:\n"
  "set_any_IP(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to any address and a specified port\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_any_IP_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_any_IPv6(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_any_IPv6_5(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_any_IPv6")) {
    return NULL;
  }
  // 1-inline bool Socket_Address::set_any_IPv6(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = (*local_this).set_any_IPv6((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_any_IPv6(const Socket_Address self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_any_IPv6_5_comment =
  "C++ Interface:\n"
  "set_any_IPv6(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to any IPv6 address and a specified port.\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_any_IPv6_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_port(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_port_6(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_port")) {
    return NULL;
  }
  // 1-inline bool Socket_Address::set_port(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = (*local_this).set_port((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_port(const Socket_Address self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_port_6_comment =
  "C++ Interface:\n"
  "set_port(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to a specified port\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_port_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::set_broadcast(unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_broadcast_7(PyObject *self, PyObject *arg) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_broadcast")) {
    return NULL;
  }
  // 1-inline bool Socket_Address::set_broadcast(unsigned short int port)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    bool return_value = (*local_this).set_broadcast((unsigned short int)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_broadcast(const Socket_Address self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_broadcast_7_comment =
  "C++ Interface:\n"
  "set_broadcast(const Socket_Address self, int port)\n"
  "\n"
  "/**\n"
  " * Set to the broadcast address and a specified port\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_broadcast_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Socket_Address::set_host(std::string const &hostname)
 * bool Socket_Address::set_host(std::string const &hostname, unsigned short int port)
 * inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port)
 */
static PyObject *Dtool_Socket_Address_set_host_8(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.set_host")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "hostname");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'hostname' (pos 1) not found");
      }
      // 1-bool Socket_Address::set_host(std::string const &hostname)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*local_this).set_host(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      {
        // -2 bool Socket_Address::set_host(std::string const &hostname, unsigned short int port)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        long param2;
        static const char *keyword_list[] = {"hostname", "port", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#l:set_host", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param2);
          }
#endif
          bool return_value = (*local_this).set_host(std::string(param1_str, param1_len), (unsigned short int)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      {
        // -2 inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port)
        unsigned long param1;
        long param2;
        static const char *keyword_list[] = {"ip4addr", "port", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "kl:set_host", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param1 > UINT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %lu out of range for unsigned integer",
                                param1);
          }
#endif
#ifndef NDEBUG
          if (param2 < 0 || param2 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param2);
          }
#endif
          bool return_value = (*local_this).set_host((uint32_t)param1, (unsigned short int)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: bool Socket_Address::set_host(std::string const &hostname, unsigned short int port)
      // No coercion possible: inline bool Socket_Address::set_host(uint32_t ip4addr, unsigned short int port)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_host() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_host(const Socket_Address self, str hostname)\n"
      "set_host(const Socket_Address self, str hostname, int port)\n"
      "set_host(const Socket_Address self, int ip4addr, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_set_host_8_comment =
  "C++ Interface:\n"
  "set_host(const Socket_Address self, str hostname)\n"
  "set_host(const Socket_Address self, str hostname, int port)\n"
  "set_host(const Socket_Address self, int ip4addr, int port)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function will take a port and string-based TCP address and initialize\n"
  " * the address with this information.  Returns true on success; on failure, it\n"
  " * returns false and the address may be undefined.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Initializes the address from a string specifying both the address and port,\n"
  " * separated by a colon.  An IPv6 address must be enclosed in brackets.\n"
  " */";
#else
static const char *Dtool_Socket_Address_set_host_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Socket_Address::clear(void)
 */
static PyObject *Dtool_Socket_Address_clear_9(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_Address, (void **)&local_this, "Socket_Address.clear")) {
    return NULL;
  }
  // 1-inline void Socket_Address::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_clear_9_comment =
  "C++ Interface:\n"
  "clear(const Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Set the internal values to a suitable known value\n"
  " */";
#else
static const char *Dtool_Socket_Address_clear_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline sa_family_t Socket_Address::get_family(void) const
 */
static PyObject *Dtool_Socket_Address_get_family_10(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline sa_family_t Socket_Address::get_family(void) const
  sa_family_t return_value = (*(const Socket_Address*)local_this).get_family();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_family_10_comment =
  "C++ Interface:\n"
  "get_family(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Returns AF_INET if this is an IPv4 address, or AF_INET6 if this is an IPv6\n"
  " * address.\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_family_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned short int Socket_Address::get_port(void) const
 */
static PyObject *Dtool_Socket_Address_get_port_11(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline unsigned short int Socket_Address::get_port(void) const
  unsigned short int return_value = (*(const Socket_Address*)local_this).get_port();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_port_11_comment =
  "C++ Interface:\n"
  "get_port(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Get the port portion as an integer\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_port_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Socket_Address::get_ip(void) const
 */
static PyObject *Dtool_Socket_Address_get_ip_12(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Socket_Address::get_ip(void) const
  std::string return_value = (*(const Socket_Address*)local_this).get_ip();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_ip_12_comment =
  "C++ Interface:\n"
  "get_ip(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Return the IP address portion in dot notation string.\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_ip_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Socket_Address::get_ip_port(void) const
 */
static PyObject *Dtool_Socket_Address_get_ip_port_13(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Socket_Address::get_ip_port(void) const
  std::string return_value = (*(const Socket_Address*)local_this).get_ip_port();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_get_ip_port_13_comment =
  "C++ Interface:\n"
  "get_ip_port(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Return the ip address/port in dot notation string.  If this is an IPv6\n"
  " * address, it will be enclosed in square brackets.\n"
  " */";
#else
static const char *Dtool_Socket_Address_get_ip_port_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * unsigned long int Socket_Address::GetIPAddressRaw(void) const
 */
static PyObject *Dtool_Socket_Address_GetIPAddressRaw_14(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-unsigned long int Socket_Address::GetIPAddressRaw(void) const
  unsigned long int return_value = (*(const Socket_Address*)local_this).GetIPAddressRaw();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_GetIPAddressRaw_14_comment =
  "C++ Interface:\n"
  "GetIPAddressRaw(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * Returns a raw 32-bit unsigned integer representing the IPv4 address.\n"
  " * @deprecated  Does not work with IPv6 addresses.\n"
  " */";
#else
static const char *Dtool_Socket_Address_GetIPAddressRaw_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::is_any(void) const
 */
static PyObject *Dtool_Socket_Address_is_any_18(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Socket_Address::is_any(void) const
  bool return_value = (*(const Socket_Address*)local_this).is_any();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_is_any_18_comment =
  "C++ Interface:\n"
  "is_any(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * True if the address is zero.\n"
  " */";
#else
static const char *Dtool_Socket_Address_is_any_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_Address::is_mcast_range(void) const
 */
static PyObject *Dtool_Socket_Address_is_mcast_range_19(PyObject *self, PyObject *) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Socket_Address::is_mcast_range(void) const
  bool return_value = (*(const Socket_Address*)local_this).is_mcast_range();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_Address_is_mcast_range_19_comment =
  "C++ Interface:\n"
  "is_mcast_range(Socket_Address self)\n"
  "\n"
  "/**\n"
  " * True if the address is in the multicast range.\n"
  " */";
#else
static const char *Dtool_Socket_Address_is_mcast_range_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
 * inline Socket_Address::Socket_Address(unsigned short int port = 0)
 */
static int Dtool_Init_Socket_Address(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_Address::Socket_Address(unsigned short int port)
      Socket_Address *return_value = new Socket_Address();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
        PyObject *param0;
        static const char *keyword_list[] = {"inaddr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Socket_Address", (char **)keyword_list, &param0)) {
          Socket_Address const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Socket_Address, (void **)&param0_this);
          if (param0_this != NULL) {
            Socket_Address *return_value = new Socket_Address(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline Socket_Address::Socket_Address(unsigned short int port)
        long param0;
        static const char *keyword_list[] = {"port", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:Socket_Address", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          Socket_Address *return_value = new Socket_Address((unsigned short int)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline Socket_Address::Socket_Address(Socket_Address const &inaddr)
        PyObject *param0;
        static const char *keyword_list[] = {"inaddr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Socket_Address", (char **)keyword_list, &param0)) {
          Socket_Address const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_Socket_Address(param0, param0_this, param0_manage)) {
            Socket_Address *return_value = new Socket_Address(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_Address, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Socket_Address::Socket_Address(unsigned short int port)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_Address() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_Address()\n"
      "Socket_Address(const Socket_Address inaddr)\n"
      "Socket_Address(int port)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Socket_Address(PyObject *args, Socket_Address const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Socket_Address, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_Address::Socket_Address(unsigned short int port)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return false;
      }
#endif
      Socket_Address *return_value = new Socket_Address((unsigned short int)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Socket_Address(PyObject *args, Socket_Address *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Socket_Address, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_Address::Socket_Address(unsigned short int port)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return false;
      }
#endif
      Socket_Address *return_value = new Socket_Address((unsigned short int)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Socket_Address(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_Address) {
    printf("Socket_Address ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_Address *local_this = (Socket_Address *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_Address) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_Address(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_Address) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_IP
 */
/**
 * Python function wrapper for:
 * inline void Socket_IP::Close(void)
 */
static PyObject *Dtool_Socket_IP_Close_23(PyObject *self, PyObject *) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.Close")) {
    return NULL;
  }
  // 1-inline void Socket_IP::Close(void)
  (*local_this).Close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_Close_23_comment =
  "C++ Interface:\n"
  "Close(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Closes a socket if it is open (allocated).\n"
  " */";
#else
static const char *Dtool_Socket_IP_Close_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int Socket_IP::GetLastError(void)
 */
static PyObject *Dtool_Socket_IP_GetLastError_24(PyObject *, PyObject *) {
  // 1-static inline int Socket_IP::GetLastError(void)
  int return_value = Socket_IP::GetLastError();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_GetLastError_24_comment =
  "C++ Interface:\n"
  "GetLastError()\n"
  "\n"
  "/**\n"
  " * Gets the last errcode from a socket operation.\n"
  " */";
#else
static const char *Dtool_Socket_IP_GetLastError_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_IP::SetNonBlocking(void)
 */
static PyObject *Dtool_Socket_IP_SetNonBlocking_25(PyObject *self, PyObject *) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetNonBlocking")) {
    return NULL;
  }
  // 1-inline int Socket_IP::SetNonBlocking(void)
  int return_value = (*local_this).SetNonBlocking();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetNonBlocking_25_comment =
  "C++ Interface:\n"
  "SetNonBlocking(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * this function will throw a socket into non-blocking mode\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetNonBlocking_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_IP::SetBlocking(void)
 */
static PyObject *Dtool_Socket_IP_SetBlocking_26(PyObject *self, PyObject *) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetBlocking")) {
    return NULL;
  }
  // 1-inline int Socket_IP::SetBlocking(void)
  int return_value = (*local_this).SetBlocking();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetBlocking_26_comment =
  "C++ Interface:\n"
  "SetBlocking(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Set the socket to block on subsequent calls to socket functions that\n"
  " * address this socket\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetBlocking_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_IP::SetReuseAddress(bool flag = true)
 */
static PyObject *Dtool_Socket_IP_SetReuseAddress_27(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetReuseAddress")) {
    return NULL;
  }
  // 1-inline bool Socket_IP::SetReuseAddress(bool flag = true)
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"flag", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:SetReuseAddress", (char **)keyword_list, &param1)) {
    bool return_value = (*local_this).SetReuseAddress((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetReuseAddress(const Socket_IP self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetReuseAddress_27_comment =
  "C++ Interface:\n"
  "SetReuseAddress(const Socket_IP self, bool flag)\n"
  "\n"
  "/**\n"
  " * Informs a socket to reuse IP address as needed\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetReuseAddress_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_IP::SetV6Only(bool flag)
 */
static PyObject *Dtool_Socket_IP_SetV6Only_28(PyObject *self, PyObject *arg) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetV6Only")) {
    return NULL;
  }
  // 1-inline bool Socket_IP::SetV6Only(bool flag)
  bool return_value = (*local_this).SetV6Only((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetV6Only(const Socket_IP self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetV6Only_28_comment =
  "C++ Interface:\n"
  "SetV6Only(const Socket_IP self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets a flag indicating whether this IPv6 socket should operate in\n"
  " * dual-stack mode or not.\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetV6Only_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_IP::Active(void)
 */
static PyObject *Dtool_Socket_IP_Active_29(PyObject *self, PyObject *) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.Active")) {
    return NULL;
  }
  // 1-inline bool Socket_IP::Active(void)
  bool return_value = (*local_this).Active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_Active_29_comment =
  "C++ Interface:\n"
  "Active(const Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Ask if the socket is open (allocated)\n"
  " */";
#else
static const char *Dtool_Socket_IP_Active_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_IP::SetRecvBufferSize(int size)
 */
static PyObject *Dtool_Socket_IP_SetRecvBufferSize_30(PyObject *self, PyObject *arg) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetRecvBufferSize")) {
    return NULL;
  }
  // 1-inline int Socket_IP::SetRecvBufferSize(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).SetRecvBufferSize((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetRecvBufferSize(const Socket_IP self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetRecvBufferSize_30_comment =
  "C++ Interface:\n"
  "SetRecvBufferSize(const Socket_IP self, int size)\n"
  "\n"
  "/**\n"
  " * Ok it sets the recv buffer size for both tcp and UDP\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetRecvBufferSize_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Socket_IP::SetSocket(SOCKET ins)
 */
static PyObject *Dtool_Socket_IP_SetSocket_31(PyObject *self, PyObject *arg) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_IP, (void **)&local_this, "Socket_IP.SetSocket")) {
    return NULL;
  }
  // 1-inline void Socket_IP::SetSocket(SOCKET ins)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    (*local_this).SetSocket((SOCKET)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetSocket(const Socket_IP self, int ins)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_SetSocket_31_comment =
  "C++ Interface:\n"
  "SetSocket(const Socket_IP self, int ins)\n"
  "\n"
  "/**\n"
  " * Assigns an existing socket to this class\n"
  " */";
#else
static const char *Dtool_Socket_IP_SetSocket_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SOCKET Socket_IP::GetSocket(void)
 * inline SOCKET Socket_IP::GetSocket(void) const
 */
static PyObject *Dtool_Socket_IP_GetSocket_32(PyObject *self, PyObject *) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_IP, (void **)&local_this)) {
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // -2 inline SOCKET Socket_IP::GetSocket(void)
    SOCKET return_value = (*local_this).GetSocket();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }

  {
    // -2 inline SOCKET Socket_IP::GetSocket(void) const
    SOCKET return_value = (*(const Socket_IP*)local_this).GetSocket();
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }

  // No coercion possible: inline SOCKET Socket_IP::GetSocket(void)
  // No coercion possible: inline SOCKET Socket_IP::GetSocket(void) const
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_GetSocket_32_comment =
  "C++ Interface:\n"
  "GetSocket(const Socket_IP self)\n"
  "GetSocket(Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Gets the base socket type\n"
  " */\n"
  "\n"
  "/**\n"
  " * Get The RAW file id of the socket\n"
  " */";
#else
static const char *Dtool_Socket_IP_GetSocket_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_Address Socket_IP::GetPeerName(void) const
 */
static PyObject *Dtool_Socket_IP_GetPeerName_33(PyObject *self, PyObject *) {
  Socket_IP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_IP, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Socket_Address Socket_IP::GetPeerName(void) const
  Socket_Address *return_value = new Socket_Address((*(const Socket_IP*)local_this).GetPeerName());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Socket_Address, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_GetPeerName_33_comment =
  "C++ Interface:\n"
  "GetPeerName(Socket_IP self)\n"
  "\n"
  "/**\n"
  " * Wrapper on berkly getpeername...\n"
  " */";
#else
static const char *Dtool_Socket_IP_GetPeerName_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int Socket_IP::InitNetworkDriver(void)
 */
static PyObject *Dtool_Socket_IP_InitNetworkDriver_34(PyObject *, PyObject *) {
  // 1-static inline int Socket_IP::InitNetworkDriver(void)
  int return_value = Socket_IP::InitNetworkDriver();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_InitNetworkDriver_34_comment =
  "C++ Interface:\n"
  "InitNetworkDriver()\n";
#else
static const char *Dtool_Socket_IP_InitNetworkDriver_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_IP::get_class_type(void)
 */
static PyObject *Dtool_Socket_IP_get_class_type_35(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_IP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Socket_IP::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_IP_get_class_type_35_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_IP_get_class_type_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_IP::Socket_IP(void)
 * inline Socket_IP::Socket_IP(SOCKET in)
 * inline Socket_IP::Socket_IP(Socket_IP const &) = default
 */
static int Dtool_Init_Socket_IP(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_IP::Socket_IP(void)
      Socket_IP *return_value = new Socket_IP();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_IP, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Socket_IP::Socket_IP(Socket_IP const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Socket_IP", (char **)keyword_list, &param0)) {
          Socket_IP const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Socket_IP, (void **)&param0_this);
          if (param0_this != NULL) {
            Socket_IP *return_value = new Socket_IP(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_IP, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline Socket_IP::Socket_IP(SOCKET in)
        unsigned long param0;
        static const char *keyword_list[] = {"in", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k:Socket_IP", (char **)keyword_list, &param0)) {
          Socket_IP *return_value = new Socket_IP((SOCKET)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_IP, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline Socket_IP::Socket_IP(Socket_IP const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Socket_IP", (char **)keyword_list, &param0)) {
          Socket_IP const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_Socket_IP(param0, param0_this, param0_manage)) {
            Socket_IP *return_value = new Socket_IP(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_IP, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Socket_IP::Socket_IP(SOCKET in)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_IP() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_IP()\n"
      "Socket_IP(const Socket_IP param0)\n"
      "Socket_IP(int in)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Socket_IP(PyObject *args, Socket_IP const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Socket_IP, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_IP::Socket_IP(SOCKET in)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Socket_IP *return_value = new Socket_IP((SOCKET)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Socket_IP, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_IP::Socket_IP(SOCKET in)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Socket_IP *return_value = new Socket_IP((SOCKET)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Socket_IP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_IP) {
    printf("Socket_IP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_IP *local_this = (Socket_IP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_IP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_IP*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_TCP
 */
/**
 * Python function wrapper for:
 * inline int Socket_TCP::SetNoDelay(bool flag = true)
 */
static PyObject *Dtool_Socket_TCP_SetNoDelay_38(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SetNoDelay")) {
    return NULL;
  }
  // 1-inline int Socket_TCP::SetNoDelay(bool flag = true)
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"flag", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:SetNoDelay", (char **)keyword_list, &param1)) {
    int return_value = (*local_this).SetNoDelay((PyObject_IsTrue(param1) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetNoDelay(const Socket_TCP self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SetNoDelay_38_comment =
  "C++ Interface:\n"
  "SetNoDelay(const Socket_TCP self, bool flag)\n"
  "\n"
  "/**\n"
  " * Disable Nagle algorithm.  Don't delay send to coalesce packets\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SetNoDelay_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::SetLinger(int interval_seconds = 0)
 */
static PyObject *Dtool_Socket_TCP_SetLinger_39(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SetLinger")) {
    return NULL;
  }
  // 1-inline int Socket_TCP::SetLinger(int interval_seconds = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"interval_seconds", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:SetLinger", (char **)keyword_list, &param1)) {
    int return_value = (*local_this).SetLinger((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetLinger(const Socket_TCP self, int interval_seconds)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SetLinger_39_comment =
  "C++ Interface:\n"
  "SetLinger(const Socket_TCP self, int interval_seconds)\n"
  "\n"
  "/**\n"
  " * will control the behavior of SO_LINGER for a TCP socket\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SetLinger_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::DontLinger(void)
 */
static PyObject *Dtool_Socket_TCP_DontLinger_40(PyObject *self, PyObject *) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.DontLinger")) {
    return NULL;
  }
  // 1-inline int Socket_TCP::DontLinger(void)
  int return_value = (*local_this).DontLinger();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_DontLinger_40_comment =
  "C++ Interface:\n"
  "DontLinger(const Socket_TCP self)\n"
  "\n"
  "/**\n"
  " * Turn off the linger flag.  The socket will quickly release buffered items\n"
  " * and free up OS resources.  You may lose a stream if you use this flag and\n"
  " * do not negotiate the close at the application layer.\n"
  " */";
#else
static const char *Dtool_Socket_TCP_DontLinger_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::SetSendBufferSize(int insize)
 */
static PyObject *Dtool_Socket_TCP_SetSendBufferSize_41(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SetSendBufferSize")) {
    return NULL;
  }
  // 1-inline int Socket_TCP::SetSendBufferSize(int insize)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*local_this).SetSendBufferSize((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SetSendBufferSize(const Socket_TCP self, int insize)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SetSendBufferSize_41_comment =
  "C++ Interface:\n"
  "SetSendBufferSize(const Socket_TCP self, int insize)\n"
  "\n"
  "/**\n"
  " * Just like it sounds.  Sets a buffered socket recv buffer size.  This\n"
  " * function does not refuse ranges outside hard-coded OS limits\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SetSendBufferSize_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay)
 */
static PyObject *Dtool_Socket_TCP_ActiveOpen_42(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ActiveOpen")) {
    return NULL;
  }
  // 1-inline bool Socket_TCP::ActiveOpen(Socket_Address const &theaddress, bool setdelay)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"theaddress", "setdelay", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:ActiveOpen", (char **)keyword_list, &param1, &param2)) {
    Socket_Address const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_Socket_Address(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Socket_TCP.ActiveOpen", "Socket_Address");
    }
    bool return_value = (*local_this).ActiveOpen(*param1_this, (PyObject_IsTrue(param2) != 0));
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ActiveOpen(const Socket_TCP self, const Socket_Address theaddress, bool setdelay)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ActiveOpen_42_comment =
  "C++ Interface:\n"
  "ActiveOpen(const Socket_TCP self, const Socket_Address theaddress, bool setdelay)\n"
  "\n"
  "// inline bool ActiveOpen(const Socket_Address &theaddress);\n"
  "\n"
  "/**\n"
  " * This function will try and set the socket up for active open to a specified\n"
  " * address and port provided by the input parameter\n"
  " */";
#else
static const char *Dtool_Socket_TCP_ActiveOpen_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress)
 */
static PyObject *Dtool_Socket_TCP_ActiveOpenNonBlocking_43(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ActiveOpenNonBlocking")) {
    return NULL;
  }
  // 1-inline bool Socket_TCP::ActiveOpenNonBlocking(Socket_Address const &theaddress)
  Socket_Address const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_TCP.ActiveOpenNonBlocking", "Socket_Address");
  }
  bool return_value = (*local_this).ActiveOpenNonBlocking(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ActiveOpenNonBlocking(const Socket_TCP self, const Socket_Address theaddress)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ActiveOpenNonBlocking_43_comment =
  "C++ Interface:\n"
  "ActiveOpenNonBlocking(const Socket_TCP self, const Socket_Address theaddress)\n"
  "\n"
  "/**\n"
  " * This function will try and set the socket up for active open to a specified\n"
  " * address and port provided by the input parameter (non-blocking version)\n"
  " */";
#else
static const char *Dtool_Socket_TCP_ActiveOpenNonBlocking_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ErrorIs_WouldBlocking(int err)
 */
static PyObject *Dtool_Socket_TCP_ErrorIs_WouldBlocking_44(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ErrorIs_WouldBlocking")) {
    return NULL;
  }
  // 1-inline bool Socket_TCP::ErrorIs_WouldBlocking(int err)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*local_this).ErrorIs_WouldBlocking((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ErrorIs_WouldBlocking(const Socket_TCP self, int err)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment =
  "C++ Interface:\n"
  "ErrorIs_WouldBlocking(const Socket_TCP self, int err)\n";
#else
static const char *Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP::ShutdownSend(void)
 */
static PyObject *Dtool_Socket_TCP_ShutdownSend_45(PyObject *self, PyObject *) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.ShutdownSend")) {
    return NULL;
  }
  // 1-inline bool Socket_TCP::ShutdownSend(void)
  bool return_value = (*local_this).ShutdownSend();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_ShutdownSend_45_comment =
  "C++ Interface:\n"
  "ShutdownSend(const Socket_TCP self)\n";
#else
static const char *Dtool_Socket_TCP_ShutdownSend_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_TCP::SendData(std::string const &str)
 */
static PyObject *Dtool_Socket_TCP_SendData_46(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.SendData")) {
    return NULL;
  }
  // 1-inline int Socket_TCP::SendData(std::string const &str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*local_this).SendData(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendData(const Socket_TCP self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_SendData_46_comment =
  "C++ Interface:\n"
  "SendData(const Socket_TCP self, str str)\n"
  "\n"
  "/**\n"
  " * Ok Lets Send the Data - if error 0 if socket closed for write or lengh is 0\n"
  " * + bytes writen ( May be smaller than requested)\n"
  " */";
#else
static const char *Dtool_Socket_TCP_SendData_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Socket_TCP::RecvData(int max_len)
 */
static PyObject *Dtool_Socket_TCP_RecvData_47(PyObject *self, PyObject *arg) {
  Socket_TCP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP, (void **)&local_this, "Socket_TCP.RecvData")) {
    return NULL;
  }
  // 1-std::string Socket_TCP::RecvData(int max_len)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*local_this).RecvData((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "RecvData(const Socket_TCP self, int max_len)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_RecvData_47_comment =
  "C++ Interface:\n"
  "RecvData(const Socket_TCP self, int max_len)\n"
  "\n"
  "/**\n"
  " * Read the data from the connection - if error 0 if socket closed for read or\n"
  " * length is 0 + bytes read ( May be smaller than requested)\n"
  " */\n"
  "\n"
  "/**\n"
  " * Read the data from the connection - if error 0 if socket closed for read or\n"
  " * length is 0 + bytes read (May be smaller than requested)\n"
  " */";
#else
static const char *Dtool_Socket_TCP_RecvData_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_TCP::get_class_type(void)
 */
static PyObject *Dtool_Socket_TCP_get_class_type_48(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_TCP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Socket_TCP::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_get_class_type_48_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_TCP_get_class_type_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_TCP::Socket_TCP(void)
 * inline Socket_TCP::Socket_TCP(SOCKET )
 * inline Socket_TCP::Socket_TCP(Socket_TCP const &) = default
 */
static int Dtool_Init_Socket_TCP(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_TCP::Socket_TCP(void)
      Socket_TCP *return_value = new Socket_TCP();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      {
        // -2 inline Socket_TCP::Socket_TCP(Socket_TCP const &) = default
        Socket_TCP const *arg_this;
        DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Socket_TCP, (void **)&arg_this);
        if (arg_this != NULL) {
          Socket_TCP *return_value = new Socket_TCP(*arg_this);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP, true, false);
        }
      }

      {
        // -2 inline Socket_TCP::Socket_TCP(SOCKET )
        if (PyLongOrInt_Check(arg)) {
          unsigned long param0 = PyLong_AsUnsignedLong(arg);
          Socket_TCP *return_value = new Socket_TCP((SOCKET)param0);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP, true, false);
        }
      }

      {
        // -2 inline Socket_TCP::Socket_TCP(Socket_TCP const &) = default
        Socket_TCP const *arg_this;
        bool arg_manage = false;
        if (Dtool_ConstCoerce_Socket_TCP(arg, arg_this, arg_manage)) {
          Socket_TCP *return_value = new Socket_TCP(*arg_this);
          if (arg_manage) {
            delete arg_this;
          }
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP, true, false);
        }
      }

      // No coercion possible: inline Socket_TCP::Socket_TCP(SOCKET )
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_TCP() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_TCP()\n"
      "Socket_TCP(const Socket_TCP param0)\n"
      "Socket_TCP(int param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Socket_TCP(PyObject *args, Socket_TCP const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Socket_TCP, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_TCP::Socket_TCP(SOCKET )
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Socket_TCP *return_value = new Socket_TCP((SOCKET)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Socket_TCP(PyObject *args, Socket_TCP *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Socket_TCP, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Socket_TCP::Socket_TCP(SOCKET )
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
      Socket_TCP *return_value = new Socket_TCP((SOCKET)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Socket_TCP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_TCP) {
    printf("Socket_TCP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_TCP *local_this = (Socket_TCP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_TCP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_TCP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_TCP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_TCP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_TCP*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_TCP_Listen
 */
/**
 * Python function wrapper for:
 * inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024)
 * inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024)
 */
static PyObject *Dtool_Socket_TCP_Listen_OpenForListen_52(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP_Listen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP_Listen, (void **)&local_this, "Socket_TCP_Listen.OpenForListen")) {
    return NULL;
  }
  {
    // -2 inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024)
    PyObject *param1;
    int param2 = 1024;
    static const char *keyword_list[] = {"address", "backlog_size", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:OpenForListen", (char **)keyword_list, &param1, &param2)) {
      Socket_Address const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Socket_Address, (void **)&param1_this);
      if (param1_this != NULL) {
        bool return_value = (*local_this).OpenForListen(*param1_this, (int)param2);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024)
    long param1;
    int param2 = 1024;
    static const char *keyword_list[] = {"port", "backlog_size", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "l|i:OpenForListen", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned short integer",
                            param1);
      }
#endif
      bool return_value = (*local_this).OpenForListen((unsigned short int)param1, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool Socket_TCP_Listen::OpenForListen(Socket_Address const &address, int backlog_size = 1024)
    PyObject *param1;
    int param2 = 1024;
    static const char *keyword_list[] = {"address", "backlog_size", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:OpenForListen", (char **)keyword_list, &param1, &param2)) {
      Socket_Address const *param1_this;
      bool param1_manage = false;
      if (Dtool_ConstCoerce_Socket_Address(param1, param1_this, param1_manage)) {
        bool return_value = (*local_this).OpenForListen(*param1_this, (int)param2);
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline bool Socket_TCP_Listen::OpenForListen(unsigned short int port, int backlog_size = 1024)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "OpenForListen(const Socket_TCP_Listen self, const Socket_Address address, int backlog_size)\n"
      "OpenForListen(const Socket_TCP_Listen self, int port, int backlog_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_Listen_OpenForListen_52_comment =
  "C++ Interface:\n"
  "OpenForListen(const Socket_TCP_Listen self, const Socket_Address address, int backlog_size)\n"
  "OpenForListen(const Socket_TCP_Listen self, int port, int backlog_size)\n"
  "\n"
  "/**\n"
  " * This function will initialize a listening Socket\n"
  " */\n"
  "\n"
  "/**\n"
  " * This function will initialize a listening Socket\n"
  " */";
#else
static const char *Dtool_Socket_TCP_Listen_OpenForListen_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address)
 */
static PyObject *Dtool_Socket_TCP_Listen_GetIncomingConnection_53(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_TCP_Listen *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_TCP_Listen, (void **)&local_this, "Socket_TCP_Listen.GetIncomingConnection")) {
    return NULL;
  }
  // 1-inline bool Socket_TCP_Listen::GetIncomingConnection(Socket_TCP &newsession, Socket_Address &address)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"newsession", "address", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:GetIncomingConnection", (char **)keyword_list, &param1, &param2)) {
    Socket_TCP *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_Socket_TCP(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Socket_TCP_Listen.GetIncomingConnection", "Socket_TCP");
    }
    Socket_Address *param2_this;
    bool param2_manage = false;
    if (!Dtool_Coerce_Socket_Address(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Socket_TCP_Listen.GetIncomingConnection", "Socket_Address");
    }
    bool return_value = (*local_this).GetIncomingConnection(*param1_this, *param2_this);
    if (param1_manage) {
      delete param1_this;
    }
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetIncomingConnection(const Socket_TCP_Listen self, Socket_TCP newsession, Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_Listen_GetIncomingConnection_53_comment =
  "C++ Interface:\n"
  "GetIncomingConnection(const Socket_TCP_Listen self, Socket_TCP newsession, Socket_Address address)\n"
  "\n"
  "/**\n"
  " * This function is used to accept new connections\n"
  " */";
#else
static const char *Dtool_Socket_TCP_Listen_GetIncomingConnection_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_TCP_Listen::get_class_type(void)
 */
static PyObject *Dtool_Socket_TCP_Listen_get_class_type_54(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_TCP_Listen::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Socket_TCP_Listen::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_TCP_Listen_get_class_type_54_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_TCP_Listen_get_class_type_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Socket_TCP_Listen::Socket_TCP_Listen(void)
 * inline Socket_TCP_Listen::Socket_TCP_Listen(Socket_TCP_Listen const &) = default
 */
static int Dtool_Init_Socket_TCP_Listen(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Socket_TCP_Listen::Socket_TCP_Listen(void)
      Socket_TCP_Listen *return_value = new Socket_TCP_Listen();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP_Listen, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Socket_TCP_Listen::Socket_TCP_Listen(Socket_TCP_Listen const &) = default
      Socket_TCP_Listen const *arg_this = (Socket_TCP_Listen *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_TCP_Listen, 0, "Socket_TCP_Listen.Socket_TCP_Listen", true, true);
      if (arg_this != NULL) {
        Socket_TCP_Listen *return_value = new Socket_TCP_Listen(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_TCP_Listen, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_TCP_Listen() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_TCP_Listen()\n"
      "Socket_TCP_Listen(const Socket_TCP_Listen param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_TCP_Listen(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_TCP_Listen) {
    printf("Socket_TCP_Listen ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_TCP_Listen *local_this = (Socket_TCP_Listen *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_TCP_Listen) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_TCP_Listen(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_TCP_Listen) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_TCP_Listen*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_TCP_Listen*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_UDP_Incoming
 */
/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
 * inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port)
 */
static PyObject *Dtool_Socket_UDP_Incoming_OpenForInput_57(PyObject *self, PyObject *arg) {
  Socket_UDP_Incoming *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.OpenForInput")) {
    return NULL;
  }
  {
    // -2 inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
    Socket_Address const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Socket_Address, (void **)&arg_this);
    if (arg_this != NULL) {
      bool return_value = (*local_this).OpenForInput(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port)
    if (PyLongOrInt_Check(arg)) {
      long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param1 < 0 || param1 > USHRT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for unsigned short integer",
                            param1);
      }
#endif
      bool return_value = (*local_this).OpenForInput((unsigned short int)param1);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool Socket_UDP_Incoming::OpenForInput(Socket_Address const &address)
    Socket_Address const *arg_this;
    bool arg_manage = false;
    if (Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
      bool return_value = (*local_this).OpenForInput(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool Socket_UDP_Incoming::OpenForInput(unsigned short int port)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "OpenForInput(const Socket_UDP_Incoming self, const Socket_Address address)\n"
      "OpenForInput(const Socket_UDP_Incoming self, int port)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_OpenForInput_57_comment =
  "C++ Interface:\n"
  "OpenForInput(const Socket_UDP_Incoming self, const Socket_Address address)\n"
  "OpenForInput(const Socket_UDP_Incoming self, int port)\n"
  "\n"
  "/**\n"
  " * Starts a UDP socket listening on a port\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts a UDP socket listening on a port\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_OpenForInput_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Incoming_OpenForInputMCast_58(PyObject *self, PyObject *arg) {
  Socket_UDP_Incoming *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.OpenForInputMCast")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Incoming::OpenForInputMCast(Socket_Address const &address)
  Socket_Address const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_UDP_Incoming.OpenForInputMCast", "Socket_Address");
  }
  bool return_value = (*local_this).OpenForInputMCast(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "OpenForInputMCast(const Socket_UDP_Incoming self, const Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_OpenForInputMCast_58_comment =
  "C++ Interface:\n"
  "OpenForInputMCast(const Socket_UDP_Incoming self, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Starts a UDP socket listening on a port\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_OpenForInputMCast_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Incoming_SendTo_60(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_UDP_Incoming *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.SendTo")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Incoming::SendTo(char const *data, int len, Socket_Address const &address)
  char const *param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"data", "len", "address", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ziO:SendTo", (char **)keyword_list, &param1, &param2, &param3)) {
    Socket_Address const *param3_this;
    bool param3_manage = false;
    if (!Dtool_ConstCoerce_Socket_Address(param3, param3_this, param3_manage)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Socket_UDP_Incoming.SendTo", "Socket_Address");
    }
    bool return_value = (*local_this).SendTo((char const *)param1, (int)param2, *param3_this);
    if (param3_manage) {
      delete param3_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendTo(const Socket_UDP_Incoming self, str data, int len, const Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_SendTo_60_comment =
  "C++ Interface:\n"
  "SendTo(const Socket_UDP_Incoming self, str data, int len, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_SendTo_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::InitNoAddress(void)
 */
static PyObject *Dtool_Socket_UDP_Incoming_InitNoAddress_61(PyObject *self, PyObject *) {
  Socket_UDP_Incoming *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.InitNoAddress")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Incoming::InitNoAddress(void)
  bool return_value = (*local_this).InitNoAddress();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_InitNoAddress_61_comment =
  "C++ Interface:\n"
  "InitNoAddress(const Socket_UDP_Incoming self)\n"
  "\n"
  "/**\n"
  " * Set this socket to work without a bound external address.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_InitNoAddress_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Incoming::SetToBroadCast(void)
 */
static PyObject *Dtool_Socket_UDP_Incoming_SetToBroadCast_62(PyObject *self, PyObject *) {
  Socket_UDP_Incoming *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Incoming, (void **)&local_this, "Socket_UDP_Incoming.SetToBroadCast")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Incoming::SetToBroadCast(void)
  bool return_value = (*local_this).SetToBroadCast();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_SetToBroadCast_62_comment =
  "C++ Interface:\n"
  "SetToBroadCast(const Socket_UDP_Incoming self)\n"
  "\n"
  "/**\n"
  " * Flips the OS bits that allow for brodcast packets to come in on this port.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Incoming_SetToBroadCast_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_UDP_Incoming::get_class_type(void)
 */
static PyObject *Dtool_Socket_UDP_Incoming_get_class_type_63(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_UDP_Incoming::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Socket_UDP_Incoming::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Incoming_get_class_type_63_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_UDP_Incoming_get_class_type_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_UDP_Incoming::Socket_UDP_Incoming(void)
 * inline Socket_UDP_Incoming::Socket_UDP_Incoming(Socket_UDP_Incoming const &) = default
 */
static int Dtool_Init_Socket_UDP_Incoming(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_UDP_Incoming::Socket_UDP_Incoming(void)
      Socket_UDP_Incoming *return_value = new Socket_UDP_Incoming();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP_Incoming, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Socket_UDP_Incoming::Socket_UDP_Incoming(Socket_UDP_Incoming const &) = default
      Socket_UDP_Incoming const *arg_this = (Socket_UDP_Incoming *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_UDP_Incoming, 0, "Socket_UDP_Incoming.Socket_UDP_Incoming", true, true);
      if (arg_this != NULL) {
        Socket_UDP_Incoming *return_value = new Socket_UDP_Incoming(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP_Incoming, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_UDP_Incoming() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_UDP_Incoming()\n"
      "Socket_UDP_Incoming(const Socket_UDP_Incoming param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_UDP_Incoming(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_UDP_Incoming) {
    printf("Socket_UDP_Incoming ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_UDP_Incoming *local_this = (Socket_UDP_Incoming *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_UDP_Incoming) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_UDP_Incoming(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_UDP_Incoming) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_UDP_Incoming*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_UDP_Incoming*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_UDP_Outgoing
 */
/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_InitToAddress_67(PyObject *self, PyObject *arg) {
  Socket_UDP_Outgoing *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.InitToAddress")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Outgoing::InitToAddress(Socket_Address const &address)
  Socket_Address const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_UDP_Outgoing.InitToAddress", "Socket_Address");
  }
  bool return_value = (*local_this).InitToAddress(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InitToAddress(const Socket_UDP_Outgoing self, const Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_InitToAddress_67_comment =
  "C++ Interface:\n"
  "InitToAddress(const Socket_UDP_Outgoing self, const Socket_Address address)\n"
  "\n"
  "// use this interface for a tagreted UDP connection\n"
  "\n"
  "/**\n"
  " * Connects the Socket to a specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_InitToAddress_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::Send(std::string const &data)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_Send_68(PyObject *self, PyObject *arg) {
  Socket_UDP_Outgoing *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.Send")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Outgoing::Send(std::string const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).Send(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Send(const Socket_UDP_Outgoing self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_Send_68_comment =
  "C++ Interface:\n"
  "Send(const Socket_UDP_Outgoing self, str data)\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_Send_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::InitNoAddress(void)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_InitNoAddress_69(PyObject *self, PyObject *) {
  Socket_UDP_Outgoing *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.InitNoAddress")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Outgoing::InitNoAddress(void)
  bool return_value = (*local_this).InitNoAddress();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_InitNoAddress_69_comment =
  "C++ Interface:\n"
  "InitNoAddress(const Socket_UDP_Outgoing self)\n"
  "\n"
  "// use this interface for a none tagreted UDP connection\n"
  "\n"
  "/**\n"
  " * This will set a udp up for targeted sends.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_InitNoAddress_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::SendTo(std::string const &data, Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_SendTo_70(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_UDP_Outgoing *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.SendTo")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Outgoing::SendTo(std::string const &data, Socket_Address const &address)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "address", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:SendTo", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Socket_Address const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_Socket_Address(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Socket_UDP_Outgoing.SendTo", "Socket_Address");
    }
    bool return_value = (*local_this).SendTo(std::string(param1_str, param1_len), *param2_this);
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendTo(const Socket_UDP_Outgoing self, str data, const Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_SendTo_70_comment =
  "C++ Interface:\n"
  "SendTo(const Socket_UDP_Outgoing self, str data, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_SendTo_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP_Outgoing::SetToBroadCast(void)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_SetToBroadCast_71(PyObject *self, PyObject *) {
  Socket_UDP_Outgoing *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP_Outgoing, (void **)&local_this, "Socket_UDP_Outgoing.SetToBroadCast")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP_Outgoing::SetToBroadCast(void)
  bool return_value = (*local_this).SetToBroadCast();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_SetToBroadCast_71_comment =
  "C++ Interface:\n"
  "SetToBroadCast(const Socket_UDP_Outgoing self)\n"
  "\n"
  "/**\n"
  " * Ask the OS to let us receive broadcast packets on this port.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Outgoing_SetToBroadCast_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_UDP_Outgoing::get_class_type(void)
 */
static PyObject *Dtool_Socket_UDP_Outgoing_get_class_type_72(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_UDP_Outgoing::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Socket_UDP_Outgoing::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Outgoing_get_class_type_72_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_UDP_Outgoing_get_class_type_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void)
 * inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(Socket_UDP_Outgoing const &) = default
 */
static int Dtool_Init_Socket_UDP_Outgoing(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(void)
      Socket_UDP_Outgoing *return_value = new Socket_UDP_Outgoing();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP_Outgoing, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Socket_UDP_Outgoing::Socket_UDP_Outgoing(Socket_UDP_Outgoing const &) = default
      Socket_UDP_Outgoing const *arg_this = (Socket_UDP_Outgoing *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_UDP_Outgoing, 0, "Socket_UDP_Outgoing.Socket_UDP_Outgoing", true, true);
      if (arg_this != NULL) {
        Socket_UDP_Outgoing *return_value = new Socket_UDP_Outgoing(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP_Outgoing, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_UDP_Outgoing() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_UDP_Outgoing()\n"
      "Socket_UDP_Outgoing(const Socket_UDP_Outgoing param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_UDP_Outgoing(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_UDP_Outgoing) {
    printf("Socket_UDP_Outgoing ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_UDP_Outgoing *local_this = (Socket_UDP_Outgoing *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_UDP_Outgoing) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_UDP_Outgoing(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_UDP_Outgoing) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_UDP_Outgoing*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_UDP_Outgoing*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_fdset
 */
/**
 * Python function wrapper for:
 * inline void Socket_fdset::setForSocket(Socket_IP const &incon)
 */
static PyObject *Dtool_Socket_fdset_setForSocket_76(PyObject *self, PyObject *arg) {
  Socket_fdset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.setForSocket")) {
    return NULL;
  }
  // 1-inline void Socket_fdset::setForSocket(Socket_IP const &incon)
  Socket_IP const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Socket_IP(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_fdset.setForSocket", "Socket_IP");
  }
  (*local_this).setForSocket(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setForSocket(const Socket_fdset self, const Socket_IP incon)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_setForSocket_76_comment =
  "C++ Interface:\n"
  "setForSocket(const Socket_fdset self, const Socket_IP incon)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Socket_fdset_setForSocket_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const
 */
static PyObject *Dtool_Socket_fdset_IsSetFor_77(PyObject *self, PyObject *arg) {
  Socket_fdset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_fdset, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Socket_fdset::IsSetFor(Socket_IP const &incon) const
  Socket_IP const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Socket_IP(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_fdset.IsSetFor", "Socket_IP");
  }
  bool return_value = (*(const Socket_fdset*)local_this).IsSetFor(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "IsSetFor(Socket_fdset self, const Socket_IP incon)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_IsSetFor_77_comment =
  "C++ Interface:\n"
  "IsSetFor(Socket_fdset self, const Socket_IP incon)\n"
  "\n"
  "/**\n"
  " * check to see if a socket object has been marked for reading\n"
  " */";
#else
static const char *Dtool_Socket_fdset_IsSetFor_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [inline int Socket_fdset::WaitForRead(bool zeroFds, Time_Span const &timeout)]
 * inline int Socket_fdset::WaitForRead(bool zeroFds, uint32_t sleep_time = 2147483647)
 */
static PyObject *Dtool_Socket_fdset_WaitForRead_78(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_fdset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.WaitForRead")) {
    return NULL;
  }
  // 1-inline int Socket_fdset::WaitForRead(bool zeroFds, uint32_t sleep_time = 2147483647)
  PyObject *param1;
  unsigned long param2 = 2147483647;
  static const char *keyword_list[] = {"zeroFds", "sleep_time", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:WaitForRead", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    int return_value = (*local_this).WaitForRead((PyObject_IsTrue(param1) != 0), (uint32_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForRead(const Socket_fdset self, bool zeroFds, int sleep_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_WaitForRead_78_comment =
  "C++ Interface:\n"
  "WaitForRead(const Socket_fdset self, bool zeroFds, int sleep_time)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Socket_fdset_WaitForRead_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_fdset::WaitForWrite(bool zeroFds, uint32_t sleep_time = 2147483647)
 */
static PyObject *Dtool_Socket_fdset_WaitForWrite_79(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_fdset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.WaitForWrite")) {
    return NULL;
  }
  // 1-inline int Socket_fdset::WaitForWrite(bool zeroFds, uint32_t sleep_time = 2147483647)
  PyObject *param1;
  unsigned long param2 = 2147483647;
  static const char *keyword_list[] = {"zeroFds", "sleep_time", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:WaitForWrite", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    int return_value = (*local_this).WaitForWrite((PyObject_IsTrue(param1) != 0), (uint32_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForWrite(const Socket_fdset self, bool zeroFds, int sleep_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_WaitForWrite_79_comment =
  "C++ Interface:\n"
  "WaitForWrite(const Socket_fdset self, bool zeroFds, int sleep_time)\n"
  "\n"
  "/**\n"
  " * This is the function that will wait till one of the sockets is ready for\n"
  " * writing\n"
  " */";
#else
static const char *Dtool_Socket_fdset_WaitForWrite_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Socket_fdset::WaitForError(bool zeroFds, uint32_t sleep_time = 2147483647)
 */
static PyObject *Dtool_Socket_fdset_WaitForError_80(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_fdset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.WaitForError")) {
    return NULL;
  }
  // 1-inline int Socket_fdset::WaitForError(bool zeroFds, uint32_t sleep_time = 2147483647)
  PyObject *param1;
  unsigned long param2 = 2147483647;
  static const char *keyword_list[] = {"zeroFds", "sleep_time", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:WaitForError", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    int return_value = (*local_this).WaitForError((PyObject_IsTrue(param1) != 0), (uint32_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForError(const Socket_fdset self, bool zeroFds, int sleep_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_WaitForError_80_comment =
  "C++ Interface:\n"
  "WaitForError(const Socket_fdset self, bool zeroFds, int sleep_time)\n"
  "\n"
  "/**\n"
  " * This is the function that will wait till one of the sockets is in error\n"
  " * state\n"
  " */";
#else
static const char *Dtool_Socket_fdset_WaitForError_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Socket_fdset::clear(void)
 */
static PyObject *Dtool_Socket_fdset_clear_81(PyObject *self, PyObject *) {
  Socket_fdset *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_fdset, (void **)&local_this, "Socket_fdset.clear")) {
    return NULL;
  }
  // 1-inline void Socket_fdset::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Socket_fdset_clear_81_comment =
  "C++ Interface:\n"
  "clear(const Socket_fdset self)\n"
  "\n"
  "/**\n"
  " * Marks the content as empty\n"
  " */";
#else
static const char *Dtool_Socket_fdset_clear_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_fdset::Socket_fdset(void)
 * inline Socket_fdset::Socket_fdset(Socket_fdset const &) = default
 */
static int Dtool_Init_Socket_fdset(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_fdset::Socket_fdset(void)
      Socket_fdset *return_value = new Socket_fdset();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_fdset, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Socket_fdset::Socket_fdset(Socket_fdset const &) = default
      Socket_fdset const *arg_this = (Socket_fdset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_fdset, 0, "Socket_fdset.Socket_fdset", true, true);
      if (arg_this != NULL) {
        Socket_fdset *return_value = new Socket_fdset(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_fdset, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_fdset() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_fdset()\n"
      "Socket_fdset(const Socket_fdset param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_fdset(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_fdset) {
    printf("Socket_fdset ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_fdset *local_this = (Socket_fdset *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_fdset) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_fdset(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_fdset) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Buffered_DatagramConnection
 */
/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::GetMessage(Datagram &val)
 */
static PyObject *Dtool_Buffered_DatagramConnection_GetMessage_84(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.GetMessage")) {
    return NULL;
  }
  // 1-inline bool Buffered_DatagramConnection::GetMessage(Datagram &val)
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Buffered_DatagramConnection.GetMessage", "Datagram");
  }
  bool return_value = (*local_this).GetMessage(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetMessage(const Buffered_DatagramConnection self, Datagram val)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_GetMessage_84_comment =
  "C++ Interface:\n"
  "GetMessage(const Buffered_DatagramConnection self, Datagram val)\n"
  "\n"
  "/**\n"
  " * Reads a message.  Returns false on failure.\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_GetMessage_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::DoConnect(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_DoConnect_85(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.DoConnect")) {
    return NULL;
  }
  // 1-inline bool Buffered_DatagramConnection::DoConnect(void)
  bool return_value = (*local_this).DoConnect();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_DoConnect_85_comment =
  "C++ Interface:\n"
  "DoConnect(const Buffered_DatagramConnection self)\n"
  "\n"
  "// all the real state magic is in here";
#else
static const char *Dtool_Buffered_DatagramConnection_DoConnect_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::IsConnected(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_IsConnected_86(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.IsConnected")) {
    return NULL;
  }
  // 1-inline bool Buffered_DatagramConnection::IsConnected(void)
  bool return_value = (*local_this).IsConnected();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_IsConnected_86_comment =
  "C++ Interface:\n"
  "IsConnected(const Buffered_DatagramConnection self)\n"
  "\n"
  "// all the real state magic is in here";
#else
static const char *Dtool_Buffered_DatagramConnection_IsConnected_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Buffered_DatagramConnection::SendMessage(Datagram const &msg)
 */
static PyObject *Dtool_Buffered_DatagramConnection_SendMessage_88(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.SendMessage")) {
    return NULL;
  }
  // 1-bool Buffered_DatagramConnection::SendMessage(Datagram const &msg)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Buffered_DatagramConnection.SendMessage", "Datagram");
  }
  bool return_value = (*local_this).SendMessage(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendMessage(const Buffered_DatagramConnection self, const Datagram msg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_SendMessage_88_comment =
  "C++ Interface:\n"
  "SendMessage(const Buffered_DatagramConnection self, const Datagram msg)\n"
  "\n"
  "// the reason thsi all exists\n"
  "\n"
  "/**\n"
  " * send the message\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_SendMessage_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Buffered_DatagramConnection::Flush(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_Flush_89(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.Flush")) {
    return NULL;
  }
  // 1-inline bool Buffered_DatagramConnection::Flush(void)
  bool return_value = (*local_this).Flush();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_Flush_89_comment =
  "C++ Interface:\n"
  "Flush(const Buffered_DatagramConnection self)\n"
  "\n"
  "/**\n"
  " * Flush all writes.\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_Flush_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::Reset(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_Reset_90(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.Reset")) {
    return NULL;
  }
  // 1-inline void Buffered_DatagramConnection::Reset(void)
  (*local_this).Reset();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_Reset_90_comment =
  "C++ Interface:\n"
  "Reset(const Buffered_DatagramConnection self)\n"
  "\n"
  "/**\n"
  " * Reset\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_Reset_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(PN_stdfloat MaxTime)
 */
static PyObject *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.WaitForNetworkReadEvent")) {
    return NULL;
  }
  // 1-inline void Buffered_DatagramConnection::WaitForNetworkReadEvent(PN_stdfloat MaxTime)
  if (PyNumber_Check(arg)) {
    (*local_this).WaitForNetworkReadEvent((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "WaitForNetworkReadEvent(const Buffered_DatagramConnection self, float MaxTime)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91_comment =
  "C++ Interface:\n"
  "WaitForNetworkReadEvent(const Buffered_DatagramConnection self, float MaxTime)\n";
#else
static const char *Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Buffered_DatagramConnection::AddressQueueSize(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_AddressQueueSize_92(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.AddressQueueSize")) {
    return NULL;
  }
  // 1-inline std::size_t Buffered_DatagramConnection::AddressQueueSize(void)
  std::size_t return_value = (*local_this).AddressQueueSize();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_AddressQueueSize_92_comment =
  "C++ Interface:\n"
  "AddressQueueSize(const Buffered_DatagramConnection self)\n"
  "\n"
  "// address queue stuff";
#else
static const char *Dtool_Buffered_DatagramConnection_AddressQueueSize_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr)
 */
static PyObject *Dtool_Buffered_DatagramConnection_AddAddress_93(PyObject *self, PyObject *arg) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.AddAddress")) {
    return NULL;
  }
  // 1-inline void Buffered_DatagramConnection::AddAddress(Socket_Address &inadr)
  Socket_Address *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Socket_Address(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Buffered_DatagramConnection.AddAddress", "Socket_Address");
  }
  (*local_this).AddAddress(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "AddAddress(const Buffered_DatagramConnection self, Socket_Address inadr)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_AddAddress_93_comment =
  "C++ Interface:\n"
  "AddAddress(const Buffered_DatagramConnection self, Socket_Address inadr)\n"
  "\n"
  "/**\n"
  " * must be called to set value to the server\n"
  " */";
#else
static const char *Dtool_Buffered_DatagramConnection_AddAddress_93_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Buffered_DatagramConnection::ClearAddresses(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_ClearAddresses_94(PyObject *self, PyObject *) {
  Buffered_DatagramConnection *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Buffered_DatagramConnection, (void **)&local_this, "Buffered_DatagramConnection.ClearAddresses")) {
    return NULL;
  }
  // 1-inline void Buffered_DatagramConnection::ClearAddresses(void)
  (*local_this).ClearAddresses();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_ClearAddresses_94_comment =
  "C++ Interface:\n"
  "ClearAddresses(const Buffered_DatagramConnection self)\n";
#else
static const char *Dtool_Buffered_DatagramConnection_ClearAddresses_94_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Buffered_DatagramConnection::get_class_type(void)
 */
static PyObject *Dtool_Buffered_DatagramConnection_get_class_type_95(PyObject *, PyObject *) {
  // 1-static TypeHandle Buffered_DatagramConnection::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Buffered_DatagramConnection::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Buffered_DatagramConnection_get_class_type_95_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Buffered_DatagramConnection_get_class_type_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Buffered_DatagramConnection::Buffered_DatagramConnection(Buffered_DatagramConnection const &) = default
 * inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
 */
static int Dtool_Init_Buffered_DatagramConnection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Buffered_DatagramConnection::Buffered_DatagramConnection(Buffered_DatagramConnection const &) = default
      Buffered_DatagramConnection const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_Buffered_DatagramConnection(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "Buffered_DatagramConnection.Buffered_DatagramConnection", "Buffered_DatagramConnection");
        return -1;
      }
      Buffered_DatagramConnection *return_value = new Buffered_DatagramConnection(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Buffered_DatagramConnection, true, false);
    }
    break;
  case 3:
    {
      // 1-inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
      int param0;
      int param1;
      int param2;
      static const char *keyword_list[] = {"rbufsize", "wbufsize", "write_flush_point", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:Buffered_DatagramConnection", (char **)keyword_list, &param0, &param1, &param2)) {
        Buffered_DatagramConnection *return_value = new Buffered_DatagramConnection((int)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Buffered_DatagramConnection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Buffered_DatagramConnection() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Buffered_DatagramConnection(const Buffered_DatagramConnection param0)\n"
      "Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Buffered_DatagramConnection(PyObject *args, Buffered_DatagramConnection const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Buffered_DatagramConnection, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
      int param0;
      int param1;
      int param2;
      if (PyArg_ParseTuple(args, "iii:Buffered_DatagramConnection", &param0, &param1, &param2)) {
        Buffered_DatagramConnection *return_value = new Buffered_DatagramConnection((int)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Buffered_DatagramConnection(PyObject *args, Buffered_DatagramConnection *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Buffered_DatagramConnection, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline Buffered_DatagramConnection::Buffered_DatagramConnection(int rbufsize, int wbufsize, int write_flush_point)
      int param0;
      int param1;
      int param2;
      if (PyArg_ParseTuple(args, "iii:Buffered_DatagramConnection", &param0, &param1, &param2)) {
        Buffered_DatagramConnection *return_value = new Buffered_DatagramConnection((int)param0, (int)param1, (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_Buffered_DatagramConnection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Buffered_DatagramConnection) {
    printf("Buffered_DatagramConnection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Buffered_DatagramConnection *local_this = (Buffered_DatagramConnection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Buffered_DatagramConnection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *)(Socket_TCP *) local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_TCP) {
    return (Socket_TCP *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *)(Socket_TCP *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Buffered_DatagramConnection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Buffered_DatagramConnection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Buffered_DatagramConnection*)other_this;
  }
  if (from_type == Dtool_Ptr_Socket_TCP) {
    Socket_TCP* other_this = (Socket_TCP*)from_this;
    return (Buffered_DatagramConnection*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Buffered_DatagramConnection*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Socket_UDP
 */
/**
 * Python function wrapper for:
 * inline bool Socket_UDP::InitToAddress(Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_InitToAddress_98(PyObject *self, PyObject *arg) {
  Socket_UDP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.InitToAddress")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP::InitToAddress(Socket_Address const &address)
  Socket_Address const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Socket_UDP.InitToAddress", "Socket_Address");
  }
  bool return_value = (*local_this).InitToAddress(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "InitToAddress(const Socket_UDP self, const Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_InitToAddress_98_comment =
  "C++ Interface:\n"
  "InitToAddress(const Socket_UDP self, const Socket_Address address)\n"
  "\n"
  "// use this interface for a tagreted UDP connection\n"
  "\n"
  "/**\n"
  " * Connects the socket to a Specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_InitToAddress_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP::Send(std::string const &data)
 */
static PyObject *Dtool_Socket_UDP_Send_99(PyObject *self, PyObject *arg) {
  Socket_UDP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.Send")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP::Send(std::string const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).Send(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "Send(const Socket_UDP self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_Send_99_comment =
  "C++ Interface:\n"
  "Send(const Socket_UDP self, str data)\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to connected address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_Send_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP::SendTo(std::string const &data, Socket_Address const &address)
 */
static PyObject *Dtool_Socket_UDP_SendTo_100(PyObject *self, PyObject *args, PyObject *kwds) {
  Socket_UDP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.SendTo")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP::SendTo(std::string const &data, Socket_Address const &address)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "address", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:SendTo", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Socket_Address const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_Socket_Address(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Socket_UDP.SendTo", "Socket_Address");
    }
    bool return_value = (*local_this).SendTo(std::string(param1_str, param1_len), *param2_this);
    if (param2_manage) {
      delete param2_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "SendTo(const Socket_UDP self, str data, const Socket_Address address)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_SendTo_100_comment =
  "C++ Interface:\n"
  "SendTo(const Socket_UDP self, str data, const Socket_Address address)\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */\n"
  "\n"
  "/**\n"
  " * Send data to specified address\n"
  " */";
#else
static const char *Dtool_Socket_UDP_SendTo_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Socket_UDP::SetToBroadCast(void)
 */
static PyObject *Dtool_Socket_UDP_SetToBroadCast_101(PyObject *self, PyObject *) {
  Socket_UDP *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Socket_UDP, (void **)&local_this, "Socket_UDP.SetToBroadCast")) {
    return NULL;
  }
  // 1-inline bool Socket_UDP::SetToBroadCast(void)
  bool return_value = (*local_this).SetToBroadCast();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_SetToBroadCast_101_comment =
  "C++ Interface:\n"
  "SetToBroadCast(const Socket_UDP self)\n"
  "\n"
  "/**\n"
  " * Ask the OS to let us receive broadcast packets on this port.\n"
  " */";
#else
static const char *Dtool_Socket_UDP_SetToBroadCast_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Socket_UDP::get_class_type(void)
 */
static PyObject *Dtool_Socket_UDP_get_class_type_102(PyObject *, PyObject *) {
  // 1-static TypeHandle Socket_UDP::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Socket_UDP::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Socket_UDP_get_class_type_102_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Socket_UDP_get_class_type_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Socket_UDP::Socket_UDP(void)
 * inline Socket_UDP::Socket_UDP(Socket_UDP const &) = default
 */
static int Dtool_Init_Socket_UDP(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Socket_UDP::Socket_UDP(void)
      Socket_UDP *return_value = new Socket_UDP();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Socket_UDP::Socket_UDP(Socket_UDP const &) = default
      Socket_UDP const *arg_this = (Socket_UDP *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Socket_UDP, 0, "Socket_UDP.Socket_UDP", true, true);
      if (arg_this != NULL) {
        Socket_UDP *return_value = new Socket_UDP(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Socket_UDP, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Socket_UDP() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Socket_UDP()\n"
      "Socket_UDP(const Socket_UDP param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Socket_UDP(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Socket_UDP) {
    printf("Socket_UDP ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Socket_UDP *local_this = (Socket_UDP *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Socket_UDP) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_IP) {
    return (Socket_IP *)(Socket_UDP_Incoming *) local_this;
  }
  if (requested_type == Dtool_Ptr_Socket_UDP_Incoming) {
    return (Socket_UDP_Incoming *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Socket_IP *)(Socket_UDP_Incoming *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Socket_UDP(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Socket_UDP) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Socket_IP) {
    Socket_IP* other_this = (Socket_IP*)from_this;
    return (Socket_UDP*)other_this;
  }
  if (from_type == Dtool_Ptr_Socket_UDP_Incoming) {
    Socket_UDP_Incoming* other_this = (Socket_UDP_Incoming*)from_this;
    return (Socket_UDP*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Socket_UDP*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for Socket_Address (Socket_Address)
 */
static PyMethodDef Dtool_Methods_Socket_Address[] = {
  {"set_any_IP", &Dtool_Socket_Address_set_any_IP_4, METH_O, (const char *)Dtool_Socket_Address_set_any_IP_4_comment},
  {"setAnyIP", &Dtool_Socket_Address_set_any_IP_4, METH_O, (const char *)Dtool_Socket_Address_set_any_IP_4_comment},
  {"set_any_IPv6", &Dtool_Socket_Address_set_any_IPv6_5, METH_O, (const char *)Dtool_Socket_Address_set_any_IPv6_5_comment},
  {"setAnyIPv6", &Dtool_Socket_Address_set_any_IPv6_5, METH_O, (const char *)Dtool_Socket_Address_set_any_IPv6_5_comment},
  {"set_port", &Dtool_Socket_Address_set_port_6, METH_O, (const char *)Dtool_Socket_Address_set_port_6_comment},
  {"setPort", &Dtool_Socket_Address_set_port_6, METH_O, (const char *)Dtool_Socket_Address_set_port_6_comment},
  {"set_broadcast", &Dtool_Socket_Address_set_broadcast_7, METH_O, (const char *)Dtool_Socket_Address_set_broadcast_7_comment},
  {"setBroadcast", &Dtool_Socket_Address_set_broadcast_7, METH_O, (const char *)Dtool_Socket_Address_set_broadcast_7_comment},
  {"set_host", (PyCFunction) &Dtool_Socket_Address_set_host_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_Address_set_host_8_comment},
  {"setHost", (PyCFunction) &Dtool_Socket_Address_set_host_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_Address_set_host_8_comment},
  {"clear", &Dtool_Socket_Address_clear_9, METH_NOARGS, (const char *)Dtool_Socket_Address_clear_9_comment},
  {"get_family", &Dtool_Socket_Address_get_family_10, METH_NOARGS, (const char *)Dtool_Socket_Address_get_family_10_comment},
  {"getFamily", &Dtool_Socket_Address_get_family_10, METH_NOARGS, (const char *)Dtool_Socket_Address_get_family_10_comment},
  {"get_port", &Dtool_Socket_Address_get_port_11, METH_NOARGS, (const char *)Dtool_Socket_Address_get_port_11_comment},
  {"getPort", &Dtool_Socket_Address_get_port_11, METH_NOARGS, (const char *)Dtool_Socket_Address_get_port_11_comment},
  {"get_ip", &Dtool_Socket_Address_get_ip_12, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_12_comment},
  {"getIp", &Dtool_Socket_Address_get_ip_12, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_12_comment},
  {"get_ip_port", &Dtool_Socket_Address_get_ip_port_13, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_port_13_comment},
  {"getIpPort", &Dtool_Socket_Address_get_ip_port_13, METH_NOARGS, (const char *)Dtool_Socket_Address_get_ip_port_13_comment},
  {"GetIPAddressRaw", &Dtool_Socket_Address_GetIPAddressRaw_14, METH_NOARGS, (const char *)Dtool_Socket_Address_GetIPAddressRaw_14_comment},
  {"is_any", &Dtool_Socket_Address_is_any_18, METH_NOARGS, (const char *)Dtool_Socket_Address_is_any_18_comment},
  {"isAny", &Dtool_Socket_Address_is_any_18, METH_NOARGS, (const char *)Dtool_Socket_Address_is_any_18_comment},
  {"is_mcast_range", &Dtool_Socket_Address_is_mcast_range_19, METH_NOARGS, (const char *)Dtool_Socket_Address_is_mcast_range_19_comment},
  {"isMcastRange", &Dtool_Socket_Address_is_mcast_range_19, METH_NOARGS, (const char *)Dtool_Socket_Address_is_mcast_range_19_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A rich comparison function
//     Socket_Address
//////////////////
static PyObject *Dtool_RichCompare_Socket_Address(PyObject *self, PyObject *arg, int op) {
  Socket_Address *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Socket_Address, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Socket_Address::operator ==(Socket_Address const &in) const
      Socket_Address const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
        bool return_value = (*(const Socket_Address*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Socket_Address::operator !=(Socket_Address const &in) const
      Socket_Address const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
        bool return_value = (*(const Socket_Address*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Socket_Address::operator <(Socket_Address const &in) const
      Socket_Address const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_Socket_Address(arg, arg_this, arg_manage)) {
        bool return_value = (*(const Socket_Address*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_Socket_Address = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_Address = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_Address",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_Address,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_Address,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A simple place to store and manipulate tcp and port address for\n"
    " * communication layer\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_Socket_Address,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_Address,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_Address,
    PyType_GenericAlloc,
    Dtool_new_Socket_Address,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_Address,
  Dtool_UpcastInterface_Socket_Address,
  Dtool_DowncastInterface_Socket_Address,
  (CoerceFunction)Dtool_ConstCoerce_Socket_Address,
  (CoerceFunction)Dtool_Coerce_Socket_Address,
};

static void Dtool_PyModuleClassInit_Socket_Address(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Socket_Address._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Socket_Address._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_Address) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_Address)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_Address);
  }
}

/**
 * Python method tables for Socket_IP (Socket_IP)
 */
static PyMethodDef Dtool_Methods_Socket_IP[] = {
  {"Close", &Dtool_Socket_IP_Close_23, METH_NOARGS, (const char *)Dtool_Socket_IP_Close_23_comment},
  {"GetLastError", &Dtool_Socket_IP_GetLastError_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_GetLastError_24_comment},
  {"SetNonBlocking", &Dtool_Socket_IP_SetNonBlocking_25, METH_NOARGS, (const char *)Dtool_Socket_IP_SetNonBlocking_25_comment},
  {"SetBlocking", &Dtool_Socket_IP_SetBlocking_26, METH_NOARGS, (const char *)Dtool_Socket_IP_SetBlocking_26_comment},
  {"SetReuseAddress", (PyCFunction) &Dtool_Socket_IP_SetReuseAddress_27, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_IP_SetReuseAddress_27_comment},
  {"SetV6Only", &Dtool_Socket_IP_SetV6Only_28, METH_O, (const char *)Dtool_Socket_IP_SetV6Only_28_comment},
  {"Active", &Dtool_Socket_IP_Active_29, METH_NOARGS, (const char *)Dtool_Socket_IP_Active_29_comment},
  {"SetRecvBufferSize", &Dtool_Socket_IP_SetRecvBufferSize_30, METH_O, (const char *)Dtool_Socket_IP_SetRecvBufferSize_30_comment},
  {"SetSocket", &Dtool_Socket_IP_SetSocket_31, METH_O, (const char *)Dtool_Socket_IP_SetSocket_31_comment},
  {"GetSocket", &Dtool_Socket_IP_GetSocket_32, METH_NOARGS, (const char *)Dtool_Socket_IP_GetSocket_32_comment},
  {"GetPeerName", &Dtool_Socket_IP_GetPeerName_33, METH_NOARGS, (const char *)Dtool_Socket_IP_GetPeerName_33_comment},
  {"InitNetworkDriver", &Dtool_Socket_IP_InitNetworkDriver_34, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_InitNetworkDriver_34_comment},
  {"get_class_type", &Dtool_Socket_IP_get_class_type_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_get_class_type_35_comment},
  {"getClassType", &Dtool_Socket_IP_get_class_type_35, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_IP_get_class_type_35_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_IP = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_IP = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Socket_IP = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Socket_IP = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_IP = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_IP",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_IP,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_IP,
    &Dtool_SequenceMethods_Socket_IP,
    &Dtool_MappingMethods_Socket_IP,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Socket_IP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a INET domain Socket This call should be the\n"
    " * starting point for all other unix domain sockets.\n"
    " *\n"
    " * SocketIP |\n"
    " * ------------------------------------------------------------------- |\n"
    " * |                       |                           | SocketTCP\n"
    " * SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_IP,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_IP,
    PyType_GenericAlloc,
    Dtool_new_Socket_IP,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_IP,
  Dtool_UpcastInterface_Socket_IP,
  Dtool_DowncastInterface_Socket_IP,
  (CoerceFunction)Dtool_ConstCoerce_Socket_IP,
  (CoerceFunction)Dtool_Coerce_Socket_IP,
};

static void Dtool_PyModuleClassInit_Socket_IP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != NULL);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(NULL);
    Dtool_Socket_IP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_Socket_IP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_IP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_IP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_IP);
  }
}

/**
 * Python method tables for Socket_TCP (Socket_TCP)
 */
static PyMethodDef Dtool_Methods_Socket_TCP[] = {
  {"SetNoDelay", (PyCFunction) &Dtool_Socket_TCP_SetNoDelay_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_SetNoDelay_38_comment},
  {"SetLinger", (PyCFunction) &Dtool_Socket_TCP_SetLinger_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_SetLinger_39_comment},
  {"DontLinger", &Dtool_Socket_TCP_DontLinger_40, METH_NOARGS, (const char *)Dtool_Socket_TCP_DontLinger_40_comment},
  {"SetSendBufferSize", &Dtool_Socket_TCP_SetSendBufferSize_41, METH_O, (const char *)Dtool_Socket_TCP_SetSendBufferSize_41_comment},
  {"ActiveOpen", (PyCFunction) &Dtool_Socket_TCP_ActiveOpen_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_ActiveOpen_42_comment},
  {"ActiveOpenNonBlocking", &Dtool_Socket_TCP_ActiveOpenNonBlocking_43, METH_O, (const char *)Dtool_Socket_TCP_ActiveOpenNonBlocking_43_comment},
  {"ErrorIs_WouldBlocking", &Dtool_Socket_TCP_ErrorIs_WouldBlocking_44, METH_O, (const char *)Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment},
  {"ErrorIsWouldBlocking", &Dtool_Socket_TCP_ErrorIs_WouldBlocking_44, METH_O, (const char *)Dtool_Socket_TCP_ErrorIs_WouldBlocking_44_comment},
  {"ShutdownSend", &Dtool_Socket_TCP_ShutdownSend_45, METH_NOARGS, (const char *)Dtool_Socket_TCP_ShutdownSend_45_comment},
  {"SendData", &Dtool_Socket_TCP_SendData_46, METH_O, (const char *)Dtool_Socket_TCP_SendData_46_comment},
  {"RecvData", &Dtool_Socket_TCP_RecvData_47, METH_O, (const char *)Dtool_Socket_TCP_RecvData_47_comment},
  {"get_class_type", &Dtool_Socket_TCP_get_class_type_48, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_get_class_type_48_comment},
  {"getClassType", &Dtool_Socket_TCP_get_class_type_48, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_get_class_type_48_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_TCP = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_TCP = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Socket_TCP = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Socket_TCP = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_TCP = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_TCP",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_TCP,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_TCP,
    &Dtool_SequenceMethods_Socket_TCP,
    &Dtool_MappingMethods_Socket_TCP,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Socket_TCP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a TCP connected socket This class is pretty useless\n"
    " * by itself but it does hide some of the platform differences from machine to\n"
    " * machine\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_TCP,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_TCP,
    PyType_GenericAlloc,
    Dtool_new_Socket_TCP,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_TCP,
  Dtool_UpcastInterface_Socket_TCP,
  Dtool_DowncastInterface_Socket_TCP,
  (CoerceFunction)Dtool_ConstCoerce_Socket_TCP,
  (CoerceFunction)Dtool_Coerce_Socket_TCP,
};

static void Dtool_PyModuleClassInit_Socket_TCP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(NULL);
    Dtool_Socket_TCP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    PyObject *dict = PyDict_New();
    Dtool_Socket_TCP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_TCP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_TCP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_TCP);
  }
}

/**
 * Python method tables for Socket_TCP_Listen (Socket_TCP_Listen)
 */
static PyMethodDef Dtool_Methods_Socket_TCP_Listen[] = {
  {"OpenForListen", (PyCFunction) &Dtool_Socket_TCP_Listen_OpenForListen_52, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_Listen_OpenForListen_52_comment},
  {"GetIncomingConnection", (PyCFunction) &Dtool_Socket_TCP_Listen_GetIncomingConnection_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_TCP_Listen_GetIncomingConnection_53_comment},
  {"get_class_type", &Dtool_Socket_TCP_Listen_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_Listen_get_class_type_54_comment},
  {"getClassType", &Dtool_Socket_TCP_Listen_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_TCP_Listen_get_class_type_54_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_TCP_Listen = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_TCP_Listen = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Socket_TCP_Listen = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Socket_TCP_Listen = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_TCP_Listen = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_TCP_Listen",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_TCP_Listen,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_TCP_Listen,
    &Dtool_SequenceMethods_Socket_TCP_Listen,
    &Dtool_MappingMethods_Socket_TCP_Listen,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Socket_TCP_Listen,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a TCP rendezvous socket\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_TCP_Listen,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_TCP_Listen,
    PyType_GenericAlloc,
    Dtool_new_Socket_TCP_Listen,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_TCP_Listen,
  Dtool_UpcastInterface_Socket_TCP_Listen,
  Dtool_DowncastInterface_Socket_TCP_Listen,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Socket_TCP_Listen(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(NULL);
    Dtool_Socket_TCP_Listen._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    PyObject *dict = PyDict_New();
    Dtool_Socket_TCP_Listen._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_TCP_Listen) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_TCP_Listen)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_TCP_Listen);
  }
}

/**
 * Python method tables for Socket_UDP_Incoming (Socket_UDP_Incoming)
 */
static PyMethodDef Dtool_Methods_Socket_UDP_Incoming[] = {
  {"OpenForInput", &Dtool_Socket_UDP_Incoming_OpenForInput_57, METH_O, (const char *)Dtool_Socket_UDP_Incoming_OpenForInput_57_comment},
  {"OpenForInputMCast", &Dtool_Socket_UDP_Incoming_OpenForInputMCast_58, METH_O, (const char *)Dtool_Socket_UDP_Incoming_OpenForInputMCast_58_comment},
  {"SendTo", (PyCFunction) &Dtool_Socket_UDP_Incoming_SendTo_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_UDP_Incoming_SendTo_60_comment},
  {"InitNoAddress", &Dtool_Socket_UDP_Incoming_InitNoAddress_61, METH_NOARGS, (const char *)Dtool_Socket_UDP_Incoming_InitNoAddress_61_comment},
  {"SetToBroadCast", &Dtool_Socket_UDP_Incoming_SetToBroadCast_62, METH_NOARGS, (const char *)Dtool_Socket_UDP_Incoming_SetToBroadCast_62_comment},
  {"get_class_type", &Dtool_Socket_UDP_Incoming_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Incoming_get_class_type_63_comment},
  {"getClassType", &Dtool_Socket_UDP_Incoming_get_class_type_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Incoming_get_class_type_63_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_UDP_Incoming = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_UDP_Incoming = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Socket_UDP_Incoming = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Socket_UDP_Incoming = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_UDP_Incoming = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_UDP_Incoming",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_UDP_Incoming,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_UDP_Incoming,
    &Dtool_SequenceMethods_Socket_UDP_Incoming,
    &Dtool_MappingMethods_Socket_UDP_Incoming,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Socket_UDP_Incoming,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a UDP Reader\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_UDP_Incoming,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_UDP_Incoming,
    PyType_GenericAlloc,
    Dtool_new_Socket_UDP_Incoming,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_UDP_Incoming,
  Dtool_UpcastInterface_Socket_UDP_Incoming,
  Dtool_DowncastInterface_Socket_UDP_Incoming,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Socket_UDP_Incoming(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(NULL);
    Dtool_Socket_UDP_Incoming._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    PyObject *dict = PyDict_New();
    Dtool_Socket_UDP_Incoming._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_UDP_Incoming) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_UDP_Incoming)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_UDP_Incoming);
  }
}

/**
 * Python method tables for Socket_UDP_Outgoing (Socket_UDP_Outgoing)
 */
static PyMethodDef Dtool_Methods_Socket_UDP_Outgoing[] = {
  {"InitToAddress", &Dtool_Socket_UDP_Outgoing_InitToAddress_67, METH_O, (const char *)Dtool_Socket_UDP_Outgoing_InitToAddress_67_comment},
  {"Send", &Dtool_Socket_UDP_Outgoing_Send_68, METH_O, (const char *)Dtool_Socket_UDP_Outgoing_Send_68_comment},
  {"InitNoAddress", &Dtool_Socket_UDP_Outgoing_InitNoAddress_69, METH_NOARGS, (const char *)Dtool_Socket_UDP_Outgoing_InitNoAddress_69_comment},
  {"SendTo", (PyCFunction) &Dtool_Socket_UDP_Outgoing_SendTo_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_UDP_Outgoing_SendTo_70_comment},
  {"SetToBroadCast", &Dtool_Socket_UDP_Outgoing_SetToBroadCast_71, METH_NOARGS, (const char *)Dtool_Socket_UDP_Outgoing_SetToBroadCast_71_comment},
  {"get_class_type", &Dtool_Socket_UDP_Outgoing_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Outgoing_get_class_type_72_comment},
  {"getClassType", &Dtool_Socket_UDP_Outgoing_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_Outgoing_get_class_type_72_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_UDP_Outgoing = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_UDP_Outgoing = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Socket_UDP_Outgoing = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Socket_UDP_Outgoing = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_UDP_Outgoing = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_UDP_Outgoing",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_UDP_Outgoing,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_UDP_Outgoing,
    &Dtool_SequenceMethods_Socket_UDP_Outgoing,
    &Dtool_MappingMethods_Socket_UDP_Outgoing,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Socket_UDP_Outgoing,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a UDP sending socket\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_UDP_Outgoing,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_UDP_Outgoing,
    PyType_GenericAlloc,
    Dtool_new_Socket_UDP_Outgoing,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_UDP_Outgoing,
  Dtool_UpcastInterface_Socket_UDP_Outgoing,
  Dtool_DowncastInterface_Socket_UDP_Outgoing,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Socket_UDP_Outgoing(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_IP(NULL);
    Dtool_Socket_UDP_Outgoing._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_IP);
    PyObject *dict = PyDict_New();
    Dtool_Socket_UDP_Outgoing._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_UDP_Outgoing) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_UDP_Outgoing)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_UDP_Outgoing);
  }
}

/**
 * Python method tables for Socket_fdset (Socket_fdset)
 */
static PyMethodDef Dtool_Methods_Socket_fdset[] = {
  {"setForSocket", &Dtool_Socket_fdset_setForSocket_76, METH_O, (const char *)Dtool_Socket_fdset_setForSocket_76_comment},
  {"IsSetFor", &Dtool_Socket_fdset_IsSetFor_77, METH_O, (const char *)Dtool_Socket_fdset_IsSetFor_77_comment},
  {"WaitForRead", (PyCFunction) &Dtool_Socket_fdset_WaitForRead_78, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_fdset_WaitForRead_78_comment},
  {"WaitForWrite", (PyCFunction) &Dtool_Socket_fdset_WaitForWrite_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_fdset_WaitForWrite_79_comment},
  {"WaitForError", (PyCFunction) &Dtool_Socket_fdset_WaitForError_80, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_fdset_WaitForError_80_comment},
  {"clear", &Dtool_Socket_fdset_clear_81, METH_NOARGS, (const char *)Dtool_Socket_fdset_clear_81_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_fdset = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_fdset = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_fdset",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_fdset,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_fdset,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_fdset,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_fdset,
    PyType_GenericAlloc,
    Dtool_new_Socket_fdset,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_fdset,
  Dtool_UpcastInterface_Socket_fdset,
  Dtool_DowncastInterface_Socket_fdset,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Socket_fdset(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Socket_fdset._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Socket_fdset._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_fdset) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_fdset)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_fdset);
  }
}

/**
 * Python method tables for Buffered_DatagramConnection (Buffered_DatagramConnection)
 */
static PyMethodDef Dtool_Methods_Buffered_DatagramConnection[] = {
  {"GetMessage", &Dtool_Buffered_DatagramConnection_GetMessage_84, METH_O, (const char *)Dtool_Buffered_DatagramConnection_GetMessage_84_comment},
  {"DoConnect", &Dtool_Buffered_DatagramConnection_DoConnect_85, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_DoConnect_85_comment},
  {"IsConnected", &Dtool_Buffered_DatagramConnection_IsConnected_86, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_IsConnected_86_comment},
  {"SendMessage", &Dtool_Buffered_DatagramConnection_SendMessage_88, METH_O, (const char *)Dtool_Buffered_DatagramConnection_SendMessage_88_comment},
  {"Flush", &Dtool_Buffered_DatagramConnection_Flush_89, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_Flush_89_comment},
  {"Reset", &Dtool_Buffered_DatagramConnection_Reset_90, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_Reset_90_comment},
  {"WaitForNetworkReadEvent", &Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91, METH_O, (const char *)Dtool_Buffered_DatagramConnection_WaitForNetworkReadEvent_91_comment},
  {"AddressQueueSize", &Dtool_Buffered_DatagramConnection_AddressQueueSize_92, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_AddressQueueSize_92_comment},
  {"AddAddress", &Dtool_Buffered_DatagramConnection_AddAddress_93, METH_O, (const char *)Dtool_Buffered_DatagramConnection_AddAddress_93_comment},
  {"ClearAddresses", &Dtool_Buffered_DatagramConnection_ClearAddresses_94, METH_NOARGS, (const char *)Dtool_Buffered_DatagramConnection_ClearAddresses_94_comment},
  {"get_class_type", &Dtool_Buffered_DatagramConnection_get_class_type_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_Buffered_DatagramConnection_get_class_type_95_comment},
  {"getClassType", &Dtool_Buffered_DatagramConnection_get_class_type_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_Buffered_DatagramConnection_get_class_type_95_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Buffered_DatagramConnection = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Buffered_DatagramConnection = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Buffered_DatagramConnection = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Buffered_DatagramConnection = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Buffered_DatagramConnection = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Buffered_DatagramConnection",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Buffered_DatagramConnection,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Buffered_DatagramConnection,
    &Dtool_SequenceMethods_Buffered_DatagramConnection,
    &Dtool_MappingMethods_Buffered_DatagramConnection,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Buffered_DatagramConnection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// there are 3 states 1. Socket not even assigned,,,, 2. Socket Assigned and\n"
    "// trying to get a active connect open 3. Socket is open and  writable.. (\n"
    "// Fully powered up )...",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Buffered_DatagramConnection,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Buffered_DatagramConnection,
    PyType_GenericAlloc,
    Dtool_new_Buffered_DatagramConnection,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Buffered_DatagramConnection,
  Dtool_UpcastInterface_Buffered_DatagramConnection,
  Dtool_DowncastInterface_Buffered_DatagramConnection,
  (CoerceFunction)Dtool_ConstCoerce_Buffered_DatagramConnection,
  (CoerceFunction)Dtool_Coerce_Buffered_DatagramConnection,
};

static void Dtool_PyModuleClassInit_Buffered_DatagramConnection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_TCP(NULL);
    Dtool_Buffered_DatagramConnection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_TCP);
    PyObject *dict = PyDict_New();
    Dtool_Buffered_DatagramConnection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Buffered_DatagramConnection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Buffered_DatagramConnection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Buffered_DatagramConnection);
  }
}

/**
 * Python method tables for Socket_UDP (Socket_UDP)
 */
static PyMethodDef Dtool_Methods_Socket_UDP[] = {
  {"InitToAddress", &Dtool_Socket_UDP_InitToAddress_98, METH_O, (const char *)Dtool_Socket_UDP_InitToAddress_98_comment},
  {"Send", &Dtool_Socket_UDP_Send_99, METH_O, (const char *)Dtool_Socket_UDP_Send_99_comment},
  {"SendTo", (PyCFunction) &Dtool_Socket_UDP_SendTo_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Socket_UDP_SendTo_100_comment},
  {"SetToBroadCast", &Dtool_Socket_UDP_SetToBroadCast_101, METH_NOARGS, (const char *)Dtool_Socket_UDP_SetToBroadCast_101_comment},
  {"get_class_type", &Dtool_Socket_UDP_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_get_class_type_102_comment},
  {"getClassType", &Dtool_Socket_UDP_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_Socket_UDP_get_class_type_102_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Socket_UDP = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Socket_UDP = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Socket_UDP = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Socket_UDP = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Socket_UDP = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Socket_UDP",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Socket_UDP,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Socket_UDP,
    &Dtool_SequenceMethods_Socket_UDP,
    &Dtool_MappingMethods_Socket_UDP,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Socket_UDP,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base functionality for a combination UDP Reader and Writer.  This\n"
    " * duplicates code from Socket_UDP_Outgoing, to avoid the problems of multiple\n"
    " * inheritance.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Socket_UDP,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Socket_UDP,
    PyType_GenericAlloc,
    Dtool_new_Socket_UDP,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Socket_UDP,
  Dtool_UpcastInterface_Socket_UDP,
  Dtool_DowncastInterface_Socket_UDP,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Socket_UDP(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_Socket_UDP_Incoming(NULL);
    Dtool_Socket_UDP._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_Socket_UDP_Incoming);
    PyObject *dict = PyDict_New();
    Dtool_Socket_UDP._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Socket_UDP) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Socket_UDP)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Socket_UDP);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3nativenet_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Socket_Address", Dtool_Socket_Address);
#endif
  Dtool_Socket_IP._type = Socket_IP::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Socket_IP);
  Dtool_Socket_TCP._type = Socket_TCP::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Socket_TCP);
  Dtool_Socket_TCP_Listen._type = Socket_TCP_Listen::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Socket_TCP_Listen);
  Dtool_Socket_UDP_Incoming._type = Socket_UDP_Incoming::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Socket_UDP_Incoming);
  Dtool_Socket_UDP_Outgoing._type = Socket_UDP_Outgoing::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Socket_UDP_Outgoing);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Socket_fdset", Dtool_Socket_fdset);
#endif
  Dtool_Buffered_DatagramConnection._type = Buffered_DatagramConnection::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Buffered_DatagramConnection);
  Dtool_Socket_UDP._type = Socket_UDP::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Socket_UDP);
}

void Dtool_libp3nativenet_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
#endif
}

void Dtool_libp3nativenet_BuildInstants(PyObject *module) {
  (void) module;
  // Socket_Address
  Dtool_PyModuleClassInit_Socket_Address(module);
  PyModule_AddObject(module, "Socket_Address", (PyObject *)&Dtool_Socket_Address);
  Py_INCREF(Dtool_Ptr_Socket_Address);
  PyModule_AddObject(module, "SocketAddress", (PyObject *)&Dtool_Socket_Address);
  // Socket_IP
  Dtool_PyModuleClassInit_Socket_IP(module);
  PyModule_AddObject(module, "Socket_IP", (PyObject *)&Dtool_Socket_IP);
  Py_INCREF(Dtool_Ptr_Socket_IP);
  PyModule_AddObject(module, "SocketIP", (PyObject *)&Dtool_Socket_IP);
  // Socket_TCP
  Dtool_PyModuleClassInit_Socket_TCP(module);
  PyModule_AddObject(module, "Socket_TCP", (PyObject *)&Dtool_Socket_TCP);
  Py_INCREF(Dtool_Ptr_Socket_TCP);
  PyModule_AddObject(module, "SocketTCP", (PyObject *)&Dtool_Socket_TCP);
  // Socket_TCP_Listen
  Dtool_PyModuleClassInit_Socket_TCP_Listen(module);
  PyModule_AddObject(module, "Socket_TCP_Listen", (PyObject *)&Dtool_Socket_TCP_Listen);
  Py_INCREF(Dtool_Ptr_Socket_TCP_Listen);
  PyModule_AddObject(module, "SocketTCPListen", (PyObject *)&Dtool_Socket_TCP_Listen);
  // Socket_UDP_Incoming
  Dtool_PyModuleClassInit_Socket_UDP_Incoming(module);
  PyModule_AddObject(module, "Socket_UDP_Incoming", (PyObject *)&Dtool_Socket_UDP_Incoming);
  Py_INCREF(Dtool_Ptr_Socket_UDP_Incoming);
  PyModule_AddObject(module, "SocketUDPIncoming", (PyObject *)&Dtool_Socket_UDP_Incoming);
  // Socket_UDP_Outgoing
  Dtool_PyModuleClassInit_Socket_UDP_Outgoing(module);
  PyModule_AddObject(module, "Socket_UDP_Outgoing", (PyObject *)&Dtool_Socket_UDP_Outgoing);
  Py_INCREF(Dtool_Ptr_Socket_UDP_Outgoing);
  PyModule_AddObject(module, "SocketUDPOutgoing", (PyObject *)&Dtool_Socket_UDP_Outgoing);
  // Socket_fdset
  Dtool_PyModuleClassInit_Socket_fdset(module);
  PyModule_AddObject(module, "Socket_fdset", (PyObject *)&Dtool_Socket_fdset);
  Py_INCREF(Dtool_Ptr_Socket_fdset);
  PyModule_AddObject(module, "SocketFdset", (PyObject *)&Dtool_Socket_fdset);
  // Buffered_DatagramConnection
  Dtool_PyModuleClassInit_Buffered_DatagramConnection(module);
  PyModule_AddObject(module, "Buffered_DatagramConnection", (PyObject *)&Dtool_Buffered_DatagramConnection);
  Py_INCREF(Dtool_Ptr_Buffered_DatagramConnection);
  PyModule_AddObject(module, "BufferedDatagramConnection", (PyObject *)&Dtool_Buffered_DatagramConnection);
  // Socket_UDP
  Dtool_PyModuleClassInit_Socket_UDP(module);
  PyModule_AddObject(module, "Socket_UDP", (PyObject *)&Dtool_Socket_UDP);
  Py_INCREF(Dtool_Ptr_Socket_UDP);
  PyModule_AddObject(module, "SocketUDP", (PyObject *)&Dtool_Socket_UDP);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3nativenet_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210430,  /* file_identifier */
  "libp3nativenet",  /* library_name */
  "5qEC",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3nativenet.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  256  /* next_index */
};

Configure(_in_configure_libp3nativenet);
ConfigureFn(_in_configure_libp3nativenet) {
  interrogate_request_module(&_in_module_def);
}

