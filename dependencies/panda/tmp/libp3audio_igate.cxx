/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/audio -Ipanda/src/audio -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3audio_igate.cxx -od built/pandac/input/libp3audio.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/audio -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3audio audio.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3audio
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "audio.h"
#include "audioLoadRequest.h"
#include "audioManager.h"
#include "audioSound.h"
#include "filterProperties.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class FilterProperties
 */
typedef FilterProperties FilterProperties_localtype;
Define_Module_ClassRef(panda3d.core, FilterProperties, FilterProperties_localtype, FilterProperties);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FilterProperties = &Dtool_FilterProperties;
static void Dtool_PyModuleClassInit_FilterProperties(PyObject *module);

/**
 * Forward declarations for top-level class AudioSound
 */
typedef AudioSound AudioSound_localtype;
Define_Module_ClassRef(panda3d.core, AudioSound, AudioSound_localtype, AudioSound);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioSound = &Dtool_AudioSound;
static void Dtool_PyModuleClassInit_AudioSound(PyObject *module);

/**
 * Forward declarations for top-level class AudioManager
 */
typedef AudioManager AudioManager_localtype;
Define_Module_ClassRef(panda3d.core, AudioManager, AudioManager_localtype, AudioManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioManager = &Dtool_AudioManager;
static void Dtool_PyModuleClassInit_AudioManager(PyObject *module);

/**
 * Forward declarations for top-level class AudioLoadRequest
 */
typedef AudioLoadRequest AudioLoadRequest_localtype;
Define_Module_ClassRef(panda3d.core, AudioLoadRequest, AudioLoadRequest_localtype, AudioLoadRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AudioLoadRequest = &Dtool_AudioLoadRequest;
static void Dtool_PyModuleClassInit_AudioLoadRequest(PyObject *module);
bool Dtool_ConstCoerce_AudioLoadRequest(PyObject *args, CPT(AudioLoadRequest) &coerced);
bool Dtool_Coerce_AudioLoadRequest(PyObject *args, PT(AudioLoadRequest) &coerced);

/**
 * Extern declarations for imported classes
 */
// ostream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ostream;
#else
extern struct Dtool_PyTypedObject Dtool_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypeHandle;
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != NULL, NULL);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != NULL, NULL);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedObject;
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Filename
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Filename;
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != NULL, NULL);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != NULL, NULL);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// Namable
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Namable;
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// AsyncTaskBase
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AsyncTaskBase;
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTaskBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskBase = &Dtool_AsyncTaskBase;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_TypedReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ReferenceCount;
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// AsyncTask
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_AsyncTask;
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTask;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_LVecBase3f;
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != NULL, NULL);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != NULL, NULL);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// MovieAudio
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_MovieAudio;
inline static bool Dtool_ConstCoerce_MovieAudio(PyObject *args, CPT(MovieAudio) &coerced) {
  nassertr(Dtool_Ptr_MovieAudio != NULL, false);
  nassertr(Dtool_Ptr_MovieAudio->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, CPT(MovieAudio) &))Dtool_Ptr_MovieAudio->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_MovieAudio(PyObject *args, PT(MovieAudio) &coerced) {
  nassertr(Dtool_Ptr_MovieAudio != NULL, false);
  nassertr(Dtool_Ptr_MovieAudio->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, PT(MovieAudio) &))Dtool_Ptr_MovieAudio->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_MovieAudio;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieAudio = &Dtool_MovieAudio;
extern bool Dtool_ConstCoerce_MovieAudio(PyObject *args, CPT(MovieAudio) &coerced);
extern bool Dtool_Coerce_MovieAudio(PyObject *args, PT(MovieAudio) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class FilterProperties
 */
/**
 * Python function wrapper for:
 * inline void FilterProperties::clear(void)
 */
static PyObject *Dtool_FilterProperties_clear_4(PyObject *self, PyObject *) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.clear")) {
    return NULL;
  }
  // 1-inline void FilterProperties::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_clear_4_comment =
  "C++ Interface:\n"
  "clear(const FilterProperties self)\n"
  "\n"
  "/**\n"
  " * Removes all DSP postprocessing.\n"
  " */";
#else
static const char *Dtool_FilterProperties_clear_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_lowpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
 */
static PyObject *Dtool_FilterProperties_add_lowpass_5(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_lowpass")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_lowpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
  float param1;
  float param2;
  static const char *keyword_list[] = {"cutoff_freq", "resonance_q", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_lowpass", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_lowpass((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_lowpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_lowpass_5_comment =
  "C++ Interface:\n"
  "add_lowpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n"
  "\n"
  "/**\n"
  " * Add a lowpass filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_lowpass_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_highpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
 */
static PyObject *Dtool_FilterProperties_add_highpass_6(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_highpass")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_highpass(PN_stdfloat cutoff_freq, PN_stdfloat resonance_q)
  float param1;
  float param2;
  static const char *keyword_list[] = {"cutoff_freq", "resonance_q", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_highpass", (char **)keyword_list, &param1, &param2)) {
    (*local_this).add_highpass((PN_stdfloat)param1, (PN_stdfloat)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_highpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_highpass_6_comment =
  "C++ Interface:\n"
  "add_highpass(const FilterProperties self, float cutoff_freq, float resonance_q)\n"
  "\n"
  "/**\n"
  " * Add a highpass filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_highpass_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_echo(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat delay, PN_stdfloat decayratio)
 */
static PyObject *Dtool_FilterProperties_add_echo_7(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_echo")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_echo(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat delay, PN_stdfloat decayratio)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"drymix", "wetmix", "delay", "decayratio", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_echo", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).add_echo((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_echo(const FilterProperties self, float drymix, float wetmix, float delay, float decayratio)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_echo_7_comment =
  "C++ Interface:\n"
  "add_echo(const FilterProperties self, float drymix, float wetmix, float delay, float decayratio)\n"
  "\n"
  "/**\n"
  " * Add a echo filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_echo_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_flange(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat depth, PN_stdfloat rate)
 */
static PyObject *Dtool_FilterProperties_add_flange_8(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_flange")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_flange(PN_stdfloat drymix, PN_stdfloat wetmix, PN_stdfloat depth, PN_stdfloat rate)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"drymix", "wetmix", "depth", "rate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_flange", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).add_flange((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_flange(const FilterProperties self, float drymix, float wetmix, float depth, float rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_flange_8_comment =
  "C++ Interface:\n"
  "add_flange(const FilterProperties self, float drymix, float wetmix, float depth, float rate)\n"
  "\n"
  "/**\n"
  " * Add a flange filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_flange_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_distort(PN_stdfloat level)
 */
static PyObject *Dtool_FilterProperties_add_distort_9(PyObject *self, PyObject *arg) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_distort")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_distort(PN_stdfloat level)
  if (PyNumber_Check(arg)) {
    (*local_this).add_distort((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_distort(const FilterProperties self, float level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_distort_9_comment =
  "C++ Interface:\n"
  "add_distort(const FilterProperties self, float level)\n"
  "\n"
  "/**\n"
  " * Add a distort filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_distort_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_normalize(PN_stdfloat fadetime, PN_stdfloat threshold, PN_stdfloat maxamp)
 */
static PyObject *Dtool_FilterProperties_add_normalize_10(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_normalize")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_normalize(PN_stdfloat fadetime, PN_stdfloat threshold, PN_stdfloat maxamp)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"fadetime", "threshold", "maxamp", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_normalize", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).add_normalize((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_normalize(const FilterProperties self, float fadetime, float threshold, float maxamp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_normalize_10_comment =
  "C++ Interface:\n"
  "add_normalize(const FilterProperties self, float fadetime, float threshold, float maxamp)\n"
  "\n"
  "/**\n"
  " * Add a normalize filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_normalize_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_parameq(PN_stdfloat center_freq, PN_stdfloat bandwidth, PN_stdfloat gain)
 */
static PyObject *Dtool_FilterProperties_add_parameq_11(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_parameq")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_parameq(PN_stdfloat center_freq, PN_stdfloat bandwidth, PN_stdfloat gain)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"center_freq", "bandwidth", "gain", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_parameq", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).add_parameq((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_parameq(const FilterProperties self, float center_freq, float bandwidth, float gain)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_parameq_11_comment =
  "C++ Interface:\n"
  "add_parameq(const FilterProperties self, float center_freq, float bandwidth, float gain)\n"
  "\n"
  "/**\n"
  " * Add a parameq filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_parameq_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_pitchshift(PN_stdfloat pitch, PN_stdfloat fftsize, PN_stdfloat overlap)
 */
static PyObject *Dtool_FilterProperties_add_pitchshift_12(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_pitchshift")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_pitchshift(PN_stdfloat pitch, PN_stdfloat fftsize, PN_stdfloat overlap)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"pitch", "fftsize", "overlap", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_pitchshift", (char **)keyword_list, &param1, &param2, &param3)) {
    (*local_this).add_pitchshift((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_pitchshift(const FilterProperties self, float pitch, float fftsize, float overlap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_pitchshift_12_comment =
  "C++ Interface:\n"
  "add_pitchshift(const FilterProperties self, float pitch, float fftsize, float overlap)\n"
  "\n"
  "/**\n"
  " * Add a pitchshift filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_pitchshift_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_chorus(PN_stdfloat drymix, PN_stdfloat wet1, PN_stdfloat wet2, PN_stdfloat wet3, PN_stdfloat delay, PN_stdfloat rate, PN_stdfloat depth)
 */
static PyObject *Dtool_FilterProperties_add_chorus_13(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_chorus")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_chorus(PN_stdfloat drymix, PN_stdfloat wet1, PN_stdfloat wet2, PN_stdfloat wet3, PN_stdfloat delay, PN_stdfloat rate, PN_stdfloat depth)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  static const char *keyword_list[] = {"drymix", "wet1", "wet2", "wet3", "delay", "rate", "depth", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffff:add_chorus", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
    (*local_this).add_chorus((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_chorus(const FilterProperties self, float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_chorus_13_comment =
  "C++ Interface:\n"
  "add_chorus(const FilterProperties self, float drymix, float wet1, float wet2, float wet3, float delay, float rate, float depth)\n"
  "\n"
  "/**\n"
  " * Add a chorus filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_chorus_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_sfxreverb(PN_stdfloat drylevel = 0, PN_stdfloat room = -10000, PN_stdfloat roomhf = 0, PN_stdfloat decaytime = 1, PN_stdfloat decayhfratio = 0.5, PN_stdfloat reflectionslevel = -10000, PN_stdfloat reflectionsdelay = 0.020000000000000005, PN_stdfloat reverblevel = 0, PN_stdfloat reverbdelay = 0.04000000000000001, PN_stdfloat diffusion = 100, PN_stdfloat density = 100, PN_stdfloat hfreference = 5000, PN_stdfloat roomlf = 0, PN_stdfloat lfreference = 250)
 */
static PyObject *Dtool_FilterProperties_add_sfxreverb_14(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_sfxreverb")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_sfxreverb(PN_stdfloat drylevel = 0, PN_stdfloat room = -10000, PN_stdfloat roomhf = 0, PN_stdfloat decaytime = 1, PN_stdfloat decayhfratio = 0.5, PN_stdfloat reflectionslevel = -10000, PN_stdfloat reflectionsdelay = 0.020000000000000005, PN_stdfloat reverblevel = 0, PN_stdfloat reverbdelay = 0.04000000000000001, PN_stdfloat diffusion = 100, PN_stdfloat density = 100, PN_stdfloat hfreference = 5000, PN_stdfloat roomlf = 0, PN_stdfloat lfreference = 250)
  float param1 = 0;
  float param2 = -10000;
  float param3 = 0;
  float param4 = 1;
  float param5 = 0.5;
  float param6 = -10000;
  float param7 = 0.020000000000000005;
  float param8 = 0;
  float param9 = 0.04000000000000001;
  float param10 = 100;
  float param11 = 100;
  float param12 = 5000;
  float param13 = 0;
  float param14 = 250;
  static const char *keyword_list[] = {"drylevel", "room", "roomhf", "decaytime", "decayhfratio", "reflectionslevel", "reflectionsdelay", "reverblevel", "reverbdelay", "diffusion", "density", "hfreference", "roomlf", "lfreference", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|ffffffffffffff:add_sfxreverb", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14)) {
    (*local_this).add_sfxreverb((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10, (PN_stdfloat)param11, (PN_stdfloat)param12, (PN_stdfloat)param13, (PN_stdfloat)param14);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_sfxreverb(const FilterProperties self, float drylevel, float room, float roomhf, float decaytime, float decayhfratio, float reflectionslevel, float reflectionsdelay, float reverblevel, float reverbdelay, float diffusion, float density, float hfreference, float roomlf, float lfreference)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_sfxreverb_14_comment =
  "C++ Interface:\n"
  "add_sfxreverb(const FilterProperties self, float drylevel, float room, float roomhf, float decaytime, float decayhfratio, float reflectionslevel, float reflectionsdelay, float reverblevel, float reverbdelay, float diffusion, float density, float hfreference, float roomlf, float lfreference)\n"
  "\n"
  "/**\n"
  " * Add a reverb filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_sfxreverb_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FilterProperties::add_compress(PN_stdfloat threshold, PN_stdfloat attack, PN_stdfloat release, PN_stdfloat gainmakeup)
 */
static PyObject *Dtool_FilterProperties_add_compress_15(PyObject *self, PyObject *args, PyObject *kwds) {
  FilterProperties *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FilterProperties, (void **)&local_this, "FilterProperties.add_compress")) {
    return NULL;
  }
  // 1-inline void FilterProperties::add_compress(PN_stdfloat threshold, PN_stdfloat attack, PN_stdfloat release, PN_stdfloat gainmakeup)
  float param1;
  float param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"threshold", "attack", "release", "gainmakeup", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:add_compress", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    (*local_this).add_compress((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_compress(const FilterProperties self, float threshold, float attack, float release, float gainmakeup)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_add_compress_15_comment =
  "C++ Interface:\n"
  "add_compress(const FilterProperties self, float threshold, float attack, float release, float gainmakeup)\n"
  "\n"
  "/**\n"
  " * Add a compress filter to the end of the DSP chain.\n"
  " */";
#else
static const char *Dtool_FilterProperties_add_compress_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FilterProperties::get_class_type(void)
 */
static PyObject *Dtool_FilterProperties_get_class_type_16(PyObject *, PyObject *) {
  // 1-static TypeHandle FilterProperties::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(FilterProperties::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FilterProperties_get_class_type_16_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FilterProperties_get_class_type_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * FilterProperties::FilterProperties(void)
 * inline FilterProperties::FilterProperties(FilterProperties const &) = default
 */
static int Dtool_Init_FilterProperties(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-FilterProperties::FilterProperties(void)
      FilterProperties *return_value = new FilterProperties();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FilterProperties, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline FilterProperties::FilterProperties(FilterProperties const &) = default
      FilterProperties const *arg_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FilterProperties, 0, "FilterProperties.FilterProperties", true, true);
      if (arg_this != NULL) {
        FilterProperties *return_value = new FilterProperties(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FilterProperties, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "FilterProperties() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FilterProperties()\n"
      "FilterProperties(const FilterProperties param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FilterProperties(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FilterProperties) {
    printf("FilterProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FilterProperties *local_this = (FilterProperties *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FilterProperties) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FilterProperties(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FilterProperties) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FilterProperties*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FilterProperties*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (FilterProperties*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AudioSound
 */
/**
 * Python function wrapper for:
 * virtual void AudioSound::play(void) = 0
 */
static PyObject *Dtool_AudioSound_play_18(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.play")) {
    return NULL;
  }
  // 1-virtual void AudioSound::play(void) = 0
  (*local_this).play();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_play_18_comment =
  "C++ Interface:\n"
  "play(const AudioSound self)\n"
  "\n"
  "// For best compatibility, set the loop_count, volume, and balance, prior to\n"
  "// calling play().  You may set them while they're playing, but it's\n"
  "// implementation specific whether you get the results.  - Calling play() a\n"
  "// second time on the same sound before it is finished will start the sound\n"
  "// again (creating a skipping or stuttering effect).";
#else
static const char *Dtool_AudioSound_play_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::stop(void) = 0
 */
static PyObject *Dtool_AudioSound_stop_19(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.stop")) {
    return NULL;
  }
  // 1-virtual void AudioSound::stop(void) = 0
  (*local_this).stop();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_stop_19_comment =
  "C++ Interface:\n"
  "stop(const AudioSound self)\n";
#else
static const char *Dtool_AudioSound_stop_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_loop(bool loop = true) = 0
 */
static PyObject *Dtool_AudioSound_set_loop_20(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_loop")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_loop(bool loop = true) = 0
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"loop", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:set_loop", (char **)keyword_list, &param1)) {
    (*local_this).set_loop((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loop(const AudioSound self, bool loop)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_loop_20_comment =
  "C++ Interface:\n"
  "set_loop(const AudioSound self, bool loop)\n"
  "\n"
  "// loop: false = play once; true = play forever.  inits to false.";
#else
static const char *Dtool_AudioSound_set_loop_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioSound::get_loop(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_loop_21(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool AudioSound::get_loop(void) const = 0
  bool return_value = (*(const AudioSound*)local_this).get_loop();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_loop_21_comment =
  "C++ Interface:\n"
  "get_loop(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_loop_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_loop_count(unsigned long int loop_count = 1) = 0
 */
static PyObject *Dtool_AudioSound_set_loop_count_22(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_loop_count")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_loop_count(unsigned long int loop_count = 1) = 0
  unsigned long param1 = 1;
  static const char *keyword_list[] = {"loop_count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|k:set_loop_count", (char **)keyword_list, &param1)) {
    (*local_this).set_loop_count((unsigned long int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loop_count(const AudioSound self, int loop_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_loop_count_22_comment =
  "C++ Interface:\n"
  "set_loop_count(const AudioSound self, int loop_count)\n"
  "\n"
  "// loop_count: 0 = forever; 1 = play once; n = play n times.  inits to 1.";
#else
static const char *Dtool_AudioSound_set_loop_count_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual unsigned long int AudioSound::get_loop_count(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_loop_count_23(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual unsigned long int AudioSound::get_loop_count(void) const = 0
  unsigned long int return_value = (*(const AudioSound*)local_this).get_loop_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_loop_count_23_comment =
  "C++ Interface:\n"
  "get_loop_count(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_loop_count_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_time(PN_stdfloat start_time = 0.0) = 0
 */
static PyObject *Dtool_AudioSound_set_time_24(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_time")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_time(PN_stdfloat start_time = 0.0) = 0
  float param1 = 0.0;
  static const char *keyword_list[] = {"start_time", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_time", (char **)keyword_list, &param1)) {
    (*local_this).set_time((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time(const AudioSound self, float start_time)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_time_24_comment =
  "C++ Interface:\n"
  "set_time(const AudioSound self, float start_time)\n"
  "\n"
  "/*\n"
  " * Control time position within the sound.  This is similar (in concept) to\n"
  " * the seek position within a file.  time in seconds: 0 = beginning; length()\n"
  " * = end.  inits to 0.0. - The current time position will not change while the\n"
  " * sound is playing; you must call play() again to effect the change.  To play\n"
  " * the same sound from a time offset a second time, explicitly set the time\n"
  " * position again.  When looping, the second and later loops will start from\n"
  " * the beginning of the sound.  - If a sound is playing, calling get_time()\n"
  " * repeatedly will return different results over time.  e.g.: PN_stdfloat\n"
  " * percent_complete = s.get_time()  s.length();\n"
  " */";
#else
static const char *Dtool_AudioSound_set_time_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_time(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_time_25(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_time(void) const = 0
  PN_stdfloat return_value = (*(const AudioSound*)local_this).get_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_time_25_comment =
  "C++ Interface:\n"
  "get_time(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_time_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_volume(PN_stdfloat volume = 1.0) = 0
 */
static PyObject *Dtool_AudioSound_set_volume_26(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_volume")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_volume(PN_stdfloat volume = 1.0) = 0
  float param1 = 1.0;
  static const char *keyword_list[] = {"volume", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_volume", (char **)keyword_list, &param1)) {
    (*local_this).set_volume((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_volume(const AudioSound self, float volume)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_volume_26_comment =
  "C++ Interface:\n"
  "set_volume(const AudioSound self, float volume)\n"
  "\n"
  "// 0 = minimum; 1.0 = maximum.  inits to 1.0.";
#else
static const char *Dtool_AudioSound_set_volume_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_volume(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_volume_27(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_volume(void) const = 0
  PN_stdfloat return_value = (*(const AudioSound*)local_this).get_volume();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_volume_27_comment =
  "C++ Interface:\n"
  "get_volume(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_volume_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_balance(PN_stdfloat balance_right = 0.0) = 0
 */
static PyObject *Dtool_AudioSound_set_balance_28(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_balance")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_balance(PN_stdfloat balance_right = 0.0) = 0
  float param1 = 0.0;
  static const char *keyword_list[] = {"balance_right", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_balance", (char **)keyword_list, &param1)) {
    (*local_this).set_balance((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_balance(const AudioSound self, float balance_right)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_balance_28_comment =
  "C++ Interface:\n"
  "set_balance(const AudioSound self, float balance_right)\n"
  "\n"
  "// -1.0 is hard left 0.0 is centered 1.0 is hard right inits to 0.0.";
#else
static const char *Dtool_AudioSound_set_balance_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_balance(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_balance_29(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_balance(void) const = 0
  PN_stdfloat return_value = (*(const AudioSound*)local_this).get_balance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_balance_29_comment =
  "C++ Interface:\n"
  "get_balance(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_balance_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_play_rate(PN_stdfloat play_rate = 1.0) = 0
 */
static PyObject *Dtool_AudioSound_set_play_rate_30(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_play_rate")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_play_rate(PN_stdfloat play_rate = 1.0) = 0
  float param1 = 1.0;
  static const char *keyword_list[] = {"play_rate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|f:set_play_rate", (char **)keyword_list, &param1)) {
    (*local_this).set_play_rate((PN_stdfloat)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const AudioSound self, float play_rate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_play_rate_30_comment =
  "C++ Interface:\n"
  "set_play_rate(const AudioSound self, float play_rate)\n"
  "\n"
  "// play_rate is any positive PN_stdfloat value.  inits to 1.0.";
#else
static const char *Dtool_AudioSound_set_play_rate_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_play_rate(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_play_rate_31(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_play_rate(void) const = 0
  PN_stdfloat return_value = (*(const AudioSound*)local_this).get_play_rate();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_play_rate_31_comment =
  "C++ Interface:\n"
  "get_play_rate(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_play_rate_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_active(bool flag = true) = 0
 */
static PyObject *Dtool_AudioSound_set_active_32(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_active")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_active(bool flag = true) = 0
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"flag", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:set_active", (char **)keyword_list, &param1)) {
    (*local_this).set_active((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const AudioSound self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_active_32_comment =
  "C++ Interface:\n"
  "set_active(const AudioSound self, bool flag)\n"
  "\n"
  "// inits to manager's state.";
#else
static const char *Dtool_AudioSound_set_active_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioSound::get_active(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_active_33(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool AudioSound::get_active(void) const = 0
  bool return_value = (*(const AudioSound*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_active_33_comment =
  "C++ Interface:\n"
  "get_active(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_active_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_finished_event(std::string const &event) = 0
 */
static PyObject *Dtool_AudioSound_set_finished_event_34(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_finished_event")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_finished_event(std::string const &event) = 0
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_finished_event(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_finished_event(const AudioSound self, str event)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_finished_event_34_comment =
  "C++ Interface:\n"
  "set_finished_event(const AudioSound self, str event)\n"
  "\n"
  "// Set (or clear) the event that will be thrown when the sound finishes\n"
  "// playing.  To clear the event, pass an empty string.";
#else
static const char *Dtool_AudioSound_set_finished_event_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string const &AudioSound::get_finished_event(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_finished_event_35(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual std::string const &AudioSound::get_finished_event(void) const = 0
  std::string const &return_value = (*(const AudioSound*)local_this).get_finished_event();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_finished_event_35_comment =
  "C++ Interface:\n"
  "get_finished_event(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_finished_event_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual std::string const &AudioSound::get_name(void) const = 0
 */
static PyObject *Dtool_AudioSound_get_name_36(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual std::string const &AudioSound::get_name(void) const = 0
  std::string const &return_value = (*(const AudioSound*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_name_36_comment =
  "C++ Interface:\n"
  "get_name(AudioSound self)\n"
  "\n"
  "// There is no set_name(), this is intentional.";
#else
static const char *Dtool_AudioSound_get_name_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::length(void) const = 0
 */
static PyObject *Dtool_AudioSound_length_37(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::length(void) const = 0
  PN_stdfloat return_value = (*(const AudioSound*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_length_37_comment =
  "C++ Interface:\n"
  "length(AudioSound self)\n"
  "\n"
  "// return: playing time in seconds.";
#else
static const char *Dtool_AudioSound_length_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_3d_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz)
 */
static PyObject *Dtool_AudioSound_set_3d_attributes_38(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_3d_attributes")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_3d_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  static const char *keyword_list[] = {"px", "py", "pz", "vx", "vy", "vz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_3d_attributes", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
    (*local_this).set_3d_attributes((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_3d_attributes(const AudioSound self, float px, float py, float pz, float vx, float vy, float vz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_3d_attributes_38_comment =
  "C++ Interface:\n"
  "set_3d_attributes(const AudioSound self, float px, float py, float pz, float vx, float vy, float vz)\n"
  "\n"
  "// Controls the position of this sound's emitter.  px, py and pz are the\n"
  "// emitter's position.  vx, vy and vz are the emitter's velocity in UNITS\n"
  "// PER SECOND (default: meters).";
#else
static const char *Dtool_AudioSound_set_3d_attributes_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_3d_min_distance(PN_stdfloat dist)
 */
static PyObject *Dtool_AudioSound_set_3d_min_distance_40(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_3d_min_distance")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_3d_min_distance(PN_stdfloat dist)
  if (PyNumber_Check(arg)) {
    (*local_this).set_3d_min_distance((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_3d_min_distance(const AudioSound self, float dist)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_3d_min_distance_40_comment =
  "C++ Interface:\n"
  "set_3d_min_distance(const AudioSound self, float dist)\n"
  "\n"
  "// Controls the distance (in units) that this sound begins to fall off.\n"
  "// Also affects the rate it falls off.  Default is 1.0 CloserFaster, <1.0\n"
  "// FartherSlower, >1.0";
#else
static const char *Dtool_AudioSound_set_3d_min_distance_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_3d_min_distance(void) const
 */
static PyObject *Dtool_AudioSound_get_3d_min_distance_41(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_3d_min_distance(void) const
  PN_stdfloat return_value = (*(const AudioSound*)local_this).get_3d_min_distance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_3d_min_distance_41_comment =
  "C++ Interface:\n"
  "get_3d_min_distance(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_3d_min_distance_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_3d_max_distance(PN_stdfloat dist)
 */
static PyObject *Dtool_AudioSound_set_3d_max_distance_42(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_3d_max_distance")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_3d_max_distance(PN_stdfloat dist)
  if (PyNumber_Check(arg)) {
    (*local_this).set_3d_max_distance((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_3d_max_distance(const AudioSound self, float dist)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_3d_max_distance_42_comment =
  "C++ Interface:\n"
  "set_3d_max_distance(const AudioSound self, float dist)\n"
  "\n"
  "// Controls the maximum distance (in units) that this sound stops falling\n"
  "// off.  The sound does not stop at that point, it just doesn't get any\n"
  "// quieter.  You should rarely need to adjust this.  Default is 1000000000.0";
#else
static const char *Dtool_AudioSound_set_3d_max_distance_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_3d_max_distance(void) const
 */
static PyObject *Dtool_AudioSound_get_3d_max_distance_43(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_3d_max_distance(void) const
  PN_stdfloat return_value = (*(const AudioSound*)local_this).get_3d_max_distance();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_3d_max_distance_43_comment =
  "C++ Interface:\n"
  "get_3d_max_distance(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_3d_max_distance_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_speaker_mix(int speaker)
 */
static PyObject *Dtool_AudioSound_get_speaker_mix_44(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.get_speaker_mix")) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_speaker_mix(int speaker)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*local_this).get_speaker_mix((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_speaker_mix(const AudioSound self, int speaker)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_speaker_mix_44_comment =
  "C++ Interface:\n"
  "get_speaker_mix(const AudioSound self, int speaker)\n"
  "\n"
  "// *_speaker_mix and *_speaker_level(s) serve the same purpose.\n"
  "// *_speaker_mix is for use with FMOD. *_speaker_level(s) is for use with\n"
  "// Miles.  Both interfaces exist because of a significant difference in the\n"
  "// two APIs.  Hopefully the difference can be reconciled into a single\n"
  "// interface at some point.";
#else
static const char *Dtool_AudioSound_get_speaker_mix_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_speaker_mix(PN_stdfloat frontleft, PN_stdfloat frontright, PN_stdfloat center, PN_stdfloat sub, PN_stdfloat backleft, PN_stdfloat backright, PN_stdfloat sideleft, PN_stdfloat sideright)
 */
static PyObject *Dtool_AudioSound_set_speaker_mix_45(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_speaker_mix")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_speaker_mix(PN_stdfloat frontleft, PN_stdfloat frontright, PN_stdfloat center, PN_stdfloat sub, PN_stdfloat backleft, PN_stdfloat backright, PN_stdfloat sideleft, PN_stdfloat sideright)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  static const char *keyword_list[] = {"frontleft", "frontright", "center", "sub", "backleft", "backright", "sideleft", "sideright", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffff:set_speaker_mix", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8)) {
    (*local_this).set_speaker_mix((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_speaker_mix(const AudioSound self, float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_speaker_mix_45_comment =
  "C++ Interface:\n"
  "set_speaker_mix(const AudioSound self, float frontleft, float frontright, float center, float sub, float backleft, float backright, float sideleft, float sideright)\n";
#else
static const char *Dtool_AudioSound_set_speaker_mix_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioSound::get_speaker_level(int index)
 */
static PyObject *Dtool_AudioSound_get_speaker_level_46(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.get_speaker_level")) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioSound::get_speaker_level(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = (*local_this).get_speaker_level((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_speaker_level(const AudioSound self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_speaker_level_46_comment =
  "C++ Interface:\n"
  "get_speaker_level(const AudioSound self, int index)\n";
#else
static const char *Dtool_AudioSound_get_speaker_level_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_speaker_levels(PN_stdfloat level1, PN_stdfloat level2 = -1.0, PN_stdfloat level3 = -1.0, PN_stdfloat level4 = -1.0, PN_stdfloat level5 = -1.0, PN_stdfloat level6 = -1.0, PN_stdfloat level7 = -1.0, PN_stdfloat level8 = -1.0, PN_stdfloat level9 = -1.0)
 */
static PyObject *Dtool_AudioSound_set_speaker_levels_47(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_speaker_levels")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_speaker_levels(PN_stdfloat level1, PN_stdfloat level2 = -1.0, PN_stdfloat level3 = -1.0, PN_stdfloat level4 = -1.0, PN_stdfloat level5 = -1.0, PN_stdfloat level6 = -1.0, PN_stdfloat level7 = -1.0, PN_stdfloat level8 = -1.0, PN_stdfloat level9 = -1.0)
  float param1;
  float param2 = -1.0;
  float param3 = -1.0;
  float param4 = -1.0;
  float param5 = -1.0;
  float param6 = -1.0;
  float param7 = -1.0;
  float param8 = -1.0;
  float param9 = -1.0;
  static const char *keyword_list[] = {"level1", "level2", "level3", "level4", "level5", "level6", "level7", "level8", "level9", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "f|ffffffff:set_speaker_levels", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    (*local_this).set_speaker_levels((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_speaker_levels(const AudioSound self, float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_speaker_levels_47_comment =
  "C++ Interface:\n"
  "set_speaker_levels(const AudioSound self, float level1, float level2, float level3, float level4, float level5, float level6, float level7, float level8, float level9)\n";
#else
static const char *Dtool_AudioSound_set_speaker_levels_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual int AudioSound::get_priority(void)
 */
static PyObject *Dtool_AudioSound_get_priority_48(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.get_priority")) {
    return NULL;
  }
  // 1-virtual int AudioSound::get_priority(void)
  int return_value = (*local_this).get_priority();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_priority_48_comment =
  "C++ Interface:\n"
  "get_priority(const AudioSound self)\n";
#else
static const char *Dtool_AudioSound_get_priority_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::set_priority(int priority)
 */
static PyObject *Dtool_AudioSound_set_priority_49(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.set_priority")) {
    return NULL;
  }
  // 1-virtual void AudioSound::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_priority((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const AudioSound self, int priority)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_set_priority_49_comment =
  "C++ Interface:\n"
  "set_priority(const AudioSound self, int priority)\n";
#else
static const char *Dtool_AudioSound_set_priority_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioSound::configure_filters(FilterProperties *config)
 */
static PyObject *Dtool_AudioSound_configure_filters_50(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioSound, (void **)&local_this, "AudioSound.configure_filters")) {
    return NULL;
  }
  // 1-virtual bool AudioSound::configure_filters(FilterProperties *config)
  FilterProperties *arg_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FilterProperties, 1, "AudioSound.configure_filters", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).configure_filters(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "configure_filters(const AudioSound self, FilterProperties config)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_configure_filters_50_comment =
  "C++ Interface:\n"
  "configure_filters(const AudioSound self, FilterProperties config)\n";
#else
static const char *Dtool_AudioSound_configure_filters_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual AudioSound::SoundStatus AudioSound::status(void) const = 0
 */
static PyObject *Dtool_AudioSound_status_52(PyObject *self, PyObject *) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual AudioSound::SoundStatus AudioSound::status(void) const = 0
  AudioSound::SoundStatus return_value = (*(const AudioSound*)local_this).status();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_status_52_comment =
  "C++ Interface:\n"
  "status(AudioSound self)\n";
#else
static const char *Dtool_AudioSound_status_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::output(ostream &out) const
 */
static PyObject *Dtool_AudioSound_output_53(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AudioSound::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AudioSound.output", false, true);
  if (arg_this != NULL) {
    (*(const AudioSound*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AudioSound self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_output_53_comment =
  "C++ Interface:\n"
  "output(AudioSound self, ostream out)\n";
#else
static const char *Dtool_AudioSound_output_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioSound::write(ostream &out) const
 */
static PyObject *Dtool_AudioSound_write_54(PyObject *self, PyObject *arg) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AudioSound::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AudioSound.write", false, true);
  if (arg_this != NULL) {
    (*(const AudioSound*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AudioSound self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_write_54_comment =
  "C++ Interface:\n"
  "write(AudioSound self, ostream out)\n";
#else
static const char *Dtool_AudioSound_write_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioSound::get_class_type(void)
 */
static PyObject *Dtool_AudioSound_get_class_type_55(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioSound::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AudioSound::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioSound_get_class_type_55_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioSound_get_class_type_55_comment = NULL;
#endif

static int Dtool_Init_AudioSound(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AudioSound(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AudioSound) {
    printf("AudioSound ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AudioSound *local_this = (AudioSound *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AudioSound) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AudioSound(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AudioSound) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioSound*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioSound*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AudioSound*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AudioManager
 */
/**
 * Python function wrapper for:
 * virtual int AudioManager::getSpeakerSetup(void)
 */
static PyObject *Dtool_AudioManager_getSpeakerSetup_60(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.getSpeakerSetup")) {
    return NULL;
  }
  // 1-virtual int AudioManager::getSpeakerSetup(void)
  int return_value = (*local_this).getSpeakerSetup();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_getSpeakerSetup_60_comment =
  "C++ Interface:\n"
  "getSpeakerSetup(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_getSpeakerSetup_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::setSpeakerSetup(AudioManager::SpeakerModeCategory cat)
 */
static PyObject *Dtool_AudioManager_setSpeakerSetup_61(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.setSpeakerSetup")) {
    return NULL;
  }
  // 1-virtual void AudioManager::setSpeakerSetup(AudioManager::SpeakerModeCategory cat)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).setSpeakerSetup((AudioManager::SpeakerModeCategory)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setSpeakerSetup(const AudioManager self, int cat)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_setSpeakerSetup_61_comment =
  "C++ Interface:\n"
  "setSpeakerSetup(const AudioManager self, int cat)\n";
#else
static const char *Dtool_AudioManager_setSpeakerSetup_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioManager::configure_filters(FilterProperties *config)
 */
static PyObject *Dtool_AudioManager_configure_filters_62(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.configure_filters")) {
    return NULL;
  }
  // 1-virtual bool AudioManager::configure_filters(FilterProperties *config)
  FilterProperties *arg_this = (FilterProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FilterProperties, 1, "AudioManager.configure_filters", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).configure_filters(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "configure_filters(const AudioManager self, FilterProperties config)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_configure_filters_62_comment =
  "C++ Interface:\n"
  "configure_filters(const AudioManager self, FilterProperties config)\n";
#else
static const char *Dtool_AudioManager_configure_filters_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< AudioManager > AudioManager::create_AudioManager(void)
 */
static PyObject *Dtool_AudioManager_create_AudioManager_63(PyObject *, PyObject *) {
  // 1-static PointerTo< AudioManager > AudioManager::create_AudioManager(void)
  PointerTo< AudioManager > return_value = AudioManager::create_AudioManager();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  AudioManager *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioManager, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_create_AudioManager_63_comment =
  "C++ Interface:\n"
  "create_AudioManager()\n";
#else
static const char *Dtool_AudioManager_create_AudioManager_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::shutdown(void)
 */
static PyObject *Dtool_AudioManager_shutdown_64(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.shutdown")) {
    return NULL;
  }
  // 1-virtual void AudioManager::shutdown(void)
  (*local_this).shutdown();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_shutdown_64_comment =
  "C++ Interface:\n"
  "shutdown(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_shutdown_64_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioManager::is_valid(void) = 0
 */
static PyObject *Dtool_AudioManager_is_valid_65(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.is_valid")) {
    return NULL;
  }
  // 1-virtual bool AudioManager::is_valid(void) = 0
  bool return_value = (*local_this).is_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_is_valid_65_comment =
  "C++ Interface:\n"
  "is_valid(const AudioManager self)\n"
  "\n"
  "// If you're interested in knowing whether this audio manager is valid,\n"
  "// here's the call to do it.  It is not necessary to check whether the audio\n"
  "// manager is valid before making other calls.  You are free to use an\n"
  "// invalid sound manager, you may get silent sounds from it though.  The\n"
  "// sound manager and the sounds it creates should not crash the application\n"
  "// even when the objects are not valid.";
#else
static const char *Dtool_AudioManager_is_valid_65_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
 * virtual PointerTo< AudioSound > AudioManager::get_sound(std::string const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
 */
static PyObject *Dtool_AudioManager_get_sound_66(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.get_sound")) {
    return NULL;
  }
  {
    // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
    PyObject *param1;
    PyObject *param2 = Py_False;
    int param3 = AudioManager::SM_heuristic;
    static const char *keyword_list[] = {"source", "positional", "mode", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Oi:get_sound", (char **)keyword_list, &param1, &param2, &param3)) {
      MovieAudio *param1_this = (MovieAudio *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_MovieAudio, 1, "AudioManager.get_sound", false, false);
      if (param1_this != NULL) {
        PointerTo< AudioSound > return_value = (*local_this).get_sound(param1_this, (PyObject_IsTrue(param2) != 0), (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        AudioSound *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(std::string const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    PyObject *param2 = Py_False;
    int param3 = AudioManager::SM_heuristic;
    static const char *keyword_list[] = {"file_name", "positional", "mode", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|Oi:get_sound", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      PointerTo< AudioSound > return_value = (*local_this).get_sound(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0), (int)param3);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      // Transfer ownership of return_value.
      AudioSound *return_ptr = return_value.p();
      return_value.cheat() = NULL;
      if (return_ptr == NULL) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual PointerTo< AudioSound > AudioManager::get_sound(MovieAudio *source, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
    PyObject *param1;
    PyObject *param2 = Py_False;
    int param3 = AudioManager::SM_heuristic;
    static const char *keyword_list[] = {"source", "positional", "mode", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Oi:get_sound", (char **)keyword_list, &param1, &param2, &param3)) {
      PT(MovieAudio) param1_this;
      if (Dtool_Coerce_MovieAudio(param1, param1_this)) {
        PointerTo< AudioSound > return_value = (*local_this).get_sound(MOVE(param1_this), (PyObject_IsTrue(param2) != 0), (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        // Transfer ownership of return_value.
        AudioSound *return_ptr = return_value.p();
        return_value.cheat() = NULL;
        if (return_ptr == NULL) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: virtual PointerTo< AudioSound > AudioManager::get_sound(std::string const &file_name, bool positional = false, int mode = ::AudioManager::SM_heuristic) = 0
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sound(const AudioManager self, MovieAudio source, bool positional, int mode)\n"
      "get_sound(const AudioManager self, str file_name, bool positional, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_sound_66_comment =
  "C++ Interface:\n"
  "get_sound(const AudioManager self, MovieAudio source, bool positional, int mode)\n"
  "get_sound(const AudioManager self, str file_name, bool positional, int mode)\n"
  "\n"
  "// Get a sound:";
#else
static const char *Dtool_AudioManager_get_sound_66_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AudioSound > AudioManager::get_null_sound(void)
 */
static PyObject *Dtool_AudioManager_get_null_sound_67(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.get_null_sound")) {
    return NULL;
  }
  // 1-PointerTo< AudioSound > AudioManager::get_null_sound(void)
  PointerTo< AudioSound > return_value = (*local_this).get_null_sound();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  AudioSound *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AudioSound, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_null_sound_67_comment =
  "C++ Interface:\n"
  "get_null_sound(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_null_sound_67_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::uncache_sound(std::string const &file_name) = 0
 */
static PyObject *Dtool_AudioManager_uncache_sound_68(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.uncache_sound")) {
    return NULL;
  }
  // 1-virtual void AudioManager::uncache_sound(std::string const &file_name) = 0
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).uncache_sound(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "uncache_sound(const AudioManager self, str file_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_uncache_sound_68_comment =
  "C++ Interface:\n"
  "uncache_sound(const AudioManager self, str file_name)\n"
  "\n"
  "// Tell the AudioManager there is no need to keep this one cached.  This\n"
  "// doesn't break any connection between AudioSounds that have already given\n"
  "// by get_sound() from this manager.  It's only affecting whether the\n"
  "// AudioManager keeps a copy of the sound in its poolcache.";
#else
static const char *Dtool_AudioManager_uncache_sound_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::clear_cache(void) = 0
 */
static PyObject *Dtool_AudioManager_clear_cache_69(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.clear_cache")) {
    return NULL;
  }
  // 1-virtual void AudioManager::clear_cache(void) = 0
  (*local_this).clear_cache();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_clear_cache_69_comment =
  "C++ Interface:\n"
  "clear_cache(const AudioManager self)\n";
#else
static const char *Dtool_AudioManager_clear_cache_69_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_cache_limit(unsigned int count) = 0
 */
static PyObject *Dtool_AudioManager_set_cache_limit_70(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_cache_limit")) {
    return NULL;
  }
  // 1-virtual void AudioManager::set_cache_limit(unsigned int count) = 0
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).set_cache_limit((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_limit(const AudioManager self, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_cache_limit_70_comment =
  "C++ Interface:\n"
  "set_cache_limit(const AudioManager self, int count)\n";
#else
static const char *Dtool_AudioManager_set_cache_limit_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual unsigned int AudioManager::get_cache_limit(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_cache_limit_71(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual unsigned int AudioManager::get_cache_limit(void) const = 0
  unsigned int return_value = (*(const AudioManager*)local_this).get_cache_limit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_cache_limit_71_comment =
  "C++ Interface:\n"
  "get_cache_limit(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_cache_limit_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_volume(PN_stdfloat volume) = 0
 */
static PyObject *Dtool_AudioManager_set_volume_72(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_volume")) {
    return NULL;
  }
  // 1-virtual void AudioManager::set_volume(PN_stdfloat volume) = 0
  if (PyNumber_Check(arg)) {
    (*local_this).set_volume((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_volume(const AudioManager self, float volume)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_volume_72_comment =
  "C++ Interface:\n"
  "set_volume(const AudioManager self, float volume)\n"
  "\n"
  "// Control volume: FYI: If you start a sound with the volume off and turn\n"
  "// the volume up later, you'll hear the sound playing at that late point.  0\n"
  "// = minimum; 1.0 = maximum.  inits to 1.0.";
#else
static const char *Dtool_AudioManager_set_volume_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::get_volume(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_volume_73(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioManager::get_volume(void) const = 0
  PN_stdfloat return_value = (*(const AudioManager*)local_this).get_volume();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_volume_73_comment =
  "C++ Interface:\n"
  "get_volume(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_volume_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_active(bool flag) = 0
 */
static PyObject *Dtool_AudioManager_set_active_74(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_active")) {
    return NULL;
  }
  // 1-virtual void AudioManager::set_active(bool flag) = 0
  (*local_this).set_active((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const AudioManager self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_active_74_comment =
  "C++ Interface:\n"
  "set_active(const AudioManager self, bool flag)\n"
  "\n"
  "/*\n"
  " * Turn the manager on or off.  If you play a sound while the manager is\n"
  " * inactive, it won't start.  If you deactivate the manager while sounds are\n"
  " * playing, they'll stop.  If you activate the manager while looping sounds\n"
  " * are playing (those that have a loop_count of zero), they will start playing\n"
  " * from the beginning of their loop.  inits to true.\n"
  " */";
#else
static const char *Dtool_AudioManager_set_active_74_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool AudioManager::get_active(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_active_75(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool AudioManager::get_active(void) const = 0
  bool return_value = (*(const AudioManager*)local_this).get_active();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_active_75_comment =
  "C++ Interface:\n"
  "get_active(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_active_75_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = 0) = 0
 */
static PyObject *Dtool_AudioManager_set_concurrent_sound_limit_76(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_concurrent_sound_limit")) {
    return NULL;
  }
  // 1-virtual void AudioManager::set_concurrent_sound_limit(unsigned int limit = 0) = 0
  unsigned long param1 = 0;
  static const char *keyword_list[] = {"limit", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|k:set_concurrent_sound_limit", (char **)keyword_list, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).set_concurrent_sound_limit((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_concurrent_sound_limit(const AudioManager self, int limit)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_concurrent_sound_limit_76_comment =
  "C++ Interface:\n"
  "set_concurrent_sound_limit(const AudioManager self, int limit)\n"
  "\n"
  "// This controls the number of sounds that you allow at once.  This is more\n"
  "// of a user choice -- it avoids talk over and the creation of a cacophony.\n"
  "// It can also be used to help performance.  0 == unlimited.  1 == mutually\n"
  "// exclusive (one sound at a time).  Which is an example of: n == allow n\n"
  "// sounds to be playing at the same time.";
#else
static const char *Dtool_AudioManager_set_concurrent_sound_limit_76_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0
 */
static PyObject *Dtool_AudioManager_get_concurrent_sound_limit_77(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual unsigned int AudioManager::get_concurrent_sound_limit(void) const = 0
  unsigned int return_value = (*(const AudioManager*)local_this).get_concurrent_sound_limit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_concurrent_sound_limit_77_comment =
  "C++ Interface:\n"
  "get_concurrent_sound_limit(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_get_concurrent_sound_limit_77_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0
 */
static PyObject *Dtool_AudioManager_reduce_sounds_playing_to_78(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.reduce_sounds_playing_to")) {
    return NULL;
  }
  // 1-virtual void AudioManager::reduce_sounds_playing_to(unsigned int count) = 0
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).reduce_sounds_playing_to((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reduce_sounds_playing_to(const AudioManager self, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_reduce_sounds_playing_to_78_comment =
  "C++ Interface:\n"
  "reduce_sounds_playing_to(const AudioManager self, int count)\n"
  "\n"
  "// This is likely to be a utility function for the concurrent_sound_limit\n"
  "// options.  It is exposed as an API, because it's reasonable that it may be\n"
  "// useful to be here.  It reduces the number of concurrently playing sounds\n"
  "// to count by some implementation specific means.  If the number of sounds\n"
  "// currently playing is at or below count then there is no effect.";
#else
static const char *Dtool_AudioManager_reduce_sounds_playing_to_78_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::stop_all_sounds(void) = 0
 */
static PyObject *Dtool_AudioManager_stop_all_sounds_79(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.stop_all_sounds")) {
    return NULL;
  }
  // 1-virtual void AudioManager::stop_all_sounds(void) = 0
  (*local_this).stop_all_sounds();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_stop_all_sounds_79_comment =
  "C++ Interface:\n"
  "stop_all_sounds(const AudioManager self)\n"
  "\n"
  "// Stop playback on all sounds managed by this manager.  This is effectively\n"
  "// the same as reduce_sounds_playing_to(0), but this call may be for\n"
  "// efficient on some implementations.";
#else
static const char *Dtool_AudioManager_stop_all_sounds_79_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::update(void)
 */
static PyObject *Dtool_AudioManager_update_80(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.update")) {
    return NULL;
  }
  // 1-virtual void AudioManager::update(void)
  (*local_this).update();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_update_80_comment =
  "C++ Interface:\n"
  "update(const AudioManager self)\n"
  "\n"
  "// This should be called every frame.  Failure to call could cause problems.";
#else
static const char *Dtool_AudioManager_update_80_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_listener_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz, PN_stdfloat fx, PN_stdfloat fy, PN_stdfloat fz, PN_stdfloat ux, PN_stdfloat uy, PN_stdfloat uz)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_listener_attributes_81(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_listener_attributes")) {
    return NULL;
  }
  // 1-virtual void AudioManager::audio_3d_set_listener_attributes(PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat vx, PN_stdfloat vy, PN_stdfloat vz, PN_stdfloat fx, PN_stdfloat fy, PN_stdfloat fz, PN_stdfloat ux, PN_stdfloat uy, PN_stdfloat uz)
  float param1;
  float param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  float param10;
  float param11;
  float param12;
  static const char *keyword_list[] = {"px", "py", "pz", "vx", "vy", "vz", "fx", "fy", "fz", "ux", "uy", "uz", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffffff:audio_3d_set_listener_attributes", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12)) {
    (*local_this).audio_3d_set_listener_attributes((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6, (PN_stdfloat)param7, (PN_stdfloat)param8, (PN_stdfloat)param9, (PN_stdfloat)param10, (PN_stdfloat)param11, (PN_stdfloat)param12);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_listener_attributes(const AudioManager self, float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment =
  "C++ Interface:\n"
  "audio_3d_set_listener_attributes(const AudioManager self, float px, float py, float pz, float vx, float vy, float vz, float fx, float fy, float fz, float ux, float uy, float uz)\n"
  "\n"
  "// This controls the \"set of ears\" that listens to 3D spacialized sound px,\n"
  "// py, pz are position coordinates.  vx, vy, vz are a velocity vector in\n"
  "// UNITS PER SECOND (default: meters). fx, fy and fz are the respective\n"
  "// components of a unit forward-vector ux, uy and uz are the respective\n"
  "// components of a unit up-vector";
#else
static const char *Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_distance_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_distance_factor_83(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_distance_factor")) {
    return NULL;
  }
  // 1-virtual void AudioManager::audio_3d_set_distance_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    (*local_this).audio_3d_set_distance_factor((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_distance_factor(const AudioManager self, float factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_distance_factor_83_comment =
  "C++ Interface:\n"
  "audio_3d_set_distance_factor(const AudioManager self, float factor)\n"
  "\n"
  "// Control the \"relative scale that sets the distance factor\" units for 3D\n"
  "// spacialized audio.  Default is 1.0 Fmod uses meters internally, so give a\n"
  "// float in Units-per meter Don't know what Miles uses.  Default is 1.0\n"
  "// which is adjust in panda to be feet.";
#else
static const char *Dtool_AudioManager_audio_3d_set_distance_factor_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::audio_3d_get_distance_factor(void) const
 */
static PyObject *Dtool_AudioManager_audio_3d_get_distance_factor_84(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioManager::audio_3d_get_distance_factor(void) const
  PN_stdfloat return_value = (*(const AudioManager*)local_this).audio_3d_get_distance_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_get_distance_factor_84_comment =
  "C++ Interface:\n"
  "audio_3d_get_distance_factor(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_audio_3d_get_distance_factor_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_doppler_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_doppler_factor_85(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_doppler_factor")) {
    return NULL;
  }
  // 1-virtual void AudioManager::audio_3d_set_doppler_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    (*local_this).audio_3d_set_doppler_factor((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_doppler_factor(const AudioManager self, float factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment =
  "C++ Interface:\n"
  "audio_3d_set_doppler_factor(const AudioManager self, float factor)\n"
  "\n"
  "// Control the presence of the Doppler effect.  Default is 1.0 Exaggerated\n"
  "// Doppler, use >1.0 Diminshed Doppler, use <1.0";
#else
static const char *Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::audio_3d_get_doppler_factor(void) const
 */
static PyObject *Dtool_AudioManager_audio_3d_get_doppler_factor_86(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioManager::audio_3d_get_doppler_factor(void) const
  PN_stdfloat return_value = (*(const AudioManager*)local_this).audio_3d_get_doppler_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment =
  "C++ Interface:\n"
  "audio_3d_get_doppler_factor(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::audio_3d_set_drop_off_factor(PN_stdfloat factor)
 */
static PyObject *Dtool_AudioManager_audio_3d_set_drop_off_factor_87(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.audio_3d_set_drop_off_factor")) {
    return NULL;
  }
  // 1-virtual void AudioManager::audio_3d_set_drop_off_factor(PN_stdfloat factor)
  if (PyNumber_Check(arg)) {
    (*local_this).audio_3d_set_drop_off_factor((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "audio_3d_set_drop_off_factor(const AudioManager self, float factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment =
  "C++ Interface:\n"
  "audio_3d_set_drop_off_factor(const AudioManager self, float factor)\n"
  "\n"
  "// Exaggerate or diminish the effect of distance on sound.  Default is 1.0\n"
  "// Valid range is 0 to 10 Faster drop off, use >1.0 Slower drop off, use\n"
  "// <1.0";
#else
static const char *Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual PN_stdfloat AudioManager::audio_3d_get_drop_off_factor(void) const
 */
static PyObject *Dtool_AudioManager_audio_3d_get_drop_off_factor_88(PyObject *self, PyObject *) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual PN_stdfloat AudioManager::audio_3d_get_drop_off_factor(void) const
  PN_stdfloat return_value = (*(const AudioManager*)local_this).audio_3d_get_drop_off_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment =
  "C++ Interface:\n"
  "audio_3d_get_drop_off_factor(AudioManager self)\n";
#else
static const char *Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename AudioManager::get_dls_pathname(void)
 */
static PyObject *Dtool_AudioManager_get_dls_pathname_89(PyObject *, PyObject *) {
  // 1-static Filename AudioManager::get_dls_pathname(void)
  Filename *return_value = new Filename(AudioManager::get_dls_pathname());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_dls_pathname_89_comment =
  "C++ Interface:\n"
  "get_dls_pathname()\n";
#else
static const char *Dtool_AudioManager_get_dls_pathname_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::output(ostream &out) const
 */
static PyObject *Dtool_AudioManager_output_90(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AudioManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AudioManager.output", false, true);
  if (arg_this != NULL) {
    (*(const AudioManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AudioManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_output_90_comment =
  "C++ Interface:\n"
  "output(AudioManager self, ostream out)\n";
#else
static const char *Dtool_AudioManager_output_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::write(ostream &out) const
 */
static PyObject *Dtool_AudioManager_write_91(PyObject *self, PyObject *arg) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void AudioManager::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "AudioManager.write", false, true);
  if (arg_this != NULL) {
    (*(const AudioManager*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AudioManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_write_91_comment =
  "C++ Interface:\n"
  "write(AudioManager self, ostream out)\n";
#else
static const char *Dtool_AudioManager_write_91_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void AudioManager::set_speaker_configuration(LVecBase3 *speaker1, LVecBase3 *speaker2 = 0, LVecBase3 *speaker3 = 0, LVecBase3 *speaker4 = 0, LVecBase3 *speaker5 = 0, LVecBase3 *speaker6 = 0, LVecBase3 *speaker7 = 0, LVecBase3 *speaker8 = 0, LVecBase3 *speaker9 = 0)
 */
static PyObject *Dtool_AudioManager_set_speaker_configuration_92(PyObject *self, PyObject *args, PyObject *kwds) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AudioManager, (void **)&local_this, "AudioManager.set_speaker_configuration")) {
    return NULL;
  }
  // 1-virtual void AudioManager::set_speaker_configuration(LVecBase3 *speaker1, LVecBase3 *speaker2 = 0, LVecBase3 *speaker3 = 0, LVecBase3 *speaker4 = 0, LVecBase3 *speaker5 = 0, LVecBase3 *speaker6 = 0, LVecBase3 *speaker7 = 0, LVecBase3 *speaker8 = 0, LVecBase3 *speaker9 = 0)
  PyObject *param1;
  PyObject *param2 = NULL;
  PyObject *param3 = NULL;
  PyObject *param4 = NULL;
  PyObject *param5 = NULL;
  PyObject *param6 = NULL;
  PyObject *param7 = NULL;
  PyObject *param8 = NULL;
  PyObject *param9 = NULL;
  static const char *keyword_list[] = {"speaker1", "speaker2", "speaker3", "speaker4", "speaker5", "speaker6", "speaker7", "speaker8", "speaker9", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OOOOOOOO:set_speaker_configuration", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
    LVecBase3f param1_local;
    LVecBase3 *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3 *param2_this = 0;
    if (param2 != NULL) {
      param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    }
    if (param2 != NULL && !(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 *param3_this = 0;
    if (param3 != NULL) {
      param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    }
    if (param3 != NULL && !(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param4_local;
    LVecBase3 *param4_this = 0;
    if (param4 != NULL) {
      param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
    }
    if (param4 != NULL && !(param4_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param5_local;
    LVecBase3 *param5_this = 0;
    if (param5 != NULL) {
      param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
    }
    if (param5 != NULL && !(param5_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param6_local;
    LVecBase3 *param6_this = 0;
    if (param6 != NULL) {
      param6_this = Dtool_Coerce_LVecBase3f(param6, param6_local);
    }
    if (param6 != NULL && !(param6_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param6, 6, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param7_local;
    LVecBase3 *param7_this = 0;
    if (param7 != NULL) {
      param7_this = Dtool_Coerce_LVecBase3f(param7, param7_local);
    }
    if (param7 != NULL && !(param7_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param7, 7, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param8_local;
    LVecBase3 *param8_this = 0;
    if (param8 != NULL) {
      param8_this = Dtool_Coerce_LVecBase3f(param8, param8_local);
    }
    if (param8 != NULL && !(param8_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param8, 8, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    LVecBase3f param9_local;
    LVecBase3 *param9_this = 0;
    if (param9 != NULL) {
      param9_this = Dtool_Coerce_LVecBase3f(param9, param9_local);
    }
    if (param9 != NULL && !(param9_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param9, 9, "AudioManager.set_speaker_configuration", "LVecBase3f");
    }
    (*local_this).set_speaker_configuration(param1_this, param2_this, param3_this, param4_this, param5_this, param6_this, param7_this, param8_this, param9_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_speaker_configuration(const AudioManager self, LVecBase3f speaker1, LVecBase3f speaker2, LVecBase3f speaker3, LVecBase3f speaker4, LVecBase3f speaker5, LVecBase3f speaker6, LVecBase3f speaker7, LVecBase3f speaker8, LVecBase3f speaker9)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_set_speaker_configuration_92_comment =
  "C++ Interface:\n"
  "set_speaker_configuration(const AudioManager self, LVecBase3f speaker1, LVecBase3f speaker2, LVecBase3f speaker3, LVecBase3f speaker4, LVecBase3f speaker5, LVecBase3f speaker6, LVecBase3f speaker7, LVecBase3f speaker8, LVecBase3f speaker9)\n"
  "\n"
  "// set_speaker_configuration is a Miles only method.";
#else
static const char *Dtool_AudioManager_set_speaker_configuration_92_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioManager::get_class_type(void)
 */
static PyObject *Dtool_AudioManager_get_class_type_93(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioManager::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AudioManager::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioManager_get_class_type_93_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioManager_get_class_type_93_comment = NULL;
#endif

static int Dtool_Init_AudioManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AudioManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AudioManager) {
    printf("AudioManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AudioManager *local_this = (AudioManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AudioManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AudioManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AudioManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AudioManager*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class AudioLoadRequest
 */
/**
 * Python function wrapper for:
 * inline AudioManager *AudioLoadRequest::get_audio_manager(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_audio_manager_97(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioLoadRequest, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AudioManager *AudioLoadRequest::get_audio_manager(void) const
  AudioManager *return_value = (*(const AudioLoadRequest*)local_this).get_audio_manager();
  if (return_value != (AudioManager *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AudioManager *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AudioManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_audio_manager_97_comment =
  "C++ Interface:\n"
  "get_audio_manager(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the AudioManager that will serve this asynchronous\n"
  " * AudioLoadRequest.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_audio_manager_97_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &AudioLoadRequest::get_filename(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_filename_98(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioLoadRequest, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &AudioLoadRequest::get_filename(void) const
  std::string const &return_value = (*(const AudioLoadRequest*)local_this).get_filename();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_filename_98_comment =
  "C++ Interface:\n"
  "get_filename(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the filename associated with this asynchronous AudioLoadRequest.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_filename_98_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AudioLoadRequest::get_positional(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_positional_99(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioLoadRequest, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AudioLoadRequest::get_positional(void) const
  bool return_value = (*(const AudioLoadRequest*)local_this).get_positional();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_positional_99_comment =
  "C++ Interface:\n"
  "get_positional(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the positional flag associated with this asynchronous\n"
  " * AudioLoadRequest.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_positional_99_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool AudioLoadRequest::is_ready(void) const
 */
static PyObject *Dtool_AudioLoadRequest_is_ready_100(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioLoadRequest, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool AudioLoadRequest::is_ready(void) const
  bool return_value = (*(const AudioLoadRequest*)local_this).is_ready();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_is_ready_100_comment =
  "C++ Interface:\n"
  "is_ready(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns true if this request has completed, false if it is still pending.\n"
  " * When this returns true, you may retrieve the sound loaded by calling\n"
  " * get_sound().\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_is_ready_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AudioSound *AudioLoadRequest::get_sound(void) const
 */
static PyObject *Dtool_AudioLoadRequest_get_sound_101(PyObject *self, PyObject *) {
  AudioLoadRequest *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioLoadRequest, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline AudioSound *AudioLoadRequest::get_sound(void) const
  AudioSound *return_value = (*(const AudioLoadRequest*)local_this).get_sound();
  if (return_value != (AudioSound *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (AudioSound *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AudioSound, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_sound_101_comment =
  "C++ Interface:\n"
  "get_sound(AudioLoadRequest self)\n"
  "\n"
  "/**\n"
  " * Returns the sound that was loaded asynchronously, if any, or NULL if there\n"
  " * was an error.  It is an error to call this unless is_ready() returns true.\n"
  " */";
#else
static const char *Dtool_AudioLoadRequest_get_sound_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AudioLoadRequest::get_class_type(void)
 */
static PyObject *Dtool_AudioLoadRequest_get_class_type_102(PyObject *, PyObject *) {
  // 1-static TypeHandle AudioLoadRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(AudioLoadRequest::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AudioLoadRequest_get_class_type_102_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AudioLoadRequest_get_class_type_102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline AudioLoadRequest::AudioLoadRequest(AudioLoadRequest const &) = default
 * inline AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional)
 */
static int Dtool_Init_AudioLoadRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline AudioLoadRequest::AudioLoadRequest(AudioLoadRequest const &) = default
      CPT(AudioLoadRequest) arg_this;
      if (!Dtool_ConstCoerce_AudioLoadRequest(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "AudioLoadRequest.AudioLoadRequest", "AudioLoadRequest");
        return -1;
      }
      AudioLoadRequest *return_value = new AudioLoadRequest(*MOVE(arg_this));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AudioLoadRequest, true, false);
    }
    break;
  case 3:
    {
      // 1-inline AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      static const char *keyword_list[] = {"audio_manager", "filename", "positional", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#O:AudioLoadRequest", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2)) {
        AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "AudioLoadRequest.AudioLoadRequest", false, true);
        if (param0_this != NULL) {
          AudioLoadRequest *return_value = new AudioLoadRequest(param0_this, std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AudioLoadRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AudioLoadRequest() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AudioLoadRequest(const AudioLoadRequest param0)\n"
      "AudioLoadRequest(AudioManager audio_manager, str filename, bool positional)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AudioLoadRequest(PyObject *args, CPT(AudioLoadRequest) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AudioLoadRequest, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "Os#O:AudioLoadRequest", &param0, &param1_str, &param1_len, &param2)) {
        AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "AudioLoadRequest.AudioLoadRequest", false, false);
        if (param0_this != NULL) {
          AudioLoadRequest *return_value = new AudioLoadRequest(param0_this, std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AudioLoadRequest(PyObject *args, PT(AudioLoadRequest) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_AudioLoadRequest, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline AudioLoadRequest::AudioLoadRequest(AudioManager *audio_manager, std::string const &filename, bool positional)
      PyObject *param0;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      PyObject *param2;
      if (PyArg_ParseTuple(args, "Os#O:AudioLoadRequest", &param0, &param1_str, &param1_len, &param2)) {
        AudioManager *param0_this = (AudioManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AudioManager, 0, "AudioLoadRequest.AudioLoadRequest", false, false);
        if (param0_this != NULL) {
          AudioLoadRequest *return_value = new AudioLoadRequest(param0_this, std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = MOVE(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AudioLoadRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_AudioLoadRequest) {
    printf("AudioLoadRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  AudioLoadRequest *local_this = (AudioLoadRequest *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_AudioLoadRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskBase) {
    return (AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncTaskBase *)(AsyncTask *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_AudioLoadRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_AudioLoadRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskBase) {
    AsyncTaskBase* other_this = (AsyncTaskBase*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AudioLoadRequest*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for FilterProperties (FilterProperties)
 */
static PyMethodDef Dtool_Methods_FilterProperties[] = {
  {"clear", &Dtool_FilterProperties_clear_4, METH_NOARGS, (const char *)Dtool_FilterProperties_clear_4_comment},
  {"add_lowpass", (PyCFunction) &Dtool_FilterProperties_add_lowpass_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_lowpass_5_comment},
  {"addLowpass", (PyCFunction) &Dtool_FilterProperties_add_lowpass_5, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_lowpass_5_comment},
  {"add_highpass", (PyCFunction) &Dtool_FilterProperties_add_highpass_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_highpass_6_comment},
  {"addHighpass", (PyCFunction) &Dtool_FilterProperties_add_highpass_6, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_highpass_6_comment},
  {"add_echo", (PyCFunction) &Dtool_FilterProperties_add_echo_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_echo_7_comment},
  {"addEcho", (PyCFunction) &Dtool_FilterProperties_add_echo_7, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_echo_7_comment},
  {"add_flange", (PyCFunction) &Dtool_FilterProperties_add_flange_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_flange_8_comment},
  {"addFlange", (PyCFunction) &Dtool_FilterProperties_add_flange_8, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_flange_8_comment},
  {"add_distort", &Dtool_FilterProperties_add_distort_9, METH_O, (const char *)Dtool_FilterProperties_add_distort_9_comment},
  {"addDistort", &Dtool_FilterProperties_add_distort_9, METH_O, (const char *)Dtool_FilterProperties_add_distort_9_comment},
  {"add_normalize", (PyCFunction) &Dtool_FilterProperties_add_normalize_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_normalize_10_comment},
  {"addNormalize", (PyCFunction) &Dtool_FilterProperties_add_normalize_10, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_normalize_10_comment},
  {"add_parameq", (PyCFunction) &Dtool_FilterProperties_add_parameq_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_parameq_11_comment},
  {"addParameq", (PyCFunction) &Dtool_FilterProperties_add_parameq_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_parameq_11_comment},
  {"add_pitchshift", (PyCFunction) &Dtool_FilterProperties_add_pitchshift_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_pitchshift_12_comment},
  {"addPitchshift", (PyCFunction) &Dtool_FilterProperties_add_pitchshift_12, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_pitchshift_12_comment},
  {"add_chorus", (PyCFunction) &Dtool_FilterProperties_add_chorus_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_chorus_13_comment},
  {"addChorus", (PyCFunction) &Dtool_FilterProperties_add_chorus_13, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_chorus_13_comment},
  {"add_sfxreverb", (PyCFunction) &Dtool_FilterProperties_add_sfxreverb_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_sfxreverb_14_comment},
  {"addSfxreverb", (PyCFunction) &Dtool_FilterProperties_add_sfxreverb_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_sfxreverb_14_comment},
  {"add_compress", (PyCFunction) &Dtool_FilterProperties_add_compress_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_compress_15_comment},
  {"addCompress", (PyCFunction) &Dtool_FilterProperties_add_compress_15, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FilterProperties_add_compress_15_comment},
  {"get_class_type", &Dtool_FilterProperties_get_class_type_16, METH_NOARGS | METH_STATIC, (const char *)Dtool_FilterProperties_get_class_type_16_comment},
  {"getClassType", &Dtool_FilterProperties_get_class_type_16, METH_NOARGS | METH_STATIC, (const char *)Dtool_FilterProperties_get_class_type_16_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FilterProperties = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FilterProperties = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FilterProperties = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FilterProperties = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FilterProperties = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FilterProperties",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FilterProperties,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FilterProperties,
    &Dtool_SequenceMethods_FilterProperties,
    &Dtool_MappingMethods_FilterProperties,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FilterProperties,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FilterProperties,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FilterProperties,
    PyType_GenericAlloc,
    Dtool_new_FilterProperties,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FilterProperties,
  Dtool_UpcastInterface_FilterProperties,
  Dtool_DowncastInterface_FilterProperties,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_FilterProperties(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_FilterProperties._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_FilterProperties._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FilterProperties) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FilterProperties)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FilterProperties);
  }
}

/**
 * Python method tables for AudioSound (AudioSound)
 */
static PyMethodDef Dtool_Methods_AudioSound[] = {
  {"play", &Dtool_AudioSound_play_18, METH_NOARGS, (const char *)Dtool_AudioSound_play_18_comment},
  {"stop", &Dtool_AudioSound_stop_19, METH_NOARGS, (const char *)Dtool_AudioSound_stop_19_comment},
  {"set_loop", (PyCFunction) &Dtool_AudioSound_set_loop_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_20_comment},
  {"setLoop", (PyCFunction) &Dtool_AudioSound_set_loop_20, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_20_comment},
  {"get_loop", &Dtool_AudioSound_get_loop_21, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_21_comment},
  {"getLoop", &Dtool_AudioSound_get_loop_21, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_21_comment},
  {"set_loop_count", (PyCFunction) &Dtool_AudioSound_set_loop_count_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_count_22_comment},
  {"setLoopCount", (PyCFunction) &Dtool_AudioSound_set_loop_count_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_loop_count_22_comment},
  {"get_loop_count", &Dtool_AudioSound_get_loop_count_23, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_count_23_comment},
  {"getLoopCount", &Dtool_AudioSound_get_loop_count_23, METH_NOARGS, (const char *)Dtool_AudioSound_get_loop_count_23_comment},
  {"set_time", (PyCFunction) &Dtool_AudioSound_set_time_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_time_24_comment},
  {"setTime", (PyCFunction) &Dtool_AudioSound_set_time_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_time_24_comment},
  {"get_time", &Dtool_AudioSound_get_time_25, METH_NOARGS, (const char *)Dtool_AudioSound_get_time_25_comment},
  {"getTime", &Dtool_AudioSound_get_time_25, METH_NOARGS, (const char *)Dtool_AudioSound_get_time_25_comment},
  {"set_volume", (PyCFunction) &Dtool_AudioSound_set_volume_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_volume_26_comment},
  {"setVolume", (PyCFunction) &Dtool_AudioSound_set_volume_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_volume_26_comment},
  {"get_volume", &Dtool_AudioSound_get_volume_27, METH_NOARGS, (const char *)Dtool_AudioSound_get_volume_27_comment},
  {"getVolume", &Dtool_AudioSound_get_volume_27, METH_NOARGS, (const char *)Dtool_AudioSound_get_volume_27_comment},
  {"set_balance", (PyCFunction) &Dtool_AudioSound_set_balance_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_balance_28_comment},
  {"setBalance", (PyCFunction) &Dtool_AudioSound_set_balance_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_balance_28_comment},
  {"get_balance", &Dtool_AudioSound_get_balance_29, METH_NOARGS, (const char *)Dtool_AudioSound_get_balance_29_comment},
  {"getBalance", &Dtool_AudioSound_get_balance_29, METH_NOARGS, (const char *)Dtool_AudioSound_get_balance_29_comment},
  {"set_play_rate", (PyCFunction) &Dtool_AudioSound_set_play_rate_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_play_rate_30_comment},
  {"setPlayRate", (PyCFunction) &Dtool_AudioSound_set_play_rate_30, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_play_rate_30_comment},
  {"get_play_rate", &Dtool_AudioSound_get_play_rate_31, METH_NOARGS, (const char *)Dtool_AudioSound_get_play_rate_31_comment},
  {"getPlayRate", &Dtool_AudioSound_get_play_rate_31, METH_NOARGS, (const char *)Dtool_AudioSound_get_play_rate_31_comment},
  {"set_active", (PyCFunction) &Dtool_AudioSound_set_active_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_active_32_comment},
  {"setActive", (PyCFunction) &Dtool_AudioSound_set_active_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_active_32_comment},
  {"get_active", &Dtool_AudioSound_get_active_33, METH_NOARGS, (const char *)Dtool_AudioSound_get_active_33_comment},
  {"getActive", &Dtool_AudioSound_get_active_33, METH_NOARGS, (const char *)Dtool_AudioSound_get_active_33_comment},
  {"set_finished_event", &Dtool_AudioSound_set_finished_event_34, METH_O, (const char *)Dtool_AudioSound_set_finished_event_34_comment},
  {"setFinishedEvent", &Dtool_AudioSound_set_finished_event_34, METH_O, (const char *)Dtool_AudioSound_set_finished_event_34_comment},
  {"get_finished_event", &Dtool_AudioSound_get_finished_event_35, METH_NOARGS, (const char *)Dtool_AudioSound_get_finished_event_35_comment},
  {"getFinishedEvent", &Dtool_AudioSound_get_finished_event_35, METH_NOARGS, (const char *)Dtool_AudioSound_get_finished_event_35_comment},
  {"get_name", &Dtool_AudioSound_get_name_36, METH_NOARGS, (const char *)Dtool_AudioSound_get_name_36_comment},
  {"getName", &Dtool_AudioSound_get_name_36, METH_NOARGS, (const char *)Dtool_AudioSound_get_name_36_comment},
  {"length", &Dtool_AudioSound_length_37, METH_NOARGS, (const char *)Dtool_AudioSound_length_37_comment},
  {"set_3d_attributes", (PyCFunction) &Dtool_AudioSound_set_3d_attributes_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_3d_attributes_38_comment},
  {"set3dAttributes", (PyCFunction) &Dtool_AudioSound_set_3d_attributes_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_3d_attributes_38_comment},
  {"set_3d_min_distance", &Dtool_AudioSound_set_3d_min_distance_40, METH_O, (const char *)Dtool_AudioSound_set_3d_min_distance_40_comment},
  {"set3dMinDistance", &Dtool_AudioSound_set_3d_min_distance_40, METH_O, (const char *)Dtool_AudioSound_set_3d_min_distance_40_comment},
  {"get_3d_min_distance", &Dtool_AudioSound_get_3d_min_distance_41, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_min_distance_41_comment},
  {"get3dMinDistance", &Dtool_AudioSound_get_3d_min_distance_41, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_min_distance_41_comment},
  {"set_3d_max_distance", &Dtool_AudioSound_set_3d_max_distance_42, METH_O, (const char *)Dtool_AudioSound_set_3d_max_distance_42_comment},
  {"set3dMaxDistance", &Dtool_AudioSound_set_3d_max_distance_42, METH_O, (const char *)Dtool_AudioSound_set_3d_max_distance_42_comment},
  {"get_3d_max_distance", &Dtool_AudioSound_get_3d_max_distance_43, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_max_distance_43_comment},
  {"get3dMaxDistance", &Dtool_AudioSound_get_3d_max_distance_43, METH_NOARGS, (const char *)Dtool_AudioSound_get_3d_max_distance_43_comment},
  {"get_speaker_mix", &Dtool_AudioSound_get_speaker_mix_44, METH_O, (const char *)Dtool_AudioSound_get_speaker_mix_44_comment},
  {"getSpeakerMix", &Dtool_AudioSound_get_speaker_mix_44, METH_O, (const char *)Dtool_AudioSound_get_speaker_mix_44_comment},
  {"set_speaker_mix", (PyCFunction) &Dtool_AudioSound_set_speaker_mix_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_speaker_mix_45_comment},
  {"setSpeakerMix", (PyCFunction) &Dtool_AudioSound_set_speaker_mix_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_speaker_mix_45_comment},
  {"get_speaker_level", &Dtool_AudioSound_get_speaker_level_46, METH_O, (const char *)Dtool_AudioSound_get_speaker_level_46_comment},
  {"getSpeakerLevel", &Dtool_AudioSound_get_speaker_level_46, METH_O, (const char *)Dtool_AudioSound_get_speaker_level_46_comment},
  {"set_speaker_levels", (PyCFunction) &Dtool_AudioSound_set_speaker_levels_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_speaker_levels_47_comment},
  {"setSpeakerLevels", (PyCFunction) &Dtool_AudioSound_set_speaker_levels_47, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioSound_set_speaker_levels_47_comment},
  {"get_priority", &Dtool_AudioSound_get_priority_48, METH_NOARGS, (const char *)Dtool_AudioSound_get_priority_48_comment},
  {"getPriority", &Dtool_AudioSound_get_priority_48, METH_NOARGS, (const char *)Dtool_AudioSound_get_priority_48_comment},
  {"set_priority", &Dtool_AudioSound_set_priority_49, METH_O, (const char *)Dtool_AudioSound_set_priority_49_comment},
  {"setPriority", &Dtool_AudioSound_set_priority_49, METH_O, (const char *)Dtool_AudioSound_set_priority_49_comment},
  {"configure_filters", &Dtool_AudioSound_configure_filters_50, METH_O, (const char *)Dtool_AudioSound_configure_filters_50_comment},
  {"configureFilters", &Dtool_AudioSound_configure_filters_50, METH_O, (const char *)Dtool_AudioSound_configure_filters_50_comment},
  {"status", &Dtool_AudioSound_status_52, METH_NOARGS, (const char *)Dtool_AudioSound_status_52_comment},
  {"output", &Dtool_AudioSound_output_53, METH_O, (const char *)Dtool_AudioSound_output_53_comment},
  {"write", &Dtool_AudioSound_write_54, METH_O, (const char *)Dtool_AudioSound_write_54_comment},
  {"get_class_type", &Dtool_AudioSound_get_class_type_55, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioSound_get_class_type_55_comment},
  {"getClassType", &Dtool_AudioSound_get_class_type_55, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioSound_get_class_type_55_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AudioSound
//////////////////
static PyObject *Dtool_Repr_AudioSound(PyObject *self) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AudioSound
//////////////////
static PyObject *Dtool_Str_AudioSound(PyObject *self) {
  AudioSound *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioSound, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AudioSound = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioSound = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AudioSound = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AudioSound = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AudioSound = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AudioSound",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioSound,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AudioSound,
    &Dtool_NumberMethods_AudioSound,
    &Dtool_SequenceMethods_AudioSound,
    &Dtool_MappingMethods_AudioSound,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AudioSound,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AudioSound,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AudioSound,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AudioSound,
    PyType_GenericAlloc,
    Dtool_new_AudioSound,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioSound,
  Dtool_UpcastInterface_AudioSound,
  Dtool_DowncastInterface_AudioSound,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AudioSound(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_AudioSound._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_AudioSound._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AudioSound::SoundStatus;
    PyDict_SetItemString(dict, "BAD", Dtool_WrapValue(AudioSound::BAD));
    PyDict_SetItemString(dict, "READY", Dtool_WrapValue(AudioSound::READY));
    PyDict_SetItemString(dict, "PLAYING", Dtool_WrapValue(AudioSound::PLAYING));
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioSound) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioSound)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioSound);
  }
}

/**
 * Python method tables for AudioManager (AudioManager)
 */
static PyMethodDef Dtool_Methods_AudioManager[] = {
  {"getSpeakerSetup", &Dtool_AudioManager_getSpeakerSetup_60, METH_NOARGS, (const char *)Dtool_AudioManager_getSpeakerSetup_60_comment},
  {"setSpeakerSetup", &Dtool_AudioManager_setSpeakerSetup_61, METH_O, (const char *)Dtool_AudioManager_setSpeakerSetup_61_comment},
  {"configure_filters", &Dtool_AudioManager_configure_filters_62, METH_O, (const char *)Dtool_AudioManager_configure_filters_62_comment},
  {"configureFilters", &Dtool_AudioManager_configure_filters_62, METH_O, (const char *)Dtool_AudioManager_configure_filters_62_comment},
  {"create_AudioManager", &Dtool_AudioManager_create_AudioManager_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_create_AudioManager_63_comment},
  {"createAudioManager", &Dtool_AudioManager_create_AudioManager_63, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_create_AudioManager_63_comment},
  {"shutdown", &Dtool_AudioManager_shutdown_64, METH_NOARGS, (const char *)Dtool_AudioManager_shutdown_64_comment},
  {"is_valid", &Dtool_AudioManager_is_valid_65, METH_NOARGS, (const char *)Dtool_AudioManager_is_valid_65_comment},
  {"isValid", &Dtool_AudioManager_is_valid_65, METH_NOARGS, (const char *)Dtool_AudioManager_is_valid_65_comment},
  {"get_sound", (PyCFunction) &Dtool_AudioManager_get_sound_66, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_get_sound_66_comment},
  {"getSound", (PyCFunction) &Dtool_AudioManager_get_sound_66, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_get_sound_66_comment},
  {"get_null_sound", &Dtool_AudioManager_get_null_sound_67, METH_NOARGS, (const char *)Dtool_AudioManager_get_null_sound_67_comment},
  {"getNullSound", &Dtool_AudioManager_get_null_sound_67, METH_NOARGS, (const char *)Dtool_AudioManager_get_null_sound_67_comment},
  {"uncache_sound", &Dtool_AudioManager_uncache_sound_68, METH_O, (const char *)Dtool_AudioManager_uncache_sound_68_comment},
  {"uncacheSound", &Dtool_AudioManager_uncache_sound_68, METH_O, (const char *)Dtool_AudioManager_uncache_sound_68_comment},
  {"clear_cache", &Dtool_AudioManager_clear_cache_69, METH_NOARGS, (const char *)Dtool_AudioManager_clear_cache_69_comment},
  {"clearCache", &Dtool_AudioManager_clear_cache_69, METH_NOARGS, (const char *)Dtool_AudioManager_clear_cache_69_comment},
  {"set_cache_limit", &Dtool_AudioManager_set_cache_limit_70, METH_O, (const char *)Dtool_AudioManager_set_cache_limit_70_comment},
  {"setCacheLimit", &Dtool_AudioManager_set_cache_limit_70, METH_O, (const char *)Dtool_AudioManager_set_cache_limit_70_comment},
  {"get_cache_limit", &Dtool_AudioManager_get_cache_limit_71, METH_NOARGS, (const char *)Dtool_AudioManager_get_cache_limit_71_comment},
  {"getCacheLimit", &Dtool_AudioManager_get_cache_limit_71, METH_NOARGS, (const char *)Dtool_AudioManager_get_cache_limit_71_comment},
  {"set_volume", &Dtool_AudioManager_set_volume_72, METH_O, (const char *)Dtool_AudioManager_set_volume_72_comment},
  {"setVolume", &Dtool_AudioManager_set_volume_72, METH_O, (const char *)Dtool_AudioManager_set_volume_72_comment},
  {"get_volume", &Dtool_AudioManager_get_volume_73, METH_NOARGS, (const char *)Dtool_AudioManager_get_volume_73_comment},
  {"getVolume", &Dtool_AudioManager_get_volume_73, METH_NOARGS, (const char *)Dtool_AudioManager_get_volume_73_comment},
  {"set_active", &Dtool_AudioManager_set_active_74, METH_O, (const char *)Dtool_AudioManager_set_active_74_comment},
  {"setActive", &Dtool_AudioManager_set_active_74, METH_O, (const char *)Dtool_AudioManager_set_active_74_comment},
  {"get_active", &Dtool_AudioManager_get_active_75, METH_NOARGS, (const char *)Dtool_AudioManager_get_active_75_comment},
  {"getActive", &Dtool_AudioManager_get_active_75, METH_NOARGS, (const char *)Dtool_AudioManager_get_active_75_comment},
  {"set_concurrent_sound_limit", (PyCFunction) &Dtool_AudioManager_set_concurrent_sound_limit_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_set_concurrent_sound_limit_76_comment},
  {"setConcurrentSoundLimit", (PyCFunction) &Dtool_AudioManager_set_concurrent_sound_limit_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_set_concurrent_sound_limit_76_comment},
  {"get_concurrent_sound_limit", &Dtool_AudioManager_get_concurrent_sound_limit_77, METH_NOARGS, (const char *)Dtool_AudioManager_get_concurrent_sound_limit_77_comment},
  {"getConcurrentSoundLimit", &Dtool_AudioManager_get_concurrent_sound_limit_77, METH_NOARGS, (const char *)Dtool_AudioManager_get_concurrent_sound_limit_77_comment},
  {"reduce_sounds_playing_to", &Dtool_AudioManager_reduce_sounds_playing_to_78, METH_O, (const char *)Dtool_AudioManager_reduce_sounds_playing_to_78_comment},
  {"reduceSoundsPlayingTo", &Dtool_AudioManager_reduce_sounds_playing_to_78, METH_O, (const char *)Dtool_AudioManager_reduce_sounds_playing_to_78_comment},
  {"stop_all_sounds", &Dtool_AudioManager_stop_all_sounds_79, METH_NOARGS, (const char *)Dtool_AudioManager_stop_all_sounds_79_comment},
  {"stopAllSounds", &Dtool_AudioManager_stop_all_sounds_79, METH_NOARGS, (const char *)Dtool_AudioManager_stop_all_sounds_79_comment},
  {"update", &Dtool_AudioManager_update_80, METH_NOARGS, (const char *)Dtool_AudioManager_update_80_comment},
  {"audio_3d_set_listener_attributes", (PyCFunction) &Dtool_AudioManager_audio_3d_set_listener_attributes_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment},
  {"audio3dSetListenerAttributes", (PyCFunction) &Dtool_AudioManager_audio_3d_set_listener_attributes_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_audio_3d_set_listener_attributes_81_comment},
  {"audio_3d_set_distance_factor", &Dtool_AudioManager_audio_3d_set_distance_factor_83, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_distance_factor_83_comment},
  {"audio3dSetDistanceFactor", &Dtool_AudioManager_audio_3d_set_distance_factor_83, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_distance_factor_83_comment},
  {"audio_3d_get_distance_factor", &Dtool_AudioManager_audio_3d_get_distance_factor_84, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_distance_factor_84_comment},
  {"audio3dGetDistanceFactor", &Dtool_AudioManager_audio_3d_get_distance_factor_84, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_distance_factor_84_comment},
  {"audio_3d_set_doppler_factor", &Dtool_AudioManager_audio_3d_set_doppler_factor_85, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment},
  {"audio3dSetDopplerFactor", &Dtool_AudioManager_audio_3d_set_doppler_factor_85, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_doppler_factor_85_comment},
  {"audio_3d_get_doppler_factor", &Dtool_AudioManager_audio_3d_get_doppler_factor_86, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment},
  {"audio3dGetDopplerFactor", &Dtool_AudioManager_audio_3d_get_doppler_factor_86, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_doppler_factor_86_comment},
  {"audio_3d_set_drop_off_factor", &Dtool_AudioManager_audio_3d_set_drop_off_factor_87, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment},
  {"audio3dSetDropOffFactor", &Dtool_AudioManager_audio_3d_set_drop_off_factor_87, METH_O, (const char *)Dtool_AudioManager_audio_3d_set_drop_off_factor_87_comment},
  {"audio_3d_get_drop_off_factor", &Dtool_AudioManager_audio_3d_get_drop_off_factor_88, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment},
  {"audio3dGetDropOffFactor", &Dtool_AudioManager_audio_3d_get_drop_off_factor_88, METH_NOARGS, (const char *)Dtool_AudioManager_audio_3d_get_drop_off_factor_88_comment},
  {"get_dls_pathname", &Dtool_AudioManager_get_dls_pathname_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_dls_pathname_89_comment},
  {"getDlsPathname", &Dtool_AudioManager_get_dls_pathname_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_dls_pathname_89_comment},
  {"output", &Dtool_AudioManager_output_90, METH_O, (const char *)Dtool_AudioManager_output_90_comment},
  {"write", &Dtool_AudioManager_write_91, METH_O, (const char *)Dtool_AudioManager_write_91_comment},
  {"set_speaker_configuration", (PyCFunction) &Dtool_AudioManager_set_speaker_configuration_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_set_speaker_configuration_92_comment},
  {"setSpeakerConfiguration", (PyCFunction) &Dtool_AudioManager_set_speaker_configuration_92, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AudioManager_set_speaker_configuration_92_comment},
  {"get_class_type", &Dtool_AudioManager_get_class_type_93, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_class_type_93_comment},
  {"getClassType", &Dtool_AudioManager_get_class_type_93, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioManager_get_class_type_93_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     AudioManager
//////////////////
static PyObject *Dtool_Repr_AudioManager(PyObject *self) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AudioManager
//////////////////
static PyObject *Dtool_Str_AudioManager(PyObject *self) {
  AudioManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AudioManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AudioManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioManager = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AudioManager = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AudioManager = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AudioManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AudioManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_AudioManager,
    &Dtool_NumberMethods_AudioManager,
    &Dtool_SequenceMethods_AudioManager,
    &Dtool_MappingMethods_AudioManager,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_AudioManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AudioManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AudioManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AudioManager,
    PyType_GenericAlloc,
    Dtool_new_AudioManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioManager,
  Dtool_UpcastInterface_AudioManager,
  Dtool_DowncastInterface_AudioManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_AudioManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != NULL);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(NULL);
    Dtool_AudioManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    PyObject *dict = _PyDict_NewPresized(45);
    Dtool_AudioManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AudioManager::SpeakerModeCategory;
    PyDict_SetItemString(dict, "SPEAKERMODE_raw", Dtool_WrapValue(AudioManager::SPEAKERMODE_raw));
    PyDict_SetItemString(dict, "SPEAKERMODERaw", Dtool_WrapValue(AudioManager::SPEAKERMODE_raw));
    PyDict_SetItemString(dict, "SPEAKERMODE_mono", Dtool_WrapValue(AudioManager::SPEAKERMODE_mono));
    PyDict_SetItemString(dict, "SPEAKERMODEMono", Dtool_WrapValue(AudioManager::SPEAKERMODE_mono));
    PyDict_SetItemString(dict, "SPEAKERMODE_stereo", Dtool_WrapValue(AudioManager::SPEAKERMODE_stereo));
    PyDict_SetItemString(dict, "SPEAKERMODEStereo", Dtool_WrapValue(AudioManager::SPEAKERMODE_stereo));
    PyDict_SetItemString(dict, "SPEAKERMODE_quad", Dtool_WrapValue(AudioManager::SPEAKERMODE_quad));
    PyDict_SetItemString(dict, "SPEAKERMODEQuad", Dtool_WrapValue(AudioManager::SPEAKERMODE_quad));
    PyDict_SetItemString(dict, "SPEAKERMODE_surround", Dtool_WrapValue(AudioManager::SPEAKERMODE_surround));
    PyDict_SetItemString(dict, "SPEAKERMODESurround", Dtool_WrapValue(AudioManager::SPEAKERMODE_surround));
    PyDict_SetItemString(dict, "SPEAKERMODE_5point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_5point1));
    PyDict_SetItemString(dict, "SPEAKERMODE5point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_5point1));
    PyDict_SetItemString(dict, "SPEAKERMODE_7point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_7point1));
    PyDict_SetItemString(dict, "SPEAKERMODE7point1", Dtool_WrapValue(AudioManager::SPEAKERMODE_7point1));
    PyDict_SetItemString(dict, "SPEAKERMODE_max", Dtool_WrapValue(AudioManager::SPEAKERMODE_max));
    PyDict_SetItemString(dict, "SPEAKERMODEMax", Dtool_WrapValue(AudioManager::SPEAKERMODE_max));
    PyDict_SetItemString(dict, "SPEAKERMODE_COUNT", Dtool_WrapValue(AudioManager::SPEAKERMODE_COUNT));
    PyDict_SetItemString(dict, "SPEAKERMODECOUNT", Dtool_WrapValue(AudioManager::SPEAKERMODE_COUNT));
    // enum AudioManager::SpeakerId;
    PyDict_SetItemString(dict, "SPK_none", Dtool_WrapValue(AudioManager::SPK_none));
    PyDict_SetItemString(dict, "SPKNone", Dtool_WrapValue(AudioManager::SPK_none));
    PyDict_SetItemString(dict, "SPK_frontleft", Dtool_WrapValue(AudioManager::SPK_frontleft));
    PyDict_SetItemString(dict, "SPKFrontleft", Dtool_WrapValue(AudioManager::SPK_frontleft));
    PyDict_SetItemString(dict, "SPK_frontright", Dtool_WrapValue(AudioManager::SPK_frontright));
    PyDict_SetItemString(dict, "SPKFrontright", Dtool_WrapValue(AudioManager::SPK_frontright));
    PyDict_SetItemString(dict, "SPK_center", Dtool_WrapValue(AudioManager::SPK_center));
    PyDict_SetItemString(dict, "SPKCenter", Dtool_WrapValue(AudioManager::SPK_center));
    PyDict_SetItemString(dict, "SPK_sub", Dtool_WrapValue(AudioManager::SPK_sub));
    PyDict_SetItemString(dict, "SPKSub", Dtool_WrapValue(AudioManager::SPK_sub));
    PyDict_SetItemString(dict, "SPK_backleft", Dtool_WrapValue(AudioManager::SPK_backleft));
    PyDict_SetItemString(dict, "SPKBackleft", Dtool_WrapValue(AudioManager::SPK_backleft));
    PyDict_SetItemString(dict, "SPK_backright", Dtool_WrapValue(AudioManager::SPK_backright));
    PyDict_SetItemString(dict, "SPKBackright", Dtool_WrapValue(AudioManager::SPK_backright));
    PyDict_SetItemString(dict, "SPK_sideleft", Dtool_WrapValue(AudioManager::SPK_sideleft));
    PyDict_SetItemString(dict, "SPKSideleft", Dtool_WrapValue(AudioManager::SPK_sideleft));
    PyDict_SetItemString(dict, "SPK_sideright", Dtool_WrapValue(AudioManager::SPK_sideright));
    PyDict_SetItemString(dict, "SPKSideright", Dtool_WrapValue(AudioManager::SPK_sideright));
    PyDict_SetItemString(dict, "SPK_COUNT", Dtool_WrapValue(AudioManager::SPK_COUNT));
    PyDict_SetItemString(dict, "SPKCOUNT", Dtool_WrapValue(AudioManager::SPK_COUNT));
    // enum AudioManager::StreamMode;
    PyDict_SetItemString(dict, "SM_heuristic", Dtool_WrapValue(AudioManager::SM_heuristic));
    PyDict_SetItemString(dict, "SMHeuristic", Dtool_WrapValue(AudioManager::SM_heuristic));
    PyDict_SetItemString(dict, "SM_sample", Dtool_WrapValue(AudioManager::SM_sample));
    PyDict_SetItemString(dict, "SMSample", Dtool_WrapValue(AudioManager::SM_sample));
    PyDict_SetItemString(dict, "SM_stream", Dtool_WrapValue(AudioManager::SM_stream));
    PyDict_SetItemString(dict, "SMStream", Dtool_WrapValue(AudioManager::SM_stream));
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioManager);
  }
}

/**
 * Python method tables for AudioLoadRequest (AudioLoadRequest)
 */
static PyMethodDef Dtool_Methods_AudioLoadRequest[] = {
  {"get_audio_manager", &Dtool_AudioLoadRequest_get_audio_manager_97, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_audio_manager_97_comment},
  {"getAudioManager", &Dtool_AudioLoadRequest_get_audio_manager_97, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_audio_manager_97_comment},
  {"get_filename", &Dtool_AudioLoadRequest_get_filename_98, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_filename_98_comment},
  {"getFilename", &Dtool_AudioLoadRequest_get_filename_98, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_filename_98_comment},
  {"get_positional", &Dtool_AudioLoadRequest_get_positional_99, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_positional_99_comment},
  {"getPositional", &Dtool_AudioLoadRequest_get_positional_99, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_positional_99_comment},
  {"is_ready", &Dtool_AudioLoadRequest_is_ready_100, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_is_ready_100_comment},
  {"isReady", &Dtool_AudioLoadRequest_is_ready_100, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_is_ready_100_comment},
  {"get_sound", &Dtool_AudioLoadRequest_get_sound_101, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_sound_101_comment},
  {"getSound", &Dtool_AudioLoadRequest_get_sound_101, METH_NOARGS, (const char *)Dtool_AudioLoadRequest_get_sound_101_comment},
  {"get_class_type", &Dtool_AudioLoadRequest_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioLoadRequest_get_class_type_102_comment},
  {"getClassType", &Dtool_AudioLoadRequest_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_AudioLoadRequest_get_class_type_102_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_AudioLoadRequest = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AudioLoadRequest = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_AudioLoadRequest = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_AudioLoadRequest = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_AudioLoadRequest = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.AudioLoadRequest",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_AudioLoadRequest,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_AudioLoadRequest,
    &Dtool_SequenceMethods_AudioLoadRequest,
    &Dtool_MappingMethods_AudioLoadRequest,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_AudioLoadRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object that manages a single asynchronous audio load request.  This\n"
    " * works in conjunction with the Loader class defined in pgraph, or really\n"
    " * with any AsyncTaskManager.  Create a new AudioLoadRequest, and add it to\n"
    " * the loader via load_async(), to begin an asynchronous load.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_AudioLoadRequest,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_AudioLoadRequest,
    PyType_GenericAlloc,
    Dtool_new_AudioLoadRequest,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AudioLoadRequest,
  Dtool_UpcastInterface_AudioLoadRequest,
  Dtool_DowncastInterface_AudioLoadRequest,
  (CoerceFunction)Dtool_ConstCoerce_AudioLoadRequest,
  (CoerceFunction)Dtool_Coerce_AudioLoadRequest,
};

static void Dtool_PyModuleClassInit_AudioLoadRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_AsyncTask != NULL);
    assert(Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit != NULL);
    Dtool_Ptr_AsyncTask->_Dtool_ModuleClassInit(NULL);
    Dtool_AudioLoadRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_AsyncTask);
    PyObject *dict = PyDict_New();
    Dtool_AudioLoadRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AudioLoadRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AudioLoadRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AudioLoadRequest);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3audio_RegisterTypes() {
  Dtool_FilterProperties._type = FilterProperties::get_class_type();
  RegisterRuntimeTypedClass(Dtool_FilterProperties);
  Dtool_AudioSound._type = AudioSound::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AudioSound);
  Dtool_AudioManager._type = AudioManager::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AudioManager);
  Dtool_AudioLoadRequest._type = AudioLoadRequest::get_class_type();
  RegisterRuntimeTypedClass(Dtool_AudioLoadRequest);
}

void Dtool_libp3audio_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_ostream = LookupNamedClass("ostream");
  Dtool_Ptr_TypeHandle = LookupNamedClass("TypeHandle");
  Dtool_Ptr_TypedObject = LookupRuntimeTypedClass(TypedObject::get_class_type());
  Dtool_Ptr_Filename = LookupRuntimeTypedClass(Filename::get_class_type());
  Dtool_Ptr_Namable = LookupRuntimeTypedClass(Namable::get_class_type());
  Dtool_Ptr_AsyncTaskBase = LookupRuntimeTypedClass(AsyncTaskBase::get_class_type());
  Dtool_Ptr_TypedReferenceCount = LookupRuntimeTypedClass(TypedReferenceCount::get_class_type());
  Dtool_Ptr_ReferenceCount = LookupRuntimeTypedClass(ReferenceCount::get_class_type());
  Dtool_Ptr_AsyncTask = LookupRuntimeTypedClass(AsyncTask::get_class_type());
  Dtool_Ptr_LVecBase3f = LookupRuntimeTypedClass(LVecBase3f::get_class_type());
  Dtool_Ptr_MovieAudio = LookupRuntimeTypedClass(MovieAudio::get_class_type());
#endif
}

void Dtool_libp3audio_BuildInstants(PyObject *module) {
  (void) module;
  // FilterProperties
  Dtool_PyModuleClassInit_FilterProperties(module);
  PyModule_AddObject(module, "FilterProperties", (PyObject *)&Dtool_FilterProperties);
  // AudioSound
  Dtool_PyModuleClassInit_AudioSound(module);
  PyModule_AddObject(module, "AudioSound", (PyObject *)&Dtool_AudioSound);
  // AudioManager
  Dtool_PyModuleClassInit_AudioManager(module);
  PyModule_AddObject(module, "AudioManager", (PyObject *)&Dtool_AudioManager);
  // AudioLoadRequest
  Dtool_PyModuleClassInit_AudioLoadRequest(module);
  PyModule_AddObject(module, "AudioLoadRequest", (PyObject *)&Dtool_AudioLoadRequest);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3audio_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478210123,  /* file_identifier */
  "libp3audio",  /* library_name */
  "M_1l",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3audio.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  228  /* next_index */
};

Configure(_in_configure_libp3audio);
ConfigureFn(_in_configure_libp3audio) {
  interrogate_request_module(&_in_module_def);
}

