/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir panda/src/express -Ipanda/src/express -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3express_igate.cxx -od built/pandac/input/libp3express.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/express -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/zlib/include -Sthirdparty/win-libs-vc10/openssl/include -Sthirdparty/win-libs-vc10/extras/include -module panda3d.core -library libp3express buffer.h checksumHashGenerator.h circBuffer.h compress_string.h config_express.h copy_stream.h datagram.h datagramGenerator.h datagramIterator.h datagramSink.h dcast.h encrypt_string.h error_utils.h export_dtool.h fileReference.h filename_ext.h globPattern_ext.h hashGeneratorBase.h hashVal.h indirectLess.h memoryInfo.h memoryUsage.h memoryUsagePointerCounts.h memoryUsagePointers.h memoryUsagePointers_ext.h multifile.h namable.h nodePointerTo.h nodePointerToBase.h nodeReferenceCount.h openSSLWrapper.h ordered_vector.h p3express_composite1.cxx p3express_composite2.cxx p3express_ext_composite.cxx pStatCollectorForwardBase.h password_hash.h patchfile.h pointerTo.h pointerToArray.h pointerToArrayBase.h pointerToArray_ext.h pointerToBase.h pointerToVoid.h profileTimer.h pta_double.h pta_float.h pta_int.h pta_stdfloat.h pta_uchar.h ramfile.h ramfile_ext.h referenceCount.h streamReader_ext.h streamWriter_ext.h subStream.h subStreamBuf.h subfileInfo.h temporaryFile.h threadSafePointerTo.h threadSafePointerToBase.h trueClock.h typeHandle_ext.h typedReferenceCount.h typedef.h vector_double.h vector_float.h vector_stdfloat.h vector_uchar.h virtualFile.h virtualFileComposite.h virtualFileList.h virtualFileMount.h virtualFileMountAndroidAsset.h virtualFileMountMultifile.h virtualFileMountRamdisk.h virtualFileMountSystem.h virtualFileSimple.h virtualFileSystem.h virtualFileSystem_ext.h virtualFile_ext.h weakPointerCallback.h weakPointerTo.h weakPointerToBase.h weakPointerToVoid.h weakReferenceList.h windowsRegistry.h zStream.h zStreamBuf.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3express
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "bigEndian.h"
#include "buffer.h"
#include "checksumHashGenerator.h"
#include "circBuffer.h"
#include "compress_string.h"
#include "configFlags.h"
#include "configPage.h"
#include "configPageManager.h"
#include "configVariable.h"
#include "configVariableBase.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "configVariableInt64.h"
#include "configVariableList.h"
#include "configVariableManager.h"
#include "configVariableSearchPath.h"
#include "configVariableString.h"
#include "config_express.h"
#include "copy_stream.h"
#include "datagram.h"
#include "datagramGenerator.h"
#include "datagramIterator.h"
#include "datagramSink.h"
#include "dcast.h"
#include "dtoolbase.h"
#include "encryptStream.h"
#include "encrypt_string.h"
#include "error_utils.h"
#include "export_dtool.h"
#include "extension.h"
#include "fileReference.h"
#include "filename.h"
#include "filename_ext.h"
#include "globPattern.h"
#include "globPattern_ext.h"
#include "hashGeneratorBase.h"
#include "hashVal.h"
#include "indirectLess.h"
#include "littleEndian.h"
#include "memoryInfo.h"
#include "memoryUsage.h"
#include "memoryUsagePointerCounts.h"
#include "memoryUsagePointers.h"
#include "memoryUsagePointers_ext.h"
#include "multifile.h"
#include "namable.h"
#include "nodePointerTo.h"
#include "nodePointerToBase.h"
#include "nodeReferenceCount.h"
#include "numeric_types.h"
#include "openSSLWrapper.h"
#include "ordered_vector.h"
#include "pStatCollectorForwardBase.h"
#include "pandaFileStream.h"
#include "pandaSystem.h"
#include "pandabase.h"
#include "password_hash.h"
#include "patchfile.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pointerToArrayBase.h"
#include "pointerToArray_ext.h"
#include "pointerToBase.h"
#include "pointerToVoid.h"
#include "profileTimer.h"
#include "pta_double.h"
#include "pta_float.h"
#include "pta_int.h"
#include "pta_stdfloat.h"
#include "pta_uchar.h"
#include "pvector.h"
#include "py_panda.h"
#include "ramfile.h"
#include "ramfile_ext.h"
#include "referenceCount.h"
#include "streamReader.h"
#include "streamReader_ext.h"
#include "streamWrapper.h"
#include "streamWriter.h"
#include "streamWriter_ext.h"
#include <string>
#include "subStream.h"
#include "subStreamBuf.h"
#include "subfileInfo.h"
#include "temporaryFile.h"
#include "threadSafePointerTo.h"
#include "threadSafePointerToBase.h"
#include "trueClock.h"
#include "typeHandle.h"
#include "typeHandle_ext.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "typedef.h"
#include "vector_double.h"
#include "vector_float.h"
#include "vector_stdfloat.h"
#include "vector_uchar.h"
#include "virtualFile.h"
#include "virtualFileComposite.h"
#include "virtualFileList.h"
#include "virtualFileMount.h"
#include "virtualFileMountAndroidAsset.h"
#include "virtualFileMountMultifile.h"
#include "virtualFileMountRamdisk.h"
#include "virtualFileMountSystem.h"
#include "virtualFileSimple.h"
#include "virtualFileSystem.h"
#include "virtualFileSystem_ext.h"
#include "virtualFile_ext.h"
#include "weakPointerCallback.h"
#include "weakPointerTo.h"
#include "weakPointerToBase.h"
#include "weakPointerToVoid.h"
#include "weakReferenceList.h"
#include "windowsRegistry.h"
#include "zStream.h"
#include "zStreamBuf.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConstPointerToArray_double
 */
typedef ConstPointerToArray< double > ConstPointerToArray_double_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_double, ConstPointerToArray_double_localtype, ConstPointerToArray_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_double = &Dtool_ConstPointerToArray_double;
static void Dtool_PyModuleClassInit_ConstPointerToArray_double(PyObject *module);
ConstPointerToArray< double > *Dtool_Coerce_ConstPointerToArray_double(PyObject *args, ConstPointerToArray< double > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_double
 */
typedef PointerToArrayBase< double > PointerToArrayBase_double_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_double, PointerToArrayBase_double_localtype, PointerToArrayBase_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_double = &Dtool_PointerToArrayBase_double;
static void Dtool_PyModuleClassInit_PointerToArrayBase_double(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_double
 */
typedef PointerToBase< ReferenceCountedVector< double > > PointerToBase_ReferenceCountedVector_double_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_double, PointerToBase_ReferenceCountedVector_double_localtype, PointerToBase_ReferenceCountedVector_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_double = &Dtool_PointerToBase_ReferenceCountedVector_double;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(PyObject *module);

/**
 * Forward declarations for top-level class PointerToVoid
 */
typedef PointerToVoid PointerToVoid_localtype;
Define_Module_Class_Private(panda3d.core, PointerToVoid, PointerToVoid_localtype, PointerToVoid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
static void Dtool_PyModuleClassInit_PointerToVoid(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_float
 */
typedef ConstPointerToArray< float > ConstPointerToArray_float_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_float, ConstPointerToArray_float_localtype, ConstPointerToArray_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_float = &Dtool_ConstPointerToArray_float;
static void Dtool_PyModuleClassInit_ConstPointerToArray_float(PyObject *module);
ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_float
 */
typedef PointerToArrayBase< float > PointerToArrayBase_float_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_float, PointerToArrayBase_float_localtype, PointerToArrayBase_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_float = &Dtool_PointerToArrayBase_float;
static void Dtool_PyModuleClassInit_PointerToArrayBase_float(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_float
 */
typedef PointerToBase< ReferenceCountedVector< float > > PointerToBase_ReferenceCountedVector_float_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_float, PointerToBase_ReferenceCountedVector_float_localtype, PointerToBase_ReferenceCountedVector_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_float = &Dtool_PointerToBase_ReferenceCountedVector_float;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_int
 */
typedef ConstPointerToArray< int > ConstPointerToArray_int_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_int, ConstPointerToArray_int_localtype, ConstPointerToArray_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_int = &Dtool_ConstPointerToArray_int;
static void Dtool_PyModuleClassInit_ConstPointerToArray_int(PyObject *module);
ConstPointerToArray< int > *Dtool_Coerce_ConstPointerToArray_int(PyObject *args, ConstPointerToArray< int > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_int
 */
typedef PointerToArrayBase< int > PointerToArrayBase_int_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_int, PointerToArrayBase_int_localtype, PointerToArrayBase_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_int = &Dtool_PointerToArrayBase_int;
static void Dtool_PyModuleClassInit_PointerToArrayBase_int(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_int
 */
typedef PointerToBase< ReferenceCountedVector< int > > PointerToBase_ReferenceCountedVector_int_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_int, PointerToBase_ReferenceCountedVector_int_localtype, PointerToBase_ReferenceCountedVector_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_int = &Dtool_PointerToBase_ReferenceCountedVector_int;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_unsigned_char
 */
typedef ConstPointerToArray< unsigned char > ConstPointerToArray_unsigned_char_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_unsigned_char, ConstPointerToArray_unsigned_char_localtype, ConstPointerToArray_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_unsigned_char = &Dtool_ConstPointerToArray_unsigned_char;
static void Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(PyObject *module);
ConstPointerToArray< unsigned char > *Dtool_Coerce_ConstPointerToArray_unsigned_char(PyObject *args, ConstPointerToArray< unsigned char > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_unsigned_char
 */
typedef PointerToArrayBase< unsigned char > PointerToArrayBase_unsigned_char_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_unsigned_char, PointerToArrayBase_unsigned_char_localtype, PointerToArrayBase_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_unsigned_char = &Dtool_PointerToArrayBase_unsigned_char;
static void Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_unsigned_char
 */
typedef PointerToBase< ReferenceCountedVector< unsigned char > > PointerToBase_ReferenceCountedVector_unsigned_char_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_unsigned_char, PointerToBase_ReferenceCountedVector_unsigned_char_localtype, PointerToBase_ReferenceCountedVector_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char = &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *module);

/**
 * Forward declarations for top-level class ConfigDeclaration
 */
typedef ConfigDeclaration ConfigDeclaration_localtype;
Define_Module_Class_Private(panda3d.core, ConfigDeclaration, ConfigDeclaration_localtype, ConfigDeclaration);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigDeclaration = &Dtool_ConfigDeclaration;
static void Dtool_PyModuleClassInit_ConfigDeclaration(PyObject *module);

/**
 * Forward declarations for top-level class ConfigFlags
 */
typedef ConfigFlags ConfigFlags_localtype;
Define_Module_Class(panda3d.core, ConfigFlags, ConfigFlags_localtype, ConfigFlags);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigFlags = &Dtool_ConfigFlags;
static void Dtool_PyModuleClassInit_ConfigFlags(PyObject *module);

/**
 * Forward declarations for top-level class ConfigPage
 */
typedef ConfigPage ConfigPage_localtype;
Define_Module_Class_Private(panda3d.core, ConfigPage, ConfigPage_localtype, ConfigPage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigPage = &Dtool_ConfigPage;
static void Dtool_PyModuleClassInit_ConfigPage(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableCore
 */
typedef ConfigVariableCore ConfigVariableCore_localtype;
Define_Module_Class_Private(panda3d.core, ConfigVariableCore, ConfigVariableCore_localtype, ConfigVariableCore);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableCore = &Dtool_ConfigVariableCore;
static void Dtool_PyModuleClassInit_ConfigVariableCore(PyObject *module);

/**
 * Forward declarations for top-level class ConfigPageManager
 */
typedef ConfigPageManager ConfigPageManager_localtype;
Define_Module_Class_Private(panda3d.core, ConfigPageManager, ConfigPageManager_localtype, ConfigPageManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigPageManager = &Dtool_ConfigPageManager;
static void Dtool_PyModuleClassInit_ConfigPageManager(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariable
 */
typedef ConfigVariable ConfigVariable_localtype;
Define_Module_Class(panda3d.core, ConfigVariable, ConfigVariable_localtype, ConfigVariable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariable = &Dtool_ConfigVariable;
static void Dtool_PyModuleClassInit_ConfigVariable(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariable(PyObject *args, ConfigVariable const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariable(PyObject *args, ConfigVariable *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConfigVariableBase
 */
typedef ConfigVariableBase ConfigVariableBase_localtype;
Define_Module_Class_Private(panda3d.core, ConfigVariableBase, ConfigVariableBase_localtype, ConfigVariableBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableBase = &Dtool_ConfigVariableBase;
static void Dtool_PyModuleClassInit_ConfigVariableBase(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableBool
 */
typedef ConfigVariableBool ConfigVariableBool_localtype;
Define_Module_Class(panda3d.core, ConfigVariableBool, ConfigVariableBool_localtype, ConfigVariableBool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableBool = &Dtool_ConfigVariableBool;
static void Dtool_PyModuleClassInit_ConfigVariableBool(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableBool(PyObject *args, ConfigVariableBool const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableBool(PyObject *args, ConfigVariableBool *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConfigVariableDouble
 */
typedef ConfigVariableDouble ConfigVariableDouble_localtype;
Define_Module_Class(panda3d.core, ConfigVariableDouble, ConfigVariableDouble_localtype, ConfigVariableDouble);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableDouble = &Dtool_ConfigVariableDouble;
static void Dtool_PyModuleClassInit_ConfigVariableDouble(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableDouble(PyObject *args, ConfigVariableDouble const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableDouble(PyObject *args, ConfigVariableDouble *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConfigVariableFilename
 */
typedef ConfigVariableFilename ConfigVariableFilename_localtype;
Define_Module_Class(panda3d.core, ConfigVariableFilename, ConfigVariableFilename_localtype, ConfigVariableFilename);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableFilename = &Dtool_ConfigVariableFilename;
static void Dtool_PyModuleClassInit_ConfigVariableFilename(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableFilename(PyObject *args, ConfigVariableFilename const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableFilename(PyObject *args, ConfigVariableFilename *&coerced, bool &manage);

/**
 * Forward declarations for top-level class Filename
 */
typedef Filename Filename_localtype;
Define_Module_Class(panda3d.core, Filename, Filename_localtype, Filename);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
static void Dtool_PyModuleClassInit_Filename(PyObject *module);
Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);

/**
 * Forward declarations for top-level class ConfigVariableInt
 */
typedef ConfigVariableInt ConfigVariableInt_localtype;
Define_Module_Class(panda3d.core, ConfigVariableInt, ConfigVariableInt_localtype, ConfigVariableInt);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableInt = &Dtool_ConfigVariableInt;
static void Dtool_PyModuleClassInit_ConfigVariableInt(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableInt(PyObject *args, ConfigVariableInt const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableInt(PyObject *args, ConfigVariableInt *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConfigVariableInt64
 */
typedef ConfigVariableInt64 ConfigVariableInt64_localtype;
Define_Module_Class(panda3d.core, ConfigVariableInt64, ConfigVariableInt64_localtype, ConfigVariableInt64);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableInt64 = &Dtool_ConfigVariableInt64;
static void Dtool_PyModuleClassInit_ConfigVariableInt64(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableInt64(PyObject *args, ConfigVariableInt64 const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableInt64(PyObject *args, ConfigVariableInt64 *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConfigVariableList
 */
typedef ConfigVariableList ConfigVariableList_localtype;
Define_Module_Class(panda3d.core, ConfigVariableList, ConfigVariableList_localtype, ConfigVariableList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableList = &Dtool_ConfigVariableList;
static void Dtool_PyModuleClassInit_ConfigVariableList(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableList(PyObject *args, ConfigVariableList const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableList(PyObject *args, ConfigVariableList *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ConfigVariableManager
 */
typedef ConfigVariableManager ConfigVariableManager_localtype;
Define_Module_Class_Private(panda3d.core, ConfigVariableManager, ConfigVariableManager_localtype, ConfigVariableManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableManager = &Dtool_ConfigVariableManager;
static void Dtool_PyModuleClassInit_ConfigVariableManager(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableSearchPath
 */
typedef ConfigVariableSearchPath ConfigVariableSearchPath_localtype;
Define_Module_Class(panda3d.core, ConfigVariableSearchPath, ConfigVariableSearchPath_localtype, ConfigVariableSearchPath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableSearchPath = &Dtool_ConfigVariableSearchPath;
static void Dtool_PyModuleClassInit_ConfigVariableSearchPath(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath *&coerced, bool &manage);

/**
 * Forward declarations for top-level class DSearchPath
 */
typedef DSearchPath DSearchPath_localtype;
Define_Module_Class(panda3d.core, DSearchPath, DSearchPath_localtype, DSearchPath);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath = &Dtool_DSearchPath;
static void Dtool_PyModuleClassInit_DSearchPath(PyObject *module);
bool Dtool_ConstCoerce_DSearchPath(PyObject *args, DSearchPath const *&coerced, bool &manage);
bool Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath *&coerced, bool &manage);

/**
 * Forward declarations for top-level class DSearchPath_Results
 */
typedef DSearchPath::Results DSearchPath_Results_localtype;
Define_Module_Class(panda3d.core, DSearchPath_Results, DSearchPath_Results_localtype, Results);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath_Results = &Dtool_DSearchPath_Results;
static void Dtool_PyModuleClassInit_DSearchPath_Results(PyObject *module);

/**
 * Forward declarations for top-level class ConfigVariableString
 */
typedef ConfigVariableString ConfigVariableString_localtype;
Define_Module_Class(panda3d.core, ConfigVariableString, ConfigVariableString_localtype, ConfigVariableString);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableString = &Dtool_ConfigVariableString;
static void Dtool_PyModuleClassInit_ConfigVariableString(PyObject *module);
bool Dtool_ConstCoerce_ConfigVariableString(PyObject *args, ConfigVariableString const *&coerced, bool &manage);
bool Dtool_Coerce_ConfigVariableString(PyObject *args, ConfigVariableString *&coerced, bool &manage);

/**
 * Forward declarations for top-level class DConfig
 */
typedef DConfig DConfig_localtype;
Define_Module_Class(panda3d.core, DConfig, DConfig_localtype, DConfig);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DConfig = &Dtool_DConfig;
static void Dtool_PyModuleClassInit_DConfig(PyObject *module);

/**
 * Forward declarations for top-level class ExecutionEnvironment
 */
typedef ExecutionEnvironment ExecutionEnvironment_localtype;
Define_Module_Class(panda3d.core, ExecutionEnvironment, ExecutionEnvironment_localtype, ExecutionEnvironment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ExecutionEnvironment = &Dtool_ExecutionEnvironment;
static void Dtool_PyModuleClassInit_ExecutionEnvironment(PyObject *module);

/**
 * Forward declarations for top-level class FileStream
 */
typedef FileStream FileStream_localtype;
Define_Module_Class(panda3d.core, FileStream, FileStream_localtype, FileStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FileStream = &Dtool_FileStream;
static void Dtool_PyModuleClassInit_FileStream(PyObject *module);
bool Dtool_ConstCoerce_FileStream(PyObject *args, FileStream const *&coerced, bool &manage);
bool Dtool_Coerce_FileStream(PyObject *args, FileStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class iostream
 */
typedef iostream iostream_localtype;
Define_Module_Class(panda3d.core, iostream, iostream_localtype, iostream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_iostream = &Dtool_iostream;
static void Dtool_PyModuleClassInit_iostream(PyObject *module);

/**
 * Forward declarations for top-level class istream
 */
typedef istream istream_localtype;
Define_Module_Class(panda3d.core, istream, istream_localtype, istream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_istream = &Dtool_istream;
static void Dtool_PyModuleClassInit_istream(PyObject *module);

/**
 * Forward declarations for top-level class ios
 */
typedef ios ios_localtype;
Define_Module_Class(panda3d.core, ios, ios_localtype, ios);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ios = &Dtool_ios;
static void Dtool_PyModuleClassInit_ios(PyObject *module);

/**
 * Forward declarations for top-level class ios_base
 */
typedef ios_base ios_base_localtype;
Define_Module_Class(panda3d.core, ios_base, ios_base_localtype, ios_base);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ios_base = &Dtool_ios_base;
static void Dtool_PyModuleClassInit_ios_base(PyObject *module);

/**
 * Forward declarations for top-level class ostream
 */
typedef ostream ostream_localtype;
Define_Module_Class(panda3d.core, ostream, ostream_localtype, ostream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ostream = &Dtool_ostream;
static void Dtool_PyModuleClassInit_ostream(PyObject *module);

/**
 * Forward declarations for top-level class GlobPattern
 */
typedef GlobPattern GlobPattern_localtype;
Define_Module_Class(panda3d.core, GlobPattern, GlobPattern_localtype, GlobPattern);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
static void Dtool_PyModuleClassInit_GlobPattern(PyObject *module);
bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage);
bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage);

/**
 * Forward declarations for top-level class IDecryptStream
 */
typedef IDecryptStream IDecryptStream_localtype;
Define_Module_Class(panda3d.core, IDecryptStream, IDecryptStream_localtype, IDecryptStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IDecryptStream = &Dtool_IDecryptStream;
static void Dtool_PyModuleClassInit_IDecryptStream(PyObject *module);
bool Dtool_ConstCoerce_IDecryptStream(PyObject *args, IDecryptStream const *&coerced, bool &manage);
bool Dtool_Coerce_IDecryptStream(PyObject *args, IDecryptStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class IFileStream
 */
typedef IFileStream IFileStream_localtype;
Define_Module_Class(panda3d.core, IFileStream, IFileStream_localtype, IFileStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IFileStream = &Dtool_IFileStream;
static void Dtool_PyModuleClassInit_IFileStream(PyObject *module);
bool Dtool_ConstCoerce_IFileStream(PyObject *args, IFileStream const *&coerced, bool &manage);
bool Dtool_Coerce_IFileStream(PyObject *args, IFileStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class IStreamWrapper
 */
typedef IStreamWrapper IStreamWrapper_localtype;
Define_Module_Class(panda3d.core, IStreamWrapper, IStreamWrapper_localtype, IStreamWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IStreamWrapper = &Dtool_IStreamWrapper;
static void Dtool_PyModuleClassInit_IStreamWrapper(PyObject *module);
bool Dtool_ConstCoerce_IStreamWrapper(PyObject *args, IStreamWrapper const *&coerced, bool &manage);
bool Dtool_Coerce_IStreamWrapper(PyObject *args, IStreamWrapper *&coerced, bool &manage);

/**
 * Forward declarations for top-level class StreamWrapperBase
 */
typedef StreamWrapperBase StreamWrapperBase_localtype;
Define_Module_Class(panda3d.core, StreamWrapperBase, StreamWrapperBase_localtype, StreamWrapperBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWrapperBase = &Dtool_StreamWrapperBase;
static void Dtool_PyModuleClassInit_StreamWrapperBase(PyObject *module);

/**
 * Forward declarations for top-level class LineStream
 */
typedef LineStream LineStream_localtype;
Define_Module_Class(panda3d.core, LineStream, LineStream_localtype, LineStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LineStream = &Dtool_LineStream;
static void Dtool_PyModuleClassInit_LineStream(PyObject *module);

/**
 * Forward declarations for top-level class NeverFreeMemory
 */
typedef NeverFreeMemory NeverFreeMemory_localtype;
Define_Module_Class(panda3d.core, NeverFreeMemory, NeverFreeMemory_localtype, NeverFreeMemory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NeverFreeMemory = &Dtool_NeverFreeMemory;
static void Dtool_PyModuleClassInit_NeverFreeMemory(PyObject *module);

/**
 * Forward declarations for top-level class Notify
 */
typedef Notify Notify_localtype;
Define_Module_Class(panda3d.core, Notify, Notify_localtype, Notify);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Notify = &Dtool_Notify;
static void Dtool_PyModuleClassInit_Notify(PyObject *module);

/**
 * Forward declarations for top-level class NotifyCategory
 */
typedef NotifyCategory NotifyCategory_localtype;
Define_Module_Class(panda3d.core, NotifyCategory, NotifyCategory_localtype, NotifyCategory);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NotifyCategory = &Dtool_NotifyCategory;
static void Dtool_PyModuleClassInit_NotifyCategory(PyObject *module);

/**
 * Forward declarations for top-level class OEncryptStream
 */
typedef OEncryptStream OEncryptStream_localtype;
Define_Module_Class(panda3d.core, OEncryptStream, OEncryptStream_localtype, OEncryptStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OEncryptStream = &Dtool_OEncryptStream;
static void Dtool_PyModuleClassInit_OEncryptStream(PyObject *module);
bool Dtool_ConstCoerce_OEncryptStream(PyObject *args, OEncryptStream const *&coerced, bool &manage);
bool Dtool_Coerce_OEncryptStream(PyObject *args, OEncryptStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OFileStream
 */
typedef OFileStream OFileStream_localtype;
Define_Module_Class(panda3d.core, OFileStream, OFileStream_localtype, OFileStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OFileStream = &Dtool_OFileStream;
static void Dtool_PyModuleClassInit_OFileStream(PyObject *module);
bool Dtool_ConstCoerce_OFileStream(PyObject *args, OFileStream const *&coerced, bool &manage);
bool Dtool_Coerce_OFileStream(PyObject *args, OFileStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OStreamWrapper
 */
typedef OStreamWrapper OStreamWrapper_localtype;
Define_Module_Class(panda3d.core, OStreamWrapper, OStreamWrapper_localtype, OStreamWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OStreamWrapper = &Dtool_OStreamWrapper;
static void Dtool_PyModuleClassInit_OStreamWrapper(PyObject *module);
bool Dtool_ConstCoerce_OStreamWrapper(PyObject *args, OStreamWrapper const *&coerced, bool &manage);
bool Dtool_Coerce_OStreamWrapper(PyObject *args, OStreamWrapper *&coerced, bool &manage);

/**
 * Forward declarations for top-level class PointerToArray_double
 */
typedef PointerToArray< double > PointerToArray_double_localtype;
Define_Module_Class(panda3d.core, PointerToArray_double, PointerToArray_double_localtype, PointerToArray_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_double = &Dtool_PointerToArray_double;
static void Dtool_PyModuleClassInit_PointerToArray_double(PyObject *module);
PointerToArray< double > *Dtool_Coerce_PointerToArray_double(PyObject *args, PointerToArray< double > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_float
 */
typedef PointerToArray< float > PointerToArray_float_localtype;
Define_Module_Class(panda3d.core, PointerToArray_float, PointerToArray_float_localtype, PointerToArray_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_float = &Dtool_PointerToArray_float;
static void Dtool_PyModuleClassInit_PointerToArray_float(PyObject *module);
PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_int
 */
typedef PointerToArray< int > PointerToArray_int_localtype;
Define_Module_Class(panda3d.core, PointerToArray_int, PointerToArray_int_localtype, PointerToArray_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_int = &Dtool_PointerToArray_int;
static void Dtool_PyModuleClassInit_PointerToArray_int(PyObject *module);
PointerToArray< int > *Dtool_Coerce_PointerToArray_int(PyObject *args, PointerToArray< int > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_unsigned_char
 */
typedef PointerToArray< unsigned char > PointerToArray_unsigned_char_localtype;
Define_Module_Class(panda3d.core, PointerToArray_unsigned_char, PointerToArray_unsigned_char_localtype, PointerToArray_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_unsigned_char = &Dtool_PointerToArray_unsigned_char;
static void Dtool_PyModuleClassInit_PointerToArray_unsigned_char(PyObject *module);
PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced);

/**
 * Forward declarations for top-level class PandaSystem
 */
typedef PandaSystem PandaSystem_localtype;
Define_Module_Class_Private(panda3d.core, PandaSystem, PandaSystem_localtype, PandaSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaSystem = &Dtool_PandaSystem;
static void Dtool_PyModuleClassInit_PandaSystem(PyObject *module);

/**
 * Forward declarations for top-level class StreamReader
 */
typedef StreamReader StreamReader_localtype;
Define_Module_Class(panda3d.core, StreamReader, StreamReader_localtype, StreamReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamReader = &Dtool_StreamReader;
static void Dtool_PyModuleClassInit_StreamReader(PyObject *module);
bool Dtool_ConstCoerce_StreamReader(PyObject *args, StreamReader const *&coerced, bool &manage);
bool Dtool_Coerce_StreamReader(PyObject *args, StreamReader *&coerced, bool &manage);

/**
 * Forward declarations for top-level class StreamWrapper
 */
typedef StreamWrapper StreamWrapper_localtype;
Define_Module_Class(panda3d.core, StreamWrapper, StreamWrapper_localtype, StreamWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWrapper = &Dtool_StreamWrapper;
static void Dtool_PyModuleClassInit_StreamWrapper(PyObject *module);
bool Dtool_ConstCoerce_StreamWrapper(PyObject *args, StreamWrapper const *&coerced, bool &manage);
bool Dtool_Coerce_StreamWrapper(PyObject *args, StreamWrapper *&coerced, bool &manage);

/**
 * Forward declarations for top-level class StreamWriter
 */
typedef StreamWriter StreamWriter_localtype;
Define_Module_Class(panda3d.core, StreamWriter, StreamWriter_localtype, StreamWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWriter = &Dtool_StreamWriter;
static void Dtool_PyModuleClassInit_StreamWriter(PyObject *module);
bool Dtool_ConstCoerce_StreamWriter(PyObject *args, StreamWriter const *&coerced, bool &manage);
bool Dtool_Coerce_StreamWriter(PyObject *args, StreamWriter *&coerced, bool &manage);

/**
 * Forward declarations for top-level class TextEncoder
 */
typedef TextEncoder TextEncoder_localtype;
Define_Module_Class(panda3d.core, TextEncoder, TextEncoder_localtype, TextEncoder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextEncoder = &Dtool_TextEncoder;
static void Dtool_PyModuleClassInit_TextEncoder(PyObject *module);

/**
 * Forward declarations for top-level class TypeHandle
 */
typedef TypeHandle TypeHandle_localtype;
Define_Module_Class(panda3d.core, TypeHandle, TypeHandle_localtype, TypeHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
static void Dtool_PyModuleClassInit_TypeHandle(PyObject *module);
TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);

/**
 * Forward declarations for top-level class TypeRegistry
 */
typedef TypeRegistry TypeRegistry_localtype;
Define_Module_Class(panda3d.core, TypeRegistry, TypeRegistry_localtype, TypeRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeRegistry = &Dtool_TypeRegistry;
static void Dtool_PyModuleClassInit_TypeRegistry(PyObject *module);

/**
 * Forward declarations for top-level class TypedObject
 */
typedef TypedObject TypedObject_localtype;
Define_Module_Class(panda3d.core, TypedObject, TypedObject_localtype, TypedObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
static void Dtool_PyModuleClassInit_TypedObject(PyObject *module);

/**
 * Forward declarations for top-level class fstream
 */
typedef fstream fstream_localtype;
Define_Module_Class(panda3d.core, fstream, fstream_localtype, fstream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_fstream = &Dtool_fstream;
static void Dtool_PyModuleClassInit_fstream(PyObject *module);

/**
 * Forward declarations for top-level class ifstream
 */
typedef ifstream ifstream_localtype;
Define_Module_Class(panda3d.core, ifstream, ifstream_localtype, ifstream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ifstream = &Dtool_ifstream;
static void Dtool_PyModuleClassInit_ifstream(PyObject *module);

/**
 * Forward declarations for top-level class ofstream
 */
typedef ofstream ofstream_localtype;
Define_Module_Class(panda3d.core, ofstream, ofstream_localtype, ofstream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ofstream = &Dtool_ofstream;
static void Dtool_PyModuleClassInit_ofstream(PyObject *module);

/**
 * Forward declarations for top-level class MemoryUsage
 */
typedef MemoryUsage MemoryUsage_localtype;
Define_Module_Class(panda3d.core, MemoryUsage, MemoryUsage_localtype, MemoryUsage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MemoryUsage = &Dtool_MemoryUsage;
static void Dtool_PyModuleClassInit_MemoryUsage(PyObject *module);

/**
 * Forward declarations for top-level class ReferenceCount
 */
typedef ReferenceCount ReferenceCount_localtype;
Define_Module_ClassRef(panda3d.core, ReferenceCount, ReferenceCount_localtype, ReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
static void Dtool_PyModuleClassInit_ReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class Buffer
 */
typedef Buffer Buffer_localtype;
Define_Module_ClassRef(panda3d.core, Buffer, Buffer_localtype, Buffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Buffer = &Dtool_Buffer;
static void Dtool_PyModuleClassInit_Buffer(PyObject *module);

/**
 * Forward declarations for top-level class PStatCollectorForwardBase
 */
typedef PStatCollectorForwardBase PStatCollectorForwardBase_localtype;
Define_Module_ClassRef(panda3d.core, PStatCollectorForwardBase, PStatCollectorForwardBase_localtype, PStatCollectorForwardBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatCollectorForwardBase = &Dtool_PStatCollectorForwardBase;
static void Dtool_PyModuleClassInit_PStatCollectorForwardBase(PyObject *module);

/**
 * Forward declarations for top-level class NodeReferenceCount
 */
typedef NodeReferenceCount NodeReferenceCount_localtype;
Define_Module_ClassRef_Private(panda3d.core, NodeReferenceCount, NodeReferenceCount_localtype, NodeReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeReferenceCount = &Dtool_NodeReferenceCount;
static void Dtool_PyModuleClassInit_NodeReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class Datagram
 */
typedef Datagram Datagram_localtype;
Define_Module_Class(panda3d.core, Datagram, Datagram_localtype, Datagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
static void Dtool_PyModuleClassInit_Datagram(PyObject *module);
bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);

/**
 * Forward declarations for top-level class DatagramGenerator
 */
typedef DatagramGenerator DatagramGenerator_localtype;
Define_Module_Class(panda3d.core, DatagramGenerator, DatagramGenerator_localtype, DatagramGenerator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGenerator = &Dtool_DatagramGenerator;
static void Dtool_PyModuleClassInit_DatagramGenerator(PyObject *module);

/**
 * Forward declarations for top-level class DatagramIterator
 */
typedef DatagramIterator DatagramIterator_localtype;
Define_Module_Class(panda3d.core, DatagramIterator, DatagramIterator_localtype, DatagramIterator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
static void Dtool_PyModuleClassInit_DatagramIterator(PyObject *module);
DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);

/**
 * Forward declarations for top-level class DatagramSink
 */
typedef DatagramSink DatagramSink_localtype;
Define_Module_Class(panda3d.core, DatagramSink, DatagramSink_localtype, DatagramSink);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSink = &Dtool_DatagramSink;
static void Dtool_PyModuleClassInit_DatagramSink(PyObject *module);

/**
 * Forward declarations for top-level class TypedReferenceCount
 */
typedef TypedReferenceCount TypedReferenceCount_localtype;
Define_Module_ClassRef(panda3d.core, TypedReferenceCount, TypedReferenceCount_localtype, TypedReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
static void Dtool_PyModuleClassInit_TypedReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class FileReference
 */
typedef FileReference FileReference_localtype;
Define_Module_ClassRef(panda3d.core, FileReference, FileReference_localtype, FileReference);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FileReference = &Dtool_FileReference;
static void Dtool_PyModuleClassInit_FileReference(PyObject *module);
bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced);
bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced);

/**
 * Forward declarations for top-level class Ramfile
 */
typedef Ramfile Ramfile_localtype;
Define_Module_Class(panda3d.core, Ramfile, Ramfile_localtype, Ramfile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Ramfile = &Dtool_Ramfile;
static void Dtool_PyModuleClassInit_Ramfile(PyObject *module);

/**
 * Forward declarations for top-level class HashVal
 */
typedef HashVal HashVal_localtype;
Define_Module_Class(panda3d.core, HashVal, HashVal_localtype, HashVal);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HashVal = &Dtool_HashVal;
static void Dtool_PyModuleClassInit_HashVal(PyObject *module);

/**
 * Forward declarations for top-level class MemoryUsagePointers
 */
typedef MemoryUsagePointers MemoryUsagePointers_localtype;
Define_Module_Class(panda3d.core, MemoryUsagePointers, MemoryUsagePointers_localtype, MemoryUsagePointers);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MemoryUsagePointers = &Dtool_MemoryUsagePointers;
static void Dtool_PyModuleClassInit_MemoryUsagePointers(PyObject *module);

/**
 * Forward declarations for top-level class ISubStream
 */
typedef ISubStream ISubStream_localtype;
Define_Module_Class(panda3d.core, ISubStream, ISubStream_localtype, ISubStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ISubStream = &Dtool_ISubStream;
static void Dtool_PyModuleClassInit_ISubStream(PyObject *module);
bool Dtool_ConstCoerce_ISubStream(PyObject *args, ISubStream const *&coerced, bool &manage);
bool Dtool_Coerce_ISubStream(PyObject *args, ISubStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OSubStream
 */
typedef OSubStream OSubStream_localtype;
Define_Module_Class(panda3d.core, OSubStream, OSubStream_localtype, OSubStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OSubStream = &Dtool_OSubStream;
static void Dtool_PyModuleClassInit_OSubStream(PyObject *module);
bool Dtool_ConstCoerce_OSubStream(PyObject *args, OSubStream const *&coerced, bool &manage);
bool Dtool_Coerce_OSubStream(PyObject *args, OSubStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class SubStream
 */
typedef SubStream SubStream_localtype;
Define_Module_Class(panda3d.core, SubStream, SubStream_localtype, SubStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SubStream = &Dtool_SubStream;
static void Dtool_PyModuleClassInit_SubStream(PyObject *module);
bool Dtool_ConstCoerce_SubStream(PyObject *args, SubStream const *&coerced, bool &manage);
bool Dtool_Coerce_SubStream(PyObject *args, SubStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OpenSSLWrapper
 */
typedef OpenSSLWrapper OpenSSLWrapper_localtype;
Define_Module_Class_Private(panda3d.core, OpenSSLWrapper, OpenSSLWrapper_localtype, OpenSSLWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OpenSSLWrapper = &Dtool_OpenSSLWrapper;
static void Dtool_PyModuleClassInit_OpenSSLWrapper(PyObject *module);

/**
 * Forward declarations for top-level class Multifile
 */
typedef Multifile Multifile_localtype;
Define_Module_ClassRef(panda3d.core, Multifile, Multifile_localtype, Multifile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Multifile = &Dtool_Multifile;
static void Dtool_PyModuleClassInit_Multifile(PyObject *module);

/**
 * Forward declarations for top-level class Namable
 */
typedef Namable Namable_localtype;
Define_Module_Class(panda3d.core, Namable, Namable_localtype, Namable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
static void Dtool_PyModuleClassInit_Namable(PyObject *module);

/**
 * Forward declarations for top-level class SubfileInfo
 */
typedef SubfileInfo SubfileInfo_localtype;
Define_Module_Class(panda3d.core, SubfileInfo, SubfileInfo_localtype, SubfileInfo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SubfileInfo = &Dtool_SubfileInfo;
static void Dtool_PyModuleClassInit_SubfileInfo(PyObject *module);
bool Dtool_ConstCoerce_SubfileInfo(PyObject *args, SubfileInfo const *&coerced, bool &manage);
bool Dtool_Coerce_SubfileInfo(PyObject *args, SubfileInfo *&coerced, bool &manage);

/**
 * Forward declarations for top-level class VirtualFile
 */
typedef VirtualFile VirtualFile_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFile, VirtualFile_localtype, VirtualFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFile = &Dtool_VirtualFile;
static void Dtool_PyModuleClassInit_VirtualFile(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileComposite
 */
typedef VirtualFileComposite VirtualFileComposite_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileComposite, VirtualFileComposite_localtype, VirtualFileComposite);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileComposite = &Dtool_VirtualFileComposite;
static void Dtool_PyModuleClassInit_VirtualFileComposite(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMount
 */
typedef VirtualFileMount VirtualFileMount_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMount, VirtualFileMount_localtype, VirtualFileMount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMount = &Dtool_VirtualFileMount;
static void Dtool_PyModuleClassInit_VirtualFileMount(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMountMultifile
 */
typedef VirtualFileMountMultifile VirtualFileMountMultifile_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountMultifile, VirtualFileMountMultifile_localtype, VirtualFileMountMultifile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountMultifile = &Dtool_VirtualFileMountMultifile;
static void Dtool_PyModuleClassInit_VirtualFileMountMultifile(PyObject *module);
bool Dtool_ConstCoerce_VirtualFileMountMultifile(PyObject *args, CPT(VirtualFileMountMultifile) &coerced);
bool Dtool_Coerce_VirtualFileMountMultifile(PyObject *args, PT(VirtualFileMountMultifile) &coerced);

/**
 * Forward declarations for top-level class VirtualFileMountRamdisk
 */
typedef VirtualFileMountRamdisk VirtualFileMountRamdisk_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountRamdisk, VirtualFileMountRamdisk_localtype, VirtualFileMountRamdisk);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountRamdisk = &Dtool_VirtualFileMountRamdisk;
static void Dtool_PyModuleClassInit_VirtualFileMountRamdisk(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMountSystem
 */
typedef VirtualFileMountSystem VirtualFileMountSystem_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountSystem, VirtualFileMountSystem_localtype, VirtualFileMountSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountSystem = &Dtool_VirtualFileMountSystem;
static void Dtool_PyModuleClassInit_VirtualFileMountSystem(PyObject *module);
bool Dtool_ConstCoerce_VirtualFileMountSystem(PyObject *args, CPT(VirtualFileMountSystem) &coerced);
bool Dtool_Coerce_VirtualFileMountSystem(PyObject *args, PT(VirtualFileMountSystem) &coerced);

/**
 * Forward declarations for top-level class VirtualFileSimple
 */
typedef VirtualFileSimple VirtualFileSimple_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileSimple, VirtualFileSimple_localtype, VirtualFileSimple);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileSimple = &Dtool_VirtualFileSimple;
static void Dtool_PyModuleClassInit_VirtualFileSimple(PyObject *module);

/**
 * Forward declarations for top-level class TemporaryFile
 */
typedef TemporaryFile TemporaryFile_localtype;
Define_Module_ClassRef(panda3d.core, TemporaryFile, TemporaryFile_localtype, TemporaryFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TemporaryFile = &Dtool_TemporaryFile;
static void Dtool_PyModuleClassInit_TemporaryFile(PyObject *module);
bool Dtool_ConstCoerce_TemporaryFile(PyObject *args, CPT(TemporaryFile) &coerced);
bool Dtool_Coerce_TemporaryFile(PyObject *args, PT(TemporaryFile) &coerced);

/**
 * Forward declarations for top-level class IDecompressStream
 */
typedef IDecompressStream IDecompressStream_localtype;
Define_Module_Class(panda3d.core, IDecompressStream, IDecompressStream_localtype, IDecompressStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IDecompressStream = &Dtool_IDecompressStream;
static void Dtool_PyModuleClassInit_IDecompressStream(PyObject *module);
bool Dtool_ConstCoerce_IDecompressStream(PyObject *args, IDecompressStream const *&coerced, bool &manage);
bool Dtool_Coerce_IDecompressStream(PyObject *args, IDecompressStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class OCompressStream
 */
typedef OCompressStream OCompressStream_localtype;
Define_Module_Class(panda3d.core, OCompressStream, OCompressStream_localtype, OCompressStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OCompressStream = &Dtool_OCompressStream;
static void Dtool_PyModuleClassInit_OCompressStream(PyObject *module);
bool Dtool_ConstCoerce_OCompressStream(PyObject *args, OCompressStream const *&coerced, bool &manage);
bool Dtool_Coerce_OCompressStream(PyObject *args, OCompressStream *&coerced, bool &manage);

/**
 * Forward declarations for top-level class VirtualFileList
 */
typedef VirtualFileList VirtualFileList_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileList, VirtualFileList_localtype, VirtualFileList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileList = &Dtool_VirtualFileList;
static void Dtool_PyModuleClassInit_VirtualFileList(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileSystem
 */
typedef VirtualFileSystem VirtualFileSystem_localtype;
Define_Module_Class(panda3d.core, VirtualFileSystem, VirtualFileSystem_localtype, VirtualFileSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileSystem = &Dtool_VirtualFileSystem;
static void Dtool_PyModuleClassInit_VirtualFileSystem(PyObject *module);

/**
 * Forward declarations for top-level class PointerTo_VirtualFileMount
 */
typedef PointerTo< VirtualFileMount > PointerTo_VirtualFileMount_localtype;
Define_Module_Class(panda3d.core, PointerTo_VirtualFileMount, PointerTo_VirtualFileMount_localtype, PointerTo_VirtualFileMount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerTo_VirtualFileMount = &Dtool_PointerTo_VirtualFileMount;
static void Dtool_PyModuleClassInit_PointerTo_VirtualFileMount(PyObject *module);
bool Dtool_ConstCoerce_PointerTo_VirtualFileMount(PyObject *args, PointerTo< VirtualFileMount > const *&coerced, bool &manage);
bool Dtool_Coerce_PointerTo_VirtualFileMount(PyObject *args, PointerTo< VirtualFileMount > *&coerced, bool &manage);

/**
 * Forward declarations for top-level class PointerToBase_VirtualFileMount
 */
typedef PointerToBase< VirtualFileMount > PointerToBase_VirtualFileMount_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_VirtualFileMount, PointerToBase_VirtualFileMount_localtype, PointerToBase_VirtualFileMount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_VirtualFileMount = &Dtool_PointerToBase_VirtualFileMount;
static void Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(PyObject *module);

/**
 * Forward declarations for top-level class TrueClock
 */
typedef TrueClock TrueClock_localtype;
Define_Module_Class_Private(panda3d.core, TrueClock, TrueClock_localtype, TrueClock);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TrueClock = &Dtool_TrueClock;
static void Dtool_PyModuleClassInit_TrueClock(PyObject *module);

/**
 * Forward declarations for top-level class Patchfile
 */
typedef Patchfile Patchfile_localtype;
Define_Module_Class(panda3d.core, Patchfile, Patchfile_localtype, Patchfile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Patchfile = &Dtool_Patchfile;
static void Dtool_PyModuleClassInit_Patchfile(PyObject *module);
bool Dtool_ConstCoerce_Patchfile(PyObject *args, Patchfile const *&coerced, bool &manage);
bool Dtool_Coerce_Patchfile(PyObject *args, Patchfile *&coerced, bool &manage);

/**
 * Forward declarations for top-level class ProfileTimer
 */
typedef ProfileTimer ProfileTimer_localtype;
Define_Module_Class(panda3d.core, ProfileTimer, ProfileTimer_localtype, ProfileTimer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ProfileTimer = &Dtool_ProfileTimer;
static void Dtool_PyModuleClassInit_ProfileTimer(PyObject *module);
bool Dtool_ConstCoerce_ProfileTimer(PyObject *args, ProfileTimer const *&coerced, bool &manage);
bool Dtool_Coerce_ProfileTimer(PyObject *args, ProfileTimer *&coerced, bool &manage);

/**
 * Forward declarations for top-level class WeakPointerToVoid
 */
typedef WeakPointerToVoid WeakPointerToVoid_localtype;
Define_Module_Class_Private(panda3d.core, WeakPointerToVoid, WeakPointerToVoid_localtype, WeakPointerToVoid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WeakPointerToVoid = &Dtool_WeakPointerToVoid;
static void Dtool_PyModuleClassInit_WeakPointerToVoid(PyObject *module);

/**
 * Forward declarations for top-level class WindowsRegistry
 */
typedef WindowsRegistry WindowsRegistry_localtype;
Define_Module_Class(panda3d.core, WindowsRegistry, WindowsRegistry_localtype, WindowsRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WindowsRegistry = &Dtool_WindowsRegistry;
static void Dtool_PyModuleClassInit_WindowsRegistry(PyObject *module);

/**
 * Extern declarations for imported classes
 */

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * DConfig &get_config_express(void)
 */
static PyObject *Dtool_get_config_express_1060(PyObject *, PyObject *) {
  // 1-DConfig &get_config_express(void)
  DConfig *return_value = &(get_config_express());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DConfig, false, false);
}

#ifndef NDEBUG
static const char *Dtool_get_config_express_1060_comment =
  "C++ Interface:\n"
  "get_config_express()\n"
  "\n"
  "// Returns the configure object for accessing config variables from a\n"
  "// scripting language.";
#else
static const char *Dtool_get_config_express_1060_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string compress_string(std::string const &source, int compression_level)
 */
static PyObject *Dtool_compress_string_1075(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string compress_string(std::string const &source, int compression_level)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  int param1;
  static const char *keyword_list[] = {"source", "compression_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:compress_string", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    std::string return_value = compress_string(std::string(param0_str, param0_len), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_string(str source, int compression_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_compress_string_1075_comment =
  "C++ Interface:\n"
  "compress_string(str source, int compression_level)\n";
#else
static const char *Dtool_compress_string_1075_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string decompress_string(std::string const &source)
 */
static PyObject *Dtool_decompress_string_1076(PyObject *, PyObject *arg) {
  // 1-std::string decompress_string(std::string const &source)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = decompress_string(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress_string(str source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decompress_string_1076_comment =
  "C++ Interface:\n"
  "decompress_string(str source)\n";
#else
static const char *Dtool_decompress_string_1076_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool compress_file(Filename const &source, Filename const &dest, int compression_level)
 */
static PyObject *Dtool_compress_file_1077(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool compress_file(Filename const &source, Filename const &dest, int compression_level)
  PyObject *param0;
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"source", "dest", "compression_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compress_file", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "compress_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "compress_file", "Filename");
    }
    bool return_value = compress_file(*param0_this, *param1_this, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_file(const Filename source, const Filename dest, int compression_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_compress_file_1077_comment =
  "C++ Interface:\n"
  "compress_file(const Filename source, const Filename dest, int compression_level)\n";
#else
static const char *Dtool_compress_file_1077_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool decompress_file(Filename const &source, Filename const &dest)
 */
static PyObject *Dtool_decompress_file_1078(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decompress_file(Filename const &source, Filename const &dest)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"source", "dest", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompress_file", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "decompress_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "decompress_file", "Filename");
    }
    bool return_value = decompress_file(*param0_this, *param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress_file(const Filename source, const Filename dest)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decompress_file_1078_comment =
  "C++ Interface:\n"
  "decompress_file(const Filename source, const Filename dest)\n";
#else
static const char *Dtool_decompress_file_1078_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool compress_stream(istream &source, ostream &dest, int compression_level)
 */
static PyObject *Dtool_compress_stream_1079(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool compress_stream(istream &source, ostream &dest, int compression_level)
  PyObject *param0;
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"source", "dest", "compression_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compress_stream", (char **)keyword_list, &param0, &param1, &param2)) {
    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "compress_stream", false, true);
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "compress_stream", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      bool return_value = compress_stream(*param0_this, *param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_stream(istream source, ostream dest, int compression_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_compress_stream_1079_comment =
  "C++ Interface:\n"
  "compress_stream(istream source, ostream dest, int compression_level)\n";
#else
static const char *Dtool_compress_stream_1079_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool decompress_stream(istream &source, ostream &dest)
 */
static PyObject *Dtool_decompress_stream_1080(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decompress_stream(istream &source, ostream &dest)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"source", "dest", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompress_stream", (char **)keyword_list, &param0, &param1)) {
    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "decompress_stream", false, true);
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "decompress_stream", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      bool return_value = decompress_stream(*param0_this, *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress_stream(istream source, ostream dest)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decompress_stream_1080_comment =
  "C++ Interface:\n"
  "decompress_stream(istream source, ostream dest)\n";
#else
static const char *Dtool_decompress_stream_1080_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool copy_stream(istream &source, ostream &dest)
 */
static PyObject *Dtool_copy_stream_1081(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool copy_stream(istream &source, ostream &dest)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"source", "dest", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_stream", (char **)keyword_list, &param0, &param1)) {
    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "copy_stream", false, true);
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "copy_stream", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      bool return_value = copy_stream(*param0_this, *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_stream(istream source, ostream dest)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_copy_stream_1081_comment =
  "C++ Interface:\n"
  "copy_stream(istream source, ostream dest)\n";
#else
static const char *Dtool_copy_stream_1081_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string encrypt_string(std::string const &source, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
 */
static PyObject *Dtool_encrypt_string_1196(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string encrypt_string(std::string const &source, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  int param3 = -1;
  int param4 = -1;
  static const char *keyword_list[] = {"source", "password", "algorithm", "key_length", "iteration_count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#ii:encrypt_string", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4)) {
    std::string return_value = encrypt_string(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3, (int)param4);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encrypt_string(str source, str password, str algorithm, int key_length, int iteration_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_encrypt_string_1196_comment =
  "C++ Interface:\n"
  "encrypt_string(str source, str password, str algorithm, int key_length, int iteration_count)\n";
#else
static const char *Dtool_encrypt_string_1196_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string decrypt_string(std::string const &source, std::string const &password)
 */
static PyObject *Dtool_decrypt_string_1197(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string decrypt_string(std::string const &source, std::string const &password)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"source", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:decrypt_string", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    std::string return_value = decrypt_string(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decrypt_string(str source, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decrypt_string_1197_comment =
  "C++ Interface:\n"
  "decrypt_string(str source, str password)\n";
#else
static const char *Dtool_decrypt_string_1197_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool encrypt_file(Filename const &source, Filename const &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
 */
static PyObject *Dtool_encrypt_file_1198(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool encrypt_file(Filename const &source, Filename const &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
  PyObject *param0;
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  const char *param3_str = "";
  Py_ssize_t param3_len = 0;
  int param4 = -1;
  int param5 = -1;
  static const char *keyword_list[] = {"source", "dest", "password", "algorithm", "key_length", "iteration_count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#|s#ii:encrypt_file", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "encrypt_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "encrypt_file", "Filename");
    }
    bool return_value = encrypt_file(*param0_this, *param1_this, std::string(param2_str, param2_len), std::string(param3_str, param3_len), (int)param4, (int)param5);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encrypt_file(const Filename source, const Filename dest, str password, str algorithm, int key_length, int iteration_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_encrypt_file_1198_comment =
  "C++ Interface:\n"
  "encrypt_file(const Filename source, const Filename dest, str password, str algorithm, int key_length, int iteration_count)\n";
#else
static const char *Dtool_encrypt_file_1198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool decrypt_file(Filename const &source, Filename const &dest, std::string const &password)
 */
static PyObject *Dtool_decrypt_file_1199(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decrypt_file(Filename const &source, Filename const &dest, std::string const &password)
  PyObject *param0;
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"source", "dest", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:decrypt_file", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "decrypt_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "decrypt_file", "Filename");
    }
    bool return_value = decrypt_file(*param0_this, *param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decrypt_file(const Filename source, const Filename dest, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decrypt_file_1199_comment =
  "C++ Interface:\n"
  "decrypt_file(const Filename source, const Filename dest, str password)\n";
#else
static const char *Dtool_decrypt_file_1199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool encrypt_stream(istream &source, ostream &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
 */
static PyObject *Dtool_encrypt_stream_1200(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool encrypt_stream(istream &source, ostream &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
  PyObject *param0;
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  const char *param3_str = "";
  Py_ssize_t param3_len = 0;
  int param4 = -1;
  int param5 = -1;
  static const char *keyword_list[] = {"source", "dest", "password", "algorithm", "key_length", "iteration_count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#|s#ii:encrypt_stream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5)) {
    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "encrypt_stream", false, true);
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "encrypt_stream", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      bool return_value = encrypt_stream(*param0_this, *param1_this, std::string(param2_str, param2_len), std::string(param3_str, param3_len), (int)param4, (int)param5);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encrypt_stream(istream source, ostream dest, str password, str algorithm, int key_length, int iteration_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_encrypt_stream_1200_comment =
  "C++ Interface:\n"
  "encrypt_stream(istream source, ostream dest, str password, str algorithm, int key_length, int iteration_count)\n";
#else
static const char *Dtool_encrypt_stream_1200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool decrypt_stream(istream &source, ostream &dest, std::string const &password)
 */
static PyObject *Dtool_decrypt_stream_1201(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decrypt_stream(istream &source, ostream &dest, std::string const &password)
  PyObject *param0;
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"source", "dest", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:decrypt_stream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "decrypt_stream", false, true);
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "decrypt_stream", false, true);
    if (param0_this != NULL && param1_this != NULL) {
      bool return_value = decrypt_stream(*param0_this, *param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decrypt_stream(istream source, ostream dest, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_decrypt_stream_1201_comment =
  "C++ Interface:\n"
  "decrypt_stream(istream source, ostream dest, str password)\n";
#else
static const char *Dtool_decrypt_stream_1201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string error_to_text(ErrorUtilCode err)
 */
static PyObject *Dtool_error_to_text_1203(PyObject *, PyObject *arg) {
  // 1-std::string error_to_text(ErrorUtilCode err)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = error_to_text((ErrorUtilCode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "error_to_text(int err)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_error_to_text_1203_comment =
  "C++ Interface:\n"
  "error_to_text(int err)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_error_to_text_1203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int get_write_error(void)
 */
static PyObject *Dtool_get_write_error_1204(PyObject *, PyObject *) {
  // 1-int get_write_error(void)
  int return_value = get_write_error();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_write_error_1204_comment =
  "C++ Interface:\n"
  "get_write_error()\n";
#else
static const char *Dtool_get_write_error_1204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string handle_socket_error(void)
 */
static PyObject *Dtool_handle_socket_error_1205(PyObject *, PyObject *) {
  // 1-std::string handle_socket_error(void)
  std::string return_value = handle_socket_error();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_handle_socket_error_1205_comment =
  "C++ Interface:\n"
  "handle_socket_error()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_handle_socket_error_1205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int get_network_error(void)
 */
static PyObject *Dtool_get_network_error_1206(PyObject *, PyObject *) {
  // 1-int get_network_error(void)
  int return_value = get_network_error();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_network_error_1206_comment =
  "C++ Interface:\n"
  "get_network_error()\n";
#else
static const char *Dtool_get_network_error_1206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string password_hash(std::string const &password, std::string const &salt, int iters, int keylen)
 */
static PyObject *Dtool_password_hash_1555(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string password_hash(std::string const &password, std::string const &salt, int iters, int keylen)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  int param3;
  static const char *keyword_list[] = {"password", "salt", "iters", "keylen", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#ii:password_hash", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3)) {
    std::string return_value = password_hash(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "password_hash(str password, str salt, int iters, int keylen)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_password_hash_1555_comment =
  "C++ Interface:\n"
  "password_hash(str password, str salt, int iters, int keylen)\n";
#else
static const char *Dtool_password_hash_1555_comment = NULL;
#endif

/**
 * Python wrappers for functions of class ConstPointerToArray< double >
 */
/**
 * Python function wrapper for:
 * inline double const &ConstPointerToArray< double >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_element_14(PyObject *self, PyObject *arg) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double const &ConstPointerToArray< double >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    double return_value = (*(const ConstPointerToArray< double >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_element_14_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_element_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< double >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_data_16(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< double >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< double >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_data_16_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_data_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_subdata_17(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< double >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_subdata_17_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_subdata_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< double >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_ref_count_18(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< double >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< double >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_ref_count_18_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_ref_count_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< double >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_node_ref_count_19(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< double >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< double >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_node_ref_count_19_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_node_ref_count_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
 * inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
 * ConstPointerToArray< double >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_double(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< double > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_double, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< double > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_double, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< double >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_double, false, false);
      ConstPointerToArray< double > *result = new ConstPointerToArray< double >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< double > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< double > param0_local;
      PointerToArray< double > const *param0_this = Dtool_Coerce_PointerToArray_double(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< double > param0_local;
      ConstPointerToArray< double > const *param0_this = Dtool_Coerce_ConstPointerToArray_double(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< double >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< double > *Dtool_Coerce_ConstPointerToArray_double(PyObject *args, ConstPointerToArray< double > &coerced) {
  ConstPointerToArray< double > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_double, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< double > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
      PointerToArray< double > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_double, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< double >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< double >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_double(&Dtool_ConstPointerToArray_double._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_double) {
    printf("ConstPointerToArray_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< double > *local_this = (ConstPointerToArray< double > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_double) {
    return (PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return (PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_double) {
    PointerToArrayBase< double >* other_this = (PointerToArrayBase< double >*)from_this;
    return (ConstPointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
    return (ConstPointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< double >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< double >
 */
static int Dtool_Init_PointerToArrayBase_double(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_double) {
    printf("PointerToArrayBase_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< double > *local_this = (PointerToArrayBase< double > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return (PointerToBase< ReferenceCountedVector< double > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< double > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
    return (PointerToArrayBase< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< double >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< double > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< double > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_double_clear_9(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< double > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_double, (void **)&local_this, "PointerToBase_ReferenceCountedVector_double.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< double > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_clear_9_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_clear_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< double > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_double_output_10(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< double > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< double > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< double > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_output_10_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_output_10_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_double(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    printf("PointerToBase_ReferenceCountedVector_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< double > > *local_this = (PointerToBase< ReferenceCountedVector< double > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< double > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToVoid
 */
/**
 * Python function wrapper for:
 * inline bool PointerToVoid::is_null(void) const
 */
static PyObject *Dtool_PointerToVoid_is_null_7(PyObject *self, PyObject *) {
  PointerToVoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToVoid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PointerToVoid::is_null(void) const
  bool return_value = (*(const PointerToVoid*)local_this).is_null();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToVoid_is_null_7_comment =
  "C++ Interface:\n"
  "is_null(PointerToVoid self)\n"
  "\n"
  "/**\n"
  " * Returns true if the PointerTo is a NULL pointer, false otherwise.  (Direct\n"
  " * comparison to a NULL pointer also works.)\n"
  " */";
#else
static const char *Dtool_PointerToVoid_is_null_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t PointerToVoid::get_hash(void) const
 */
static PyObject *Dtool_PointerToVoid_get_hash_8(PyObject *self, PyObject *) {
  PointerToVoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToVoid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t PointerToVoid::get_hash(void) const
  std::size_t return_value = (*(const PointerToVoid*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToVoid_get_hash_8_comment =
  "C++ Interface:\n"
  "get_hash(PointerToVoid self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PointerToVoid_get_hash_8_comment = NULL;
#endif

static int Dtool_Init_PointerToVoid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToVoid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToVoid) {
    printf("PointerToVoid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToVoid *local_this = (PointerToVoid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToVoid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< float >
 */
/**
 * Python function wrapper for:
 * inline float const &ConstPointerToArray< float >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_element_32(PyObject *self, PyObject *arg) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float const &ConstPointerToArray< float >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    float return_value = (*(const ConstPointerToArray< float >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_element_32_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_element_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< float >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_data_34(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< float >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< float >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_data_34_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_data_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_subdata_35(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< float >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_subdata_35_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_subdata_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< float >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_ref_count_36(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< float >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< float >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_ref_count_36_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_ref_count_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< float >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_node_ref_count_37(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< float >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< float >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_node_ref_count_37_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_node_ref_count_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
 * inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
 * ConstPointerToArray< float >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_float(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< float > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_float, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< float > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_float, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< float >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_float, false, false);
      ConstPointerToArray< float > *result = new ConstPointerToArray< float >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< float > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< float > param0_local;
      PointerToArray< float > const *param0_this = Dtool_Coerce_PointerToArray_float(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< float > param0_local;
      ConstPointerToArray< float > const *param0_this = Dtool_Coerce_ConstPointerToArray_float(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< float >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced) {
  ConstPointerToArray< float > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_float, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< float > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
      PointerToArray< float > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_float, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< float >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< float >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_float(&Dtool_ConstPointerToArray_float._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_float) {
    printf("ConstPointerToArray_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< float > *local_this = (ConstPointerToArray< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_float) {
    return (PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return (PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_float) {
    PointerToArrayBase< float >* other_this = (PointerToArrayBase< float >*)from_this;
    return (ConstPointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
    return (ConstPointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< float >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< float >
 */
static int Dtool_Init_PointerToArrayBase_float(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_float) {
    printf("PointerToArrayBase_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< float > *local_this = (PointerToArrayBase< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return (PointerToBase< ReferenceCountedVector< float > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< float > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
    return (PointerToArrayBase< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< float >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< float > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< float > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_float_clear_27(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< float > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_float, (void **)&local_this, "PointerToBase_ReferenceCountedVector_float.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< float > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_clear_27_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_clear_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< float > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_float_output_28(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< float > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< float > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< float > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_output_28_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_output_28_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_float(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    printf("PointerToBase_ReferenceCountedVector_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< float > > *local_this = (PointerToBase< ReferenceCountedVector< float > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< float > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< int >
 */
/**
 * Python function wrapper for:
 * inline int const &ConstPointerToArray< int >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_element_50(PyObject *self, PyObject *arg) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int const &ConstPointerToArray< int >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    int return_value = (*(const ConstPointerToArray< int >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_element_50_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_element_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< int >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_data_52(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< int >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< int >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_data_52_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_data_52_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_subdata_53(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< int >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_subdata_53_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_subdata_53_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< int >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_ref_count_54(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< int >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< int >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_ref_count_54_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_ref_count_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< int >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_node_ref_count_55(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< int >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< int >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_node_ref_count_55_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_node_ref_count_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
 * inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
 * ConstPointerToArray< int >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_int(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< int > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_int, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< int > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_int, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< int >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_int, false, false);
      ConstPointerToArray< int > *result = new ConstPointerToArray< int >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< int > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< int > param0_local;
      PointerToArray< int > const *param0_this = Dtool_Coerce_PointerToArray_int(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< int > param0_local;
      ConstPointerToArray< int > const *param0_this = Dtool_Coerce_ConstPointerToArray_int(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< int >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< int > *Dtool_Coerce_ConstPointerToArray_int(PyObject *args, ConstPointerToArray< int > &coerced) {
  ConstPointerToArray< int > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_int, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< int > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
      PointerToArray< int > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_int, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< int >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< int >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_int(&Dtool_ConstPointerToArray_int._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_int) {
    printf("ConstPointerToArray_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< int > *local_this = (ConstPointerToArray< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_int) {
    return (PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return (PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_int) {
    PointerToArrayBase< int >* other_this = (PointerToArrayBase< int >*)from_this;
    return (ConstPointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
    return (ConstPointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< int >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< int >
 */
static int Dtool_Init_PointerToArrayBase_int(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_int) {
    printf("PointerToArrayBase_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< int > *local_this = (PointerToArrayBase< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return (PointerToBase< ReferenceCountedVector< int > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< int > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
    return (PointerToArrayBase< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< int >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< int > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< int > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_int_clear_45(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< int > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_int, (void **)&local_this, "PointerToBase_ReferenceCountedVector_int.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< int > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_clear_45_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_clear_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< int > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_int_output_46(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< int > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< int > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< int > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_output_46_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_output_46_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_int(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    printf("PointerToBase_ReferenceCountedVector_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< int > > *local_this = (PointerToBase< ReferenceCountedVector< int > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< int > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< unsigned char >
 */
/**
 * Python function wrapper for:
 * inline unsigned char const &ConstPointerToArray< unsigned char >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_element_68(PyObject *self, PyObject *arg) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline unsigned char const &ConstPointerToArray< unsigned char >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    unsigned char return_value = (*(const ConstPointerToArray< unsigned char >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_element_68_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_element_68_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< unsigned char >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_data_70(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< unsigned char >::get_data(void) const
  std::basic_string< char > return_value = (*(const ConstPointerToArray< unsigned char >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_data_70_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_data_70_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > ConstPointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_subdata_71(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > ConstPointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const ConstPointerToArray< unsigned char >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_subdata_71_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_subdata_71_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< unsigned char >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< unsigned char >::get_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< unsigned char >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< unsigned char >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConstPointerToArray< unsigned char >::get_node_ref_count(void) const
  int return_value = (*(const ConstPointerToArray< unsigned char >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
 * inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
 * ConstPointerToArray< unsigned char >::ConstPointerToArray(PyObject *self, PyObject *source)
 */
static int Dtool_Init_ConstPointerToArray_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< unsigned char > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConstPointerToArray_unsigned_char, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< unsigned char > const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_unsigned_char, (void **)&param0_this);
      if (param0_this != NULL) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConstPointerToArray< unsigned char >::ConstPointerToArray(PyObject *self, PyObject *source)
    PyObject *param0;
    static const char *keyword_list[] = {"source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, NULL, &Dtool_ConstPointerToArray_unsigned_char, false, false);
      ConstPointerToArray< unsigned char > *result = new ConstPointerToArray< unsigned char >;
      invoke_extension(result).__init__(self, param0);
      ConstPointerToArray< unsigned char > *return_value = result;
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        delete return_value;
        return -1;
      } else {
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          delete return_value;
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      ConstPointerToArray< unsigned char > param0_local;
      ConstPointerToArray< unsigned char > const *param0_this = Dtool_Coerce_ConstPointerToArray_unsigned_char(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
    PyObject *param0;
    static const char *keyword_list[] = {"copy", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConstPointerToArray", (char **)keyword_list, &param0)) {
      PointerToArray< unsigned char > param0_local;
      PointerToArray< unsigned char > const *param0_this = Dtool_Coerce_PointerToArray_unsigned_char(param0, param0_local);
      if ((param0_this != NULL)) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: ConstPointerToArray< unsigned char >::ConstPointerToArray(PyObject *self, PyObject *source)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n"
      "ConstPointerToArray(object source)\n");
  }
  return -1;
}

ConstPointerToArray< unsigned char > *Dtool_Coerce_ConstPointerToArray_unsigned_char(PyObject *args, ConstPointerToArray< unsigned char > &coerced) {
  ConstPointerToArray< unsigned char > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConstPointerToArray_unsigned_char, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< unsigned char > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
      PointerToArray< unsigned char > const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_PointerToArray_unsigned_char, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = ConstPointerToArray< unsigned char >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 ConstPointerToArray< unsigned char >::ConstPointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_ConstPointerToArray_unsigned_char(&Dtool_ConstPointerToArray_unsigned_char._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConstPointerToArray_unsigned_char) {
    printf("ConstPointerToArray_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConstPointerToArray< unsigned char > *local_this = (ConstPointerToArray< unsigned char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConstPointerToArray_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return (PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return (PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    PointerToArrayBase< unsigned char >* other_this = (PointerToArrayBase< unsigned char >*)from_this;
    return (ConstPointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
    return (ConstPointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< unsigned char >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< unsigned char >
 */
static int Dtool_Init_PointerToArrayBase_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    printf("PointerToArrayBase_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArrayBase< unsigned char > *local_this = (PointerToArrayBase< unsigned char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return (PointerToBase< ReferenceCountedVector< unsigned char > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< unsigned char > > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
    return (PointerToArrayBase< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< unsigned char >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< unsigned char > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< unsigned char > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_63(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_unsigned_char, (void **)&local_this, "PointerToBase_ReferenceCountedVector_unsigned_char.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< unsigned char > >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_63_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_63_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< unsigned char > >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_64(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< ReferenceCountedVector< unsigned char > >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< ReferenceCountedVector< unsigned char > >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_64_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_64_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    printf("PointerToBase_ReferenceCountedVector_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = (PointerToBase< ReferenceCountedVector< unsigned char > > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< unsigned char > >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigDeclaration
 */
/**
 * Python function wrapper for:
 * inline ConfigPage *ConfigDeclaration::get_page(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_page_83(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigPage *ConfigDeclaration::get_page(void) const
  ConfigPage *return_value = (*(const ConfigDeclaration*)local_this).get_page();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_page_83_comment =
  "C++ Interface:\n"
  "get_page(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the page on which this declaration can be found.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_page_83_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableCore *ConfigDeclaration::get_variable(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_variable_84(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigVariableCore *ConfigDeclaration::get_variable(void) const
  ConfigVariableCore *return_value = (*(const ConfigDeclaration*)local_this).get_variable();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_variable_84_comment =
  "C++ Interface:\n"
  "get_variable(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the variable that this declaration names.  This variable may or may\n"
  " * not have been defined by the time the declaration is read.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_variable_84_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigDeclaration::get_string_value(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_string_value_176(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigDeclaration::get_string_value(void) const
  std::string const &return_value = (*(const ConfigDeclaration*)local_this).get_string_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_string_value_176_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the value assigned to this variable.  This is the original one-line\n"
  " * text defined for the variable in the .prc file (or passed to\n"
  " * ConfigPage::make_declaration()).\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_string_value_176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigDeclaration::set_string_value(std::string const &value)
 */
static PyObject *Dtool_ConfigDeclaration_set_string_value_177(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_string_value")) {
    return NULL;
  }
  // 1-inline void ConfigDeclaration::set_string_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_string_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_value(const ConfigDeclaration self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_string_value_177_comment =
  "C++ Interface:\n"
  "set_string_value(const ConfigDeclaration self, str value)\n"
  "\n"
  "/**\n"
  " * Changes the value assigned to this variable.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_set_string_value_177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigDeclaration::get_num_words(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_num_words_178(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigDeclaration::get_num_words(void) const
  std::size_t return_value = (*(const ConfigDeclaration*)local_this).get_num_words();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_num_words_178_comment =
  "C++ Interface:\n"
  "get_num_words(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the number of words in the declaration's value.  A word is defined\n"
  " * as a sequence of non-whitespace characters delimited by whitespace.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_num_words_178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_string_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_string_word_179(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigDeclaration::has_string_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:has_string_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigDeclaration*)local_this).has_string_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_string_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_string_word_179_comment =
  "C++ Interface:\n"
  "has_string_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid string value for the\n"
  " * nth word.  This is really the same thing as asking if there are at least n\n"
  " * words in the value.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_string_word_179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_bool_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_bool_word_180(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigDeclaration::has_bool_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:has_bool_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigDeclaration*)local_this).has_bool_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bool_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_bool_word_180_comment =
  "C++ Interface:\n"
  "has_bool_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid boolean value for the\n"
  " * nth word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_bool_word_180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_int_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_int_word_181(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigDeclaration::has_int_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:has_int_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigDeclaration*)local_this).has_int_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_int_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_int_word_181_comment =
  "C++ Interface:\n"
  "has_int_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid integer value for the\n"
  " * nth word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_int_word_181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_int64_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_int64_word_182(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigDeclaration::has_int64_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:has_int64_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigDeclaration*)local_this).has_int64_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_int64_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_int64_word_182_comment =
  "C++ Interface:\n"
  "has_int64_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid int64 value for the nth\n"
  " * word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_int64_word_182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::has_double_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_has_double_word_183(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigDeclaration::has_double_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:has_double_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigDeclaration*)local_this).has_double_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_double_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_has_double_word_183_comment =
  "C++ Interface:\n"
  "has_double_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns true if the declaration's value has a valid integer value for the\n"
  " * nth word.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_has_double_word_183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigDeclaration::get_string_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_string_word_184(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigDeclaration::get_string_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_string_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigDeclaration*)local_this).get_string_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_string_word_184_comment =
  "C++ Interface:\n"
  "get_string_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the string value of the nth word of the declaration's value, or\n"
  " * empty string if there is no nth value.  See also has_string_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_string_word_184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigDeclaration::get_bool_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_bool_word_185(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigDeclaration::get_bool_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_bool_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigDeclaration*)local_this).get_bool_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bool_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_bool_word_185_comment =
  "C++ Interface:\n"
  "get_bool_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the boolean value of the nth word of the declaration's value, or\n"
  " * false if there is no nth value.  See also has_bool_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_bool_word_185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigDeclaration::get_int_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_int_word_186(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigDeclaration::get_int_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_int_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int return_value = (*(const ConfigDeclaration*)local_this).get_int_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_int_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_int_word_186_comment =
  "C++ Interface:\n"
  "get_int_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the integer value of the nth word of the declaration's value, or 0\n"
  " * if there is no nth value.  See also has_int_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_int_word_186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigDeclaration::get_int64_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_int64_word_187(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int64_t ConfigDeclaration::get_int64_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_int64_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int64_t return_value = (*(const ConfigDeclaration*)local_this).get_int64_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_int64_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_int64_word_187_comment =
  "C++ Interface:\n"
  "get_int64_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the int64 value of the nth word of the declaration's value, or 0 if\n"
  " * there is no nth value.  See also has_int64_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_int64_word_187_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigDeclaration::get_double_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigDeclaration_get_double_word_188(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ConfigDeclaration::get_double_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_double_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    double return_value = (*(const ConfigDeclaration*)local_this).get_double_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_double_word(ConfigDeclaration self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_double_word_188_comment =
  "C++ Interface:\n"
  "get_double_word(ConfigDeclaration self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the integer value of the nth word of the declaration's value, or 0\n"
  " * if there is no nth value.  See also has_double_word().\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_double_word_188_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_string_word(std::size_t n, std::string const &value)
 */
static PyObject *Dtool_ConfigDeclaration_set_string_word_189(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_string_word")) {
    return NULL;
  }
  // 1-void ConfigDeclaration::set_string_word(std::size_t n, std::string const &value)
  Py_ssize_t param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ns#:set_string_word", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_string_word((std::size_t)param1, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_word(const ConfigDeclaration self, int n, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_string_word_189_comment =
  "C++ Interface:\n"
  "set_string_word(const ConfigDeclaration self, int n, str value)\n";
#else
static const char *Dtool_ConfigDeclaration_set_string_word_189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_bool_word(std::size_t n, bool value)
 */
static PyObject *Dtool_ConfigDeclaration_set_bool_word_190(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_bool_word")) {
    return NULL;
  }
  // 1-void ConfigDeclaration::set_bool_word(std::size_t n, bool value)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_bool_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_bool_word((std::size_t)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bool_word(const ConfigDeclaration self, int n, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_bool_word_190_comment =
  "C++ Interface:\n"
  "set_bool_word(const ConfigDeclaration self, int n, bool value)\n";
#else
static const char *Dtool_ConfigDeclaration_set_bool_word_190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_int_word(std::size_t n, int value)
 */
static PyObject *Dtool_ConfigDeclaration_set_int_word_191(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_int_word")) {
    return NULL;
  }
  // 1-void ConfigDeclaration::set_int_word(std::size_t n, int value)
  Py_ssize_t param1;
  int param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:set_int_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_int_word((std::size_t)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_int_word(const ConfigDeclaration self, int n, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_int_word_191_comment =
  "C++ Interface:\n"
  "set_int_word(const ConfigDeclaration self, int n, int value)\n";
#else
static const char *Dtool_ConfigDeclaration_set_int_word_191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_int64_word(std::size_t n, int64_t value)
 */
static PyObject *Dtool_ConfigDeclaration_set_int64_word_192(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_int64_word")) {
    return NULL;
  }
  // 1-void ConfigDeclaration::set_int64_word(std::size_t n, int64_t value)
  Py_ssize_t param1;
  PY_LONG_LONG param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nL:set_int64_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_int64_word((std::size_t)param1, (int64_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_int64_word(const ConfigDeclaration self, int n, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_int64_word_192_comment =
  "C++ Interface:\n"
  "set_int64_word(const ConfigDeclaration self, int n, long value)\n";
#else
static const char *Dtool_ConfigDeclaration_set_int64_word_192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::set_double_word(std::size_t n, double value)
 */
static PyObject *Dtool_ConfigDeclaration_set_double_word_193(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigDeclaration, (void **)&local_this, "ConfigDeclaration.set_double_word")) {
    return NULL;
  }
  // 1-void ConfigDeclaration::set_double_word(std::size_t n, double value)
  Py_ssize_t param1;
  double param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:set_double_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_double_word((std::size_t)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_double_word(const ConfigDeclaration self, int n, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_set_double_word_193_comment =
  "C++ Interface:\n"
  "set_double_word(const ConfigDeclaration self, int n, double value)\n";
#else
static const char *Dtool_ConfigDeclaration_set_double_word_193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigDeclaration::get_decl_seq(void) const
 */
static PyObject *Dtool_ConfigDeclaration_get_decl_seq_194(PyObject *self, PyObject *) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigDeclaration::get_decl_seq(void) const
  int return_value = (*(const ConfigDeclaration*)local_this).get_decl_seq();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_get_decl_seq_194_comment =
  "C++ Interface:\n"
  "get_decl_seq(ConfigDeclaration self)\n"
  "\n"
  "/**\n"
  " * Returns the sequence number of the declaration within the page.  Sequence\n"
  " * numbers are assigned as each declaration is created; each declaration is\n"
  " * given a higher sequence number than all the declarations created in the\n"
  " * page before it.\n"
  " */";
#else
static const char *Dtool_ConfigDeclaration_get_decl_seq_194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::output(ostream &out) const
 */
static PyObject *Dtool_ConfigDeclaration_output_195(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigDeclaration::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigDeclaration.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigDeclaration*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigDeclaration self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_output_195_comment =
  "C++ Interface:\n"
  "output(ConfigDeclaration self, ostream out)\n";
#else
static const char *Dtool_ConfigDeclaration_output_195_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigDeclaration::write(ostream &out) const
 */
static PyObject *Dtool_ConfigDeclaration_write_196(PyObject *self, PyObject *arg) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigDeclaration::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigDeclaration.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigDeclaration*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigDeclaration self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigDeclaration_write_196_comment =
  "C++ Interface:\n"
  "write(ConfigDeclaration self, ostream out)\n";
#else
static const char *Dtool_ConfigDeclaration_write_196_comment = NULL;
#endif

static PyObject *Dtool_ConfigDeclaration_page_Getter(PyObject *self, void *) {
  const ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ConfigPage *ConfigDeclaration::get_page(void) const
  ConfigPage *return_value = (*(const ConfigDeclaration*)local_this).get_page();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

static PyObject *Dtool_ConfigDeclaration_variable_Getter(PyObject *self, void *) {
  const ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ConfigVariableCore *ConfigDeclaration::get_variable(void) const
  ConfigVariableCore *return_value = (*(const ConfigDeclaration*)local_this).get_variable();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
}

static int Dtool_Init_ConfigDeclaration(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigDeclaration) {
    printf("ConfigDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigDeclaration *local_this = (ConfigDeclaration *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigDeclaration) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigDeclaration(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigDeclaration) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigDeclaration*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigFlags
 */
/**
 * Python function wrapper for:
 * NotifyCategory *ConfigFlags::downcast_to_NotifyCategory(void)
 */
static PyObject *Dtool_ConfigFlags_downcast_to_NotifyCategory_674(PyObject *self, PyObject *) {
  ConfigFlags *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigFlags, (void **)&local_this, "ConfigFlags.downcast_to_NotifyCategory")) {
    return NULL;
  }
  // 1-NotifyCategory *ConfigFlags::downcast_to_NotifyCategory(void)
  NotifyCategory *return_value = (NotifyCategory *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigFlags_downcast_to_NotifyCategory_674_comment =
  "C++ Interface:\n"
  "downcast_to_NotifyCategory(const ConfigFlags self)\n"
  "\n"
  "downcast from ConfigFlags to NotifyCategory";
#else
static const char *Dtool_ConfigFlags_downcast_to_NotifyCategory_674_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigFlags::ConfigFlags(void) = default
 * inline ConfigFlags::ConfigFlags(ConfigFlags const &) = default
 */
static int Dtool_Init_ConfigFlags(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ConfigFlags::ConfigFlags(void) = default
      ConfigFlags *return_value = new ConfigFlags();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigFlags, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline ConfigFlags::ConfigFlags(ConfigFlags const &) = default
      ConfigFlags const *arg_this = (ConfigFlags *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigFlags, 0, "ConfigFlags.ConfigFlags", true, true);
      if (arg_this != NULL) {
        ConfigFlags *return_value = new ConfigFlags(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigFlags, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigFlags() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigFlags()\n"
      "ConfigFlags(const ConfigFlags param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConfigFlags(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigFlags) {
    printf("ConfigFlags ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigFlags *local_this = (ConfigFlags *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigFlags(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigPage
 */
/**
 * Python function wrapper for:
 * static ConfigPage *ConfigPage::get_default_page(void)
 */
static PyObject *Dtool_ConfigPage_get_default_page_88(PyObject *, PyObject *) {
  // 1-static ConfigPage *ConfigPage::get_default_page(void)
  ConfigPage *return_value = ConfigPage::get_default_page();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_default_page_88_comment =
  "C++ Interface:\n"
  "get_default_page()\n";
#else
static const char *Dtool_ConfigPage_get_default_page_88_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ConfigPage *ConfigPage::get_local_page(void)
 */
static PyObject *Dtool_ConfigPage_get_local_page_89(PyObject *, PyObject *) {
  // 1-static ConfigPage *ConfigPage::get_local_page(void)
  ConfigPage *return_value = ConfigPage::get_local_page();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_local_page_89_comment =
  "C++ Interface:\n"
  "get_local_page()\n";
#else
static const char *Dtool_ConfigPage_get_local_page_89_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigPage::get_name(void) const
 */
static PyObject *Dtool_ConfigPage_get_name_90(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigPage::get_name(void) const
  std::string const &return_value = (*(const ConfigPage*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_name_90_comment =
  "C++ Interface:\n"
  "get_name(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the page.  If the page was loaded from a .prc file,\n"
  " * this is usually the filename.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_name_90_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigPage::is_special(void) const
 */
static PyObject *Dtool_ConfigPage_is_special_95(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigPage::is_special(void) const
  bool return_value = (*(const ConfigPage*)local_this).is_special();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_is_special_95_comment =
  "C++ Interface:\n"
  "is_special(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is the special \"default\" or \"local\" page, or false if\n"
  " * it is an ordinary page, e.g.  an implicit page loaded from a prc file at\n"
  " * startup, or an explicit page created by\n"
  " * ConfigPageManager::make_explicit_page().\n"
  " */";
#else
static const char *Dtool_ConfigPage_is_special_95_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigPage::is_implicit(void) const
 */
static PyObject *Dtool_ConfigPage_is_implicit_96(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigPage::is_implicit(void) const
  bool return_value = (*(const ConfigPage*)local_this).is_implicit();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_is_implicit_96_comment =
  "C++ Interface:\n"
  "is_implicit(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns true if the page was loaded by implicitly searching the config path\n"
  " * on startup, or false if it was explicitly loaded by dynamic code after\n"
  " * initial startup.\n"
  " */";
#else
static const char *Dtool_ConfigPage_is_implicit_96_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::set_sort(int sort)
 */
static PyObject *Dtool_ConfigPage_set_sort_100(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.set_sort")) {
    return NULL;
  }
  // 1-void ConfigPage::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_sort((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const ConfigPage self, int sort)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_set_sort_100_comment =
  "C++ Interface:\n"
  "set_sort(const ConfigPage self, int sort)\n";
#else
static const char *Dtool_ConfigPage_set_sort_100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigPage::get_sort(void) const
 */
static PyObject *Dtool_ConfigPage_get_sort_101(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigPage::get_sort(void) const
  int return_value = (*(const ConfigPage*)local_this).get_sort();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_sort_101_comment =
  "C++ Interface:\n"
  "get_sort(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the explicit sort order of this particular ConfigPage.  See\n"
  " * set_sort().\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_sort_101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigPage::get_page_seq(void) const
 */
static PyObject *Dtool_ConfigPage_get_page_seq_104(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigPage::get_page_seq(void) const
  int return_value = (*(const ConfigPage*)local_this).get_page_seq();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_page_seq_104_comment =
  "C++ Interface:\n"
  "get_page_seq(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the sequence number of the page.\n"
  " *\n"
  " * Sequence numbers for a particular class (implicit vs.  explicit) of pages\n"
  " * are assigned as each page is loaded; each page is given a higher sequence\n"
  " * number than all the pages loaded before it.\n"
  " *\n"
  " * The implicit_load pages, which are discovered in the file system\n"
  " * automatically, have a different set of sequence numbers than the explicit\n"
  " * pages.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_page_seq_104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigPage::get_trust_level(void) const
 */
static PyObject *Dtool_ConfigPage_get_trust_level_105(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigPage::get_trust_level(void) const
  int return_value = (*(const ConfigPage*)local_this).get_trust_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_trust_level_105_comment =
  "C++ Interface:\n"
  "get_trust_level(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the trust level associated with this page.  An untrusted page is\n"
  " * trust level 0; if the page was loaded from a signed .prc file, its trust\n"
  " * level is the index number of the certificate that signed it.  Generally, a\n"
  " * higher trust level value represents a greater level of trust.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_trust_level_105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigPage::set_trust_level(int trust_level)
 */
static PyObject *Dtool_ConfigPage_set_trust_level_106(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.set_trust_level")) {
    return NULL;
  }
  // 1-inline void ConfigPage::set_trust_level(int trust_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_trust_level((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_trust_level(const ConfigPage self, int trust_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_set_trust_level_106_comment =
  "C++ Interface:\n"
  "set_trust_level(const ConfigPage self, int trust_level)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the trust level on this particular page.  Note that any\n"
  " * subsequent changes to the page, or to any variable declarations on it, will\n"
  " * reset the trust level to zero.\n"
  " */";
#else
static const char *Dtool_ConfigPage_set_trust_level_106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigPage::get_signature(void) const
 */
static PyObject *Dtool_ConfigPage_get_signature_107(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigPage::get_signature(void) const
  std::string const &return_value = (*(const ConfigPage*)local_this).get_signature();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_signature_107_comment =
  "C++ Interface:\n"
  "get_signature(ConfigPage self)\n"
  "\n"
  "/**\n"
  " * Returns the raw binary signature that was found in the prc file, if any.\n"
  " * This method is probably not terribly useful for most applications.\n"
  " */";
#else
static const char *Dtool_ConfigPage_get_signature_107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::clear(void)
 */
static PyObject *Dtool_ConfigPage_clear_111(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.clear")) {
    return NULL;
  }
  // 1-void ConfigPage::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_clear_111_comment =
  "C++ Interface:\n"
  "clear(const ConfigPage self)\n";
#else
static const char *Dtool_ConfigPage_clear_111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::read_prc(istream &in)
 */
static PyObject *Dtool_ConfigPage_read_prc_112(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.read_prc")) {
    return NULL;
  }
  // 1-bool ConfigPage::read_prc(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "ConfigPage.read_prc", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).read_prc(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_prc(const ConfigPage self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_read_prc_112_comment =
  "C++ Interface:\n"
  "read_prc(const ConfigPage self, istream in)\n";
#else
static const char *Dtool_ConfigPage_read_prc_112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::read_encrypted_prc(istream &in, std::string const &password)
 */
static PyObject *Dtool_ConfigPage_read_encrypted_prc_113(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.read_encrypted_prc")) {
    return NULL;
  }
  // 1-bool ConfigPage::read_encrypted_prc(istream &in, std::string const &password)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"in", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:read_encrypted_prc", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "ConfigPage.read_encrypted_prc", false, true);
    if (param1_this != NULL) {
      bool return_value = (*local_this).read_encrypted_prc(*param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_encrypted_prc(const ConfigPage self, istream in, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_read_encrypted_prc_113_comment =
  "C++ Interface:\n"
  "read_encrypted_prc(const ConfigPage self, istream in, str password)\n";
#else
static const char *Dtool_ConfigPage_read_encrypted_prc_113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration *ConfigPage::make_declaration(ConfigVariableCore *variable, std::string const &value)
 * ConfigDeclaration *ConfigPage::make_declaration(std::string const &variable, std::string const &value)
 */
static PyObject *Dtool_ConfigPage_make_declaration_114(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.make_declaration")) {
    return NULL;
  }
  {
    // -2 ConfigDeclaration *ConfigPage::make_declaration(ConfigVariableCore *variable, std::string const &value)
    PyObject *param1;
    char *param2_str = NULL;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"variable", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:make_declaration", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
      ConfigVariableCore *param1_this = (ConfigVariableCore *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ConfigVariableCore, 1, "ConfigPage.make_declaration", false, false);
      if (param1_this != NULL) {
        ConfigDeclaration *return_value = (*local_this).make_declaration(param1_this, std::string(param2_str, param2_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 ConfigDeclaration *ConfigPage::make_declaration(std::string const &variable, std::string const &value)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    char *param2_str = NULL;
    Py_ssize_t param2_len;
    static const char *keyword_list[] = {"variable", "value", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:make_declaration", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      ConfigDeclaration *return_value = (*local_this).make_declaration(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: ConfigDeclaration *ConfigPage::make_declaration(ConfigVariableCore *variable, std::string const &value)
  // No coercion possible: ConfigDeclaration *ConfigPage::make_declaration(std::string const &variable, std::string const &value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_declaration(const ConfigPage self, ConfigVariableCore variable, str value)\n"
      "make_declaration(const ConfigPage self, str variable, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_make_declaration_114_comment =
  "C++ Interface:\n"
  "make_declaration(const ConfigPage self, ConfigVariableCore variable, str value)\n"
  "make_declaration(const ConfigPage self, str variable, str value)\n";
#else
static const char *Dtool_ConfigPage_make_declaration_114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::delete_declaration(ConfigDeclaration *decl)
 */
static PyObject *Dtool_ConfigPage_delete_declaration_115(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.delete_declaration")) {
    return NULL;
  }
  // 1-bool ConfigPage::delete_declaration(ConfigDeclaration *decl)
  ConfigDeclaration *arg_this = (ConfigDeclaration *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigDeclaration, 1, "ConfigPage.delete_declaration", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).delete_declaration(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_declaration(const ConfigPage self, ConfigDeclaration decl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_delete_declaration_115_comment =
  "C++ Interface:\n"
  "delete_declaration(const ConfigPage self, ConfigDeclaration decl)\n";
#else
static const char *Dtool_ConfigPage_delete_declaration_115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t ConfigPage::get_num_declarations(void) const
 */
static PyObject *Dtool_ConfigPage_get_num_declarations_116(PyObject *self, PyObject *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t ConfigPage::get_num_declarations(void) const
  std::size_t return_value = (*(const ConfigPage*)local_this).get_num_declarations();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_num_declarations_116_comment =
  "C++ Interface:\n"
  "get_num_declarations(ConfigPage self)\n";
#else
static const char *Dtool_ConfigPage_get_num_declarations_116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration const *ConfigPage::get_declaration(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_get_declaration_117(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConfigDeclaration const *ConfigPage::get_declaration(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_declaration", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigDeclaration const *return_value = (*(const ConfigPage*)local_this).get_declaration((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_declaration(ConfigPage self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_declaration_117_comment =
  "C++ Interface:\n"
  "get_declaration(ConfigPage self, int n)\n";
#else
static const char *Dtool_ConfigPage_get_declaration_117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration *ConfigPage::modify_declaration(std::size_t n)
 */
static PyObject *Dtool_ConfigPage_modify_declaration_118(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.modify_declaration")) {
    return NULL;
  }
  // 1-ConfigDeclaration *ConfigPage::modify_declaration(std::size_t n)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:modify_declaration", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigDeclaration *return_value = (*local_this).modify_declaration((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_declaration(const ConfigPage self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_modify_declaration_118_comment =
  "C++ Interface:\n"
  "modify_declaration(const ConfigPage self, int n)\n";
#else
static const char *Dtool_ConfigPage_modify_declaration_118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string ConfigPage::get_variable_name(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_get_variable_name_119(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string ConfigPage::get_variable_name(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_variable_name", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigPage*)local_this).get_variable_name((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable_name(ConfigPage self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_variable_name_119_comment =
  "C++ Interface:\n"
  "get_variable_name(ConfigPage self, int n)\n";
#else
static const char *Dtool_ConfigPage_get_variable_name_119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string ConfigPage::get_string_value(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_get_string_value_120(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string ConfigPage::get_string_value(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_string_value", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigPage*)local_this).get_string_value((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_value(ConfigPage self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_get_string_value_120_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigPage self, int n)\n";
#else
static const char *Dtool_ConfigPage_get_string_value_120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPage::is_variable_used(std::size_t n) const
 */
static PyObject *Dtool_ConfigPage_is_variable_used_121(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConfigPage::is_variable_used(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:is_variable_used", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigPage*)local_this).is_variable_used((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_variable_used(ConfigPage self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_is_variable_used_121_comment =
  "C++ Interface:\n"
  "is_variable_used(ConfigPage self, int n)\n";
#else
static const char *Dtool_ConfigPage_is_variable_used_121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::output(ostream &out) const
 */
static PyObject *Dtool_ConfigPage_output_124(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigPage::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigPage.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigPage*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigPage self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_output_124_comment =
  "C++ Interface:\n"
  "output(ConfigPage self, ostream out)\n";
#else
static const char *Dtool_ConfigPage_output_124_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::output_brief_signature(ostream &out) const
 */
static PyObject *Dtool_ConfigPage_output_brief_signature_125(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigPage::output_brief_signature(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigPage.output_brief_signature", false, true);
  if (arg_this != NULL) {
    (*(const ConfigPage*)local_this).output_brief_signature(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_brief_signature(ConfigPage self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_output_brief_signature_125_comment =
  "C++ Interface:\n"
  "output_brief_signature(ConfigPage self, ostream out)\n";
#else
static const char *Dtool_ConfigPage_output_brief_signature_125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPage::write(ostream &out) const
 */
static PyObject *Dtool_ConfigPage_write_126(PyObject *self, PyObject *arg) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigPage::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigPage.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigPage*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigPage self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPage_write_126_comment =
  "C++ Interface:\n"
  "write(ConfigPage self, ostream out)\n";
#else
static const char *Dtool_ConfigPage_write_126_comment = NULL;
#endif

static PyObject *Dtool_ConfigPage_name_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigPage::get_name(void) const
  std::string const &return_value = (*(const ConfigPage*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_special_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigPage::is_special(void) const
  bool return_value = (*(const ConfigPage*)local_this).is_special();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_implicit_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigPage::is_implicit(void) const
  bool return_value = (*(const ConfigPage*)local_this).is_implicit();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_sort_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigPage::get_sort(void) const
  int return_value = (*(const ConfigPage*)local_this).get_sort();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigPage_sort_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.sort")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete sort attribute");
    return -1;
  }
  // 1-void ConfigPage::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_sort((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_sort(const ConfigPage self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigPage_page_seq_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigPage::get_page_seq(void) const
  int return_value = (*(const ConfigPage*)local_this).get_page_seq();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigPage_trust_level_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigPage::get_trust_level(void) const
  int return_value = (*(const ConfigPage*)local_this).get_trust_level();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigPage_trust_level_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPage, (void **)&local_this, "ConfigPage.trust_level")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete trust_level attribute");
    return -1;
  }
  // 1-inline void ConfigPage::set_trust_level(int trust_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_trust_level((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_trust_level(const ConfigPage self, int trust_level)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigPage_signature_Getter(PyObject *self, void *) {
  const ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigPage::get_signature(void) const
  std::string const &return_value = (*(const ConfigPage*)local_this).get_signature();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property ConfigPage::declarations
 */
static Py_ssize_t Dtool_ConfigPage_declarations_Len(PyObject *self) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_declarations();
}

/**
 * sequence getter for property ConfigPage::declarations
 */
static PyObject *Dtool_ConfigPage_declarations_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_declarations()) {
    PyErr_SetString(PyExc_IndexError, "ConfigPage.declarations[] index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-ConfigDeclaration *ConfigPage::modify_declaration(std::size_t n)
    ConfigDeclaration *return_value = (*local_this).modify_declaration(index);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call ConfigPage.modify_declaration() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_declaration(const ConfigPage self, index)\n");
  }
}

static PyObject *Dtool_ConfigPage_declarations_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigPage_declarations_Len;
  wrap->_getitem_func = &Dtool_ConfigPage_declarations_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static int Dtool_Init_ConfigPage(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigPage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigPage) {
    printf("ConfigPage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigPage *local_this = (ConfigPage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigPage) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigPage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigPage) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableCore
 */
/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableCore::get_name(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_name_130(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigVariableCore::get_name(void) const
  std::string const &return_value = (*(const ConfigVariableCore*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_name_130_comment =
  "C++ Interface:\n"
  "get_name(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_name_130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::is_used(void) const
 */
static PyObject *Dtool_ConfigVariableCore_is_used_131(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableCore::is_used(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).is_used();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_is_used_131_comment =
  "C++ Interface:\n"
  "is_used(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable has been referenced by a ConfigVariable\n"
  " * somewhere in code, false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_is_used_131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigFlags::ValueType ConfigVariableCore::get_value_type(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_value_type_132(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigFlags::ValueType ConfigVariableCore::get_value_type(void) const
  ConfigFlags::ValueType return_value = (*(const ConfigVariableCore*)local_this).get_value_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_value_type_132_comment =
  "C++ Interface:\n"
  "get_value_type(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the stated type of this variable.  If the variable has not yet been\n"
  " * defined, this will be VT_undefined.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_value_type_132_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableCore::get_description(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_description_133(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigVariableCore::get_description(void) const
  std::string const &return_value = (*(const ConfigVariableCore*)local_this).get_description();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_description_133_comment =
  "C++ Interface:\n"
  "get_description(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the brief description of this variable, if it has been defined.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_description_133_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableCore::get_flags(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_flags_134(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableCore::get_flags(void) const
  int return_value = (*(const ConfigVariableCore*)local_this).get_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_flags_134_comment =
  "C++ Interface:\n"
  "get_flags(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the flags value as set by set_flags().  This includes the trust\n"
  " * level and some other settings.  See the individual methods is_closed(),\n"
  " * get_trust_level(), etc.  to pull out the semantic meaning of these flags\n"
  " * individually.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_flags_134_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::is_closed(void) const
 */
static PyObject *Dtool_ConfigVariableCore_is_closed_135(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableCore::is_closed(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_is_closed_135_comment =
  "C++ Interface:\n"
  "is_closed(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable is not trusted by any prc file (and hence\n"
  " * cannot be modified from its compiled-in default value), or false for the\n"
  " * normal case, in which the variable can be modified by any prc file at or\n"
  " * above its trust level (see get_trust_level()).\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_is_closed_135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableCore::get_trust_level(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_trust_level_136(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableCore::get_trust_level(void) const
  int return_value = (*(const ConfigVariableCore*)local_this).get_trust_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_trust_level_136_comment =
  "C++ Interface:\n"
  "get_trust_level(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum trust_level a prc file must demonstrate in order to\n"
  " * redefine the value for this variable.  Arguably, this should be called the\n"
  " * \"mistrust level\", since the larger the value, the more suspicious we are of\n"
  " * prc files.  This value is not used if is_closed() returns true, which\n"
  " * indicates no file may be trusted.\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_trust_level_136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::is_dynamic(void) const
 */
static PyObject *Dtool_ConfigVariableCore_is_dynamic_137(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableCore::is_dynamic(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).is_dynamic();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_is_dynamic_137_comment =
  "C++ Interface:\n"
  "is_dynamic(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable was indicated as \"dynamic\" by its constructor,\n"
  " * indicating that its name was dynamically generated, possibly from a large\n"
  " * pool, and it should not be listed along with the other variables.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_is_dynamic_137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_default_value_138(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_default_value(void) const
  ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_default_value_138_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the default variable specified for this variable.  If the variable\n"
  " * has not yet been defined, this will return NULL.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_default_value_138_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_value_type(ConfigFlags::ValueType value_type)
 */
static PyObject *Dtool_ConfigVariableCore_set_value_type_139(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_value_type")) {
    return NULL;
  }
  // 1-void ConfigVariableCore::set_value_type(ConfigFlags::ValueType value_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_value_type((ConfigFlags::ValueType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_type(const ConfigVariableCore self, int value_type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_value_type_139_comment =
  "C++ Interface:\n"
  "set_value_type(const ConfigVariableCore self, int value_type)\n";
#else
static const char *Dtool_ConfigVariableCore_set_value_type_139_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_flags(int flags)
 */
static PyObject *Dtool_ConfigVariableCore_set_flags_140(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_flags")) {
    return NULL;
  }
  // 1-void ConfigVariableCore::set_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_flags((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flags(const ConfigVariableCore self, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_flags_140_comment =
  "C++ Interface:\n"
  "set_flags(const ConfigVariableCore self, int flags)\n";
#else
static const char *Dtool_ConfigVariableCore_set_flags_140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_description(std::string const &description)
 */
static PyObject *Dtool_ConfigVariableCore_set_description_141(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_description")) {
    return NULL;
  }
  // 1-void ConfigVariableCore::set_description(std::string const &description)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_description(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_description(const ConfigVariableCore self, str description)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_description_141_comment =
  "C++ Interface:\n"
  "set_description(const ConfigVariableCore self, str description)\n";
#else
static const char *Dtool_ConfigVariableCore_set_description_141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::set_default_value(std::string const &default_value)
 */
static PyObject *Dtool_ConfigVariableCore_set_default_value_142(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_default_value")) {
    return NULL;
  }
  // 1-void ConfigVariableCore::set_default_value(std::string const &default_value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_default_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_value(const ConfigVariableCore self, str default_value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_default_value_142_comment =
  "C++ Interface:\n"
  "set_default_value(const ConfigVariableCore self, str default_value)\n";
#else
static const char *Dtool_ConfigVariableCore_set_default_value_142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableCore::set_used(void)
 */
static PyObject *Dtool_ConfigVariableCore_set_used_143(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.set_used")) {
    return NULL;
  }
  // 1-inline void ConfigVariableCore::set_used(void)
  (*local_this).set_used();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_set_used_143_comment =
  "C++ Interface:\n"
  "set_used(const ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Marks that the variable has been \"declared\" by a ConfigVariable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_set_used_143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration *ConfigVariableCore::make_local_value(void)
 */
static PyObject *Dtool_ConfigVariableCore_make_local_value_144(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.make_local_value")) {
    return NULL;
  }
  // 1-ConfigDeclaration *ConfigVariableCore::make_local_value(void)
  ConfigDeclaration *return_value = (*local_this).make_local_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_make_local_value_144_comment =
  "C++ Interface:\n"
  "make_local_value(const ConfigVariableCore self)\n";
#else
static const char *Dtool_ConfigVariableCore_make_local_value_144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigVariableCore::clear_local_value(void)
 */
static PyObject *Dtool_ConfigVariableCore_clear_local_value_145(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.clear_local_value")) {
    return NULL;
  }
  // 1-bool ConfigVariableCore::clear_local_value(void)
  bool return_value = (*local_this).clear_local_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_clear_local_value_145_comment =
  "C++ Interface:\n"
  "clear_local_value(const ConfigVariableCore self)\n";
#else
static const char *Dtool_ConfigVariableCore_clear_local_value_145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableCore::has_local_value(void) const
 */
static PyObject *Dtool_ConfigVariableCore_has_local_value_146(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableCore::has_local_value(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).has_local_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_has_local_value_146_comment =
  "C++ Interface:\n"
  "has_local_value(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable's value has been shadowed by a local\n"
  " * assignment (as created via make_local_value()), or false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_has_local_value_146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigVariableCore::has_value(void) const
 */
static PyObject *Dtool_ConfigVariableCore_has_value_147(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConfigVariableCore::has_value(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).has_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_has_value_147_comment =
  "C++ Interface:\n"
  "has_value(ConfigVariableCore self)\n";
#else
static const char *Dtool_ConfigVariableCore_has_value_147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t ConfigVariableCore::get_num_declarations(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_declarations_148(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t ConfigVariableCore::get_num_declarations(void) const
  std::size_t return_value = (*(const ConfigVariableCore*)local_this).get_num_declarations();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_declarations_148_comment =
  "C++ Interface:\n"
  "get_num_declarations(ConfigVariableCore self)\n";
#else
static const char *Dtool_ConfigVariableCore_get_num_declarations_148_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigDeclaration const *ConfigVariableCore::get_declaration(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_declaration_149(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-ConfigDeclaration const *ConfigVariableCore::get_declaration(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_declaration", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_declaration((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_declaration(ConfigVariableCore self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_declaration_149_comment =
  "C++ Interface:\n"
  "get_declaration(ConfigVariableCore self, int n)\n";
#else
static const char *Dtool_ConfigVariableCore_get_declaration_149_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableCore::get_num_references(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_references_151(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableCore::get_num_references(void) const
  std::size_t return_value = (*(const ConfigVariableCore*)local_this).get_num_references();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_references_151_comment =
  "C++ Interface:\n"
  "get_num_references(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of prc files that reference this variable.  This is not\n"
  " * exactly the same as the number of declarations; see get_reference().\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_references_151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_reference(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_reference_152(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_reference(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_reference", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_reference((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_reference(ConfigVariableCore self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_reference_152_comment =
  "C++ Interface:\n"
  "get_reference(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth declaration in a prc file that references this variable.\n"
  " * This is similar, but not identical to, get_declaration().  The difference\n"
  " * is that this will list *only* true references in a prc file, and will not\n"
  " * list default values or locally-assigned values; it also will list even the\n"
  " * untrusted files.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_reference_152_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableCore::get_num_trusted_references(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_trusted_references_154(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableCore::get_num_trusted_references(void) const
  std::size_t return_value = (*(const ConfigVariableCore*)local_this).get_num_trusted_references();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_trusted_references_154_comment =
  "C++ Interface:\n"
  "get_num_trusted_references(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of trusted prc files that reference this variable.  See\n"
  " * also get_num_references().\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_trusted_references_154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_trusted_reference(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_trusted_reference_155(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_trusted_reference(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_trusted_reference", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_trusted_reference((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_trusted_reference(ConfigVariableCore self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_trusted_reference_155_comment =
  "C++ Interface:\n"
  "get_trusted_reference(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth declaration in a trusted prc file that references this\n"
  " * variable.  This is similar, but not identical to, get_declaration().  The\n"
  " * difference is that this will list *only* true references in a prc file, and\n"
  " * will not list default values or locally-assigned values.\n"
  " *\n"
  " * This is also similar to get_reference(), except that it only lists the\n"
  " * trusted declarations, omitting the untrusted ones.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_trusted_reference_155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableCore::get_num_unique_references(void) const
 */
static PyObject *Dtool_ConfigVariableCore_get_num_unique_references_157(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableCore::get_num_unique_references(void) const
  std::size_t return_value = (*(const ConfigVariableCore*)local_this).get_num_unique_references();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_num_unique_references_157_comment =
  "C++ Interface:\n"
  "get_num_unique_references(ConfigVariableCore self)\n"
  "\n"
  "/**\n"
  " * Returns the number of trusted, unique (by string value) values there exist\n"
  " * for this variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_num_unique_references_157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigDeclaration const *ConfigVariableCore::get_unique_reference(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableCore_get_unique_reference_158(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_unique_reference(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_unique_reference", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_unique_reference((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unique_reference(ConfigVariableCore self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_get_unique_reference_158_comment =
  "C++ Interface:\n"
  "get_unique_reference(ConfigVariableCore self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth trusted, unique value for this variable.  This is similar\n"
  " * to get_trusted_reference(), except that duplicate values are removed.\n"
  " */";
#else
static const char *Dtool_ConfigVariableCore_get_unique_reference_158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::output(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableCore_output_163(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableCore::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableCore.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableCore*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableCore self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_output_163_comment =
  "C++ Interface:\n"
  "output(ConfigVariableCore self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableCore_output_163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableCore::write(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableCore_write_164(PyObject *self, PyObject *arg) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableCore::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableCore.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableCore*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableCore self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableCore_write_164_comment =
  "C++ Interface:\n"
  "write(ConfigVariableCore self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableCore_write_164_comment = NULL;
#endif

/**
 * sequence length function for property ConfigVariableCore::declarations
 */
static Py_ssize_t Dtool_ConfigVariableCore_declarations_Len(PyObject *self) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_declarations();
}

/**
 * sequence getter for property ConfigVariableCore::declarations
 */
static PyObject *Dtool_ConfigVariableCore_declarations_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_declarations()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.declarations[] index out of range");
    return NULL;
  }
  // 1-ConfigDeclaration const *ConfigVariableCore::get_declaration(std::size_t n) const
  ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_declaration(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_declaration(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_declarations_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigVariableCore_declarations_Len;
  wrap->_getitem_func = &Dtool_ConfigVariableCore_declarations_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static PyObject *Dtool_ConfigVariableCore_name_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigVariableCore::get_name(void) const
  std::string const &return_value = (*(const ConfigVariableCore*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_used_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableCore::is_used(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).is_used();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_closed_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableCore::is_closed(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).is_closed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_trust_level_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigVariableCore::get_trust_level(void) const
  int return_value = (*(const ConfigVariableCore*)local_this).get_trust_level();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_dynamic_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableCore::is_dynamic(void) const
  bool return_value = (*(const ConfigVariableCore*)local_this).is_dynamic();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableCore_value_type_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ConfigFlags::ValueType ConfigVariableCore::get_value_type(void) const
  ConfigFlags::ValueType return_value = (*(const ConfigVariableCore*)local_this).get_value_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableCore_value_type_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.value_type")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value_type attribute");
    return -1;
  }
  // 1-void ConfigVariableCore::set_value_type(ConfigFlags::ValueType value_type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_value_type((ConfigFlags::ValueType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value_type(const ConfigVariableCore self, int value_type)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableCore_description_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigVariableCore::get_description(void) const
  std::string const &return_value = (*(const ConfigVariableCore*)local_this).get_description();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableCore_description_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.description")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete description attribute");
    return -1;
  }
  // 1-void ConfigVariableCore::set_description(std::string const &description)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_description(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_description(const ConfigVariableCore self, str description)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableCore_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_default_value(void) const
  ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_default_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
}

static int Dtool_ConfigVariableCore_default_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableCore, (void **)&local_this, "ConfigVariableCore.default_value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete default_value attribute");
    return -1;
  }
  // 1-void ConfigVariableCore::set_default_value(std::string const &default_value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_default_value(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_value(const ConfigVariableCore self, str default_value)\n");
  }
  return -1;
}

/**
 * sequence length function for property ConfigVariableCore::references
 */
static Py_ssize_t Dtool_ConfigVariableCore_references_Len(PyObject *self) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_references();
}

/**
 * sequence getter for property ConfigVariableCore::references
 */
static PyObject *Dtool_ConfigVariableCore_references_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_references()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.references[] index out of range");
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_reference(std::size_t n) const
  ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_reference(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_reference(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_references_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigVariableCore_references_Len;
  wrap->_getitem_func = &Dtool_ConfigVariableCore_references_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property ConfigVariableCore::trusted_references
 */
static Py_ssize_t Dtool_ConfigVariableCore_trusted_references_Len(PyObject *self) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_trusted_references();
}

/**
 * sequence getter for property ConfigVariableCore::trusted_references
 */
static PyObject *Dtool_ConfigVariableCore_trusted_references_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_trusted_references()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.trusted_references[] index out of range");
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_trusted_reference(std::size_t n) const
  ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_trusted_reference(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_trusted_reference(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_trusted_references_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigVariableCore_trusted_references_Len;
  wrap->_getitem_func = &Dtool_ConfigVariableCore_trusted_references_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property ConfigVariableCore::unique_references
 */
static Py_ssize_t Dtool_ConfigVariableCore_unique_references_Len(PyObject *self) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_unique_references();
}

/**
 * sequence getter for property ConfigVariableCore::unique_references
 */
static PyObject *Dtool_ConfigVariableCore_unique_references_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_unique_references()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableCore.unique_references[] index out of range");
    return NULL;
  }
  // 1-inline ConfigDeclaration const *ConfigVariableCore::get_unique_reference(std::size_t n) const
  ConfigDeclaration const *return_value = (*(const ConfigVariableCore*)local_this).get_unique_reference(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigDeclaration, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unique_reference(ConfigVariableCore self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableCore_unique_references_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigVariableCore_unique_references_Len;
  wrap->_getitem_func = &Dtool_ConfigVariableCore_unique_references_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static int Dtool_Init_ConfigVariableCore(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_declarations(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_declarations();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_declaration_149(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_references(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_references();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_reference_152(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_trusted_references(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_trusted_references();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_trusted_reference_155(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableCore_get_unique_references(PyObject *self, PyObject *) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_unique_references();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableCore_get_unique_reference_158(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConfigVariableCore(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableCore) {
    printf("ConfigVariableCore ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableCore *local_this = (ConfigVariableCore *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableCore) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableCore(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableCore) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableCore*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigPageManager
 */
/**
 * Python function wrapper for:
 * inline bool ConfigPageManager::loaded_implicit_pages(void) const
 */
static PyObject *Dtool_ConfigPageManager_loaded_implicit_pages_198(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigPageManager::loaded_implicit_pages(void) const
  bool return_value = (*(const ConfigPageManager*)local_this).loaded_implicit_pages();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_loaded_implicit_pages_198_comment =
  "C++ Interface:\n"
  "loaded_implicit_pages(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns true if the implicit *.prc files have already been loaded, false\n"
  " * otherwise.  Normally this will only be false briefly before startup.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_loaded_implicit_pages_198_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigPageManager::load_implicit_pages(void)
 */
static PyObject *Dtool_ConfigPageManager_load_implicit_pages_199(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.load_implicit_pages")) {
    return NULL;
  }
  // 1-inline void ConfigPageManager::load_implicit_pages(void)
  (*local_this).load_implicit_pages();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_load_implicit_pages_199_comment =
  "C++ Interface:\n"
  "load_implicit_pages(const ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Searches the PRC_DIR and/or PRC_PATH directories for *.prc files and loads\n"
  " * them in as pages.  This is normally called automatically at startup time,\n"
  " * when the first variable's value is referenced.  See also\n"
  " * reload_implicit_pages().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_load_implicit_pages_199_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPageManager::reload_implicit_pages(void)
 */
static PyObject *Dtool_ConfigPageManager_reload_implicit_pages_200(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.reload_implicit_pages")) {
    return NULL;
  }
  // 1-void ConfigPageManager::reload_implicit_pages(void)
  (*local_this).reload_implicit_pages();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_reload_implicit_pages_200_comment =
  "C++ Interface:\n"
  "reload_implicit_pages(const ConfigPageManager self)\n";
#else
static const char *Dtool_ConfigPageManager_reload_implicit_pages_200_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath &ConfigPageManager::get_search_path(void)
 */
static PyObject *Dtool_ConfigPageManager_get_search_path_201(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.get_search_path")) {
    return NULL;
  }
  // 1-inline DSearchPath &ConfigPageManager::get_search_path(void)
  DSearchPath *return_value = &((*local_this).get_search_path());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_search_path_201_comment =
  "C++ Interface:\n"
  "get_search_path(const ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the search path used to locate implicit .prc files.  This is\n"
  " * determined by the PRC_DIR and PRC_PATH environment variables.  The object\n"
  " * returned by this method may be modified to change the path at runtime, and\n"
  " * then reload_implicit_pages() called.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_search_path_201_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_prc_patterns(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_prc_patterns_202(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_prc_patterns(void) const
  std::size_t return_value = (*(const ConfigPageManager*)local_this).get_num_prc_patterns();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_prc_patterns_202_comment =
  "C++ Interface:\n"
  "get_num_prc_patterns(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of patterns, like \"*.prc\", that are compiled in that\n"
  " * will be searched for as default config filenames.  Normally there is only\n"
  " * one pattern, and it is \"*.prc\", but others may be specified with the\n"
  " * PRC_FILENAME variable in Config.pp.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_prc_patterns_202_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigPageManager::get_prc_pattern(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_prc_pattern_203(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigPageManager::get_prc_pattern(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_prc_pattern", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigPageManager*)local_this).get_prc_pattern((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prc_pattern(ConfigPageManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_prc_pattern_203_comment =
  "C++ Interface:\n"
  "get_prc_pattern(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth filename pattern that will be considered a match as a valid\n"
  " * config file.  See get_num_prc_patterns().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_prc_pattern_203_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_prc_encrypted_patterns(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_prc_encrypted_patterns(void) const
  std::size_t return_value = (*(const ConfigPageManager*)local_this).get_num_prc_encrypted_patterns();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204_comment =
  "C++ Interface:\n"
  "get_num_prc_encrypted_patterns(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of patterns, like \"*.pre\", that are compiled in that\n"
  " * will be searched for as special config files that are understood to be\n"
  " * encrypted.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigPageManager::get_prc_encrypted_pattern(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_prc_encrypted_pattern_205(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigPageManager::get_prc_encrypted_pattern(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_prc_encrypted_pattern", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigPageManager*)local_this).get_prc_encrypted_pattern((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prc_encrypted_pattern(ConfigPageManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_prc_encrypted_pattern_205_comment =
  "C++ Interface:\n"
  "get_prc_encrypted_pattern(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth filename pattern that will be considered a match as a valid\n"
  " * encrypted config file.  See get_num_prc_encrypted_patterns().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_prc_encrypted_pattern_205_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_prc_executable_patterns(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_prc_executable_patterns_206(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_prc_executable_patterns(void) const
  std::size_t return_value = (*(const ConfigPageManager*)local_this).get_num_prc_executable_patterns();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_prc_executable_patterns_206_comment =
  "C++ Interface:\n"
  "get_num_prc_executable_patterns(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of patterns, like \"*.exe\", that are compiled in that\n"
  " * will be searched for as special config files that are to be executed as a\n"
  " * program, and their output taken to be input.  This is normally empty.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_prc_executable_patterns_206_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigPageManager::get_prc_executable_pattern(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_prc_executable_pattern_207(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigPageManager::get_prc_executable_pattern(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_prc_executable_pattern", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigPageManager*)local_this).get_prc_executable_pattern((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_prc_executable_pattern(ConfigPageManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_prc_executable_pattern_207_comment =
  "C++ Interface:\n"
  "get_prc_executable_pattern(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth filename pattern that will be considered a match as a valid\n"
  " * executable-style config file.  See get_num_prc_executable_patterns().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_prc_executable_pattern_207_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigPage *ConfigPageManager::make_explicit_page(std::string const &name)
 */
static PyObject *Dtool_ConfigPageManager_make_explicit_page_208(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.make_explicit_page")) {
    return NULL;
  }
  // 1-ConfigPage *ConfigPageManager::make_explicit_page(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    ConfigPage *return_value = (*local_this).make_explicit_page(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_explicit_page(const ConfigPageManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_make_explicit_page_208_comment =
  "C++ Interface:\n"
  "make_explicit_page(const ConfigPageManager self, str name)\n";
#else
static const char *Dtool_ConfigPageManager_make_explicit_page_208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigPageManager::delete_explicit_page(ConfigPage *page)
 */
static PyObject *Dtool_ConfigPageManager_delete_explicit_page_209(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigPageManager, (void **)&local_this, "ConfigPageManager.delete_explicit_page")) {
    return NULL;
  }
  // 1-bool ConfigPageManager::delete_explicit_page(ConfigPage *page)
  ConfigPage *arg_this = (ConfigPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigPage, 1, "ConfigPageManager.delete_explicit_page", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).delete_explicit_page(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_explicit_page(const ConfigPageManager self, ConfigPage page)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_delete_explicit_page_209_comment =
  "C++ Interface:\n"
  "delete_explicit_page(const ConfigPageManager self, ConfigPage page)\n";
#else
static const char *Dtool_ConfigPageManager_delete_explicit_page_209_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_implicit_pages(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_implicit_pages_210(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_implicit_pages(void) const
  std::size_t return_value = (*(const ConfigPageManager*)local_this).get_num_implicit_pages();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_implicit_pages_210_comment =
  "C++ Interface:\n"
  "get_num_implicit_pages(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of implicitly-loaded ConfigPages in the world.\n"
  " * These represent files that were automatically discovered on the disk as\n"
  " * .prc files.\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_implicit_pages_210_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigPage *ConfigPageManager::get_implicit_page(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_implicit_page_211(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigPage *ConfigPageManager::get_implicit_page(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_implicit_page", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigPage *return_value = (*(const ConfigPageManager*)local_this).get_implicit_page((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_implicit_page(ConfigPageManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_implicit_page_211_comment =
  "C++ Interface:\n"
  "get_implicit_page(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth implicit ConfigPage in the world.  See\n"
  " * get_num_implicit_pages().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_implicit_page_211_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigPageManager::get_num_explicit_pages(void) const
 */
static PyObject *Dtool_ConfigPageManager_get_num_explicit_pages_212(PyObject *self, PyObject *) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigPageManager::get_num_explicit_pages(void) const
  std::size_t return_value = (*(const ConfigPageManager*)local_this).get_num_explicit_pages();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_num_explicit_pages_212_comment =
  "C++ Interface:\n"
  "get_num_explicit_pages(ConfigPageManager self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of explicitly-loaded ConfigPages in the world.\n"
  " * These represent pages that were loaded dynamically at runtime by explicit\n"
  " * calls to ConfigPageManager::make_explicit_page().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_num_explicit_pages_212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigPage *ConfigPageManager::get_explicit_page(std::size_t n) const
 */
static PyObject *Dtool_ConfigPageManager_get_explicit_page_213(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigPage *ConfigPageManager::get_explicit_page(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_explicit_page", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigPage *return_value = (*(const ConfigPageManager*)local_this).get_explicit_page((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_explicit_page(ConfigPageManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_explicit_page_213_comment =
  "C++ Interface:\n"
  "get_explicit_page(ConfigPageManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth explicit ConfigPage in the world.  See\n"
  " * get_num_explicit_pages().\n"
  " */";
#else
static const char *Dtool_ConfigPageManager_get_explicit_page_213_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPageManager::output(ostream &out) const
 */
static PyObject *Dtool_ConfigPageManager_output_214(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigPageManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigPageManager.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigPageManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigPageManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_output_214_comment =
  "C++ Interface:\n"
  "output(ConfigPageManager self, ostream out)\n";
#else
static const char *Dtool_ConfigPageManager_output_214_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigPageManager::write(ostream &out) const
 */
static PyObject *Dtool_ConfigPageManager_write_215(PyObject *self, PyObject *arg) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigPageManager::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigPageManager.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigPageManager*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigPageManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_write_215_comment =
  "C++ Interface:\n"
  "write(ConfigPageManager self, ostream out)\n";
#else
static const char *Dtool_ConfigPageManager_write_215_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ConfigPageManager *ConfigPageManager::get_global_ptr(void)
 */
static PyObject *Dtool_ConfigPageManager_get_global_ptr_216(PyObject *, PyObject *) {
  // 1-static ConfigPageManager *ConfigPageManager::get_global_ptr(void)
  ConfigPageManager *return_value = ConfigPageManager::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPageManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigPageManager_get_global_ptr_216_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_ConfigPageManager_get_global_ptr_216_comment = NULL;
#endif

static int Dtool_Init_ConfigPageManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigPageManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigPageManager) {
    printf("ConfigPageManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigPageManager *local_this = (ConfigPageManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigPageManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigPageManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigPageManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigPageManager*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariable
 */
/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariable::get_string_value(void) const
 */
static PyObject *Dtool_ConfigVariable_get_string_value_239(PyObject *self, PyObject *) {
  ConfigVariable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigVariable::get_string_value(void) const
  std::string const &return_value = (*(const ConfigVariable*)local_this).get_string_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_get_string_value_239_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigVariable self)\n"
  "\n"
  "/**\n"
  " * Returns the toplevel value of the variable, formatted as a string.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_get_string_value_239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariable::set_string_value(std::string const &value)
 */
static PyObject *Dtool_ConfigVariable_set_string_value_240(PyObject *self, PyObject *arg) {
  ConfigVariable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariable, (void **)&local_this, "ConfigVariable.set_string_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariable::set_string_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_string_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_value(const ConfigVariable self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_set_string_value_240_comment =
  "C++ Interface:\n"
  "set_string_value(const ConfigVariable self, str value)\n"
  "\n"
  "/**\n"
  " * Changes the value assigned to this variable.  This creates a local value\n"
  " * that shadows any values defined in the .prc files, until\n"
  " * clear_local_value() is called.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_set_string_value_240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariable::clear_value(void)
 */
static PyObject *Dtool_ConfigVariable_clear_value_241(PyObject *self, PyObject *) {
  ConfigVariable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariable, (void **)&local_this, "ConfigVariable.clear_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariable::clear_value(void)
  (*local_this).clear_value();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_clear_value_241_comment =
  "C++ Interface:\n"
  "clear_value(const ConfigVariable self)\n"
  "\n"
  "/**\n"
  " * Removes the value assigned to this variable, and lets its original value\n"
  " * (as read from the prc files) show through.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_clear_value_241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariable::get_num_words(void) const
 */
static PyObject *Dtool_ConfigVariable_get_num_words_242(PyObject *self, PyObject *) {
  ConfigVariable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariable::get_num_words(void) const
  std::size_t return_value = (*(const ConfigVariable*)local_this).get_num_words();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariable_get_num_words_242_comment =
  "C++ Interface:\n"
  "get_num_words(ConfigVariable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of words in the variable's value.  A word is defined as\n"
  " * a sequence of non-whitespace characters delimited by whitespace.\n"
  " */";
#else
static const char *Dtool_ConfigVariable_get_num_words_242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariable::ConfigVariable(ConfigVariable const &) = default
 * inline ConfigVariable::ConfigVariable(std::string const &name)
 */
static int Dtool_Init_ConfigVariable(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariable() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline ConfigVariable::ConfigVariable(ConfigVariable const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariable", (char **)keyword_list, &param0)) {
      ConfigVariable const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariable, (void **)&param0_this);
      if (param0_this != NULL) {
        ConfigVariable *return_value = new ConfigVariable(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariable, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConfigVariable::ConfigVariable(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariable", (char **)keyword_list, &param0_str, &param0_len)) {
      ConfigVariable *return_value = new ConfigVariable(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariable, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ConfigVariable::ConfigVariable(ConfigVariable const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariable", (char **)keyword_list, &param0)) {
      ConfigVariable const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_ConfigVariable(param0, param0_this, param0_manage)) {
        ConfigVariable *return_value = new ConfigVariable(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariable, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline ConfigVariable::ConfigVariable(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariable(const ConfigVariable param0)\n"
      "ConfigVariable(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariable(PyObject *args, ConfigVariable const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariable, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariable::ConfigVariable(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariable *return_value = new ConfigVariable(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ConfigVariable(PyObject *args, ConfigVariable *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariable, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariable::ConfigVariable(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariable *return_value = new ConfigVariable(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ConfigVariable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariable) {
    printf("ConfigVariable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariable *local_this = (ConfigVariable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariable*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariable*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableBase
 */
/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableBase::get_name(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_name_219(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigVariableBase::get_name(void) const
  std::string const &return_value = (*(const ConfigVariableBase*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_name_219_comment =
  "C++ Interface:\n"
  "get_name(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_name_219_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_value_type_220(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
  ConfigFlags::ValueType return_value = (*(const ConfigVariableBase*)local_this).get_value_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_value_type_220_comment =
  "C++ Interface:\n"
  "get_value_type(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the stated type of this variable.  This should be VT_list, unless a\n"
  " * later variable declaration has changed it.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_value_type_220_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableBase::get_description(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_description_221(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigVariableBase::get_description(void) const
  std::string const &return_value = (*(const ConfigVariableBase*)local_this).get_description();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_description_221_comment =
  "C++ Interface:\n"
  "get_description(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the brief description of this variable, if it has been defined.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_description_221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableBase::get_flags(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_flags_222(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableBase::get_flags(void) const
  int return_value = (*(const ConfigVariableBase*)local_this).get_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_flags_222_comment =
  "C++ Interface:\n"
  "get_flags(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the flags value as set by set_flags().  This includes the trust\n"
  " * level and some other settings.  See the individual methods is_closed(),\n"
  " * get_trust_level(), etc.  to pull out the semantic meaning of these flags\n"
  " * individually.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_flags_222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::is_closed(void) const
 */
static PyObject *Dtool_ConfigVariableBase_is_closed_223(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBase::is_closed(void) const
  bool return_value = (*(const ConfigVariableBase*)local_this).is_closed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_is_closed_223_comment =
  "C++ Interface:\n"
  "is_closed(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable is not trusted by any prc file (and hence\n"
  " * cannot be modified from its compiled-in default value), or false for the\n"
  " * normal case, in which the variable can be modified by any prc file at or\n"
  " * above its trust level (see get_trust_level()).\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_is_closed_223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableBase::get_trust_level(void) const
 */
static PyObject *Dtool_ConfigVariableBase_get_trust_level_224(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableBase::get_trust_level(void) const
  int return_value = (*(const ConfigVariableBase*)local_this).get_trust_level();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_get_trust_level_224_comment =
  "C++ Interface:\n"
  "get_trust_level(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns the minimum trust_level a prc file must demonstrate in order to\n"
  " * redefine the value for this variable.  Arguably, this should be called the\n"
  " * \"mistrust level\", since the larger the value, the more suspicious we are of\n"
  " * prc files.  This value is not used if is_closed() returns true, which\n"
  " * indicates no file may be trusted.\n"
  " *\n"
  " * This value only has effect in a release build (specifically, when\n"
  " * PRC_RESPECT_TRUST_LEVEL is defined true in Config.pp).\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_get_trust_level_224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::is_dynamic(void) const
 */
static PyObject *Dtool_ConfigVariableBase_is_dynamic_225(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBase::is_dynamic(void) const
  bool return_value = (*(const ConfigVariableBase*)local_this).is_dynamic();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_is_dynamic_225_comment =
  "C++ Interface:\n"
  "is_dynamic(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the variable was indicated as \"dynamic\" by its constructor,\n"
  " * indicating that its name was dynamically generated, possibly from a large\n"
  " * pool, and it should not be listed along with the other variables.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_is_dynamic_225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::clear_local_value(void)
 */
static PyObject *Dtool_ConfigVariableBase_clear_local_value_232(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBase, (void **)&local_this, "ConfigVariableBase.clear_local_value")) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBase::clear_local_value(void)
  bool return_value = (*local_this).clear_local_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_clear_local_value_232_comment =
  "C++ Interface:\n"
  "clear_local_value(const ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Removes the local value defined for this variable, and allows its value to\n"
  " * be once again retrieved from the .prc files.\n"
  " *\n"
  " * Returns true if the value was successfully removed, false if it did not\n"
  " * exist in the first place.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_clear_local_value_232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::has_local_value(void) const
 */
static PyObject *Dtool_ConfigVariableBase_has_local_value_233(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBase::has_local_value(void) const
  bool return_value = (*(const ConfigVariableBase*)local_this).has_local_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_has_local_value_233_comment =
  "C++ Interface:\n"
  "has_local_value(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable's value has been shadowed by a local\n"
  " * assignment (as created via make_local_value()), or false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_has_local_value_233_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBase::has_value(void) const
 */
static PyObject *Dtool_ConfigVariableBase_has_value_234(PyObject *self, PyObject *) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBase::has_value(void) const
  bool return_value = (*(const ConfigVariableBase*)local_this).has_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_has_value_234_comment =
  "C++ Interface:\n"
  "has_value(ConfigVariableBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if this variable has an explicit value, either from a prc file\n"
  " * or locally set, or false if variable has its default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_has_value_234_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBase::output(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableBase_output_235(PyObject *self, PyObject *arg) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ConfigVariableBase::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableBase.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableBase*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_output_235_comment =
  "C++ Interface:\n"
  "output(ConfigVariableBase self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_output_235_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBase::write(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableBase_write_236(PyObject *self, PyObject *arg) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ConfigVariableBase::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableBase.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableBase*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBase_write_236_comment =
  "C++ Interface:\n"
  "write(ConfigVariableBase self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableBase_write_236_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableBase_name_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigVariableBase::get_name(void) const
  std::string const &return_value = (*(const ConfigVariableBase*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_value_type_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ConfigFlags::ValueType ConfigVariableBase::get_value_type(void) const
  ConfigFlags::ValueType return_value = (*(const ConfigVariableBase*)local_this).get_value_type();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_description_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigVariableBase::get_description(void) const
  std::string const &return_value = (*(const ConfigVariableBase*)local_this).get_description();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_closed_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableBase::is_closed(void) const
  bool return_value = (*(const ConfigVariableBase*)local_this).is_closed();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_trust_level_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigVariableBase::get_trust_level(void) const
  int return_value = (*(const ConfigVariableBase*)local_this).get_trust_level();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ConfigVariableBase_dynamic_Getter(PyObject *self, void *) {
  const ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableBase::is_dynamic(void) const
  bool return_value = (*(const ConfigVariableBase*)local_this).is_dynamic();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ConfigVariableBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConfigVariableBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableBase) {
    printf("ConfigVariableBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableBase *local_this = (ConfigVariableBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableBool
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableBool::operator =(bool value)
 */
static PyObject *Dtool_ConfigVariableBool_operator_245(PyObject *self, PyObject *arg) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableBool::operator =(bool value)
  (*local_this).operator =((PyObject_IsTrue(arg) != 0));
  ConfigVariableBool *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableBool, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableBool self, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_operator_245_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableBool self, bool value)\n";
#else
static const char *Dtool_ConfigVariableBool_operator_245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBool::set_value(bool value)
 */
static PyObject *Dtool_ConfigVariableBool_set_value_249(PyObject *self, PyObject *arg) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableBool::set_value(bool value)
  (*local_this).set_value((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableBool self, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_set_value_249_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableBool self, bool value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_set_value_249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBool::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableBool_get_value_250(PyObject *self, PyObject *) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBool::get_value(void) const
  bool return_value = (*(const ConfigVariableBool*)local_this).get_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_get_value_250_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableBool self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_get_value_250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBool::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableBool_get_default_value_251(PyObject *self, PyObject *) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBool::get_default_value(void) const
  bool return_value = (*(const ConfigVariableBool*)local_this).get_default_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_get_default_value_251_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableBool self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_get_default_value_251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableBool::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableBool_get_word_254(PyObject *self, PyObject *arg) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableBool::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigVariableBool*)local_this).get_word((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableBool self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_get_word_254_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableBool self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_get_word_254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableBool::set_word(std::size_t n, bool value)
 */
static PyObject *Dtool_ConfigVariableBool_set_word_255(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.set_word")) {
    return NULL;
  }
  // 1-inline void ConfigVariableBool::set_word(std::size_t n, bool value)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_word((std::size_t)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableBool self, int n, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableBool_set_word_255_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableBool self, int n, bool value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableBool_set_word_255_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableBool_value_Getter(PyObject *self, void *) {
  const ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableBool::get_value(void) const
  bool return_value = (*(const ConfigVariableBool*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableBool_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableBool, (void **)&local_this, "ConfigVariableBool.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableBool::set_value(bool value)
  (*local_this).set_value((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableBool self, bool value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableBool_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool ConfigVariableBool::get_default_value(void) const
  bool return_value = (*(const ConfigVariableBool*)local_this).get_default_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableBool::ConfigVariableBool(ConfigVariableBool const &) = default
 * inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
 * inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableBool(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(ConfigVariableBool const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableBool", (char **)keyword_list, &param0)) {
          ConfigVariableBool const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableBool, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableBool *return_value = new ConfigVariableBool(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableBool", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(ConfigVariableBool const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableBool", (char **)keyword_list, &param0)) {
          ConfigVariableBool const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableBool(param0, param0_this, param0_manage)) {
            ConfigVariableBool *return_value = new ConfigVariableBool(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableBool", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|s#i:ConfigVariableBool", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableBool, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableBool() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableBool(const ConfigVariableBool param0)\n"
      "ConfigVariableBool(str name)\n"
      "ConfigVariableBool(str name, str default_value, str description, int flags)\n"
      "ConfigVariableBool(str name, bool default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableBool(PyObject *args, ConfigVariableBool const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableBool, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableBool", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#O|s#i:ConfigVariableBool", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableBool(PyObject *args, ConfigVariableBool *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableBool, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableBool::ConfigVariableBool(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableBool", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableBool::ConfigVariableBool(std::string const &name, bool default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#O|s#i:ConfigVariableBool", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableBool *return_value = new ConfigVariableBool(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableBool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableBool) {
    printf("ConfigVariableBool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableBool *local_this = (ConfigVariableBool *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableBool) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableBool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBool) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableBool*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableBool*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableBool*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableDouble
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableDouble::operator =(double value)
 */
static PyObject *Dtool_ConfigVariableDouble_operator_259(PyObject *self, PyObject *arg) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableDouble::operator =(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).operator =(PyFloat_AsDouble(arg));
    ConfigVariableDouble *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableDouble, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableDouble self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_operator_259_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableDouble self, double value)\n";
#else
static const char *Dtool_ConfigVariableDouble_operator_259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableDouble::set_value(double value)
 */
static PyObject *Dtool_ConfigVariableDouble_set_value_263(PyObject *self, PyObject *arg) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableDouble::set_value(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_value(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableDouble self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_set_value_263_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableDouble self, double value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_set_value_263_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigVariableDouble::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableDouble_get_value_264(PyObject *self, PyObject *) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ConfigVariableDouble::get_value(void) const
  double return_value = (*(const ConfigVariableDouble*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_get_value_264_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableDouble self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_get_value_264_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigVariableDouble::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableDouble_get_default_value_265(PyObject *self, PyObject *) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ConfigVariableDouble::get_default_value(void) const
  double return_value = (*(const ConfigVariableDouble*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_get_default_value_265_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableDouble self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_get_default_value_265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double ConfigVariableDouble::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableDouble_get_word_269(PyObject *self, PyObject *arg) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double ConfigVariableDouble::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    double return_value = (*(const ConfigVariableDouble*)local_this).get_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableDouble self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_get_word_269_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableDouble self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_get_word_269_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableDouble::set_word(std::size_t n, double value)
 */
static PyObject *Dtool_ConfigVariableDouble_set_word_270(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.set_word")) {
    return NULL;
  }
  // 1-inline void ConfigVariableDouble::set_word(std::size_t n, double value)
  Py_ssize_t param1;
  double param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nd:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_word((std::size_t)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableDouble self, int n, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableDouble_set_word_270_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableDouble self, int n, double value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableDouble_set_word_270_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableDouble_value_Getter(PyObject *self, void *) {
  const ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ConfigVariableDouble::get_value(void) const
  double return_value = (*(const ConfigVariableDouble*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableDouble_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableDouble, (void **)&local_this, "ConfigVariableDouble.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableDouble::set_value(double value)
  if (PyNumber_Check(arg)) {
    (*local_this).set_value(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableDouble self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableDouble_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ConfigVariableDouble::get_default_value(void) const
  double return_value = (*(const ConfigVariableDouble*)local_this).get_default_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableDouble::ConfigVariableDouble(ConfigVariableDouble const &) = default
 * inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
 * inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableDouble(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(ConfigVariableDouble const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableDouble", (char **)keyword_list, &param0)) {
          ConfigVariableDouble const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableDouble, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableDouble *return_value = new ConfigVariableDouble(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableDouble", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(ConfigVariableDouble const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableDouble", (char **)keyword_list, &param0)) {
          ConfigVariableDouble const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableDouble(param0, param0_this, param0_manage)) {
            ConfigVariableDouble *return_value = new ConfigVariableDouble(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableDouble", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d|s#i:ConfigVariableDouble", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), (double)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableDouble, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableDouble() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableDouble(const ConfigVariableDouble param0)\n"
      "ConfigVariableDouble(str name)\n"
      "ConfigVariableDouble(str name, str default_value, str description, int flags)\n"
      "ConfigVariableDouble(str name, double default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableDouble(PyObject *args, ConfigVariableDouble const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableDouble, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableDouble", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#d|s#i:ConfigVariableDouble", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), (double)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableDouble(PyObject *args, ConfigVariableDouble *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableDouble, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableDouble", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableDouble::ConfigVariableDouble(std::string const &name, double default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        double param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#d|s#i:ConfigVariableDouble", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableDouble *return_value = new ConfigVariableDouble(std::string(param0_str, param0_len), (double)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableDouble(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableDouble) {
    printf("ConfigVariableDouble ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableDouble *local_this = (ConfigVariableDouble *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableDouble) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableDouble(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableDouble) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableDouble*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableDouble*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableDouble*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableFilename
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableFilename::operator =(Filename const &value)
 */
static PyObject *Dtool_ConfigVariableFilename_operator_274(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableFilename::operator =(Filename const &value)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableFilename.assign", "Filename");
  }
  (*local_this).operator =(*arg_this);
  ConfigVariableFilename *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableFilename, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableFilename self, const Filename value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_operator_274_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableFilename self, const Filename value)\n";
#else
static const char *Dtool_ConfigVariableFilename_operator_274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline char const *ConfigVariableFilename::c_str(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_c_str_276(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char const *ConfigVariableFilename::c_str(void) const
  char const *return_value = (*(const ConfigVariableFilename*)local_this).c_str();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_c_str_276_comment =
  "C++ Interface:\n"
  "c_str(ConfigVariableFilename self)\n"
  "\n"
  "// These methods help the ConfigVariableFilename act like a Filename object.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_c_str_276_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableFilename::empty(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_empty_277(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableFilename::empty(void) const
  bool return_value = (*(const ConfigVariableFilename*)local_this).empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_empty_277_comment =
  "C++ Interface:\n"
  "empty(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_empty_277_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableFilename::length(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_length_278(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableFilename::length(void) const
  std::size_t return_value = (*(const ConfigVariableFilename*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_length_278_comment =
  "C++ Interface:\n"
  "length(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_length_278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_fullpath(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_fullpath_280(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableFilename::get_fullpath(void) const
  std::string return_value = (*(const ConfigVariableFilename*)local_this).get_fullpath();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_fullpath_280_comment =
  "C++ Interface:\n"
  "get_fullpath(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the entire filename: directory, basename, extension.  This is the\n"
  " * same thing returned by the string typecast operator, so this function is a\n"
  " * little redundant.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_fullpath_280_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_dirname(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_dirname_281(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableFilename::get_dirname(void) const
  std::string return_value = (*(const ConfigVariableFilename*)local_this).get_dirname();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_dirname_281_comment =
  "C++ Interface:\n"
  "get_dirname(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the directory part of the filename.  This is everything in the\n"
  " * filename up to, but not including the rightmost slash.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_dirname_281_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_basename(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_basename_282(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableFilename::get_basename(void) const
  std::string return_value = (*(const ConfigVariableFilename*)local_this).get_basename();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_basename_282_comment =
  "C++ Interface:\n"
  "get_basename(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename.  This is everything in the\n"
  " * filename after the rightmost slash, including any extensions.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_basename_282_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_fullpath_wo_extension(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableFilename::get_fullpath_wo_extension(void) const
  std::string return_value = (*(const ConfigVariableFilename*)local_this).get_fullpath_wo_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283_comment =
  "C++ Interface:\n"
  "get_fullpath_wo_extension(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the full filename--directory and basename parts--except for the\n"
  " * extension.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_basename_wo_extension(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_basename_wo_extension_284(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableFilename::get_basename_wo_extension(void) const
  std::string return_value = (*(const ConfigVariableFilename*)local_this).get_basename_wo_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_basename_wo_extension_284_comment =
  "C++ Interface:\n"
  "get_basename_wo_extension(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename, without the file extension.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_basename_wo_extension_284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableFilename::get_extension(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_extension_285(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableFilename::get_extension(void) const
  std::string return_value = (*(const ConfigVariableFilename*)local_this).get_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_extension_285_comment =
  "C++ Interface:\n"
  "get_extension(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the file extension.  This is everything after the rightmost dot, if\n"
  " * there is one, or the empty string if there is not.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_extension_285_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableFilename::set_value(Filename const &value)
 */
static PyObject *Dtool_ConfigVariableFilename_set_value_289(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableFilename::set_value(Filename const &value)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableFilename.set_value", "Filename");
  }
  (*local_this).set_value(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableFilename self, const Filename value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_set_value_289_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableFilename self, const Filename value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_set_value_289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableFilename::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_value_290(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename ConfigVariableFilename::get_value(void) const
  Filename *return_value = new Filename((*(const ConfigVariableFilename*)local_this).get_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_value_290_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_value_290_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableFilename::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_default_value_291(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename ConfigVariableFilename::get_default_value(void) const
  Filename *return_value = new Filename((*(const ConfigVariableFilename*)local_this).get_default_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_default_value_291_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableFilename self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_default_value_291_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableFilename::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableFilename_get_word_397(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename ConfigVariableFilename::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Filename *return_value = new Filename((*(const ConfigVariableFilename*)local_this).get_word((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableFilename self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_get_word_397_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableFilename self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_get_word_397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableFilename::set_word(std::size_t n, Filename const &value)
 */
static PyObject *Dtool_ConfigVariableFilename_set_word_398(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.set_word")) {
    return NULL;
  }
  // 1-inline void ConfigVariableFilename::set_word(std::size_t n, Filename const &value)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ConfigVariableFilename.set_word", "Filename");
    }
    (*local_this).set_word((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableFilename self, int n, const Filename value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_set_word_398_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableFilename self, int n, const Filename value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableFilename_set_word_398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &ConfigVariableFilename::operator typecast(void) const
 */
static PyObject *Dtool_ConfigVariableFilename_operator_typecast_275(PyObject *self, PyObject *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &ConfigVariableFilename::operator typecast(void) const
  Filename const *return_value = &((Filename const &)*(const ConfigVariableFilename*)local_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableFilename_operator_typecast_275_comment =
  "C++ Interface:\n"
  "operator_typecast(ConfigVariableFilename self)\n";
#else
static const char *Dtool_ConfigVariableFilename_operator_typecast_275_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableFilename_value_Getter(PyObject *self, void *) {
  const ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename ConfigVariableFilename::get_value(void) const
  Filename *return_value = new Filename((*(const ConfigVariableFilename*)local_this).get_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

static int Dtool_ConfigVariableFilename_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableFilename, (void **)&local_this, "ConfigVariableFilename.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableFilename::set_value(Filename const &value)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableFilename.set_value", "Filename");
    return -1;
  }
  (*local_this).set_value(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableFilename self, const Filename value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableFilename_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline Filename ConfigVariableFilename::get_default_value(void) const
  Filename *return_value = new Filename((*(const ConfigVariableFilename*)local_this).get_default_value());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableFilename::ConfigVariableFilename(ConfigVariableFilename const &) = default
 * inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
 * inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name, Filename const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableFilename(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableFilename::ConfigVariableFilename(ConfigVariableFilename const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableFilename", (char **)keyword_list, &param0)) {
          ConfigVariableFilename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableFilename, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableFilename *return_value = new ConfigVariableFilename(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableFilename", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableFilename::ConfigVariableFilename(ConfigVariableFilename const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableFilename", (char **)keyword_list, &param0)) {
          ConfigVariableFilename const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableFilename(param0, param0_this, param0_manage)) {
            ConfigVariableFilename *return_value = new ConfigVariableFilename(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name, Filename const &default_value, std::string const &description = string(), int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O|s#i:ConfigVariableFilename", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "ConfigVariableFilename.ConfigVariableFilename", "Filename");
          return -1;
        }
        ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableFilename, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableFilename() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableFilename(const ConfigVariableFilename param0)\n"
      "ConfigVariableFilename(str name)\n"
      "ConfigVariableFilename(str name, const Filename default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableFilename(PyObject *args, ConfigVariableFilename const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableFilename, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name, Filename const &default_value, std::string const &description = string(), int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      if (PyArg_ParseTuple(args, "s#O|s#i:ConfigVariableFilename", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param1_this != NULL) {
          ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableFilename(PyObject *args, ConfigVariableFilename *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableFilename, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-inline ConfigVariableFilename::ConfigVariableFilename(std::string const &name, Filename const &default_value, std::string const &description = string(), int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      PyObject *param1;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      if (PyArg_ParseTuple(args, "s#O|s#i:ConfigVariableFilename", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param1_this != NULL) {
          ConfigVariableFilename *return_value = new ConfigVariableFilename(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableFilename(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableFilename) {
    printf("ConfigVariableFilename ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableFilename *local_this = (ConfigVariableFilename *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableFilename) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableFilename(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableFilename) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableFilename*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableFilename*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableFilename*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Filename
 */
/**
 * Python function wrapper for:
 * PyObject *Filename::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_Filename_reduce_297(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *Filename::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_reduce_297_comment =
  "C++ Interface:\n"
  "__reduce__(Filename self)\n";
#else
static const char *Dtool_Filename_reduce_297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::text_filename(Filename const &filename)
 * static inline Filename Filename::text_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_text_filename_298(PyObject *, PyObject *arg) {
  {
    // -2 static inline Filename Filename::text_filename(Filename const &filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      Filename *return_value = new Filename(Filename::text_filename(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  {
    // -2 static inline Filename Filename::text_filename(std::string const &filename)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Filename *return_value = new Filename(Filename::text_filename(std::string(param0_str, param0_len)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 static inline Filename Filename::text_filename(Filename const &filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
      Filename *return_value = new Filename(Filename::text_filename(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  // No coercion possible: static inline Filename Filename::text_filename(std::string const &filename)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "text_filename(const Filename filename)\n"
      "text_filename(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_text_filename_298_comment =
  "C++ Interface:\n"
  "text_filename(const Filename filename)\n"
  "text_filename(str filename)\n"
  "\n"
  "// Static constructors to explicitly create a filename that refers to a text\n"
  "// or binary file.  This is in lieu of calling set_text() or set_binary() or\n"
  "// set_type().\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_text_filename_298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::binary_filename(Filename const &filename)
 * static inline Filename Filename::binary_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_binary_filename_299(PyObject *, PyObject *arg) {
  {
    // -2 static inline Filename Filename::binary_filename(Filename const &filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      Filename *return_value = new Filename(Filename::binary_filename(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  {
    // -2 static inline Filename Filename::binary_filename(std::string const &filename)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Filename *return_value = new Filename(Filename::binary_filename(std::string(param0_str, param0_len)));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 static inline Filename Filename::binary_filename(Filename const &filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
      Filename *return_value = new Filename(Filename::binary_filename(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
    }
  }

  // No coercion possible: static inline Filename Filename::binary_filename(std::string const &filename)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "binary_filename(const Filename filename)\n"
      "binary_filename(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_binary_filename_299_comment =
  "C++ Interface:\n"
  "binary_filename(const Filename filename)\n"
  "binary_filename(str filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_binary_filename_299_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::dso_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_dso_filename_300(PyObject *, PyObject *arg) {
  // 1-static inline Filename Filename::dso_filename(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    Filename *return_value = new Filename(Filename::dso_filename(std::string(param0_str, param0_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dso_filename(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_dso_filename_300_comment =
  "C++ Interface:\n"
  "dso_filename(str filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_dso_filename_300_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::executable_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_executable_filename_301(PyObject *, PyObject *arg) {
  // 1-static inline Filename Filename::executable_filename(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    Filename *return_value = new Filename(Filename::executable_filename(std::string(param0_str, param0_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "executable_filename(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_executable_filename_301_comment =
  "C++ Interface:\n"
  "executable_filename(str filename)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_executable_filename_301_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Filename Filename::pattern_filename(std::string const &filename)
 */
static PyObject *Dtool_Filename_pattern_filename_302(PyObject *, PyObject *arg) {
  // 1-static inline Filename Filename::pattern_filename(std::string const &filename)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    Filename *return_value = new Filename(Filename::pattern_filename(std::string(param0_str, param0_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pattern_filename(str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_pattern_filename_302_comment =
  "C++ Interface:\n"
  "pattern_filename(str filename)\n"
  "\n"
  "/**\n"
  " * Constructs a filename that represents a sequence of numbered files.  See\n"
  " * set_pattern().\n"
  " */";
#else
static const char *Dtool_Filename_pattern_filename_302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::from_os_specific(std::string const &os_specific, Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_from_os_specific_303(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::from_os_specific(std::string const &os_specific, Filename::Type type = ::Filename::T_general)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  int param1 = Filename::T_general;
  static const char *keyword_list[] = {"os_specific", "type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:from_os_specific", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    Filename *return_value = new Filename(Filename::from_os_specific(std::string(param0_str, param0_len), (Filename::Type)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_os_specific(str os_specific, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_from_os_specific_303_comment =
  "C++ Interface:\n"
  "from_os_specific(str os_specific, int type)\n";
#else
static const char *Dtool_Filename_from_os_specific_303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::from_os_specific_w(std::wstring const &os_specific, Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_from_os_specific_w_304(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::from_os_specific_w(std::wstring const &os_specific, Filename::Type type = ::Filename::T_general)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
  #else
  PyUnicodeObject *param0;
  #endif
  int param1 = Filename::T_general;
  static const char *keyword_list[] = {"os_specific", "type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "U|i:from_os_specific_w", (char **)keyword_list, &param0, &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param0_len;
    wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
    Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
    wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
    PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
    Filename *return_value = new Filename(Filename::from_os_specific_w(std::wstring(param0_str, param0_len), (Filename::Type)param1));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param0_str);
#endif
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "from_os_specific_w(unicode os_specific, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_from_os_specific_w_304_comment =
  "C++ Interface:\n"
  "from_os_specific_w(unicode os_specific, int type)\n";
#else
static const char *Dtool_Filename_from_os_specific_w_304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::expand_from(std::string const &user_string, Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_expand_from_305(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::expand_from(std::string const &user_string, Filename::Type type = ::Filename::T_general)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  int param1 = Filename::T_general;
  static const char *keyword_list[] = {"user_string", "type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:expand_from", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    Filename *return_value = new Filename(Filename::expand_from(std::string(param0_str, param0_len), (Filename::Type)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_from(str user_string, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_expand_from_305_comment =
  "C++ Interface:\n"
  "expand_from(str user_string, int type)\n";
#else
static const char *Dtool_Filename_expand_from_305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename Filename::temporary(std::string const &dirname, std::string const &prefix, std::string const &suffix = string(), Filename::Type type = ::Filename::T_general)
 */
static PyObject *Dtool_Filename_temporary_306(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename Filename::temporary(std::string const &dirname, std::string const &prefix, std::string const &suffix = string(), Filename::Type type = ::Filename::T_general)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  int param3 = Filename::T_general;
  static const char *keyword_list[] = {"dirname", "prefix", "suffix", "type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:temporary", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    Filename *return_value = new Filename(Filename::temporary(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (Filename::Type)param3));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "temporary(str dirname, str prefix, str suffix, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_temporary_306_comment =
  "C++ Interface:\n"
  "temporary(str dirname, str prefix, str suffix, int type)\n";
#else
static const char *Dtool_Filename_temporary_306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_home_directory(void)
 */
static PyObject *Dtool_Filename_get_home_directory_307(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_home_directory(void)
  Filename const *return_value = &(Filename::get_home_directory());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_home_directory_307_comment =
  "C++ Interface:\n"
  "get_home_directory()\n";
#else
static const char *Dtool_Filename_get_home_directory_307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_temp_directory(void)
 */
static PyObject *Dtool_Filename_get_temp_directory_308(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_temp_directory(void)
  Filename const *return_value = &(Filename::get_temp_directory());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_temp_directory_308_comment =
  "C++ Interface:\n"
  "get_temp_directory()\n";
#else
static const char *Dtool_Filename_get_temp_directory_308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_user_appdata_directory(void)
 */
static PyObject *Dtool_Filename_get_user_appdata_directory_309(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_user_appdata_directory(void)
  Filename const *return_value = &(Filename::get_user_appdata_directory());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_user_appdata_directory_309_comment =
  "C++ Interface:\n"
  "get_user_appdata_directory()\n";
#else
static const char *Dtool_Filename_get_user_appdata_directory_309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename const &Filename::get_common_appdata_directory(void)
 */
static PyObject *Dtool_Filename_get_common_appdata_directory_310(PyObject *, PyObject *) {
  // 1-static Filename const &Filename::get_common_appdata_directory(void)
  Filename const *return_value = &(Filename::get_common_appdata_directory());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_common_appdata_directory_310_comment =
  "C++ Interface:\n"
  "get_common_appdata_directory()\n";
#else
static const char *Dtool_Filename_get_common_appdata_directory_310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename &Filename::operator =(Filename const &copy)
 * inline Filename &Filename::operator =(char const *filename)
 * inline Filename &Filename::operator =(std::string const &filename)
 * inline Filename &Filename::operator =(std::wstring const &filename)
 */
static PyObject *Dtool_Filename_operator_311(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.assign")) {
    return NULL;
  }
  {
    // -2 inline Filename &Filename::operator =(Filename const &copy)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(*arg_this);
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
  }

  {
    // -2 inline Filename &Filename::operator =(std::wstring const &filename)
    #if PY_VERSION_HEX >= 0x03020000
    PyObject *param1;
    #else
    PyUnicodeObject *param1;
    #endif
    if (PyArg_Parse(arg, "U:assign", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param1_len;
      wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
      Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
      wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
      PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
      (*local_this).operator =(std::wstring(param1_str, param1_len));
      Filename *return_value = local_this;
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param1_str);
#endif
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline Filename &Filename::operator =(std::string const &filename)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (*local_this).operator =(std::string(param1_str, param1_len));
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline Filename &Filename::operator =(char const *filename)
    char const *param1;
    if (PyArg_Parse(arg, "z:assign", &param1)) {
      (*local_this).operator =((char const *)param1);
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline Filename &Filename::operator =(Filename const &copy)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
      (*local_this).operator =(*arg_this);
      Filename *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, false);
    }
  }

  // No coercion possible: inline Filename &Filename::operator =(std::wstring const &filename)
  // No coercion possible: inline Filename &Filename::operator =(std::string const &filename)
  // No coercion possible: inline Filename &Filename::operator =(char const *filename)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Filename self, const Filename copy)\n"
      "assign(const Filename self, unicode filename)\n"
      "assign(const Filename self, str filename)\n"
      "assign(const Filename self, str filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_operator_311_comment =
  "C++ Interface:\n"
  "assign(const Filename self, const Filename copy)\n"
  "assign(const Filename self, unicode filename)\n"
  "assign(const Filename self, str filename)\n"
  "assign(const Filename self, str filename)\n"
  "\n"
  "// Assignment is via the = operator.\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_operator_311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline char const *Filename::c_str(void) const
 */
static PyObject *Dtool_Filename_c_str_313(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char const *Filename::c_str(void) const
  char const *return_value = (*(const Filename*)local_this).c_str();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_c_str_313_comment =
  "C++ Interface:\n"
  "c_str(Filename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_c_str_313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::empty(void) const
 */
static PyObject *Dtool_Filename_empty_314(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::empty(void) const
  bool return_value = (*(const Filename*)local_this).empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_empty_314_comment =
  "C++ Interface:\n"
  "empty(Filename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_empty_314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Filename::length(void) const
 */
static PyObject *Dtool_Filename_length_315(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t Filename::length(void) const
  std::size_t return_value = (*(const Filename*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_length_315_comment =
  "C++ Interface:\n"
  "length(Filename self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_length_315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::substr(std::size_t begin) const
 * inline std::string Filename::substr(std::size_t begin, std::size_t end) const
 */
static PyObject *Dtool_Filename_substr_318(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "begin");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'begin' (pos 1) not found");
      }
      // 1-inline std::string Filename::substr(std::size_t begin) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:substr", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::string return_value = (*(const Filename*)local_this).substr((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::string Filename::substr(std::size_t begin, std::size_t end) const
      Py_ssize_t param1;
      Py_ssize_t param2;
      static const char *keyword_list[] = {"begin", "end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "nn:substr", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        std::string return_value = (*(const Filename*)local_this).substr((std::size_t)param1, (std::size_t)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "substr() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "substr(Filename self, int begin)\n"
      "substr(Filename self, int begin, int end)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_substr_318_comment =
  "C++ Interface:\n"
  "substr(Filename self, int begin)\n"
  "substr(Filename self, int begin, int end)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_substr_318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_fullpath(void) const
 */
static PyObject *Dtool_Filename_get_fullpath_322(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_fullpath(void) const
  std::string return_value = (*(const Filename*)local_this).get_fullpath();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_fullpath_322_comment =
  "C++ Interface:\n"
  "get_fullpath(Filename self)\n"
  "\n"
  "// Or, you can use any of these.\n"
  "\n"
  "/**\n"
  " * Returns the entire filename: directory, basename, extension.  This is the\n"
  " * same thing returned by the string typecast operator.\n"
  " */";
#else
static const char *Dtool_Filename_get_fullpath_322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring Filename::get_fullpath_w(void) const
 */
static PyObject *Dtool_Filename_get_fullpath_w_323(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring Filename::get_fullpath_w(void) const
  std::wstring return_value = (*(const Filename*)local_this).get_fullpath_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_fullpath_w_323_comment =
  "C++ Interface:\n"
  "get_fullpath_w(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the entire filename as a wide-character string.\n"
  " */";
#else
static const char *Dtool_Filename_get_fullpath_w_323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_dirname(void) const
 */
static PyObject *Dtool_Filename_get_dirname_324(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_dirname(void) const
  std::string return_value = (*(const Filename*)local_this).get_dirname();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_dirname_324_comment =
  "C++ Interface:\n"
  "get_dirname(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the directory part of the filename.  This is everything in the\n"
  " * filename up to, but not including the rightmost slash.\n"
  " */";
#else
static const char *Dtool_Filename_get_dirname_324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_basename(void) const
 */
static PyObject *Dtool_Filename_get_basename_325(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_basename(void) const
  std::string return_value = (*(const Filename*)local_this).get_basename();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_basename_325_comment =
  "C++ Interface:\n"
  "get_basename(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename.  This is everything in the\n"
  " * filename after the rightmost slash, including any extensions.\n"
  " */";
#else
static const char *Dtool_Filename_get_basename_325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_fullpath_wo_extension(void) const
 */
static PyObject *Dtool_Filename_get_fullpath_wo_extension_326(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_fullpath_wo_extension(void) const
  std::string return_value = (*(const Filename*)local_this).get_fullpath_wo_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_fullpath_wo_extension_326_comment =
  "C++ Interface:\n"
  "get_fullpath_wo_extension(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the full filename--directory and basename parts--except for the\n"
  " * extension.\n"
  " */";
#else
static const char *Dtool_Filename_get_fullpath_wo_extension_326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_basename_wo_extension(void) const
 */
static PyObject *Dtool_Filename_get_basename_wo_extension_327(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_basename_wo_extension(void) const
  std::string return_value = (*(const Filename*)local_this).get_basename_wo_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_basename_wo_extension_327_comment =
  "C++ Interface:\n"
  "get_basename_wo_extension(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the basename part of the filename, without the file extension.\n"
  " */";
#else
static const char *Dtool_Filename_get_basename_wo_extension_327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_extension(void) const
 */
static PyObject *Dtool_Filename_get_extension_328(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_extension(void) const
  std::string return_value = (*(const Filename*)local_this).get_extension();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_extension_328_comment =
  "C++ Interface:\n"
  "get_extension(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the file extension.  This is everything after the rightmost dot, if\n"
  " * there is one, or the empty string if there is not.\n"
  " */";
#else
static const char *Dtool_Filename_get_extension_328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_fullpath(std::string const &s)
 */
static PyObject *Dtool_Filename_set_fullpath_329(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_fullpath")) {
    return NULL;
  }
  // 1-void Filename::set_fullpath(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_fullpath(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_fullpath_329_comment =
  "C++ Interface:\n"
  "set_fullpath(const Filename self, str s)\n"
  "\n"
  "// You can also use any of these to reassign pieces of the filename.";
#else
static const char *Dtool_Filename_set_fullpath_329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_dirname(std::string const &s)
 */
static PyObject *Dtool_Filename_set_dirname_330(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_dirname")) {
    return NULL;
  }
  // 1-void Filename::set_dirname(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_dirname(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dirname(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_dirname_330_comment =
  "C++ Interface:\n"
  "set_dirname(const Filename self, str s)\n";
#else
static const char *Dtool_Filename_set_dirname_330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_basename(std::string const &s)
 */
static PyObject *Dtool_Filename_set_basename_331(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_basename")) {
    return NULL;
  }
  // 1-void Filename::set_basename(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_basename(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_basename(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_basename_331_comment =
  "C++ Interface:\n"
  "set_basename(const Filename self, str s)\n";
#else
static const char *Dtool_Filename_set_basename_331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_fullpath_wo_extension(std::string const &s)
 */
static PyObject *Dtool_Filename_set_fullpath_wo_extension_332(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_fullpath_wo_extension")) {
    return NULL;
  }
  // 1-void Filename::set_fullpath_wo_extension(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_fullpath_wo_extension(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullpath_wo_extension(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_fullpath_wo_extension_332_comment =
  "C++ Interface:\n"
  "set_fullpath_wo_extension(const Filename self, str s)\n";
#else
static const char *Dtool_Filename_set_fullpath_wo_extension_332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_basename_wo_extension(std::string const &s)
 */
static PyObject *Dtool_Filename_set_basename_wo_extension_333(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_basename_wo_extension")) {
    return NULL;
  }
  // 1-void Filename::set_basename_wo_extension(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_basename_wo_extension(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_basename_wo_extension(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_basename_wo_extension_333_comment =
  "C++ Interface:\n"
  "set_basename_wo_extension(const Filename self, str s)\n";
#else
static const char *Dtool_Filename_set_basename_wo_extension_333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_extension(std::string const &s)
 */
static PyObject *Dtool_Filename_set_extension_334(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_extension")) {
    return NULL;
  }
  // 1-void Filename::set_extension(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_extension(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_extension(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_extension_334_comment =
  "C++ Interface:\n"
  "set_extension(const Filename self, str s)\n";
#else
static const char *Dtool_Filename_set_extension_334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_binary(void)
 */
static PyObject *Dtool_Filename_set_binary_335(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_binary")) {
    return NULL;
  }
  // 1-inline void Filename::set_binary(void)
  (*local_this).set_binary();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_binary_335_comment =
  "C++ Interface:\n"
  "set_binary(const Filename self)\n"
  "\n"
  "// Setting these flags appropriately is helpful when opening or searching\n"
  "// for a file; it helps the Filename resolve OS-specific conventions (for\n"
  "// instance, that dynamic library names should perhaps be changed from .so\n"
  "// to .dll).\n"
  "\n"
  "/**\n"
  " * Indicates that the filename represents a binary file.  This is primarily\n"
  " * relevant to the read_file() and write_file() methods, so they can set the\n"
  " * appropriate flags to the OS.\n"
  " */";
#else
static const char *Dtool_Filename_set_binary_335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_text(void)
 */
static PyObject *Dtool_Filename_set_text_336(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_text")) {
    return NULL;
  }
  // 1-inline void Filename::set_text(void)
  (*local_this).set_text();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_text_336_comment =
  "C++ Interface:\n"
  "set_text(const Filename self)\n"
  "\n"
  "/**\n"
  " * Indicates that the filename represents a text file.  This is primarily\n"
  " * relevant to the read_file() and write_file() methods, so they can set the\n"
  " * appropriate flags to the OS.\n"
  " */";
#else
static const char *Dtool_Filename_set_text_336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_binary(void) const
 */
static PyObject *Dtool_Filename_is_binary_337(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::is_binary(void) const
  bool return_value = (*(const Filename*)local_this).is_binary();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_binary_337_comment =
  "C++ Interface:\n"
  "is_binary(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Filename has been indicated to represent a binary file\n"
  " * via a previous call to set_binary().  It is possible that neither\n"
  " * is_binary() nor is_text() will be true, if neither set_binary() nor\n"
  " * set_text() was ever called.\n"
  " */";
#else
static const char *Dtool_Filename_is_binary_337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_text(void) const
 */
static PyObject *Dtool_Filename_is_text_338(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::is_text(void) const
  bool return_value = (*(const Filename*)local_this).is_text();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_text_338_comment =
  "C++ Interface:\n"
  "is_text(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Filename has been indicated to represent a text file\n"
  " * via a previous call to set_text().  It is possible that neither is_binary()\n"
  " * nor is_text() will be true, if neither set_binary() nor set_text() was ever\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_Filename_is_text_338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_binary_or_text(void) const
 */
static PyObject *Dtool_Filename_is_binary_or_text_339(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::is_binary_or_text(void) const
  bool return_value = (*(const Filename*)local_this).is_binary_or_text();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_binary_or_text_339_comment =
  "C++ Interface:\n"
  "is_binary_or_text(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true either is_binary() or is_text() is true; that is, that the\n"
  " * filename has been specified as either binary or text.  If this is false,\n"
  " * the filename has not been specified.\n"
  " */";
#else
static const char *Dtool_Filename_is_binary_or_text_339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_type(Filename::Type type)
 */
static PyObject *Dtool_Filename_set_type_340(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_type")) {
    return NULL;
  }
  // 1-inline void Filename::set_type(Filename::Type type)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_type((Filename::Type)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_type(const Filename self, int type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_type_340_comment =
  "C++ Interface:\n"
  "set_type(const Filename self, int type)\n"
  "\n"
  "/**\n"
  " * Sets the type of the file represented by the filename.  This is useful for\n"
  " * to_os_specific(), resolve_filename(), test_existence(), and all such real-\n"
  " * world access functions.  It helps the Filename know how to map the internal\n"
  " * filename to the OS-specific filename (for instance, maybe executables\n"
  " * should have an .exe extension).\n"
  " */";
#else
static const char *Dtool_Filename_set_type_340_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename::Type Filename::get_type(void) const
 */
static PyObject *Dtool_Filename_get_type_341(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename::Type Filename::get_type(void) const
  Filename::Type return_value = (*(const Filename*)local_this).get_type();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_type_341_comment =
  "C++ Interface:\n"
  "get_type(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the type of the file represented by the filename, as previously set\n"
  " * by set_type().\n"
  " */";
#else
static const char *Dtool_Filename_get_type_341_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::set_pattern(bool pattern)
 */
static PyObject *Dtool_Filename_set_pattern_342(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_pattern")) {
    return NULL;
  }
  // 1-inline void Filename::set_pattern(bool pattern)
  (*local_this).set_pattern((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pattern(const Filename self, bool pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_pattern_342_comment =
  "C++ Interface:\n"
  "set_pattern(const Filename self, bool pattern)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether this is a filename pattern.  When this is\n"
  " * true, the filename is understood to be a placeholder for a numbered\n"
  " * sequence of filename, such as an image sequence.  In this case, a sequence\n"
  " * of one or more hash characters (\"#\") should appear in the filename string;\n"
  " * these characters will be filled in with the corresponding number (or more)\n"
  " * of digits representing the sequence number.  Sequence numbers always begin\n"
  " * counting at 0.\n"
  " *\n"
  " * When this is true, methods like has_hash() and get_hash_to_end() and\n"
  " * get_filename_index() may be called.  Methods like is_exists() will\n"
  " * implicitly test for existance of filename sequence 0.\n"
  " */";
#else
static const char *Dtool_Filename_set_pattern_342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::get_pattern(void) const
 */
static PyObject *Dtool_Filename_get_pattern_343(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::get_pattern(void) const
  bool return_value = (*(const Filename*)local_this).get_pattern();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_pattern_343_comment =
  "C++ Interface:\n"
  "get_pattern(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating whether this is a filename pattern.  See\n"
  " * set_pattern().\n"
  " */";
#else
static const char *Dtool_Filename_get_pattern_343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::has_hash(void) const
 */
static PyObject *Dtool_Filename_has_hash_344(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::has_hash(void) const
  bool return_value = (*(const Filename*)local_this).has_hash();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_has_hash_344_comment =
  "C++ Interface:\n"
  "has_hash(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename is indicated to be a filename pattern (that\n"
  " * is, set_pattern(true) was called), and the filename pattern did include a\n"
  " * sequence of hash marks, or false if it was not a filename pattern or did\n"
  " * not include hash marks.  If this is true, then get_filename_index() will\n"
  " * return a different filename each time.\n"
  " */";
#else
static const char *Dtool_Filename_has_hash_344_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Filename Filename::get_filename_index(int index) const
 */
static PyObject *Dtool_Filename_get_filename_index_345(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-Filename Filename::get_filename_index(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Filename *return_value = new Filename((*(const Filename*)local_this).get_filename_index((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_filename_index(Filename self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_filename_index_345_comment =
  "C++ Interface:\n"
  "get_filename_index(Filename self, int index)\n";
#else
static const char *Dtool_Filename_get_filename_index_345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Filename::get_hash_to_end(void) const
 */
static PyObject *Dtool_Filename_get_hash_to_end_346(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Filename::get_hash_to_end(void) const
  std::string return_value = (*(const Filename*)local_this).get_hash_to_end();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_hash_to_end_346_comment =
  "C++ Interface:\n"
  "get_hash_to_end(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns the part of the filename beginning at the hash sequence (if any),\n"
  " * and continuing to the end of the filename.\n"
  " */";
#else
static const char *Dtool_Filename_get_hash_to_end_346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::set_hash_to_end(std::string const &s)
 */
static PyObject *Dtool_Filename_set_hash_to_end_347(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.set_hash_to_end")) {
    return NULL;
  }
  // 1-void Filename::set_hash_to_end(std::string const &s)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_hash_to_end(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hash_to_end(const Filename self, str s)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_hash_to_end_347_comment =
  "C++ Interface:\n"
  "set_hash_to_end(const Filename self, str s)\n";
#else
static const char *Dtool_Filename_set_hash_to_end_347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::standardize(void)
 */
static PyObject *Dtool_Filename_standardize_349(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.standardize")) {
    return NULL;
  }
  // 1-void Filename::standardize(void)
  (*local_this).standardize();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Filename_standardize_349_comment =
  "C++ Interface:\n"
  "standardize(const Filename self)\n";
#else
static const char *Dtool_Filename_standardize_349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_local(void) const
 */
static PyObject *Dtool_Filename_is_local_350(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::is_local(void) const
  bool return_value = (*(const Filename*)local_this).is_local();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_local_350_comment =
  "C++ Interface:\n"
  "is_local(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename is local, e.g.  does not begin with a slash,\n"
  " * or false if the filename is fully specified from the root.\n"
  " */";
#else
static const char *Dtool_Filename_is_local_350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Filename::is_fully_qualified(void) const
 */
static PyObject *Dtool_Filename_is_fully_qualified_351(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Filename::is_fully_qualified(void) const
  bool return_value = (*(const Filename*)local_this).is_fully_qualified();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_fully_qualified_351_comment =
  "C++ Interface:\n"
  "is_fully_qualified(Filename self)\n"
  "\n"
  "/**\n"
  " * Returns true if the filename is fully qualified, e.g.  begins with a slash.\n"
  " * This is almost, but not quite, the same thing as !is_local().  It's not\n"
  " * exactly the same because a special case is made for filenames that begin\n"
  " * with a single dot followed by a slash--these are considered to be fully\n"
  " * qualified (they are explicitly relative to the current directory, and do\n"
  " * not refer to a filename on a search path somewhere).\n"
  " */";
#else
static const char *Dtool_Filename_is_fully_qualified_351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Filename::make_absolute(void)
 * void Filename::make_absolute(Filename const &start_directory)
 */
static PyObject *Dtool_Filename_make_absolute_352(PyObject *self, PyObject *args) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_absolute")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void Filename::make_absolute(void)
      (*local_this).make_absolute();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void Filename::make_absolute(Filename const &start_directory)
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Filename.make_absolute", "Filename");
      }
      (*local_this).make_absolute(*arg_this);
      return Dtool_Return_None();
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_absolute() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_absolute(const Filename self)\n"
      "make_absolute(const Filename self, const Filename start_directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_absolute_352_comment =
  "C++ Interface:\n"
  "make_absolute(const Filename self)\n"
  "make_absolute(const Filename self, const Filename start_directory)\n";
#else
static const char *Dtool_Filename_make_absolute_352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_canonical(void)
 */
static PyObject *Dtool_Filename_make_canonical_353(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_canonical")) {
    return NULL;
  }
  // 1-bool Filename::make_canonical(void)
  bool return_value = (*local_this).make_canonical();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_canonical_353_comment =
  "C++ Interface:\n"
  "make_canonical(const Filename self)\n";
#else
static const char *Dtool_Filename_make_canonical_353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_true_case(void)
 */
static PyObject *Dtool_Filename_make_true_case_354(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_true_case")) {
    return NULL;
  }
  // 1-bool Filename::make_true_case(void)
  bool return_value = (*local_this).make_true_case();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_true_case_354_comment =
  "C++ Interface:\n"
  "make_true_case(const Filename self)\n";
#else
static const char *Dtool_Filename_make_true_case_354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_specific(void) const
 */
static PyObject *Dtool_Filename_to_os_specific_355(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Filename::to_os_specific(void) const
  std::string return_value = (*(const Filename*)local_this).to_os_specific();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_specific_355_comment =
  "C++ Interface:\n"
  "to_os_specific(Filename self)\n";
#else
static const char *Dtool_Filename_to_os_specific_355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring Filename::to_os_specific_w(void) const
 */
static PyObject *Dtool_Filename_to_os_specific_w_356(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::wstring Filename::to_os_specific_w(void) const
  std::wstring return_value = (*(const Filename*)local_this).to_os_specific_w();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_specific_w_356_comment =
  "C++ Interface:\n"
  "to_os_specific_w(Filename self)\n";
#else
static const char *Dtool_Filename_to_os_specific_w_356_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_generic(void) const
 */
static PyObject *Dtool_Filename_to_os_generic_357(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Filename::to_os_generic(void) const
  std::string return_value = (*(const Filename*)local_this).to_os_generic();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_generic_357_comment =
  "C++ Interface:\n"
  "to_os_generic(Filename self)\n";
#else
static const char *Dtool_Filename_to_os_generic_357_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_short_name(void) const
 */
static PyObject *Dtool_Filename_to_os_short_name_358(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Filename::to_os_short_name(void) const
  std::string return_value = (*(const Filename*)local_this).to_os_short_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_short_name_358_comment =
  "C++ Interface:\n"
  "to_os_short_name(Filename self)\n";
#else
static const char *Dtool_Filename_to_os_short_name_358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Filename::to_os_long_name(void) const
 */
static PyObject *Dtool_Filename_to_os_long_name_359(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Filename::to_os_long_name(void) const
  std::string return_value = (*(const Filename*)local_this).to_os_long_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_to_os_long_name_359_comment =
  "C++ Interface:\n"
  "to_os_long_name(Filename self)\n";
#else
static const char *Dtool_Filename_to_os_long_name_359_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::exists(void) const
 */
static PyObject *Dtool_Filename_exists_360(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::exists(void) const
  bool return_value = (*(const Filename*)local_this).exists();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_exists_360_comment =
  "C++ Interface:\n"
  "exists(Filename self)\n";
#else
static const char *Dtool_Filename_exists_360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_regular_file(void) const
 */
static PyObject *Dtool_Filename_is_regular_file_361(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::is_regular_file(void) const
  bool return_value = (*(const Filename*)local_this).is_regular_file();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_regular_file_361_comment =
  "C++ Interface:\n"
  "is_regular_file(Filename self)\n";
#else
static const char *Dtool_Filename_is_regular_file_361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_writable(void) const
 */
static PyObject *Dtool_Filename_is_writable_362(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::is_writable(void) const
  bool return_value = (*(const Filename*)local_this).is_writable();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_writable_362_comment =
  "C++ Interface:\n"
  "is_writable(Filename self)\n";
#else
static const char *Dtool_Filename_is_writable_362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_directory(void) const
 */
static PyObject *Dtool_Filename_is_directory_363(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::is_directory(void) const
  bool return_value = (*(const Filename*)local_this).is_directory();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_directory_363_comment =
  "C++ Interface:\n"
  "is_directory(Filename self)\n";
#else
static const char *Dtool_Filename_is_directory_363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::is_executable(void) const
 */
static PyObject *Dtool_Filename_is_executable_364(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::is_executable(void) const
  bool return_value = (*(const Filename*)local_this).is_executable();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_is_executable_364_comment =
  "C++ Interface:\n"
  "is_executable(Filename self)\n";
#else
static const char *Dtool_Filename_is_executable_364_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old = true, bool other_missing_is_old = true) const
 */
static PyObject *Dtool_Filename_compare_timestamps_365(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Filename::compare_timestamps(Filename const &other, bool this_missing_is_old = true, bool other_missing_is_old = true) const
  PyObject *param1;
  PyObject *param2 = Py_True;
  PyObject *param3 = Py_True;
  static const char *keyword_list[] = {"other", "this_missing_is_old", "other_missing_is_old", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OO:compare_timestamps", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Filename.compare_timestamps", "Filename");
    }
    int return_value = (*(const Filename*)local_this).compare_timestamps(*param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_timestamps(Filename self, const Filename other, bool this_missing_is_old, bool other_missing_is_old)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_compare_timestamps_365_comment =
  "C++ Interface:\n"
  "compare_timestamps(Filename self, const Filename other, bool this_missing_is_old, bool other_missing_is_old)\n";
#else
static const char *Dtool_Filename_compare_timestamps_365_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * time_t Filename::get_timestamp(void) const
 */
static PyObject *Dtool_Filename_get_timestamp_366(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-time_t Filename::get_timestamp(void) const
  time_t return_value = (*(const Filename*)local_this).get_timestamp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_timestamp_366_comment =
  "C++ Interface:\n"
  "get_timestamp(Filename self)\n";
#else
static const char *Dtool_Filename_get_timestamp_366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * time_t Filename::get_access_timestamp(void) const
 */
static PyObject *Dtool_Filename_get_access_timestamp_367(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-time_t Filename::get_access_timestamp(void) const
  time_t return_value = (*(const Filename*)local_this).get_access_timestamp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_access_timestamp_367_comment =
  "C++ Interface:\n"
  "get_access_timestamp(Filename self)\n";
#else
static const char *Dtool_Filename_get_access_timestamp_367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * streamsize Filename::get_file_size(void) const
 */
static PyObject *Dtool_Filename_get_file_size_368(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-streamsize Filename::get_file_size(void) const
  streamsize return_value = (*(const Filename*)local_this).get_file_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_file_size_368_comment =
  "C++ Interface:\n"
  "get_file_size(Filename self)\n";
#else
static const char *Dtool_Filename_get_file_size_368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::resolve_filename(DSearchPath const &searchpath, std::string const &default_extension = string())
 */
static PyObject *Dtool_Filename_resolve_filename_369(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.resolve_filename")) {
    return NULL;
  }
  // 1-bool Filename::resolve_filename(DSearchPath const &searchpath, std::string const &default_extension = string())
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"searchpath", "default_extension", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:resolve_filename", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    DSearchPath const *param1_this;
    bool param1_manage = false;
    if (!Dtool_ConstCoerce_DSearchPath(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Filename.resolve_filename", "DSearchPath");
    }
    bool return_value = (*local_this).resolve_filename(*param1_this, std::string(param2_str, param2_len));
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_filename(const Filename self, const DSearchPath searchpath, str default_extension)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_resolve_filename_369_comment =
  "C++ Interface:\n"
  "resolve_filename(const Filename self, const DSearchPath searchpath, str default_extension)\n";
#else
static const char *Dtool_Filename_resolve_filename_369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_relative_to(Filename directory, bool allow_backups = true)
 */
static PyObject *Dtool_Filename_make_relative_to_370(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.make_relative_to")) {
    return NULL;
  }
  // 1-bool Filename::make_relative_to(Filename directory, bool allow_backups = true)
  PyObject *param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"directory", "allow_backups", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:make_relative_to", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Filename.make_relative_to", "Filename");
    }
    bool return_value = (*local_this).make_relative_to(*param1_this, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_relative_to(const Filename self, Filename directory, bool allow_backups)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_relative_to_370_comment =
  "C++ Interface:\n"
  "make_relative_to(const Filename self, Filename directory, bool allow_backups)\n";
#else
static const char *Dtool_Filename_make_relative_to_370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Filename::find_on_searchpath(DSearchPath const &searchpath)
 */
static PyObject *Dtool_Filename_find_on_searchpath_371(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Filename, (void **)&local_this, "Filename.find_on_searchpath")) {
    return NULL;
  }
  // 1-int Filename::find_on_searchpath(DSearchPath const &searchpath)
  DSearchPath const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DSearchPath(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.find_on_searchpath", "DSearchPath");
  }
  int return_value = (*local_this).find_on_searchpath(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_on_searchpath(const Filename self, const DSearchPath searchpath)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_find_on_searchpath_371_comment =
  "C++ Interface:\n"
  "find_on_searchpath(const Filename self, const DSearchPath searchpath)\n";
#else
static const char *Dtool_Filename_find_on_searchpath_371_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *Filename::scan_directory(void) const
 * Rejected Remap [bool Filename::scan_directory(vector_string &contents) const]
 */
static PyObject *Dtool_Filename_scan_directory_372(PyObject *self, PyObject *args) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  if (PyTuple_Size(args) > 0) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no arguments");
#else
    return PyErr_Format(PyExc_TypeError,
                        "scan_directory() takes no arguments (%d given)",
                        parameter_count);
#endif
  }
  // 1-PyObject *Filename::scan_directory(void) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).scan_directory();
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scan_directory(Filename self)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_scan_directory_372_comment =
  "C++ Interface:\n"
  "scan_directory(Filename self)\n";
#else
static const char *Dtool_Filename_scan_directory_372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_read(ifstream &stream) const
 * bool Filename::open_read(pifstream &stream) const
 */
static PyObject *Dtool_Filename_open_read_373(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool Filename::open_read(pifstream &stream) const
    pifstream *arg_this = (IFileStream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_IFileStream, 1, "Filename.open_read", false, false);
    if (arg_this != NULL) {
      bool return_value = (*(const Filename*)local_this).open_read(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_read(ifstream &stream) const
    ifstream *arg_this = (ifstream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ifstream, 1, "Filename.open_read", false, false);
    if (arg_this != NULL) {
      bool return_value = (*(const Filename*)local_this).open_read(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_read(pifstream &stream) const
    pifstream *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_IFileStream(arg, arg_this, arg_manage)) {
      bool return_value = (*(const Filename*)local_this).open_read(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Filename::open_read(ifstream &stream) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read(Filename self, IFileStream stream)\n"
      "open_read(Filename self, ifstream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_read_373_comment =
  "C++ Interface:\n"
  "open_read(Filename self, IFileStream stream)\n"
  "open_read(Filename self, ifstream stream)\n";
#else
static const char *Dtool_Filename_open_read_373_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_write(ofstream &stream, bool truncate = true) const
 * bool Filename::open_write(pofstream &stream, bool truncate = true) const
 */
static PyObject *Dtool_Filename_open_write_374(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool Filename::open_write(ofstream &stream, bool truncate = true) const
    PyObject *param1;
    PyObject *param2 = Py_True;
    static const char *keyword_list[] = {"stream", "truncate", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      ofstream *param1_this = (ofstream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ofstream, 1, "Filename.open_write", false, false);
      if (param1_this != NULL) {
        bool return_value = (*(const Filename*)local_this).open_write(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Filename::open_write(ofstream &stream, bool truncate = true) const
  {
    // -2 bool Filename::open_write(pofstream &stream, bool truncate = true) const
    PyObject *param1;
    PyObject *param2 = Py_True;
    static const char *keyword_list[] = {"stream", "truncate", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      pofstream *param1_this;
      bool param1_manage = false;
      if (Dtool_Coerce_OFileStream(param1, param1_this, param1_manage)) {
        bool return_value = (*(const Filename*)local_this).open_write(*param1_this, (PyObject_IsTrue(param2) != 0));
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write(Filename self, ofstream stream, bool truncate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_write_374_comment =
  "C++ Interface:\n"
  "open_write(Filename self, ofstream stream, bool truncate)\n";
#else
static const char *Dtool_Filename_open_write_374_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_append(ofstream &stream) const
 * bool Filename::open_append(pofstream &stream) const
 */
static PyObject *Dtool_Filename_open_append_375(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool Filename::open_append(ofstream &stream) const
    ofstream *arg_this = (ofstream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ofstream, 1, "Filename.open_append", false, false);
    if (arg_this != NULL) {
      bool return_value = (*(const Filename*)local_this).open_append(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Filename::open_append(ofstream &stream) const
  {
    // -2 bool Filename::open_append(pofstream &stream) const
    pofstream *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_OFileStream(arg, arg_this, arg_manage)) {
      bool return_value = (*(const Filename*)local_this).open_append(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_append(Filename self, ofstream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_append_375_comment =
  "C++ Interface:\n"
  "open_append(Filename self, ofstream stream)\n";
#else
static const char *Dtool_Filename_open_append_375_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_read_write(fstream &stream, bool truncate = false) const
 * bool Filename::open_read_write(pfstream &stream, bool truncate = false) const
 */
static PyObject *Dtool_Filename_open_read_write_376(PyObject *self, PyObject *args, PyObject *kwds) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool Filename::open_read_write(fstream &stream, bool truncate = false) const
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"stream", "truncate", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read_write", (char **)keyword_list, &param1, &param2)) {
      fstream *param1_this = (fstream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_fstream, 1, "Filename.open_read_write", false, false);
      if (param1_this != NULL) {
        bool return_value = (*(const Filename*)local_this).open_read_write(*param1_this, (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Filename::open_read_write(fstream &stream, bool truncate = false) const
  {
    // -2 bool Filename::open_read_write(pfstream &stream, bool truncate = false) const
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"stream", "truncate", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read_write", (char **)keyword_list, &param1, &param2)) {
      pfstream *param1_this;
      bool param1_manage = false;
      if (Dtool_Coerce_FileStream(param1, param1_this, param1_manage)) {
        bool return_value = (*(const Filename*)local_this).open_read_write(*param1_this, (PyObject_IsTrue(param2) != 0));
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write(Filename self, fstream stream, bool truncate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_read_write_376_comment =
  "C++ Interface:\n"
  "open_read_write(Filename self, fstream stream, bool truncate)\n";
#else
static const char *Dtool_Filename_open_read_write_376_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::open_read_append(fstream &stream) const
 * bool Filename::open_read_append(pfstream &stream) const
 */
static PyObject *Dtool_Filename_open_read_append_377(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  {
    // -2 bool Filename::open_read_append(pfstream &stream) const
    pfstream *arg_this = (FileStream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FileStream, 1, "Filename.open_read_append", false, false);
    if (arg_this != NULL) {
      bool return_value = (*(const Filename*)local_this).open_read_append(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_read_append(fstream &stream) const
    fstream *arg_this = (fstream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_fstream, 1, "Filename.open_read_append", false, false);
    if (arg_this != NULL) {
      bool return_value = (*(const Filename*)local_this).open_read_append(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool Filename::open_read_append(pfstream &stream) const
    pfstream *arg_this;
    bool arg_manage = false;
    if (Dtool_Coerce_FileStream(arg, arg_this, arg_manage)) {
      bool return_value = (*(const Filename*)local_this).open_read_append(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: bool Filename::open_read_append(fstream &stream) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_append(Filename self, FileStream stream)\n"
      "open_read_append(Filename self, fstream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_open_read_append_377_comment =
  "C++ Interface:\n"
  "open_read_append(Filename self, FileStream stream)\n"
  "open_read_append(Filename self, fstream stream)\n";
#else
static const char *Dtool_Filename_open_read_append_377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::chdir(void) const
 */
static PyObject *Dtool_Filename_chdir_378(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::chdir(void) const
  bool return_value = (*(const Filename*)local_this).chdir();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_chdir_378_comment =
  "C++ Interface:\n"
  "chdir(Filename self)\n";
#else
static const char *Dtool_Filename_chdir_378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::touch(void) const
 */
static PyObject *Dtool_Filename_touch_379(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::touch(void) const
  bool return_value = (*(const Filename*)local_this).touch();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_touch_379_comment =
  "C++ Interface:\n"
  "touch(Filename self)\n";
#else
static const char *Dtool_Filename_touch_379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::unlink(void) const
 */
static PyObject *Dtool_Filename_unlink_380(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::unlink(void) const
  bool return_value = (*(const Filename*)local_this).unlink();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_unlink_380_comment =
  "C++ Interface:\n"
  "unlink(Filename self)\n";
#else
static const char *Dtool_Filename_unlink_380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::rename_to(Filename const &other) const
 */
static PyObject *Dtool_Filename_rename_to_381(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::rename_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.rename_to", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const Filename*)local_this).rename_to(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rename_to(Filename self, const Filename other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_rename_to_381_comment =
  "C++ Interface:\n"
  "rename_to(Filename self, const Filename other)\n";
#else
static const char *Dtool_Filename_rename_to_381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::copy_to(Filename const &other) const
 */
static PyObject *Dtool_Filename_copy_to_382(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::copy_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.copy_to", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const Filename*)local_this).copy_to(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_to(Filename self, const Filename other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_copy_to_382_comment =
  "C++ Interface:\n"
  "copy_to(Filename self, const Filename other)\n";
#else
static const char *Dtool_Filename_copy_to_382_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::make_dir(void) const
 */
static PyObject *Dtool_Filename_make_dir_383(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::make_dir(void) const
  bool return_value = (*(const Filename*)local_this).make_dir();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_make_dir_383_comment =
  "C++ Interface:\n"
  "make_dir(Filename self)\n";
#else
static const char *Dtool_Filename_make_dir_383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::mkdir(void) const
 */
static PyObject *Dtool_Filename_mkdir_384(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::mkdir(void) const
  bool return_value = (*(const Filename*)local_this).mkdir();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_mkdir_384_comment =
  "C++ Interface:\n"
  "mkdir(Filename self)\n";
#else
static const char *Dtool_Filename_mkdir_384_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Filename::rmdir(void) const
 */
static PyObject *Dtool_Filename_rmdir_385(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Filename::rmdir(void) const
  bool return_value = (*(const Filename*)local_this).rmdir();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_rmdir_385_comment =
  "C++ Interface:\n"
  "rmdir(Filename self)\n";
#else
static const char *Dtool_Filename_rmdir_385_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Filename::compare_to(Filename const &other) const
 */
static PyObject *Dtool_Filename_compare_to_389(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Filename::compare_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.compare_to", "Filename");
  }
  int return_value = (*(const Filename*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(Filename self, const Filename other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_compare_to_389_comment =
  "C++ Interface:\n"
  "compare_to(Filename self, const Filename other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_compare_to_389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Filename::get_hash(void) const
 */
static PyObject *Dtool_Filename_get_hash_391(PyObject *self, PyObject *) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Filename::get_hash(void) const
  int return_value = (*(const Filename*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_hash_391_comment =
  "C++ Interface:\n"
  "get_hash(Filename self)\n";
#else
static const char *Dtool_Filename_get_hash_391_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Filename::output(ostream &out) const
 */
static PyObject *Dtool_Filename_output_392(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void Filename::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Filename.output", false, true);
  if (arg_this != NULL) {
    (*(const Filename*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Filename self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_output_392_comment =
  "C++ Interface:\n"
  "output(Filename self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Filename_output_392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void Filename::set_filesystem_encoding(TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_Filename_set_filesystem_encoding_393(PyObject *, PyObject *arg) {
  // 1-static inline void Filename::set_filesystem_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Filename::set_filesystem_encoding((TextEncoder::Encoding)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_filesystem_encoding(int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Filename_set_filesystem_encoding_393_comment =
  "C++ Interface:\n"
  "set_filesystem_encoding(int encoding)\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequent Filenames.\n"
  " * This is used to represent wide-character (Unicode) filenames internally.\n"
  " * On non-Windows-based systems, the encoded filename is also passed to the\n"
  " * underlying operating system.\n"
  " */";
#else
static const char *Dtool_Filename_set_filesystem_encoding_393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline TextEncoder::Encoding Filename::get_filesystem_encoding(void)
 */
static PyObject *Dtool_Filename_get_filesystem_encoding_394(PyObject *, PyObject *) {
  // 1-static inline TextEncoder::Encoding Filename::get_filesystem_encoding(void)
  TextEncoder::Encoding return_value = Filename::get_filesystem_encoding();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_filesystem_encoding_394_comment =
  "C++ Interface:\n"
  "get_filesystem_encoding()\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequent Filenames\n"
  " * objects.  See set_filesystem_encoding().\n"
  " */";
#else
static const char *Dtool_Filename_get_filesystem_encoding_394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Filename::get_class_type(void)
 */
static PyObject *Dtool_Filename_get_class_type_395(PyObject *, PyObject *) {
  // 1-static TypeHandle Filename::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Filename::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Filename_get_class_type_395_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Filename_get_class_type_395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename::Filename(Filename const &copy)
 * Filename::Filename(Filename const &dirname, Filename const &basename)
 * inline Filename::Filename(std::string const &filename = "")
 * inline Filename::Filename(std::wstring const &filename)
 */
static int Dtool_Init_Filename(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Filename::Filename(std::string const &filename)
      Filename *return_value = new Filename();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Filename::Filename(Filename const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Filename", (char **)keyword_list, &param0)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            Filename *return_value = new Filename(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline Filename::Filename(std::wstring const &filename)
        #if PY_VERSION_HEX >= 0x03020000
        PyObject *param0;
        #else
        PyUnicodeObject *param0;
        #endif
        static const char *keyword_list[] = {"filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "U:Filename", (char **)keyword_list, &param0)) {
#if PY_VERSION_HEX >= 0x03030000
          Py_ssize_t param0_len;
          wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
          Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
          wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
          PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
          Filename *return_value = new Filename(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
          PyMem_Free(param0_str);
#endif
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline Filename::Filename(std::string const &filename)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"filename", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Filename", (char **)keyword_list, &param0_str, &param0_len)) {
          Filename *return_value = new Filename(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline Filename::Filename(Filename const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Filename", (char **)keyword_list, &param0)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != NULL)) {
            Filename *return_value = new Filename(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Filename::Filename(std::wstring const &filename)
      // No coercion possible: inline Filename::Filename(std::string const &filename)
    }
    break;
  case 2:
    {
      // 1-Filename::Filename(Filename const &dirname, Filename const &basename)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"dirname", "basename", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:Filename", (char **)keyword_list, &param0, &param1)) {
        Filename param0_local;
        Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
        if (!(param0_this != NULL)) {
          Dtool_Raise_ArgTypeError(param0, 0, "Filename.Filename", "Filename");
          return -1;
        }
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          Dtool_Raise_ArgTypeError(param1, 1, "Filename.Filename", "Filename");
          return -1;
        }
        Filename *return_value = new Filename(*param0_this, *param1_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Filename, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Filename() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Filename()\n"
      "Filename(const Filename copy)\n"
      "Filename(unicode filename)\n"
      "Filename(str filename)\n"
      "Filename(const Filename dirname, const Filename basename)\n");
  }
  return -1;
}

Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  Filename *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Filename, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const Filename *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline Filename::Filename(std::wstring const &filename)
      #if PY_VERSION_HEX >= 0x03020000
      PyObject *param0;
      #else
      PyUnicodeObject *param0;
      #endif
      if (PyArg_Parse(arg, "U:Filename", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param0_len;
        wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
        Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
        wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
        PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
        coerced = Filename(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param0_str);
#endif
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline Filename::Filename(std::string const &filename)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        coerced = Filename(std::string(param0_str, param0_len));
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Filename::Filename(Filename const &dirname, Filename const &basename)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "Filename", 2, 2, &param0, &param1)) {
        Filename const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
        Filename const *param1_this;
        DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
        if (param0_this != NULL && param1_this != NULL) {
          coerced = Filename(*param0_this, *param1_this);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_Filename(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Filename) {
    printf("Filename ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Filename *local_this = (Filename *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Filename) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Filename(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Filename) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableInt
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableInt::operator =(int value)
 */
static PyObject *Dtool_ConfigVariableInt_operator_402(PyObject *self, PyObject *arg) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableInt::operator =(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).operator =((int)arg_val);
    ConfigVariableInt *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableInt, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableInt self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_operator_402_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableInt self, int value)\n";
#else
static const char *Dtool_ConfigVariableInt_operator_402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt::set_value(int value)
 */
static PyObject *Dtool_ConfigVariableInt_set_value_406(PyObject *self, PyObject *arg) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableInt::set_value(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_value((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_set_value_406_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableInt self, int value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_set_value_406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableInt::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt_get_value_407(PyObject *self, PyObject *) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableInt::get_value(void) const
  int return_value = (*(const ConfigVariableInt*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_get_value_407_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableInt self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_get_value_407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableInt::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt_get_default_value_408(PyObject *self, PyObject *) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableInt::get_default_value(void) const
  int return_value = (*(const ConfigVariableInt*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_get_default_value_408_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableInt self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_get_default_value_408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int ConfigVariableInt::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableInt_get_word_411(PyObject *self, PyObject *arg) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ConfigVariableInt::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int return_value = (*(const ConfigVariableInt*)local_this).get_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableInt self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_get_word_411_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableInt self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_get_word_411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt::set_word(std::size_t n, int value)
 */
static PyObject *Dtool_ConfigVariableInt_set_word_412(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.set_word")) {
    return NULL;
  }
  // 1-inline void ConfigVariableInt::set_word(std::size_t n, int value)
  Py_ssize_t param1;
  int param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_word((std::size_t)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableInt self, int n, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt_set_word_412_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableInt self, int n, int value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt_set_word_412_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableInt_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigVariableInt::get_value(void) const
  int return_value = (*(const ConfigVariableInt*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableInt_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt, (void **)&local_this, "ConfigVariableInt.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableInt::set_value(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_value((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableInt_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigVariableInt::get_default_value(void) const
  int return_value = (*(const ConfigVariableInt*)local_this).get_default_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableInt::ConfigVariableInt(ConfigVariableInt const &) = default
 * inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
 * inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableInt(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(ConfigVariableInt const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableInt", (char **)keyword_list, &param0)) {
          ConfigVariableInt const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableInt, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableInt *return_value = new ConfigVariableInt(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableInt", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(ConfigVariableInt const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableInt", (char **)keyword_list, &param0)) {
          ConfigVariableInt const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableInt(param0, param0_this, param0_manage)) {
            ConfigVariableInt *return_value = new ConfigVariableInt(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableInt", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        int param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i|s#i:ConfigVariableInt", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), (int)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableInt() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableInt(const ConfigVariableInt param0)\n"
      "ConfigVariableInt(str name)\n"
      "ConfigVariableInt(str name, str default_value, str description, int flags)\n"
      "ConfigVariableInt(str name, int default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableInt(PyObject *args, ConfigVariableInt const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableInt, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableInt", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        int param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#i|s#i:ConfigVariableInt", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), (int)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableInt(PyObject *args, ConfigVariableInt *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableInt, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableInt::ConfigVariableInt(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableInt", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt::ConfigVariableInt(std::string const &name, int default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        int param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#i|s#i:ConfigVariableInt", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt *return_value = new ConfigVariableInt(std::string(param0_str, param0_len), (int)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableInt(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableInt) {
    printf("ConfigVariableInt ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableInt *local_this = (ConfigVariableInt *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableInt) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableInt(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableInt) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableInt*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableInt*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableInt*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableInt64
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableInt64::operator =(int64_t value)
 */
static PyObject *Dtool_ConfigVariableInt64_operator_416(PyObject *self, PyObject *arg) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableInt64::operator =(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:assign", &param1)) {
    (*local_this).operator =((int64_t)param1);
    ConfigVariableInt64 *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableInt64, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableInt64 self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_operator_416_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableInt64 self, long value)\n";
#else
static const char *Dtool_ConfigVariableInt64_operator_416_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt64::set_value(int64_t value)
 */
static PyObject *Dtool_ConfigVariableInt64_set_value_420(PyObject *self, PyObject *arg) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableInt64::set_value(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:set_value", &param1)) {
    (*local_this).set_value((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt64 self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_set_value_420_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableInt64 self, long value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_set_value_420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigVariableInt64::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt64_get_value_421(PyObject *self, PyObject *) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int64_t ConfigVariableInt64::get_value(void) const
  int64_t return_value = (*(const ConfigVariableInt64*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_get_value_421_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableInt64 self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_get_value_421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigVariableInt64::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableInt64_get_default_value_422(PyObject *self, PyObject *) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int64_t ConfigVariableInt64::get_default_value(void) const
  int64_t return_value = (*(const ConfigVariableInt64*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_get_default_value_422_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableInt64 self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_get_default_value_422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t ConfigVariableInt64::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableInt64_get_word_427(PyObject *self, PyObject *arg) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int64_t ConfigVariableInt64::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int64_t return_value = (*(const ConfigVariableInt64*)local_this).get_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableInt64 self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_get_word_427_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableInt64 self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_get_word_427_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableInt64::set_word(std::size_t n, int64_t value)
 */
static PyObject *Dtool_ConfigVariableInt64_set_word_428(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.set_word")) {
    return NULL;
  }
  // 1-inline void ConfigVariableInt64::set_word(std::size_t n, int64_t value)
  Py_ssize_t param1;
  PY_LONG_LONG param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nL:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_word((std::size_t)param1, (int64_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableInt64 self, int n, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableInt64_set_word_428_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableInt64 self, int n, long value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableInt64_set_word_428_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableInt64_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int64_t ConfigVariableInt64::get_value(void) const
  int64_t return_value = (*(const ConfigVariableInt64*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableInt64_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableInt64, (void **)&local_this, "ConfigVariableInt64.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableInt64::set_value(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:set_value", &param1)) {
    (*local_this).set_value((int64_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableInt64 self, long value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableInt64_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int64_t ConfigVariableInt64::get_default_value(void) const
  int64_t return_value = (*(const ConfigVariableInt64*)local_this).get_default_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableInt64::ConfigVariableInt64(ConfigVariableInt64 const &) = default
 * inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
 * inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableInt64(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(ConfigVariableInt64 const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableInt64", (char **)keyword_list, &param0)) {
          ConfigVariableInt64 const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableInt64, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableInt64 *return_value = new ConfigVariableInt64(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableInt64", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(ConfigVariableInt64 const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableInt64", (char **)keyword_list, &param0)) {
          ConfigVariableInt64 const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableInt64(param0, param0_this, param0_manage)) {
            ConfigVariableInt64 *return_value = new ConfigVariableInt64(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableInt64", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PY_LONG_LONG param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#L|s#i:ConfigVariableInt64", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), (int64_t)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableInt64, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      // No coercion possible: inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableInt64() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableInt64(const ConfigVariableInt64 param0)\n"
      "ConfigVariableInt64(str name)\n"
      "ConfigVariableInt64(str name, str default_value, str description, int flags)\n"
      "ConfigVariableInt64(str name, long default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableInt64(PyObject *args, ConfigVariableInt64 const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableInt64, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableInt64", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PY_LONG_LONG param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#L|s#i:ConfigVariableInt64", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), (int64_t)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableInt64(PyObject *args, ConfigVariableInt64 *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableInt64, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableInt64", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableInt64::ConfigVariableInt64(std::string const &name, int64_t default_value, std::string const &description = string(), int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PY_LONG_LONG param1;
        const char *param2_str = "";
        Py_ssize_t param2_len = 0;
        int param3 = 0;
        if (PyArg_ParseTuple(args, "s#L|s#i:ConfigVariableInt64", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          ConfigVariableInt64 *return_value = new ConfigVariableInt64(std::string(param0_str, param0_len), (int64_t)param1, std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableInt64(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableInt64) {
    printf("ConfigVariableInt64 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableInt64 *local_this = (ConfigVariableInt64 *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableInt64) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableInt64(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableInt64) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableInt64*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableInt64*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableInt64*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableList
 */
/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableList::get_num_values(void) const
 */
static PyObject *Dtool_ConfigVariableList_get_num_values_433(PyObject *self, PyObject *) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableList::get_num_values(void) const
  std::size_t return_value = (*(const ConfigVariableList*)local_this).get_num_values();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_num_values_433_comment =
  "C++ Interface:\n"
  "get_num_values(ConfigVariableList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of values in the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_num_values_433_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableList::get_string_value(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableList_get_string_value_434(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableList::get_string_value(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_string_value", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigVariableList*)local_this).get_string_value((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_value(ConfigVariableList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_string_value_434_comment =
  "C++ Interface:\n"
  "get_string_value(ConfigVariableList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth value of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_string_value_434_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableList::get_num_unique_values(void) const
 */
static PyObject *Dtool_ConfigVariableList_get_num_unique_values_435(PyObject *self, PyObject *) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableList::get_num_unique_values(void) const
  std::size_t return_value = (*(const ConfigVariableList*)local_this).get_num_unique_values();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_num_unique_values_435_comment =
  "C++ Interface:\n"
  "get_num_unique_values(ConfigVariableList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of unique values in the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_num_unique_values_435_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableList::get_unique_value(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableList_get_unique_value_436(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableList::get_unique_value(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_unique_value", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigVariableList*)local_this).get_unique_value((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unique_value(ConfigVariableList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_get_unique_value_436_comment =
  "C++ Interface:\n"
  "get_unique_value(ConfigVariableList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth unique value of the variable.\n"
  " */";
#else
static const char *Dtool_ConfigVariableList_get_unique_value_436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableList::output(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableList_output_439(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableList::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableList.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableList*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableList self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_output_439_comment =
  "C++ Interface:\n"
  "output(ConfigVariableList self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableList_output_439_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableList::write(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableList_write_440(PyObject *self, PyObject *arg) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableList::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableList.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableList*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableList self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableList_write_440_comment =
  "C++ Interface:\n"
  "write(ConfigVariableList self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableList_write_440_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableList::ConfigVariableList(ConfigVariableList const &) = default
 * inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableList(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description = string(), int flags = 0)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
    const char *param1_str = "";
    Py_ssize_t param1_len = 0;
    int param2 = 0;
    static const char *keyword_list[] = {"name", "description", "flags", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#i:ConfigVariableList", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
      ConfigVariableList *return_value = new ConfigVariableList(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableList, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description = string(), int flags = 0)
  {
    // -2 inline ConfigVariableList::ConfigVariableList(ConfigVariableList const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableList", (char **)keyword_list, &param0)) {
      ConfigVariableList const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_ConfigVariableList(param0, param0_this, param0_manage)) {
        ConfigVariableList *return_value = new ConfigVariableList(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableList, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableList(str name, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableList(PyObject *args, ConfigVariableList const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableList, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description, int flags)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableList *return_value = new ConfigVariableList(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description, int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      int param2 = 0;
      if (PyArg_ParseTuple(args, "s#s#|i:ConfigVariableList", &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
        ConfigVariableList *return_value = new ConfigVariableList(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableList(PyObject *args, ConfigVariableList *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableList, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description, int flags)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableList *return_value = new ConfigVariableList(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-inline ConfigVariableList::ConfigVariableList(std::string const &name, std::string const &description, int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      int param2 = 0;
      if (PyArg_ParseTuple(args, "s#s#|i:ConfigVariableList", &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
        ConfigVariableList *return_value = new ConfigVariableList(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableList) {
    printf("ConfigVariableList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableList *local_this = (ConfigVariableList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableList*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableList*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableManager
 */
/**
 * Python function wrapper for:
 * ConfigVariableCore *ConfigVariableManager::make_variable(std::string const &name)
 */
static PyObject *Dtool_ConfigVariableManager_make_variable_442(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableManager, (void **)&local_this, "ConfigVariableManager.make_variable")) {
    return NULL;
  }
  // 1-ConfigVariableCore *ConfigVariableManager::make_variable(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    ConfigVariableCore *return_value = (*local_this).make_variable(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_variable(const ConfigVariableManager self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_make_variable_442_comment =
  "C++ Interface:\n"
  "make_variable(const ConfigVariableManager self, str name)\n";
#else
static const char *Dtool_ConfigVariableManager_make_variable_442_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigVariableCore *ConfigVariableManager::make_variable_template(std::string const &pattern, ConfigFlags::ValueType type, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static PyObject *Dtool_ConfigVariableManager_make_variable_template_443(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableManager, (void **)&local_this, "ConfigVariableManager.make_variable_template")) {
    return NULL;
  }
  // 1-ConfigVariableCore *ConfigVariableManager::make_variable_template(std::string const &pattern, ConfigFlags::ValueType type, std::string const &default_value, std::string const &description = string(), int flags = 0)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  const char *param4_str = "";
  Py_ssize_t param4_len = 0;
  int param5 = 0;
  static const char *keyword_list[] = {"pattern", "type", "default_value", "description", "flags", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#is#|s#i:make_variable_template", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3_str, &param3_len, &param4_str, &param4_len, &param5)) {
    ConfigVariableCore *return_value = (*local_this).make_variable_template(std::string(param1_str, param1_len), (ConfigFlags::ValueType)param2, std::string(param3_str, param3_len), std::string(param4_str, param4_len), (int)param5);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_variable_template(const ConfigVariableManager self, str pattern, int type, str default_value, str description, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_make_variable_template_443_comment =
  "C++ Interface:\n"
  "make_variable_template(const ConfigVariableManager self, str pattern, int type, str default_value, str description, int flags)\n";
#else
static const char *Dtool_ConfigVariableManager_make_variable_template_443_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableManager::get_num_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_get_num_variables_444(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableManager::get_num_variables(void) const
  std::size_t return_value = (*(const ConfigVariableManager*)local_this).get_num_variables();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_num_variables_444_comment =
  "C++ Interface:\n"
  "get_num_variables(ConfigVariableManager self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of active ConfigVariableCores in the world.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_get_num_variables_444_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConfigVariableCore *ConfigVariableManager::get_variable(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableManager_get_variable_445(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ConfigVariableCore *ConfigVariableManager::get_variable(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_variable", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ConfigVariableCore *return_value = (*(const ConfigVariableManager*)local_this).get_variable((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable(ConfigVariableManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_variable_445_comment =
  "C++ Interface:\n"
  "get_variable(ConfigVariableManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth active ConfigVariableCore in the world.\n"
  " */";
#else
static const char *Dtool_ConfigVariableManager_get_variable_445_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string ConfigVariableManager::get_variable_name(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableManager_get_variable_name_447(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string ConfigVariableManager::get_variable_name(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_variable_name", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigVariableManager*)local_this).get_variable_name((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable_name(ConfigVariableManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_variable_name_447_comment =
  "C++ Interface:\n"
  "get_variable_name(ConfigVariableManager self, int n)\n";
#else
static const char *Dtool_ConfigVariableManager_get_variable_name_447_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ConfigVariableManager::is_variable_used(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableManager_is_variable_used_448(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ConfigVariableManager::is_variable_used(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:is_variable_used", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*(const ConfigVariableManager*)local_this).is_variable_used((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_variable_used(ConfigVariableManager self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_is_variable_used_448_comment =
  "C++ Interface:\n"
  "is_variable_used(ConfigVariableManager self, int n)\n";
#else
static const char *Dtool_ConfigVariableManager_is_variable_used_448_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::output(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableManager_output_450(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableManager::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableManager.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableManager*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_output_450_comment =
  "C++ Interface:\n"
  "output(ConfigVariableManager self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableManager_output_450_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::write(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableManager_write_451(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableManager::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableManager.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableManager*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_write_451_comment =
  "C++ Interface:\n"
  "write(ConfigVariableManager self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableManager_write_451_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::write_prc_variables(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableManager_write_prc_variables_452(PyObject *self, PyObject *arg) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableManager::write_prc_variables(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableManager.write_prc_variables", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableManager*)local_this).write_prc_variables(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_prc_variables(ConfigVariableManager self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_write_prc_variables_452_comment =
  "C++ Interface:\n"
  "write_prc_variables(ConfigVariableManager self, ostream out)\n";
#else
static const char *Dtool_ConfigVariableManager_write_prc_variables_452_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::list_unused_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_list_unused_variables_453(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableManager::list_unused_variables(void) const
  (*(const ConfigVariableManager*)local_this).list_unused_variables();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_list_unused_variables_453_comment =
  "C++ Interface:\n"
  "list_unused_variables(ConfigVariableManager self)\n";
#else
static const char *Dtool_ConfigVariableManager_list_unused_variables_453_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::list_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_list_variables_454(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableManager::list_variables(void) const
  (*(const ConfigVariableManager*)local_this).list_variables();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_list_variables_454_comment =
  "C++ Interface:\n"
  "list_variables(ConfigVariableManager self)\n";
#else
static const char *Dtool_ConfigVariableManager_list_variables_454_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ConfigVariableManager::list_dynamic_variables(void) const
 */
static PyObject *Dtool_ConfigVariableManager_list_dynamic_variables_455(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  // 1-void ConfigVariableManager::list_dynamic_variables(void) const
  (*(const ConfigVariableManager*)local_this).list_dynamic_variables();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_list_dynamic_variables_455_comment =
  "C++ Interface:\n"
  "list_dynamic_variables(ConfigVariableManager self)\n";
#else
static const char *Dtool_ConfigVariableManager_list_dynamic_variables_455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ConfigVariableManager *ConfigVariableManager::get_global_ptr(void)
 */
static PyObject *Dtool_ConfigVariableManager_get_global_ptr_456(PyObject *, PyObject *) {
  // 1-static ConfigVariableManager *ConfigVariableManager::get_global_ptr(void)
  ConfigVariableManager *return_value = ConfigVariableManager::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableManager_get_global_ptr_456_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_ConfigVariableManager_get_global_ptr_456_comment = NULL;
#endif

/**
 * sequence length function for property ConfigVariableManager::variables
 */
static Py_ssize_t Dtool_ConfigVariableManager_variables_Len(PyObject *self) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_variables();
}

/**
 * sequence getter for property ConfigVariableManager::variables
 */
static PyObject *Dtool_ConfigVariableManager_variables_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_variables()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableManager.variables[] index out of range");
    return NULL;
  }
  // 1-inline ConfigVariableCore *ConfigVariableManager::get_variable(std::size_t n) const
  ConfigVariableCore *return_value = (*(const ConfigVariableManager*)local_this).get_variable(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableCore, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_variable(ConfigVariableManager self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableManager_variables_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigVariableManager_variables_Len;
  wrap->_getitem_func = &Dtool_ConfigVariableManager_variables_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static int Dtool_Init_ConfigVariableManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableManager_get_variables(PyObject *self, PyObject *) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_variables();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableManager_get_variable_445(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConfigVariableManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableManager) {
    printf("ConfigVariableManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableManager *local_this = (ConfigVariableManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableManager) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableManager) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableSearchPath
 */
/**
 * Python function wrapper for:
 * inline DSearchPath const &ConfigVariableSearchPath::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_value_461(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DSearchPath const &ConfigVariableSearchPath::get_value(void) const
  DSearchPath const *return_value = &((*(const ConfigVariableSearchPath*)local_this).get_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_value_461_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_value_461_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_default_value_462(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
  DSearchPath const *return_value = &((*(const ConfigVariableSearchPath*)local_this).get_default_value());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_default_value_462_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_default_value_462_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableSearchPath::clear_local_value(void)
 */
static PyObject *Dtool_ConfigVariableSearchPath_clear_local_value_497(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.clear_local_value")) {
    return NULL;
  }
  // 1-inline bool ConfigVariableSearchPath::clear_local_value(void)
  bool return_value = (*local_this).clear_local_value();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_clear_local_value_497_comment =
  "C++ Interface:\n"
  "clear_local_value(const ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Removes all the directories locally added to the search list, and restores\n"
  " * it to its original form.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_clear_local_value_497_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::clear(void)
 */
static PyObject *Dtool_ConfigVariableSearchPath_clear_498(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.clear")) {
    return NULL;
  }
  // 1-inline void ConfigVariableSearchPath::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_clear_498_comment =
  "C++ Interface:\n"
  "clear(const ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Removes all the directories locally added to the search list, and restores\n"
  " * it to its original form.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_clear_498_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::append_directory(Filename const &directory)
 */
static PyObject *Dtool_ConfigVariableSearchPath_append_directory_499(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.append_directory")) {
    return NULL;
  }
  // 1-inline void ConfigVariableSearchPath::append_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.append_directory", "Filename");
  }
  (*local_this).append_directory(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_directory(const ConfigVariableSearchPath self, const Filename directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_append_directory_499_comment =
  "C++ Interface:\n"
  "append_directory(const ConfigVariableSearchPath self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Adds a new directory to the end of the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_append_directory_499_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::prepend_directory(Filename const &directory)
 */
static PyObject *Dtool_ConfigVariableSearchPath_prepend_directory_500(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.prepend_directory")) {
    return NULL;
  }
  // 1-inline void ConfigVariableSearchPath::prepend_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.prepend_directory", "Filename");
  }
  (*local_this).prepend_directory(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_directory(const ConfigVariableSearchPath self, const Filename directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_prepend_directory_500_comment =
  "C++ Interface:\n"
  "prepend_directory(const ConfigVariableSearchPath self, const Filename directory)\n"
  "\n"
  "/**\n"
  " * Adds a new directory to the front of the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_prepend_directory_500_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::append_path(DSearchPath const &path)
 * inline void ConfigVariableSearchPath::append_path(std::string const &path, std::string const &separator = string())
 */
static PyObject *Dtool_ConfigVariableSearchPath_append_path_501(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.append_path")) {
    return NULL;
  }
  {
    // -2 inline void ConfigVariableSearchPath::append_path(std::string const &path, std::string const &separator = string())
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"path", "separator", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:append_path", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      (*local_this).append_path(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: inline void ConfigVariableSearchPath::append_path(std::string const &path, std::string const &separator = string())
  {
    // -2 inline void ConfigVariableSearchPath::append_path(DSearchPath const &path)
    PyObject *param1;
    static const char *keyword_list[] = {"path", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:append_path", (char **)keyword_list, &param1)) {
      DSearchPath const *param1_this;
      bool param1_manage = false;
      if (Dtool_ConstCoerce_DSearchPath(param1, param1_this, param1_manage)) {
        (*local_this).append_path(*param1_this);
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_path(const ConfigVariableSearchPath self, str path, str separator)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_append_path_501_comment =
  "C++ Interface:\n"
  "append_path(const ConfigVariableSearchPath self, str path, str separator)\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the end of the\n"
  " * search list.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the end of the\n"
  " * search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_append_path_501_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::prepend_path(DSearchPath const &path)
 */
static PyObject *Dtool_ConfigVariableSearchPath_prepend_path_502(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableSearchPath, (void **)&local_this, "ConfigVariableSearchPath.prepend_path")) {
    return NULL;
  }
  // 1-inline void ConfigVariableSearchPath::prepend_path(DSearchPath const &path)
  DSearchPath const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DSearchPath(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.prepend_path", "DSearchPath");
  }
  (*local_this).prepend_path(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_path(const ConfigVariableSearchPath self, const DSearchPath path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_prepend_path_502_comment =
  "C++ Interface:\n"
  "prepend_path(const ConfigVariableSearchPath self, const DSearchPath path)\n"
  "\n"
  "/**\n"
  " * Adds all of the directories listed in the search path to the beginning of\n"
  " * the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_prepend_path_502_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableSearchPath::is_empty(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_is_empty_503(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableSearchPath::is_empty(void) const
  bool return_value = (*(const ConfigVariableSearchPath*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_is_empty_503_comment =
  "C++ Interface:\n"
  "is_empty(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Returns true if the search list is empty, false otherwise.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_is_empty_503_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableSearchPath::get_num_directories(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_num_directories_504(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableSearchPath::get_num_directories(void) const
  std::size_t return_value = (*(const ConfigVariableSearchPath*)local_this).get_num_directories();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_num_directories_504_comment =
  "C++ Interface:\n"
  "get_num_directories(ConfigVariableSearchPath self)\n"
  "\n"
  "/**\n"
  " * Returns the number of directories on the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_num_directories_504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &ConfigVariableSearchPath::get_directory(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_get_directory_505(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &ConfigVariableSearchPath::get_directory(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_directory", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Filename const *return_value = &((*(const ConfigVariableSearchPath*)local_this).get_directory((std::size_t)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(ConfigVariableSearchPath self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_get_directory_505_comment =
  "C++ Interface:\n"
  "get_directory(ConfigVariableSearchPath self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth directory on the search list.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_get_directory_505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename ConfigVariableSearchPath::find_file(Filename const &filename) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_find_file_508(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename ConfigVariableSearchPath::find_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.find_file", "Filename");
  }
  Filename *return_value = new Filename((*(const ConfigVariableSearchPath*)local_this).find_file(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_file(ConfigVariableSearchPath self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_find_file_508_comment =
  "C++ Interface:\n"
  "find_file(ConfigVariableSearchPath self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Returns the full matching pathname of the first match if found, or\n"
  " * the empty string if not found.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_find_file_508_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath::Results ConfigVariableSearchPath::find_all_files(Filename const &filename) const
 * inline std::size_t ConfigVariableSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_find_all_files_509(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "filename");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'filename' (pos 1) not found");
      }
      // 1-inline DSearchPath::Results ConfigVariableSearchPath::find_all_files(Filename const &filename) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "ConfigVariableSearchPath.find_all_files", "Filename");
      }
      DSearchPath::Results *return_value = new DSearchPath::Results((*(const ConfigVariableSearchPath*)local_this).find_all_files(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath_Results, true, false);
    }
    break;
  case 2:
    {
      // 1-inline std::size_t ConfigVariableSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"filename", "results", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:find_all_files", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ConfigVariableSearchPath.find_all_files", "Filename");
        }
        DSearchPath::Results *param2_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DSearchPath_Results, 2, "ConfigVariableSearchPath.find_all_files", false, true);
        if (param2_this != NULL) {
          std::size_t return_value = (*(const ConfigVariableSearchPath*)local_this).find_all_files(*param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_files() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_files(ConfigVariableSearchPath self, const Filename filename)\n"
      "find_all_files(ConfigVariableSearchPath self, const Filename filename, Results results)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_find_all_files_509_comment =
  "C++ Interface:\n"
  "find_all_files(ConfigVariableSearchPath self, const Filename filename)\n"
  "find_all_files(ConfigVariableSearchPath self, const Filename filename, Results results)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Fills up the results list with *all* of the matching filenames\n"
  " * found, if any.  Returns the number of matches found.\n"
  " *\n"
  " * It is the responsibility of the the caller to clear the results list first;\n"
  " * otherwise, the newly-found files will be appended to the list.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant of find_all_files() returns the new Results object, instead of\n"
  " * filling on in on the parameter list.  This is a little more convenient to\n"
  " * call from Python.\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_find_all_files_509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::output(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_output_510(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ConfigVariableSearchPath::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableSearchPath.output", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableSearchPath*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ConfigVariableSearchPath self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_output_510_comment =
  "C++ Interface:\n"
  "output(ConfigVariableSearchPath self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_output_510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableSearchPath::write(ostream &out) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_write_511(PyObject *self, PyObject *arg) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ConfigVariableSearchPath::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ConfigVariableSearchPath.write", false, true);
  if (arg_this != NULL) {
    (*(const ConfigVariableSearchPath*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ConfigVariableSearchPath self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_write_511_comment =
  "C++ Interface:\n"
  "write(ConfigVariableSearchPath self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableSearchPath_write_511_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath const &ConfigVariableSearchPath::operator typecast(void) const
 */
static PyObject *Dtool_ConfigVariableSearchPath_operator_typecast_460(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline DSearchPath const &ConfigVariableSearchPath::operator typecast(void) const
  DSearchPath const *return_value = &((DSearchPath const &)*(const ConfigVariableSearchPath*)local_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableSearchPath_operator_typecast_460_comment =
  "C++ Interface:\n"
  "operator_typecast(ConfigVariableSearchPath self)\n";
#else
static const char *Dtool_ConfigVariableSearchPath_operator_typecast_460_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableSearchPath_value_Getter(PyObject *self, void *) {
  const ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DSearchPath const &ConfigVariableSearchPath::get_value(void) const
  DSearchPath const *return_value = &((*(const ConfigVariableSearchPath*)local_this).get_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

static PyObject *Dtool_ConfigVariableSearchPath_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline DSearchPath const &ConfigVariableSearchPath::get_default_value(void) const
  DSearchPath const *return_value = &((*(const ConfigVariableSearchPath*)local_this).get_default_value());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, true);
}

/**
 * sequence length function for property ConfigVariableSearchPath::directories
 */
static Py_ssize_t Dtool_ConfigVariableSearchPath_directories_Len(PyObject *self) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_directories();
}

/**
 * sequence getter for property ConfigVariableSearchPath::directories
 */
static PyObject *Dtool_ConfigVariableSearchPath_directories_Getitem(PyObject *self, Py_ssize_t index) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_directories()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableSearchPath.directories[] index out of range");
    return NULL;
  }
  // 1-inline Filename const &ConfigVariableSearchPath::get_directory(std::size_t n) const
  Filename const *return_value = &((*(const ConfigVariableSearchPath*)local_this).get_directory(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(ConfigVariableSearchPath self, index)\n");
  }
}

static PyObject *Dtool_ConfigVariableSearchPath_directories_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_ConfigVariableSearchPath_directories_Len;
  wrap->_getitem_func = &Dtool_ConfigVariableSearchPath_directories_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(ConfigVariableSearchPath const &) = default
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description = string(), int flags = 0)
 * inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
 */
static int Dtool_Init_ConfigVariableSearchPath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(ConfigVariableSearchPath const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableSearchPath", (char **)keyword_list, &param0)) {
          ConfigVariableSearchPath const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableSearchPath(param0, param0_this, param0_manage)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 2:
    {
      // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"name", "description", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
        ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
      }
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Os#|i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          DSearchPath const *param1_this;
          DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_DSearchPath, (void **)&param1_this);
          if (param1_this != NULL) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#|i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        int param2;
        static const char *keyword_list[] = {"name", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        PyObject *param1;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        int param3 = 0;
        static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Os#|i:ConfigVariableSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
          DSearchPath const *param1_this;
          bool param1_manage = false;
          if (Dtool_ConstCoerce_DSearchPath(param1, param1_this, param1_manage)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
            if (param1_manage) {
              delete param1_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
      // No coercion possible: inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags = 0)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableSearchPath() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableSearchPath(str name)\n"
      "ConfigVariableSearchPath(str name, str description)\n"
      "ConfigVariableSearchPath(str name, const DSearchPath default_value, str description, int flags)\n"
      "ConfigVariableSearchPath(str name, str default_value, str description, int flags)\n"
      "ConfigVariableSearchPath(str name, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableSearchPath, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        if (PyArg_ParseTuple(args, "s#s#:ConfigVariableSearchPath", &param0_str, &param0_len, &param1_str, &param1_len)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3:
      case 4: {
        {
          // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
          char *param0_str = NULL;
          Py_ssize_t param0_len;
          PyObject *param1;
          char *param2_str = NULL;
          Py_ssize_t param2_len;
          int param3 = 0;
          if (PyArg_ParseTuple(args, "s#Os#|i:ConfigVariableSearchPath", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
            DSearchPath const *param1_this;
            DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_DSearchPath, (void **)&param1_this);
            if (param1_this != NULL) {
              ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
              if (return_value == NULL) {
                PyErr_NoMemory();
                return false;
              }
              if (_PyErr_OCCURRED()) {
                delete return_value;
                return false;
              } else {
                coerced = return_value;
                manage = true;
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
          char *param0_str = NULL;
          Py_ssize_t param0_len;
          char *param1_str = NULL;
          Py_ssize_t param1_len;
          char *param2_str = NULL;
          Py_ssize_t param2_len;
          int param3 = 0;
          if (PyArg_ParseTuple(args, "s#s#s#|i:ConfigVariableSearchPath", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags = 0)
          char *param0_str = NULL;
          Py_ssize_t param0_len;
          char *param1_str = NULL;
          Py_ssize_t param1_len;
          int param2;
          if (PyArg_ParseTuple(args, "s#s#i:ConfigVariableSearchPath", &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
          PyErr_Clear();
        }

        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableSearchPath(PyObject *args, ConfigVariableSearchPath *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableSearchPath, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        if (PyArg_ParseTuple(args, "s#s#:ConfigVariableSearchPath", &param0_str, &param0_len, &param1_str, &param1_len)) {
          ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
        PyErr_Clear();
        break;
      }
      case 3:
      case 4: {
        {
          // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, DSearchPath const &default_value, std::string const &description, int flags = 0)
          char *param0_str = NULL;
          Py_ssize_t param0_len;
          PyObject *param1;
          char *param2_str = NULL;
          Py_ssize_t param2_len;
          int param3 = 0;
          if (PyArg_ParseTuple(args, "s#Os#|i:ConfigVariableSearchPath", &param0_str, &param0_len, &param1, &param2_str, &param2_len, &param3)) {
            DSearchPath const *param1_this;
            DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_DSearchPath, (void **)&param1_this);
            if (param1_this != NULL) {
              ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), *param1_this, std::string(param2_str, param2_len), (int)param3);
              if (return_value == NULL) {
                PyErr_NoMemory();
                return false;
              }
              if (_PyErr_OCCURRED()) {
                delete return_value;
                return false;
              } else {
                coerced = return_value;
                manage = true;
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &default_value, std::string const &description, int flags = 0)
          char *param0_str = NULL;
          Py_ssize_t param0_len;
          char *param1_str = NULL;
          Py_ssize_t param1_len;
          char *param2_str = NULL;
          Py_ssize_t param2_len;
          int param3 = 0;
          if (PyArg_ParseTuple(args, "s#s#s#|i:ConfigVariableSearchPath", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
          PyErr_Clear();
        }

        {
          // -2 inline ConfigVariableSearchPath::ConfigVariableSearchPath(std::string const &name, std::string const &description, int flags = 0)
          char *param0_str = NULL;
          Py_ssize_t param0_len;
          char *param1_str = NULL;
          Py_ssize_t param1_len;
          int param2;
          if (PyArg_ParseTuple(args, "s#s#i:ConfigVariableSearchPath", &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
            ConfigVariableSearchPath *return_value = new ConfigVariableSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
          PyErr_Clear();
        }

        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConfigVariableSearchPath_get_directories(PyObject *self, PyObject *) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_directories();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConfigVariableSearchPath_get_directory_505(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConfigVariableSearchPath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableSearchPath) {
    printf("ConfigVariableSearchPath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableSearchPath *local_this = (ConfigVariableSearchPath *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableSearchPath) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableSearchPath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableSearchPath) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableSearchPath*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableSearchPath*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DSearchPath
 */
/**
 * Python function wrapper for:
 * void DSearchPath::operator =(DSearchPath const &copy)
 */
static PyObject *Dtool_DSearchPath_operator_478(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.assign")) {
    return NULL;
  }
  // 1-void DSearchPath::operator =(DSearchPath const &copy)
  DSearchPath const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DSearchPath(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.assign", "DSearchPath");
  }
  (*local_this).operator =(*arg_this);
  DSearchPath *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const DSearchPath self, const DSearchPath copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_operator_478_comment =
  "C++ Interface:\n"
  "assign(const DSearchPath self, const DSearchPath copy)\n";
#else
static const char *Dtool_DSearchPath_operator_478_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::clear(void)
 */
static PyObject *Dtool_DSearchPath_clear_480(PyObject *self, PyObject *) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.clear")) {
    return NULL;
  }
  // 1-void DSearchPath::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_clear_480_comment =
  "C++ Interface:\n"
  "clear(const DSearchPath self)\n";
#else
static const char *Dtool_DSearchPath_clear_480_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::append_directory(Filename const &directory)
 */
static PyObject *Dtool_DSearchPath_append_directory_481(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.append_directory")) {
    return NULL;
  }
  // 1-void DSearchPath::append_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.append_directory", "Filename");
  }
  (*local_this).append_directory(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_directory(const DSearchPath self, const Filename directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_append_directory_481_comment =
  "C++ Interface:\n"
  "append_directory(const DSearchPath self, const Filename directory)\n";
#else
static const char *Dtool_DSearchPath_append_directory_481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::prepend_directory(Filename const &directory)
 */
static PyObject *Dtool_DSearchPath_prepend_directory_482(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.prepend_directory")) {
    return NULL;
  }
  // 1-void DSearchPath::prepend_directory(Filename const &directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.prepend_directory", "Filename");
  }
  (*local_this).prepend_directory(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_directory(const DSearchPath self, const Filename directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_prepend_directory_482_comment =
  "C++ Interface:\n"
  "prepend_directory(const DSearchPath self, const Filename directory)\n";
#else
static const char *Dtool_DSearchPath_prepend_directory_482_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::append_path(DSearchPath const &path)
 * void DSearchPath::append_path(std::string const &path, std::string const &separator = string())
 */
static PyObject *Dtool_DSearchPath_append_path_483(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.append_path")) {
    return NULL;
  }
  {
    // -2 void DSearchPath::append_path(std::string const &path, std::string const &separator = string())
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"path", "separator", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:append_path", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      (*local_this).append_path(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  // No coercion possible: void DSearchPath::append_path(std::string const &path, std::string const &separator = string())
  {
    // -2 void DSearchPath::append_path(DSearchPath const &path)
    PyObject *param1;
    static const char *keyword_list[] = {"path", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:append_path", (char **)keyword_list, &param1)) {
      DSearchPath const *param1_this;
      bool param1_manage = false;
      if (Dtool_ConstCoerce_DSearchPath(param1, param1_this, param1_manage)) {
        (*local_this).append_path(*param1_this);
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_path(const DSearchPath self, str path, str separator)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_append_path_483_comment =
  "C++ Interface:\n"
  "append_path(const DSearchPath self, str path, str separator)\n";
#else
static const char *Dtool_DSearchPath_append_path_483_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::prepend_path(DSearchPath const &path)
 */
static PyObject *Dtool_DSearchPath_prepend_path_484(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath, (void **)&local_this, "DSearchPath.prepend_path")) {
    return NULL;
  }
  // 1-void DSearchPath::prepend_path(DSearchPath const &path)
  DSearchPath const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_DSearchPath(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.prepend_path", "DSearchPath");
  }
  (*local_this).prepend_path(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "prepend_path(const DSearchPath self, const DSearchPath path)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_prepend_path_484_comment =
  "C++ Interface:\n"
  "prepend_path(const DSearchPath self, const DSearchPath path)\n";
#else
static const char *Dtool_DSearchPath_prepend_path_484_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool DSearchPath::is_empty(void) const
 */
static PyObject *Dtool_DSearchPath_is_empty_485(PyObject *self, PyObject *) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool DSearchPath::is_empty(void) const
  bool return_value = (*(const DSearchPath*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_is_empty_485_comment =
  "C++ Interface:\n"
  "is_empty(DSearchPath self)\n";
#else
static const char *Dtool_DSearchPath_is_empty_485_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t DSearchPath::get_num_directories(void) const
 */
static PyObject *Dtool_DSearchPath_get_num_directories_486(PyObject *self, PyObject *) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t DSearchPath::get_num_directories(void) const
  std::size_t return_value = (*(const DSearchPath*)local_this).get_num_directories();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_get_num_directories_486_comment =
  "C++ Interface:\n"
  "get_num_directories(DSearchPath self)\n";
#else
static const char *Dtool_DSearchPath_get_num_directories_486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Filename const &DSearchPath::get_directory(std::size_t n) const
 */
static PyObject *Dtool_DSearchPath_get_directory_487(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-Filename const &DSearchPath::get_directory(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_directory", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Filename const *return_value = &((*(const DSearchPath*)local_this).get_directory((std::size_t)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(DSearchPath self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_get_directory_487_comment =
  "C++ Interface:\n"
  "get_directory(DSearchPath self, int n)\n";
#else
static const char *Dtool_DSearchPath_get_directory_487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Filename DSearchPath::find_file(Filename const &filename) const
 */
static PyObject *Dtool_DSearchPath_find_file_491(PyObject *self, PyObject *arg) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-Filename DSearchPath::find_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.find_file", "Filename");
  }
  Filename *return_value = new Filename((*(const DSearchPath*)local_this).find_file(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_file(DSearchPath self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_find_file_491_comment =
  "C++ Interface:\n"
  "find_file(DSearchPath self, const Filename filename)\n";
#else
static const char *Dtool_DSearchPath_find_file_491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DSearchPath::Results DSearchPath::find_all_files(Filename const &filename) const
 * std::size_t DSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
 */
static PyObject *Dtool_DSearchPath_find_all_files_492(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "filename");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'filename' (pos 1) not found");
      }
      // 1-inline DSearchPath::Results DSearchPath::find_all_files(Filename const &filename) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "DSearchPath.find_all_files", "Filename");
      }
      DSearchPath::Results *return_value = new DSearchPath::Results((*(const DSearchPath*)local_this).find_all_files(*arg_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath_Results, true, false);
    }
    break;
  case 2:
    {
      // 1-std::size_t DSearchPath::find_all_files(Filename const &filename, DSearchPath::Results &results) const
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"filename", "results", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:find_all_files", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "DSearchPath.find_all_files", "Filename");
        }
        DSearchPath::Results *param2_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DSearchPath_Results, 2, "DSearchPath.find_all_files", false, true);
        if (param2_this != NULL) {
          std::size_t return_value = (*(const DSearchPath*)local_this).find_all_files(*param1_this, *param2_this);
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "find_all_files() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_files(DSearchPath self, const Filename filename)\n"
      "find_all_files(DSearchPath self, const Filename filename, Results results)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_find_all_files_492_comment =
  "C++ Interface:\n"
  "find_all_files(DSearchPath self, const Filename filename)\n"
  "find_all_files(DSearchPath self, const Filename filename, Results results)\n"
  "\n"
  "/**\n"
  " * This variant of find_all_files() returns the new Results object, instead of\n"
  " * filling on in on the parameter list.  This is a little more convenient to\n"
  " * call from Python.\n"
  " */";
#else
static const char *Dtool_DSearchPath_find_all_files_492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline Filename DSearchPath::search_path(Filename const &filename, std::string const &path, std::string const &separator = string())
 */
static PyObject *Dtool_DSearchPath_search_path_493(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline Filename DSearchPath::search_path(Filename const &filename, std::string const &path, std::string const &separator = string())
  PyObject *param0;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"filename", "path", "separator", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#|s#:search_path", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2_str, &param2_len)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "DSearchPath.search_path", "Filename");
    }
    Filename *return_value = new Filename(DSearchPath::search_path(*param0_this, std::string(param1_str, param1_len), std::string(param2_str, param2_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "search_path(const Filename filename, str path, str separator)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_search_path_493_comment =
  "C++ Interface:\n"
  "search_path(const Filename filename, str path, str separator)\n"
  "\n"
  "/**\n"
  " * A quick-and-easy way to search a searchpath for a file when you don't feel\n"
  " * like building or keeping around a DSearchPath object.  This simply\n"
  " * constructs a temporary DSearchPath based on the indicated path string, and\n"
  " * searches that.\n"
  " */";
#else
static const char *Dtool_DSearchPath_search_path_493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::output(ostream &out, std::string const &separator = string()) const
 */
static PyObject *Dtool_DSearchPath_output_494(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DSearchPath::output(ostream &out, std::string const &separator = string()) const
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"out", "separator", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:output", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DSearchPath.output", false, true);
    if (param1_this != NULL) {
      (*(const DSearchPath*)local_this).output(*param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DSearchPath self, ostream out, str separator)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_output_494_comment =
  "C++ Interface:\n"
  "output(DSearchPath self, ostream out, str separator)\n";
#else
static const char *Dtool_DSearchPath_output_494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DSearchPath_write_495(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DSearchPath::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DSearchPath.write", false, true);
    if (param1_this != NULL) {
      (*(const DSearchPath*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DSearchPath self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_write_495_comment =
  "C++ Interface:\n"
  "write(DSearchPath self, ostream out, int indent_level)\n";
#else
static const char *Dtool_DSearchPath_write_495_comment = NULL;
#endif

/**
 * sequence length function for property DSearchPath::directories
 */
static Py_ssize_t Dtool_DSearchPath_directories_Len(PyObject *self) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_directories();
}

/**
 * sequence getter for property DSearchPath::directories
 */
static PyObject *Dtool_DSearchPath_directories_Getitem(PyObject *self, Py_ssize_t index) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_directories()) {
    PyErr_SetString(PyExc_IndexError, "DSearchPath.directories[] index out of range");
    return NULL;
  }
  // 1-Filename const &DSearchPath::get_directory(std::size_t n) const
  Filename const *return_value = &((*(const DSearchPath*)local_this).get_directory(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_directory(DSearchPath self, index)\n");
  }
}

static PyObject *Dtool_DSearchPath_directories_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_DSearchPath_directories_Len;
  wrap->_getitem_func = &Dtool_DSearchPath_directories_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * DSearchPath::DSearchPath(void)
 * DSearchPath::DSearchPath(DSearchPath const &copy)
 * DSearchPath::DSearchPath(Filename const &directory)
 * DSearchPath::DSearchPath(std::string const &path, std::string const &separator = string())
 */
static int Dtool_Init_DSearchPath(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DSearchPath::DSearchPath(void)
      DSearchPath *return_value = new DSearchPath();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 DSearchPath::DSearchPath(std::string const &path, std::string const &separator = string())
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        const char *param1_str = "";
        Py_ssize_t param1_len = 0;
        static const char *keyword_list[] = {"path", "separator", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:DSearchPath", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
          DSearchPath *return_value = new DSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 DSearchPath::DSearchPath(DSearchPath const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DSearchPath", (char **)keyword_list, &param0)) {
          DSearchPath const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_DSearchPath, (void **)&param0_this);
          if (param0_this != NULL) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DSearchPath::DSearchPath(Filename const &directory)
        PyObject *param0;
        static const char *keyword_list[] = {"directory", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DSearchPath", (char **)keyword_list, &param0)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: DSearchPath::DSearchPath(std::string const &path, std::string const &separator = string())
      {
        // -2 DSearchPath::DSearchPath(DSearchPath const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DSearchPath", (char **)keyword_list, &param0)) {
          DSearchPath const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_DSearchPath(param0, param0_this, param0_manage)) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 DSearchPath::DSearchPath(Filename const &directory)
        PyObject *param0;
        static const char *keyword_list[] = {"directory", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DSearchPath", (char **)keyword_list, &param0)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != NULL)) {
            DSearchPath *return_value = new DSearchPath(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DSearchPath() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DSearchPath()\n"
      "DSearchPath(str path, str separator)\n"
      "DSearchPath(const DSearchPath copy)\n"
      "DSearchPath(const Filename directory)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_DSearchPath(PyObject *args, DSearchPath const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DSearchPath, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 DSearchPath::DSearchPath(std::string const &path, std::string const &separator)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        DSearchPath *return_value = new DSearchPath(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 DSearchPath::DSearchPath(Filename const &directory)
      Filename const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
      if (arg_this != NULL) {
        DSearchPath *return_value = new DSearchPath(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DSearchPath::DSearchPath(std::string const &path, std::string const &separator)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:DSearchPath", &param0_str, &param0_len, &param1_str, &param1_len)) {
        DSearchPath *return_value = new DSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DSearchPath, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 DSearchPath::DSearchPath(std::string const &path, std::string const &separator)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        DSearchPath *return_value = new DSearchPath(std::string(param0_str, param0_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 DSearchPath::DSearchPath(Filename const &directory)
      Filename const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
      if (arg_this != NULL) {
        DSearchPath *return_value = new DSearchPath(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
    }

  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-DSearchPath::DSearchPath(std::string const &path, std::string const &separator)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "s#s#:DSearchPath", &param0_str, &param0_len, &param1_str, &param1_len)) {
        DSearchPath *return_value = new DSearchPath(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_DSearchPath_get_directories(PyObject *self, PyObject *) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_directories();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_DSearchPath_get_directory_487(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_DSearchPath(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DSearchPath) {
    printf("DSearchPath ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DSearchPath *local_this = (DSearchPath *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DSearchPath) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DSearchPath(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DSearchPath) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DSearchPath::Results
 */
/**
 * Python function wrapper for:
 * void DSearchPath::Results::operator =(DSearchPath::Results const &copy)
 */
static PyObject *Dtool_DSearchPath_Results_operator_468(PyObject *self, PyObject *arg) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath_Results, (void **)&local_this, "DSearchPath::Results.assign")) {
    return NULL;
  }
  // 1-void DSearchPath::Results::operator =(DSearchPath::Results const &copy)
  DSearchPath::Results const *arg_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DSearchPath_Results, 1, "Results.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    DSearchPath::Results *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DSearchPath_Results, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Results self, const Results copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_operator_468_comment =
  "C++ Interface:\n"
  "assign(const Results self, const Results copy)\n";
#else
static const char *Dtool_DSearchPath_Results_operator_468_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::Results::clear(void)
 */
static PyObject *Dtool_DSearchPath_Results_clear_470(PyObject *self, PyObject *) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DSearchPath_Results, (void **)&local_this, "DSearchPath::Results.clear")) {
    return NULL;
  }
  // 1-void DSearchPath::Results::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_clear_470_comment =
  "C++ Interface:\n"
  "clear(const Results self)\n";
#else
static const char *Dtool_DSearchPath_Results_clear_470_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t DSearchPath::Results::get_num_files(void) const
 */
static PyObject *Dtool_DSearchPath_Results_get_num_files_471(PyObject *self, PyObject *) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t DSearchPath::Results::get_num_files(void) const
  std::size_t return_value = (*(const DSearchPath::Results*)local_this).get_num_files();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_get_num_files_471_comment =
  "C++ Interface:\n"
  "get_num_files(Results self)\n";
#else
static const char *Dtool_DSearchPath_Results_get_num_files_471_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Filename const &DSearchPath::Results::get_file(std::size_t n) const
 */
static PyObject *Dtool_DSearchPath_Results_get_file_472(PyObject *self, PyObject *arg) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }
  // 1-Filename const &DSearchPath::Results::get_file(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_file", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Filename const *return_value = &((*(const DSearchPath::Results*)local_this).get_file((std::size_t)param1));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(Results self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_get_file_472_comment =
  "C++ Interface:\n"
  "get_file(Results self, int n)\n";
#else
static const char *Dtool_DSearchPath_Results_get_file_472_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::Results::output(ostream &out) const
 */
static PyObject *Dtool_DSearchPath_Results_output_475(PyObject *self, PyObject *arg) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DSearchPath::Results::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Results.output", false, true);
  if (arg_this != NULL) {
    (*(const DSearchPath::Results*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Results self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_output_475_comment =
  "C++ Interface:\n"
  "output(Results self, ostream out)\n";
#else
static const char *Dtool_DSearchPath_Results_output_475_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DSearchPath::Results::write(ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DSearchPath_Results_write_476(PyObject *self, PyObject *args, PyObject *kwds) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DSearchPath::Results::write(ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Results.write", false, true);
    if (param1_this != NULL) {
      (*(const DSearchPath::Results*)local_this).write(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Results self, ostream out, int indent_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DSearchPath_Results_write_476_comment =
  "C++ Interface:\n"
  "write(Results self, ostream out, int indent_level)\n";
#else
static const char *Dtool_DSearchPath_Results_write_476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * DSearchPath::Results::Results(void)
 * DSearchPath::Results::Results(DSearchPath::Results const &copy)
 */
static int Dtool_Init_DSearchPath_Results(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-DSearchPath::Results::Results(void)
      DSearchPath::Results *return_value = new DSearchPath::Results();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath_Results, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-DSearchPath::Results::Results(DSearchPath::Results const &copy)
      DSearchPath::Results const *arg_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DSearchPath_Results, 0, "Results.Results", true, true);
      if (arg_this != NULL) {
        DSearchPath::Results *return_value = new DSearchPath::Results(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DSearchPath_Results, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Results() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Results()\n"
      "Results(const Results copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DSearchPath_Results(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DSearchPath_Results) {
    printf("DSearchPath_Results ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DSearchPath::Results *local_this = (DSearchPath::Results *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DSearchPath_Results) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DSearchPath_Results(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DSearchPath_Results) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ConfigVariableString
 */
/**
 * Python function wrapper for:
 * inline void ConfigVariableString::operator =(std::string const &value)
 */
static PyObject *Dtool_ConfigVariableString_operator_514(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.assign")) {
    return NULL;
  }
  // 1-inline void ConfigVariableString::operator =(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).operator =(std::string(param1_str, param1_len));
    ConfigVariableString *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableString, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ConfigVariableString self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_operator_514_comment =
  "C++ Interface:\n"
  "assign(const ConfigVariableString self, str value)\n";
#else
static const char *Dtool_ConfigVariableString_operator_514_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline char const *ConfigVariableString::c_str(void) const
 */
static PyObject *Dtool_ConfigVariableString_c_str_516(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char const *ConfigVariableString::c_str(void) const
  char const *return_value = (*(const ConfigVariableString*)local_this).c_str();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_c_str_516_comment =
  "C++ Interface:\n"
  "c_str(ConfigVariableString self)\n"
  "\n"
  "// These methods help the ConfigVariableString act like a C++ string object.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_c_str_516_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ConfigVariableString::empty(void) const
 */
static PyObject *Dtool_ConfigVariableString_empty_517(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ConfigVariableString::empty(void) const
  bool return_value = (*(const ConfigVariableString*)local_this).empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_empty_517_comment =
  "C++ Interface:\n"
  "empty(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_empty_517_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ConfigVariableString::length(void) const
 */
static PyObject *Dtool_ConfigVariableString_length_518(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t ConfigVariableString::length(void) const
  std::size_t return_value = (*(const ConfigVariableString*)local_this).length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_length_518_comment =
  "C++ Interface:\n"
  "length(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_length_518_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableString::set_value(std::string const &value)
 */
static PyObject *Dtool_ConfigVariableString_set_value_523(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.set_value")) {
    return NULL;
  }
  // 1-inline void ConfigVariableString::set_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_value(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableString self, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_set_value_523_comment =
  "C++ Interface:\n"
  "set_value(const ConfigVariableString self, str value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's local value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_set_value_523_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ConfigVariableString::get_value(void) const
 */
static PyObject *Dtool_ConfigVariableString_get_value_524(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &ConfigVariableString::get_value(void) const
  std::string const &return_value = (*(const ConfigVariableString*)local_this).get_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_get_value_524_comment =
  "C++ Interface:\n"
  "get_value(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_get_value_524_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableString::get_default_value(void) const
 */
static PyObject *Dtool_ConfigVariableString_get_default_value_525(PyObject *self, PyObject *) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableString::get_default_value(void) const
  std::string return_value = (*(const ConfigVariableString*)local_this).get_default_value();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_get_default_value_525_comment =
  "C++ Interface:\n"
  "get_default_value(ConfigVariableString self)\n"
  "\n"
  "/**\n"
  " * Returns the variable's default value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_get_default_value_525_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string ConfigVariableString::get_word(std::size_t n) const
 */
static PyObject *Dtool_ConfigVariableString_get_word_528(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string ConfigVariableString::get_word(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_word", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const ConfigVariableString*)local_this).get_word((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(ConfigVariableString self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_get_word_528_comment =
  "C++ Interface:\n"
  "get_word(ConfigVariableString self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the variable's nth value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_get_word_528_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ConfigVariableString::set_word(std::size_t n, std::string const &value)
 */
static PyObject *Dtool_ConfigVariableString_set_word_529(PyObject *self, PyObject *args, PyObject *kwds) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.set_word")) {
    return NULL;
  }
  // 1-inline void ConfigVariableString::set_word(std::size_t n, std::string const &value)
  Py_ssize_t param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ns#:set_word", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_word((std::size_t)param1, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const ConfigVariableString self, int n, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ConfigVariableString_set_word_529_comment =
  "C++ Interface:\n"
  "set_word(const ConfigVariableString self, int n, str value)\n"
  "\n"
  "/**\n"
  " * Reassigns the variable's nth value.  This makes a local copy of the\n"
  " * variable's overall value.\n"
  " */";
#else
static const char *Dtool_ConfigVariableString_set_word_529_comment = NULL;
#endif

static PyObject *Dtool_ConfigVariableString_value_Getter(PyObject *self, void *) {
  const ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigVariableString::get_value(void) const
  std::string const &return_value = (*(const ConfigVariableString*)local_this).get_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ConfigVariableString_value_Setter(PyObject *self, PyObject *arg, void *) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConfigVariableString, (void **)&local_this, "ConfigVariableString.value")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ConfigVariableString::set_value(std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_value(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ConfigVariableString self, str value)\n");
  }
  return -1;
}

static PyObject *Dtool_ConfigVariableString_default_value_Getter(PyObject *self, void *) {
  const ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string ConfigVariableString::get_default_value(void) const
  std::string return_value = (*(const ConfigVariableString*)local_this).get_default_value();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ConfigVariableString::ConfigVariableString(ConfigVariableString const &) = default
 * inline ConfigVariableString::ConfigVariableString(std::string const &name)
 * inline ConfigVariableString::ConfigVariableString(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
 */
static int Dtool_Init_ConfigVariableString(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ConfigVariableString::ConfigVariableString(ConfigVariableString const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableString", (char **)keyword_list, &param0)) {
          ConfigVariableString const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_ConfigVariableString, (void **)&param0_this);
          if (param0_this != NULL) {
            ConfigVariableString *return_value = new ConfigVariableString(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableString::ConfigVariableString(std::string const &name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ConfigVariableString", (char **)keyword_list, &param0_str, &param0_len)) {
          ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ConfigVariableString::ConfigVariableString(ConfigVariableString const &) = default
        PyObject *param0;
        static const char *keyword_list[] = {"param0", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ConfigVariableString", (char **)keyword_list, &param0)) {
          ConfigVariableString const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ConfigVariableString(param0, param0_this, param0_manage)) {
            ConfigVariableString *return_value = new ConfigVariableString(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline ConfigVariableString::ConfigVariableString(std::string const &name)
    }
    break;
  case 2:
  case 3:
  case 4:
    {
      // 1-inline ConfigVariableString::ConfigVariableString(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      static const char *keyword_list[] = {"name", "default_value", "description", "flags", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#i:ConfigVariableString", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
        ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConfigVariableString, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ConfigVariableString() takes 1, 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConfigVariableString(const ConfigVariableString param0)\n"
      "ConfigVariableString(str name)\n"
      "ConfigVariableString(str name, str default_value, str description, int flags)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ConfigVariableString(PyObject *args, ConfigVariableString const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableString, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableString::ConfigVariableString(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-inline ConfigVariableString::ConfigVariableString(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableString", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
        ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ConfigVariableString(PyObject *args, ConfigVariableString *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ConfigVariableString, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConfigVariableString::ConfigVariableString(std::string const &name)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 4) {
      // 1-inline ConfigVariableString::ConfigVariableString(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      const char *param2_str = "";
      Py_ssize_t param2_len = 0;
      int param3 = 0;
      if (PyArg_ParseTuple(args, "s#s#|s#i:ConfigVariableString", &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
        ConfigVariableString *return_value = new ConfigVariableString(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ConfigVariableString(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ConfigVariableString) {
    printf("ConfigVariableString ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ConfigVariableString *local_this = (ConfigVariableString *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ConfigVariableString) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *)(ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariable) {
    return (ConfigVariable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigVariableBase) {
    return (ConfigVariableBase *)(ConfigVariable *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ConfigVariableString(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ConfigVariableString) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (ConfigVariableString*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariable) {
    ConfigVariable* other_this = (ConfigVariable*)from_this;
    return (ConfigVariableString*)other_this;
  }
  if (from_type == Dtool_Ptr_ConfigVariableBase) {
    ConfigVariableBase* other_this = (ConfigVariableBase*)from_this;
    return (ConfigVariableString*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DConfig
 */
/**
 * Python function wrapper for:
 * static inline bool DConfig::GetBool(std::string const &sym, bool def = false)
 */
static PyObject *Dtool_DConfig_GetBool_532(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline bool DConfig::GetBool(std::string const &sym, bool def = false)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  PyObject *param1 = Py_False;
  static const char *keyword_list[] = {"sym", "def", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|O:GetBool", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    bool return_value = DConfig::GetBool(std::string(param0_str, param0_len), (PyObject_IsTrue(param1) != 0));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetBool(str sym, bool def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DConfig_GetBool_532_comment =
  "C++ Interface:\n"
  "GetBool(str sym, bool def)\n";
#else
static const char *Dtool_DConfig_GetBool_532_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int DConfig::GetInt(std::string const &sym, int def = 0)
 */
static PyObject *Dtool_DConfig_GetInt_533(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline int DConfig::GetInt(std::string const &sym, int def = 0)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  int param1 = 0;
  static const char *keyword_list[] = {"sym", "def", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|i:GetInt", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    int return_value = DConfig::GetInt(std::string(param0_str, param0_len), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetInt(str sym, int def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DConfig_GetInt_533_comment =
  "C++ Interface:\n"
  "GetInt(str sym, int def)\n";
#else
static const char *Dtool_DConfig_GetInt_533_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline float DConfig::GetFloat(std::string const &sym, float def = 0.0)
 */
static PyObject *Dtool_DConfig_GetFloat_534(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline float DConfig::GetFloat(std::string const &sym, float def = 0.0)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  float param1 = 0.0;
  static const char *keyword_list[] = {"sym", "def", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|f:GetFloat", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    float return_value = DConfig::GetFloat(std::string(param0_str, param0_len), (float)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetFloat(str sym, float def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DConfig_GetFloat_534_comment =
  "C++ Interface:\n"
  "GetFloat(str sym, float def)\n";
#else
static const char *Dtool_DConfig_GetFloat_534_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline double DConfig::GetDouble(std::string const &sym, double def = 0.0)
 */
static PyObject *Dtool_DConfig_GetDouble_535(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline double DConfig::GetDouble(std::string const &sym, double def = 0.0)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  double param1 = 0.0;
  static const char *keyword_list[] = {"sym", "def", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|d:GetDouble", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    double return_value = DConfig::GetDouble(std::string(param0_str, param0_len), (double)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetDouble(str sym, double def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DConfig_GetDouble_535_comment =
  "C++ Interface:\n"
  "GetDouble(str sym, double def)\n";
#else
static const char *Dtool_DConfig_GetDouble_535_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string DConfig::GetString(std::string const &sym, std::string const &def = "")
 */
static PyObject *Dtool_DConfig_GetString_536(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline std::string DConfig::GetString(std::string const &sym, std::string const &def = "")
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  const char *param1_str = "";
  Py_ssize_t param1_len = 0;
  static const char *keyword_list[] = {"sym", "def", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:GetString", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    std::string return_value = DConfig::GetString(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "GetString(str sym, str def)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DConfig_GetString_536_comment =
  "C++ Interface:\n"
  "GetString(str sym, str def)\n";
#else
static const char *Dtool_DConfig_GetString_536_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DConfig::DConfig(void) = default
 * inline DConfig::DConfig(DConfig const &) = default
 */
static int Dtool_Init_DConfig(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DConfig::DConfig(void) = default
      DConfig *return_value = new DConfig();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DConfig, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline DConfig::DConfig(DConfig const &) = default
      DConfig const *arg_this = (DConfig *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DConfig, 0, "DConfig.DConfig", true, true);
      if (arg_this != NULL) {
        DConfig *return_value = new DConfig(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DConfig, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DConfig() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DConfig()\n"
      "DConfig(const DConfig param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DConfig(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DConfig) {
    printf("DConfig ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DConfig *local_this = (DConfig *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DConfig) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DConfig(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DConfig) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ExecutionEnvironment
 */
/**
 * Python function wrapper for:
 * static inline bool ExecutionEnvironment::has_environment_variable(std::string const &var)
 */
static PyObject *Dtool_ExecutionEnvironment_has_environment_variable_540(PyObject *, PyObject *arg) {
  // 1-static inline bool ExecutionEnvironment::has_environment_variable(std::string const &var)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    bool return_value = ExecutionEnvironment::has_environment_variable(std::string(param0_str, param0_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_environment_variable(str var)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_has_environment_variable_540_comment =
  "C++ Interface:\n"
  "has_environment_variable(str var)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated environment variable is defined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_has_environment_variable_540_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_environment_variable(std::string const &var)
 */
static PyObject *Dtool_ExecutionEnvironment_get_environment_variable_541(PyObject *, PyObject *arg) {
  // 1-static inline std::string ExecutionEnvironment::get_environment_variable(std::string const &var)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = ExecutionEnvironment::get_environment_variable(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_environment_variable(str var)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_environment_variable_541_comment =
  "C++ Interface:\n"
  "get_environment_variable(str var)\n"
  "\n"
  "/**\n"
  " * Returns the definition of the indicated environment variable, or the empty\n"
  " * string if the variable is undefined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_environment_variable_541_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::set_environment_variable(std::string const &var, std::string const &value)
 */
static PyObject *Dtool_ExecutionEnvironment_set_environment_variable_542(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void ExecutionEnvironment::set_environment_variable(std::string const &var, std::string const &value)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"var", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_environment_variable", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    ExecutionEnvironment::set_environment_variable(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_environment_variable(str var, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_set_environment_variable_542_comment =
  "C++ Interface:\n"
  "set_environment_variable(str var, str value)\n"
  "\n"
  "/**\n"
  " * Changes the definition of the indicated environment variable.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_set_environment_variable_542_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::shadow_environment_variable(std::string const &var, std::string const &value)
 */
static PyObject *Dtool_ExecutionEnvironment_shadow_environment_variable_543(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void ExecutionEnvironment::shadow_environment_variable(std::string const &var, std::string const &value)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"var", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:shadow_environment_variable", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    ExecutionEnvironment::shadow_environment_variable(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "shadow_environment_variable(str var, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_shadow_environment_variable_543_comment =
  "C++ Interface:\n"
  "shadow_environment_variable(str var, str value)\n"
  "\n"
  "/**\n"
  " * Changes the apparent definition of the indicated environment variable by\n"
  " * masking it within this class with a new value.  This does not change the\n"
  " * actual environment variable, but future calls to get_environment_variable()\n"
  " * will return this new value.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_shadow_environment_variable_543_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::clear_shadow(std::string const &var)
 */
static PyObject *Dtool_ExecutionEnvironment_clear_shadow_544(PyObject *, PyObject *arg) {
  // 1-static inline void ExecutionEnvironment::clear_shadow(std::string const &var)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ExecutionEnvironment::clear_shadow(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_shadow(str var)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_clear_shadow_544_comment =
  "C++ Interface:\n"
  "clear_shadow(str var)\n"
  "\n"
  "/**\n"
  " * Removes a value set by a previous call to shadow_environment_variable(),\n"
  " * and lets the actual value of the variable show again.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_clear_shadow_544_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string ExecutionEnvironment::expand_string(std::string const &str)
 */
static PyObject *Dtool_ExecutionEnvironment_expand_string_545(PyObject *, PyObject *arg) {
  // 1-static std::string ExecutionEnvironment::expand_string(std::string const &str)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    std::string return_value = ExecutionEnvironment::expand_string(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "expand_string(str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_expand_string_545_comment =
  "C++ Interface:\n"
  "expand_string(str str)\n";
#else
static const char *Dtool_ExecutionEnvironment_expand_string_545_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t ExecutionEnvironment::get_num_args(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_num_args_546(PyObject *, PyObject *) {
  // 1-static inline std::size_t ExecutionEnvironment::get_num_args(void)
  std::size_t return_value = ExecutionEnvironment::get_num_args();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_num_args_546_comment =
  "C++ Interface:\n"
  "get_num_args()\n"
  "\n"
  "/**\n"
  " * Returns the number of command-line arguments available, not counting arg 0,\n"
  " * the binary name.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_num_args_546_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_arg(std::size_t n)
 */
static PyObject *Dtool_ExecutionEnvironment_get_arg_547(PyObject *, PyObject *arg) {
  // 1-static inline std::string ExecutionEnvironment::get_arg(std::size_t n)
  Py_ssize_t param0;
  if (PyArg_Parse(arg, "n:get_arg", &param0)) {
#ifndef NDEBUG
    if (param0 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param0);
    }
#endif
    std::string return_value = ExecutionEnvironment::get_arg((std::size_t)param0);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_arg(int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_arg_547_comment =
  "C++ Interface:\n"
  "get_arg(int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth command-line argument.  The index n must be in the range [0\n"
  " * .. get_num_args()).  The first parameter, n == 0, is the first actual\n"
  " * parameter, not the binary name.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_arg_547_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_binary_name(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_binary_name_548(PyObject *, PyObject *) {
  // 1-static inline std::string ExecutionEnvironment::get_binary_name(void)
  std::string return_value = ExecutionEnvironment::get_binary_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_binary_name_548_comment =
  "C++ Interface:\n"
  "get_binary_name()\n"
  "\n"
  "/**\n"
  " * Returns the name of the binary executable that started this program, if it\n"
  " * can be determined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_binary_name_548_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string ExecutionEnvironment::get_dtool_name(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_dtool_name_549(PyObject *, PyObject *) {
  // 1-static inline std::string ExecutionEnvironment::get_dtool_name(void)
  std::string return_value = ExecutionEnvironment::get_dtool_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_dtool_name_549_comment =
  "C++ Interface:\n"
  "get_dtool_name()\n"
  "\n"
  "/**\n"
  " * Returns the name of the libdtool DLL that is used in this program, if it\n"
  " * can be determined.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_get_dtool_name_549_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::set_binary_name(std::string const &name)
 */
static PyObject *Dtool_ExecutionEnvironment_set_binary_name_550(PyObject *, PyObject *arg) {
  // 1-static inline void ExecutionEnvironment::set_binary_name(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ExecutionEnvironment::set_binary_name(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_binary_name(str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_set_binary_name_550_comment =
  "C++ Interface:\n"
  "set_binary_name(str name)\n"
  "\n"
  "/**\n"
  " * Do not use.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_set_binary_name_550_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void ExecutionEnvironment::set_dtool_name(std::string const &name)
 */
static PyObject *Dtool_ExecutionEnvironment_set_dtool_name_551(PyObject *, PyObject *arg) {
  // 1-static inline void ExecutionEnvironment::set_dtool_name(std::string const &name)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    ExecutionEnvironment::set_dtool_name(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dtool_name(str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_set_dtool_name_551_comment =
  "C++ Interface:\n"
  "set_dtool_name(str name)\n"
  "\n"
  "/**\n"
  " * Do not use.\n"
  " */";
#else
static const char *Dtool_ExecutionEnvironment_set_dtool_name_551_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Filename ExecutionEnvironment::get_cwd(void)
 */
static PyObject *Dtool_ExecutionEnvironment_get_cwd_552(PyObject *, PyObject *) {
  // 1-static Filename ExecutionEnvironment::get_cwd(void)
  Filename *return_value = new Filename(ExecutionEnvironment::get_cwd());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ExecutionEnvironment_get_cwd_552_comment =
  "C++ Interface:\n"
  "get_cwd()\n";
#else
static const char *Dtool_ExecutionEnvironment_get_cwd_552_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ExecutionEnvironment::ExecutionEnvironment(ExecutionEnvironment const &) = default
 */
static int Dtool_Init_ExecutionEnvironment(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ExecutionEnvironment() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline ExecutionEnvironment::ExecutionEnvironment(ExecutionEnvironment const &) = default
  ExecutionEnvironment const *arg_this = (ExecutionEnvironment *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ExecutionEnvironment, 0, "ExecutionEnvironment.ExecutionEnvironment", true, true);
  if (arg_this != NULL) {
    ExecutionEnvironment *return_value = new ExecutionEnvironment(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ExecutionEnvironment, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ExecutionEnvironment(const ExecutionEnvironment param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ExecutionEnvironment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ExecutionEnvironment) {
    printf("ExecutionEnvironment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ExecutionEnvironment *local_this = (ExecutionEnvironment *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ExecutionEnvironment) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ExecutionEnvironment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ExecutionEnvironment) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FileStream
 */
/**
 * Python function wrapper for:
 * inline void FileStream::open(char const *filename, ios_base::openmode mode = ::ios_base::in)
 */
static PyObject *Dtool_FileStream_open_589(PyObject *self, PyObject *args, PyObject *kwds) {
  FileStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FileStream, (void **)&local_this, "FileStream.open")) {
    return NULL;
  }
  // 1-inline void FileStream::open(char const *filename, ios_base::openmode mode = ::ios_base::in)
  char const *param1;
  int param2 = ios_base::in;
  static const char *keyword_list[] = {"filename", "mode", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:open", (char **)keyword_list, &param1, &param2)) {
    (*local_this).open((char const *)param1, (ios_base::openmode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const FileStream self, str filename, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_FileStream_open_589_comment =
  "C++ Interface:\n"
  "open(const FileStream self, str filename, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FileStream_open_589_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void FileStream::close(void)
 */
static PyObject *Dtool_FileStream_close_590(PyObject *self, PyObject *) {
  FileStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FileStream, (void **)&local_this, "FileStream.close")) {
    return NULL;
  }
  // 1-inline void FileStream::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FileStream_close_590_comment =
  "C++ Interface:\n"
  "close(const FileStream self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FileStream_close_590_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline FileStream::FileStream(void)
 * inline FileStream::FileStream(char const *filename, ios_base::openmode mode = ::ios_base::in)
 */
static int Dtool_Init_FileStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline FileStream::FileStream(void)
      FileStream *return_value = new FileStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileStream, true, false);
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode = ::ios_base::in)
      char const *param0;
      int param1 = ios_base::in;
      static const char *keyword_list[] = {"filename", "mode", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:FileStream", (char **)keyword_list, &param0, &param1)) {
        FileStream *return_value = new FileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "FileStream() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FileStream()\n"
      "FileStream(str filename, int mode)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FileStream(PyObject *args, FileStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FileStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode)
    char const *param0;
    if (PyArg_Parse(arg, "z:FileStream", &param0)) {
      FileStream *return_value = new FileStream((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:FileStream", &param0, &param1)) {
        FileStream *return_value = new FileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_FileStream(PyObject *args, FileStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FileStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode)
    char const *param0;
    if (PyArg_Parse(arg, "z:FileStream", &param0)) {
      FileStream *return_value = new FileStream((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline FileStream::FileStream(char const *filename, ios_base::openmode mode)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:FileStream", &param0, &param1)) {
        FileStream *return_value = new FileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_FileStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FileStream) {
    printf("FileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FileStream *local_this = (FileStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FileStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_iostream) {
    return (iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *)(iostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FileStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FileStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_iostream) {
    iostream* other_this = (iostream*)from_this;
    return (FileStream*)other_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (FileStream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (FileStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class iostream
 */
/**
 * Python function wrapper for:
 * void iostream::flush(void)
 */
static PyObject *Dtool_iostream_flush_585(PyObject *self, PyObject *) {
  iostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_iostream, (void **)&local_this, "iostream.flush")) {
    return NULL;
  }
  // 1-void iostream::flush(void)
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_iostream_flush_585_comment =
  "C++ Interface:\n"
  "flush(const iostream self)\n";
#else
static const char *Dtool_iostream_flush_585_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * istream *iostream::upcast_to_istream(void)
 */
static PyObject *Dtool_iostream_upcast_to_istream_574(PyObject *self, PyObject *) {
  iostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_iostream, (void **)&local_this, "iostream.upcast_to_istream")) {
    return NULL;
  }
  // 1-istream *iostream::upcast_to_istream(void)
  istream *return_value = (istream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_iostream_upcast_to_istream_574_comment =
  "C++ Interface:\n"
  "upcast_to_istream(const iostream self)\n"
  "\n"
  "upcast from iostream to istream";
#else
static const char *Dtool_iostream_upcast_to_istream_574_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ostream *iostream::upcast_to_ostream(void)
 */
static PyObject *Dtool_iostream_upcast_to_ostream_583(PyObject *self, PyObject *) {
  iostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_iostream, (void **)&local_this, "iostream.upcast_to_ostream")) {
    return NULL;
  }
  // 1-ostream *iostream::upcast_to_ostream(void)
  ostream *return_value = (ostream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_iostream_upcast_to_ostream_583_comment =
  "C++ Interface:\n"
  "upcast_to_ostream(const iostream self)\n"
  "\n"
  "upcast from iostream to ostream";
#else
static const char *Dtool_iostream_upcast_to_ostream_583_comment = NULL;
#endif

static int Dtool_Init_iostream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_iostream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_iostream) {
    printf("iostream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  iostream *local_this = (iostream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_iostream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_iostream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_iostream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (iostream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (iostream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class istream
 */
/**
 * Python function wrapper for:
 * int istream::get(void)
 */
static PyObject *Dtool_istream_get_570(PyObject *self, PyObject *) {
  istream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_istream, (void **)&local_this, "istream.get")) {
    return NULL;
  }
  // 1-int istream::get(void)
  int return_value = (*local_this).get();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_istream_get_570_comment =
  "C++ Interface:\n"
  "get(const istream self)\n";
#else
static const char *Dtool_istream_get_570_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * streamoff istream::tellg(void)
 */
static PyObject *Dtool_istream_tellg_571(PyObject *self, PyObject *) {
  istream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_istream, (void **)&local_this, "istream.tellg")) {
    return NULL;
  }
  // 1-streamoff istream::tellg(void)
  streamoff return_value = (*local_this).tellg();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_istream_tellg_571_comment =
  "C++ Interface:\n"
  "tellg(const istream self)\n";
#else
static const char *Dtool_istream_tellg_571_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void istream::seekg(streamoff pos)
 * void istream::seekg(streamoff off, ios_base::seekdir dir)
 */
static PyObject *Dtool_istream_seekg_572(PyObject *self, PyObject *args, PyObject *kwds) {
  istream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_istream, (void **)&local_this, "istream.seekg")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-void istream::seekg(streamoff pos)
      if (PyLongOrInt_Check(arg)) {
        (*local_this).seekg(PyLongOrInt_AS_LONG(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void istream::seekg(streamoff off, ios_base::seekdir dir)
      long param1;
      int param2;
      static const char *keyword_list[] = {"off", "dir", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "li:seekg", (char **)keyword_list, &param1, &param2)) {
        (*local_this).seekg((streamoff)param1, (ios_base::seekdir)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "seekg() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seekg(const istream self, int pos)\n"
      "seekg(const istream self, int off, int dir)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_istream_seekg_572_comment =
  "C++ Interface:\n"
  "seekg(const istream self, int pos)\n"
  "seekg(const istream self, int off, int dir)\n";
#else
static const char *Dtool_istream_seekg_572_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ios *istream::upcast_to_ios(void)
 */
static PyObject *Dtool_istream_upcast_to_ios_569(PyObject *self, PyObject *) {
  istream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_istream, (void **)&local_this, "istream.upcast_to_ios")) {
    return NULL;
  }
  // 1-ios *istream::upcast_to_ios(void)
  ios *return_value = (ios *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ios, false, false);
}

#ifndef NDEBUG
static const char *Dtool_istream_upcast_to_ios_569_comment =
  "C++ Interface:\n"
  "upcast_to_ios(const istream self)\n"
  "\n"
  "upcast from istream to ios";
#else
static const char *Dtool_istream_upcast_to_ios_569_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * iostream *istream::downcast_to_iostream(void)
 */
static PyObject *Dtool_istream_downcast_to_iostream_575(PyObject *self, PyObject *) {
  istream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_istream, (void **)&local_this, "istream.downcast_to_iostream")) {
    return NULL;
  }
  // 1-iostream *istream::downcast_to_iostream(void)
  iostream *return_value = (iostream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_istream_downcast_to_iostream_575_comment =
  "C++ Interface:\n"
  "downcast_to_iostream(const istream self)\n"
  "\n"
  "downcast from istream to iostream";
#else
static const char *Dtool_istream_downcast_to_iostream_575_comment = NULL;
#endif

static int Dtool_Init_istream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_istream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_istream) {
    printf("istream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  istream *local_this = (istream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_istream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_istream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_istream) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ios
 */
/**
 * Python function wrapper for:
 * bool ios::good(void) const
 */
static PyObject *Dtool_ios_good_563(PyObject *self, PyObject *) {
  ios *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ios, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ios::good(void) const
  bool return_value = (*(const ios*)local_this).good();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ios_good_563_comment =
  "C++ Interface:\n"
  "good(ios self)\n";
#else
static const char *Dtool_ios_good_563_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ios::eof(void) const
 */
static PyObject *Dtool_ios_eof_564(PyObject *self, PyObject *) {
  ios *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ios, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ios::eof(void) const
  bool return_value = (*(const ios*)local_this).eof();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ios_eof_564_comment =
  "C++ Interface:\n"
  "eof(ios self)\n";
#else
static const char *Dtool_ios_eof_564_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ios::fail(void) const
 */
static PyObject *Dtool_ios_fail_565(PyObject *self, PyObject *) {
  ios *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ios, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ios::fail(void) const
  bool return_value = (*(const ios*)local_this).fail();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ios_fail_565_comment =
  "C++ Interface:\n"
  "fail(ios self)\n";
#else
static const char *Dtool_ios_fail_565_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool ios::bad(void) const
 */
static PyObject *Dtool_ios_bad_566(PyObject *self, PyObject *) {
  ios *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ios, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool ios::bad(void) const
  bool return_value = (*(const ios*)local_this).bad();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ios_bad_566_comment =
  "C++ Interface:\n"
  "bad(ios self)\n";
#else
static const char *Dtool_ios_bad_566_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ios::clear(void)
 */
static PyObject *Dtool_ios_clear_567(PyObject *self, PyObject *) {
  ios *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ios, (void **)&local_this, "ios.clear")) {
    return NULL;
  }
  // 1-void ios::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ios_clear_567_comment =
  "C++ Interface:\n"
  "clear(const ios self)\n";
#else
static const char *Dtool_ios_clear_567_comment = NULL;
#endif

static int Dtool_Init_ios(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ios(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ios) {
    printf("ios ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ios *local_this = (ios *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ios) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ios(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ios) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ios_base) {
    ios_base* other_this = (ios_base*)from_this;
    return (ios*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ios_base
 */
static int Dtool_Init_ios_base(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ios_base(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ios_base) {
    printf("ios_base ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ios_base *local_this = (ios_base *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ios_base) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ios_base(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ios_base) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ostream
 */
/**
 * Python function wrapper for:
 * void ostream::put(char c)
 */
static PyObject *Dtool_ostream_put_578(PyObject *self, PyObject *arg) {
  ostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ostream, (void **)&local_this, "ostream.put")) {
    return NULL;
  }
  // 1-void ostream::put(char c)
  char param1;
  if (PyArg_Parse(arg, "c:put", &param1)) {
    (*local_this).put((char) param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put(const ostream self, char c)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ostream_put_578_comment =
  "C++ Interface:\n"
  "put(const ostream self, char c)\n";
#else
static const char *Dtool_ostream_put_578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ostream::flush(void)
 */
static PyObject *Dtool_ostream_flush_579(PyObject *self, PyObject *) {
  ostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ostream, (void **)&local_this, "ostream.flush")) {
    return NULL;
  }
  // 1-void ostream::flush(void)
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ostream_flush_579_comment =
  "C++ Interface:\n"
  "flush(const ostream self)\n";
#else
static const char *Dtool_ostream_flush_579_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * streamoff ostream::tellp(void)
 */
static PyObject *Dtool_ostream_tellp_580(PyObject *self, PyObject *) {
  ostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ostream, (void **)&local_this, "ostream.tellp")) {
    return NULL;
  }
  // 1-streamoff ostream::tellp(void)
  streamoff return_value = (*local_this).tellp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ostream_tellp_580_comment =
  "C++ Interface:\n"
  "tellp(const ostream self)\n";
#else
static const char *Dtool_ostream_tellp_580_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ostream::seekp(streamoff pos)
 * void ostream::seekp(streamoff off, ios_base::seekdir dir)
 */
static PyObject *Dtool_ostream_seekp_581(PyObject *self, PyObject *args, PyObject *kwds) {
  ostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ostream, (void **)&local_this, "ostream.seekp")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "pos");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'pos' (pos 1) not found");
      }
      // 1-void ostream::seekp(streamoff pos)
      if (PyLongOrInt_Check(arg)) {
        (*local_this).seekp(PyLongOrInt_AS_LONG(arg));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-void ostream::seekp(streamoff off, ios_base::seekdir dir)
      long param1;
      int param2;
      static const char *keyword_list[] = {"off", "dir", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "li:seekp", (char **)keyword_list, &param1, &param2)) {
        (*local_this).seekp((streamoff)param1, (ios_base::seekdir)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "seekp() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seekp(const ostream self, int pos)\n"
      "seekp(const ostream self, int off, int dir)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ostream_seekp_581_comment =
  "C++ Interface:\n"
  "seekp(const ostream self, int pos)\n"
  "seekp(const ostream self, int off, int dir)\n";
#else
static const char *Dtool_ostream_seekp_581_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ios *ostream::upcast_to_ios(void)
 */
static PyObject *Dtool_ostream_upcast_to_ios_577(PyObject *self, PyObject *) {
  ostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ostream, (void **)&local_this, "ostream.upcast_to_ios")) {
    return NULL;
  }
  // 1-ios *ostream::upcast_to_ios(void)
  ios *return_value = (ios *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ios, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ostream_upcast_to_ios_577_comment =
  "C++ Interface:\n"
  "upcast_to_ios(const ostream self)\n"
  "\n"
  "upcast from ostream to ios";
#else
static const char *Dtool_ostream_upcast_to_ios_577_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * iostream *ostream::downcast_to_iostream(void)
 */
static PyObject *Dtool_ostream_downcast_to_iostream_584(PyObject *self, PyObject *) {
  ostream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ostream, (void **)&local_this, "ostream.downcast_to_iostream")) {
    return NULL;
  }
  // 1-iostream *ostream::downcast_to_iostream(void)
  iostream *return_value = (iostream *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ostream_downcast_to_iostream_584_comment =
  "C++ Interface:\n"
  "downcast_to_iostream(const ostream self)\n"
  "\n"
  "downcast from ostream to iostream";
#else
static const char *Dtool_ostream_downcast_to_iostream_584_comment = NULL;
#endif

static int Dtool_Init_ostream(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ostream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ostream) {
    printf("ostream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ostream *local_this = (ostream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ostream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ostream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ostream) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class GlobPattern
 */
/**
 * Python function wrapper for:
 * inline void GlobPattern::operator =(GlobPattern const &copy)
 */
static PyObject *Dtool_GlobPattern_operator_593(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.assign")) {
    return NULL;
  }
  // 1-inline void GlobPattern::operator =(GlobPattern const &copy)
  GlobPattern const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GlobPattern.assign", "GlobPattern");
  }
  (*local_this).operator =(*arg_this);
  GlobPattern *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GlobPattern, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GlobPattern self, const GlobPattern copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_operator_593_comment =
  "C++ Interface:\n"
  "assign(const GlobPattern self, const GlobPattern copy)\n";
#else
static const char *Dtool_GlobPattern_operator_593_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::set_pattern(std::string const &pattern)
 */
static PyObject *Dtool_GlobPattern_set_pattern_597(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.set_pattern")) {
    return NULL;
  }
  // 1-inline void GlobPattern::set_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_pattern(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pattern(const GlobPattern self, str pattern)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_set_pattern_597_comment =
  "C++ Interface:\n"
  "set_pattern(const GlobPattern self, str pattern)\n"
  "\n"
  "/**\n"
  " * Changes the pattern string that the GlobPattern object matches.\n"
  " */";
#else
static const char *Dtool_GlobPattern_set_pattern_597_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GlobPattern::get_pattern(void) const
 */
static PyObject *Dtool_GlobPattern_get_pattern_598(PyObject *self, PyObject *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &GlobPattern::get_pattern(void) const
  std::string const &return_value = (*(const GlobPattern*)local_this).get_pattern();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_pattern_598_comment =
  "C++ Interface:\n"
  "get_pattern(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns the pattern string that the GlobPattern object matches.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_pattern_598_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::set_case_sensitive(bool case_sensitive)
 */
static PyObject *Dtool_GlobPattern_set_case_sensitive_600(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.set_case_sensitive")) {
    return NULL;
  }
  // 1-inline void GlobPattern::set_case_sensitive(bool case_sensitive)
  (*local_this).set_case_sensitive((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_case_sensitive(const GlobPattern self, bool case_sensitive)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_set_case_sensitive_600_comment =
  "C++ Interface:\n"
  "set_case_sensitive(const GlobPattern self, bool case_sensitive)\n"
  "\n"
  "/**\n"
  " * Sets whether the match is case sensitive (true) or case insensitive\n"
  " * (false).  The default is case sensitive.\n"
  " */";
#else
static const char *Dtool_GlobPattern_set_case_sensitive_600_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GlobPattern::get_case_sensitive(void) const
 */
static PyObject *Dtool_GlobPattern_get_case_sensitive_601(PyObject *self, PyObject *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool GlobPattern::get_case_sensitive(void) const
  bool return_value = (*(const GlobPattern*)local_this).get_case_sensitive();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_case_sensitive_601_comment =
  "C++ Interface:\n"
  "get_case_sensitive(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns whether the match is case sensitive (true) or case insensitive\n"
  " * (false).  The default is case sensitive.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_case_sensitive_601_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::set_nomatch_chars(std::string const &nomatch_chars)
 */
static PyObject *Dtool_GlobPattern_set_nomatch_chars_603(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.set_nomatch_chars")) {
    return NULL;
  }
  // 1-inline void GlobPattern::set_nomatch_chars(std::string const &nomatch_chars)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_nomatch_chars(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_nomatch_chars(const GlobPattern self, str nomatch_chars)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_set_nomatch_chars_603_comment =
  "C++ Interface:\n"
  "set_nomatch_chars(const GlobPattern self, str nomatch_chars)\n"
  "\n"
  "/**\n"
  " * Specifies a set of characters that are not matched by * or ?.\n"
  " */";
#else
static const char *Dtool_GlobPattern_set_nomatch_chars_603_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GlobPattern::get_nomatch_chars(void) const
 */
static PyObject *Dtool_GlobPattern_get_nomatch_chars_604(PyObject *self, PyObject *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &GlobPattern::get_nomatch_chars(void) const
  std::string const &return_value = (*(const GlobPattern*)local_this).get_nomatch_chars();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_nomatch_chars_604_comment =
  "C++ Interface:\n"
  "get_nomatch_chars(GlobPattern self)\n"
  "\n"
  "/**\n"
  " * Returns the set of characters that are not matched by * or ?.\n"
  " */";
#else
static const char *Dtool_GlobPattern_get_nomatch_chars_604_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool GlobPattern::matches(std::string const &candidate) const
 */
static PyObject *Dtool_GlobPattern_matches_606(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool GlobPattern::matches(std::string const &candidate) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const GlobPattern*)local_this).matches(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches(GlobPattern self, str candidate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_matches_606_comment =
  "C++ Interface:\n"
  "matches(GlobPattern self, str candidate)\n"
  "\n"
  "/**\n"
  " * Returns true if the candidate string matches the pattern, false otherwise.\n"
  " */";
#else
static const char *Dtool_GlobPattern_matches_606_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void GlobPattern::output(ostream &out) const
 */
static PyObject *Dtool_GlobPattern_output_607(PyObject *self, PyObject *arg) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void GlobPattern::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "GlobPattern.output", false, true);
  if (arg_this != NULL) {
    (*(const GlobPattern*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GlobPattern self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_output_607_comment =
  "C++ Interface:\n"
  "output(GlobPattern self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GlobPattern_output_607_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool GlobPattern::has_glob_characters(void) const
 */
static PyObject *Dtool_GlobPattern_has_glob_characters_608(PyObject *self, PyObject *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool GlobPattern::has_glob_characters(void) const
  bool return_value = (*(const GlobPattern*)local_this).has_glob_characters();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_has_glob_characters_608_comment =
  "C++ Interface:\n"
  "has_glob_characters(GlobPattern self)\n";
#else
static const char *Dtool_GlobPattern_has_glob_characters_608_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string GlobPattern::get_const_prefix(void) const
 */
static PyObject *Dtool_GlobPattern_get_const_prefix_609(PyObject *self, PyObject *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string GlobPattern::get_const_prefix(void) const
  std::string return_value = (*(const GlobPattern*)local_this).get_const_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_get_const_prefix_609_comment =
  "C++ Interface:\n"
  "get_const_prefix(GlobPattern self)\n";
#else
static const char *Dtool_GlobPattern_get_const_prefix_609_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *GlobPattern::match_files(Filename const &cwd = Filename()) const
 * Rejected Remap [int GlobPattern::match_files(vector_string &results, Filename const &cwd) const]
 */
static PyObject *Dtool_GlobPattern_match_files_610(PyObject *self, PyObject *args, PyObject *kwds) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PyObject *GlobPattern::match_files(Filename const &cwd) const
      PyObject *return_value = invoke_extension((const GlobPattern*)local_this).match_files();
      return Dtool_Return(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "cwd");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'cwd' (pos 1) not found");
      }
      // 1-PyObject *GlobPattern::match_files(Filename const &cwd) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "GlobPattern.match_files", "Filename");
      }
      PyObject *return_value = invoke_extension((const GlobPattern*)local_this).match_files(*arg_this);
      return Dtool_Return(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "match_files() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "match_files(GlobPattern self)\n"
      "match_files(GlobPattern self, const Filename cwd)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_GlobPattern_match_files_610_comment =
  "C++ Interface:\n"
  "match_files(GlobPattern self)\n"
  "match_files(GlobPattern self, const Filename cwd)\n";
#else
static const char *Dtool_GlobPattern_match_files_610_comment = NULL;
#endif

static PyObject *Dtool_GlobPattern_pattern_Getter(PyObject *self, void *) {
  const GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &GlobPattern::get_pattern(void) const
  std::string const &return_value = (*(const GlobPattern*)local_this).get_pattern();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GlobPattern_pattern_Setter(PyObject *self, PyObject *arg, void *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.pattern")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete pattern attribute");
    return -1;
  }
  // 1-inline void GlobPattern::set_pattern(std::string const &pattern)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_pattern(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pattern(const GlobPattern self, str pattern)\n");
  }
  return -1;
}

static PyObject *Dtool_GlobPattern_case_sensitive_Getter(PyObject *self, void *) {
  const GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline bool GlobPattern::get_case_sensitive(void) const
  bool return_value = (*(const GlobPattern*)local_this).get_case_sensitive();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GlobPattern_case_sensitive_Setter(PyObject *self, PyObject *arg, void *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.case_sensitive")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete case_sensitive attribute");
    return -1;
  }
  // 1-inline void GlobPattern::set_case_sensitive(bool case_sensitive)
  (*local_this).set_case_sensitive((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_case_sensitive(const GlobPattern self, bool case_sensitive)\n");
  }
  return -1;
}

static PyObject *Dtool_GlobPattern_nomatch_chars_Getter(PyObject *self, void *) {
  const GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &GlobPattern::get_nomatch_chars(void) const
  std::string const &return_value = (*(const GlobPattern*)local_this).get_nomatch_chars();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GlobPattern_nomatch_chars_Setter(PyObject *self, PyObject *arg, void *) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GlobPattern, (void **)&local_this, "GlobPattern.nomatch_chars")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete nomatch_chars attribute");
    return -1;
  }
  // 1-inline void GlobPattern::set_nomatch_chars(std::string const &nomatch_chars)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_nomatch_chars(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_nomatch_chars(const GlobPattern self, str nomatch_chars)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline GlobPattern::GlobPattern(GlobPattern const &copy)
 * inline GlobPattern::GlobPattern(std::string const &pattern = string())
 */
static int Dtool_Init_GlobPattern(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GlobPattern::GlobPattern(std::string const &pattern)
      GlobPattern *return_value = new GlobPattern();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline GlobPattern::GlobPattern(GlobPattern const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:GlobPattern", (char **)keyword_list, &param0)) {
          GlobPattern const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_GlobPattern, (void **)&param0_this);
          if (param0_this != NULL) {
            GlobPattern *return_value = new GlobPattern(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline GlobPattern::GlobPattern(std::string const &pattern)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"pattern", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:GlobPattern", (char **)keyword_list, &param0_str, &param0_len)) {
          GlobPattern *return_value = new GlobPattern(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline GlobPattern::GlobPattern(GlobPattern const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:GlobPattern", (char **)keyword_list, &param0)) {
          GlobPattern const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_GlobPattern(param0, param0_this, param0_manage)) {
            GlobPattern *return_value = new GlobPattern(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GlobPattern, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline GlobPattern::GlobPattern(std::string const &pattern)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GlobPattern() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GlobPattern()\n"
      "GlobPattern(const GlobPattern copy)\n"
      "GlobPattern(str pattern)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_GlobPattern(PyObject *args, GlobPattern const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GlobPattern, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline GlobPattern::GlobPattern(std::string const &pattern)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      GlobPattern *return_value = new GlobPattern(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_GlobPattern, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline GlobPattern::GlobPattern(std::string const &pattern)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      GlobPattern *return_value = new GlobPattern(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_GlobPattern(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_GlobPattern) {
    printf("GlobPattern ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  GlobPattern *local_this = (GlobPattern *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_GlobPattern) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_GlobPattern(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_GlobPattern) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class IDecryptStream
 */
/**
 * Python function wrapper for:
 * inline IDecryptStream &IDecryptStream::open(istream *source, bool owns_source, std::string const &password)
 */
static PyObject *Dtool_IDecryptStream_open_614(PyObject *self, PyObject *args, PyObject *kwds) {
  IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecryptStream, (void **)&local_this, "IDecryptStream.open")) {
    return NULL;
  }
  // 1-inline IDecryptStream &IDecryptStream::open(istream *source, bool owns_source, std::string const &password)
  PyObject *param1;
  PyObject *param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"source", "owns_source", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:open", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "IDecryptStream.open", false, true);
    if (param1_this != NULL) {
      IDecryptStream *return_value = &((*local_this).open(param1_this, (PyObject_IsTrue(param2) != 0), std::string(param3_str, param3_len)));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecryptStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const IDecryptStream self, istream source, bool owns_source, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_open_614_comment =
  "C++ Interface:\n"
  "open(const IDecryptStream self, istream source, bool owns_source, str password)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IDecryptStream_open_614_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline IDecryptStream &IDecryptStream::close(void)
 */
static PyObject *Dtool_IDecryptStream_close_615(PyObject *self, PyObject *) {
  IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecryptStream, (void **)&local_this, "IDecryptStream.close")) {
    return NULL;
  }
  // 1-inline IDecryptStream &IDecryptStream::close(void)
  IDecryptStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecryptStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_close_615_comment =
  "C++ Interface:\n"
  "close(const IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Resets the EncryptStream to empty, but does not actually close the source\n"
  " * istream unless owns_source was true.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_close_615_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &IDecryptStream::get_algorithm(void) const
 */
static PyObject *Dtool_IDecryptStream_get_algorithm_616(PyObject *self, PyObject *) {
  IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &IDecryptStream::get_algorithm(void) const
  std::string const &return_value = (*(const IDecryptStream*)local_this).get_algorithm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_get_algorithm_616_comment =
  "C++ Interface:\n"
  "get_algorithm(IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption algorithm that was read from the stream.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_get_algorithm_616_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int IDecryptStream::get_key_length(void) const
 */
static PyObject *Dtool_IDecryptStream_get_key_length_617(PyObject *self, PyObject *) {
  IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int IDecryptStream::get_key_length(void) const
  int return_value = (*(const IDecryptStream*)local_this).get_key_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_get_key_length_617_comment =
  "C++ Interface:\n"
  "get_key_length(IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption key length, in bits, that was read from the stream.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_get_key_length_617_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int IDecryptStream::get_iteration_count(void) const
 */
static PyObject *Dtool_IDecryptStream_get_iteration_count_618(PyObject *self, PyObject *) {
  IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int IDecryptStream::get_iteration_count(void) const
  int return_value = (*(const IDecryptStream*)local_this).get_iteration_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_IDecryptStream_get_iteration_count_618_comment =
  "C++ Interface:\n"
  "get_iteration_count(IDecryptStream self)\n"
  "\n"
  "/**\n"
  " * Returns the value that was was read from the stream.\n"
  " */";
#else
static const char *Dtool_IDecryptStream_get_iteration_count_618_comment = NULL;
#endif

static PyObject *Dtool_IDecryptStream_algorithm_Getter(PyObject *self, void *) {
  const IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &IDecryptStream::get_algorithm(void) const
  std::string const &return_value = (*(const IDecryptStream*)local_this).get_algorithm();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_IDecryptStream_key_length_Getter(PyObject *self, void *) {
  const IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int IDecryptStream::get_key_length(void) const
  int return_value = (*(const IDecryptStream*)local_this).get_key_length();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_IDecryptStream_iteration_count_Getter(PyObject *self, void *) {
  const IDecryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IDecryptStream, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int IDecryptStream::get_iteration_count(void) const
  int return_value = (*(const IDecryptStream*)local_this).get_iteration_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline IDecryptStream::IDecryptStream(void)
 * inline IDecryptStream::IDecryptStream(istream *source, bool owns_source, std::string const &password)
 */
static int Dtool_Init_IDecryptStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline IDecryptStream::IDecryptStream(void)
      IDecryptStream *return_value = new IDecryptStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecryptStream, true, false);
    }
    break;
  case 3:
    {
      // 1-inline IDecryptStream::IDecryptStream(istream *source, bool owns_source, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"source", "owns_source", "password", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:IDecryptStream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IDecryptStream.IDecryptStream", false, true);
        if (param0_this != NULL) {
          IDecryptStream *return_value = new IDecryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecryptStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IDecryptStream() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IDecryptStream()\n"
      "IDecryptStream(istream source, bool owns_source, str password)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_IDecryptStream(PyObject *args, IDecryptStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IDecryptStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline IDecryptStream::IDecryptStream(istream *source, bool owns_source, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      if (PyArg_ParseTuple(args, "OOs#:IDecryptStream", &param0, &param1, &param2_str, &param2_len)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IDecryptStream.IDecryptStream", false, false);
        if (param0_this != NULL) {
          IDecryptStream *return_value = new IDecryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_IDecryptStream(PyObject *args, IDecryptStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IDecryptStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline IDecryptStream::IDecryptStream(istream *source, bool owns_source, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      if (PyArg_ParseTuple(args, "OOs#:IDecryptStream", &param0, &param1, &param2_str, &param2_len)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IDecryptStream.IDecryptStream", false, false);
        if (param0_this != NULL) {
          IDecryptStream *return_value = new IDecryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_IDecryptStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_IDecryptStream) {
    printf("IDecryptStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  IDecryptStream *local_this = (IDecryptStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_IDecryptStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_IDecryptStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_IDecryptStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (IDecryptStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class IFileStream
 */
/**
 * Python function wrapper for:
 * inline void IFileStream::open(char const *filename, ios_base::openmode mode = ::ios_base::in)
 */
static PyObject *Dtool_IFileStream_open_626(PyObject *self, PyObject *args, PyObject *kwds) {
  IFileStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IFileStream, (void **)&local_this, "IFileStream.open")) {
    return NULL;
  }
  // 1-inline void IFileStream::open(char const *filename, ios_base::openmode mode = ::ios_base::in)
  char const *param1;
  int param2 = ios_base::in;
  static const char *keyword_list[] = {"filename", "mode", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:open", (char **)keyword_list, &param1, &param2)) {
    (*local_this).open((char const *)param1, (ios_base::openmode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const IFileStream self, str filename, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IFileStream_open_626_comment =
  "C++ Interface:\n"
  "open(const IFileStream self, str filename, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IFileStream_open_626_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void IFileStream::close(void)
 */
static PyObject *Dtool_IFileStream_close_627(PyObject *self, PyObject *) {
  IFileStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IFileStream, (void **)&local_this, "IFileStream.close")) {
    return NULL;
  }
  // 1-inline void IFileStream::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_IFileStream_close_627_comment =
  "C++ Interface:\n"
  "close(const IFileStream self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IFileStream_close_627_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline IFileStream::IFileStream(void)
 * inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode = ::ios_base::in)
 */
static int Dtool_Init_IFileStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline IFileStream::IFileStream(void)
      IFileStream *return_value = new IFileStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IFileStream, true, false);
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode = ::ios_base::in)
      char const *param0;
      int param1 = ios_base::in;
      static const char *keyword_list[] = {"filename", "mode", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:IFileStream", (char **)keyword_list, &param0, &param1)) {
        IFileStream *return_value = new IFileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IFileStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IFileStream() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IFileStream()\n"
      "IFileStream(str filename, int mode)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_IFileStream(PyObject *args, IFileStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IFileStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode)
    char const *param0;
    if (PyArg_Parse(arg, "z:IFileStream", &param0)) {
      IFileStream *return_value = new IFileStream((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:IFileStream", &param0, &param1)) {
        IFileStream *return_value = new IFileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_IFileStream(PyObject *args, IFileStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IFileStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode)
    char const *param0;
    if (PyArg_Parse(arg, "z:IFileStream", &param0)) {
      IFileStream *return_value = new IFileStream((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline IFileStream::IFileStream(char const *filename, ios_base::openmode mode)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:IFileStream", &param0, &param1)) {
        IFileStream *return_value = new IFileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_IFileStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_IFileStream) {
    printf("IFileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  IFileStream *local_this = (IFileStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_IFileStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_IFileStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_IFileStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (IFileStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class IStreamWrapper
 */
/**
 * Python function wrapper for:
 * inline istream *IStreamWrapper::get_istream(void) const
 */
static PyObject *Dtool_IStreamWrapper_get_istream_637(PyObject *self, PyObject *) {
  IStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IStreamWrapper, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline istream *IStreamWrapper::get_istream(void) const
  istream *return_value = (*(const IStreamWrapper*)local_this).get_istream();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IStreamWrapper_get_istream_637_comment =
  "C++ Interface:\n"
  "get_istream(IStreamWrapper self)\n"
  "\n"
  "/**\n"
  " * Returns the istream this object is wrapping.\n"
  " */";
#else
static const char *Dtool_IStreamWrapper_get_istream_637_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * StreamWrapperBase *IStreamWrapper::upcast_to_StreamWrapperBase(void)
 */
static PyObject *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634(PyObject *self, PyObject *) {
  IStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IStreamWrapper, (void **)&local_this, "IStreamWrapper.upcast_to_StreamWrapperBase")) {
    return NULL;
  }
  // 1-StreamWrapperBase *IStreamWrapper::upcast_to_StreamWrapperBase(void)
  StreamWrapperBase *return_value = (StreamWrapperBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWrapperBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634_comment =
  "C++ Interface:\n"
  "upcast_to_StreamWrapperBase(const IStreamWrapper self)\n"
  "\n"
  "upcast from IStreamWrapper to StreamWrapperBase";
#else
static const char *Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * StreamWrapper *IStreamWrapper::downcast_to_StreamWrapper(void)
 */
static PyObject *Dtool_IStreamWrapper_downcast_to_StreamWrapper_873(PyObject *self, PyObject *) {
  IStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IStreamWrapper, (void **)&local_this, "IStreamWrapper.downcast_to_StreamWrapper")) {
    return NULL;
  }
  // 1-StreamWrapper *IStreamWrapper::downcast_to_StreamWrapper(void)
  StreamWrapper *return_value = (StreamWrapper *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IStreamWrapper_downcast_to_StreamWrapper_873_comment =
  "C++ Interface:\n"
  "downcast_to_StreamWrapper(const IStreamWrapper self)\n"
  "\n"
  "downcast from IStreamWrapper to StreamWrapper";
#else
static const char *Dtool_IStreamWrapper_downcast_to_StreamWrapper_873_comment = NULL;
#endif

static PyObject *Dtool_IStreamWrapper_istream_Getter(PyObject *self, void *) {
  const IStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_IStreamWrapper, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline istream *IStreamWrapper::get_istream(void) const
  istream *return_value = (*(const IStreamWrapper*)local_this).get_istream();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

/**
 * Python function wrapper for:
 * inline IStreamWrapper::IStreamWrapper(IStreamWrapper const &) = default
 * inline IStreamWrapper::IStreamWrapper(istream &stream)
 */
static int Dtool_Init_IStreamWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "IStreamWrapper() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline IStreamWrapper::IStreamWrapper(istream &stream)
    PyObject *param0;
    static const char *keyword_list[] = {"stream", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:IStreamWrapper", (char **)keyword_list, &param0)) {
      istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IStreamWrapper.IStreamWrapper", false, false);
      if (param0_this != NULL) {
        IStreamWrapper *return_value = new IStreamWrapper(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IStreamWrapper, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline IStreamWrapper::IStreamWrapper(istream &stream)
  {
    // -2 inline IStreamWrapper::IStreamWrapper(IStreamWrapper const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:IStreamWrapper", (char **)keyword_list, &param0)) {
      IStreamWrapper const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_IStreamWrapper(param0, param0_this, param0_manage)) {
        IStreamWrapper *return_value = new IStreamWrapper(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IStreamWrapper, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IStreamWrapper(istream stream)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_IStreamWrapper(PyObject *args, IStreamWrapper const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IStreamWrapper, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline IStreamWrapper::IStreamWrapper(istream &stream)
    istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 0, "IStreamWrapper.IStreamWrapper", false, false);
    if (arg_this != NULL) {
      IStreamWrapper *return_value = new IStreamWrapper(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_IStreamWrapper(PyObject *args, IStreamWrapper *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IStreamWrapper, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline IStreamWrapper::IStreamWrapper(istream &stream)
    istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 0, "IStreamWrapper.IStreamWrapper", false, false);
    if (arg_this != NULL) {
      IStreamWrapper *return_value = new IStreamWrapper(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_IStreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_IStreamWrapper) {
    printf("IStreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  IStreamWrapper *local_this = (IStreamWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_IStreamWrapper) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return (StreamWrapperBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_IStreamWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_IStreamWrapper) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StreamWrapperBase
 */
/**
 * Python function wrapper for:
 * inline void StreamWrapperBase::acquire(void)
 */
static PyObject *Dtool_StreamWrapperBase_acquire_630(PyObject *self, PyObject *) {
  StreamWrapperBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapperBase, (void **)&local_this, "StreamWrapperBase.acquire")) {
    return NULL;
  }
  // 1-inline void StreamWrapperBase::acquire(void)
  (*local_this).acquire();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapperBase_acquire_630_comment =
  "C++ Interface:\n"
  "acquire(const StreamWrapperBase self)\n"
  "\n"
  "/**\n"
  " * Acquires the internal lock.\n"
  " *\n"
  " * User code should call this to take temporary possession of the stream and\n"
  " * perform direct I/O operations on it, for instance to make several\n"
  " * sequential atomic reads.  You may not call any of the StreamWrapper methods\n"
  " * while the lock is held, other than release().\n"
  " *\n"
  " * Use with extreme caution!  This is a very low-level, non-recursive lock.\n"
  " * You must call acquire() only once, and you must later call release()\n"
  " * exactly once.  Failing to do so may result in a hard deadlock with no\n"
  " * available debugging features.\n"
  " */";
#else
static const char *Dtool_StreamWrapperBase_acquire_630_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWrapperBase::release(void)
 */
static PyObject *Dtool_StreamWrapperBase_release_631(PyObject *self, PyObject *) {
  StreamWrapperBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapperBase, (void **)&local_this, "StreamWrapperBase.release")) {
    return NULL;
  }
  // 1-inline void StreamWrapperBase::release(void)
  (*local_this).release();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapperBase_release_631_comment =
  "C++ Interface:\n"
  "release(const StreamWrapperBase self)\n"
  "\n"
  "/**\n"
  " * Releases the internal lock.  Must be called exactly once following a call\n"
  " * to acquire().  See the cautions with acquire().\n"
  " */";
#else
static const char *Dtool_StreamWrapperBase_release_631_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline StreamWrapperBase::StreamWrapperBase(StreamWrapperBase const &) = default
 */
static int Dtool_Init_StreamWrapperBase(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "StreamWrapperBase() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline StreamWrapperBase::StreamWrapperBase(StreamWrapperBase const &) = default
  StreamWrapperBase const *arg_this = (StreamWrapperBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamWrapperBase, 0, "StreamWrapperBase.StreamWrapperBase", true, true);
  if (arg_this != NULL) {
    StreamWrapperBase *return_value = new StreamWrapperBase(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWrapperBase, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamWrapperBase(const StreamWrapperBase param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StreamWrapperBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StreamWrapperBase) {
    printf("StreamWrapperBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StreamWrapperBase *local_this = (StreamWrapperBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StreamWrapperBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StreamWrapperBase) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class LineStream
 */
/**
 * Python function wrapper for:
 * inline bool LineStream::is_text_available(void) const
 */
static PyObject *Dtool_LineStream_is_text_available_642(PyObject *self, PyObject *) {
  LineStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineStream, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LineStream::is_text_available(void) const
  bool return_value = (*(const LineStream*)local_this).is_text_available();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineStream_is_text_available_642_comment =
  "C++ Interface:\n"
  "is_text_available(LineStream self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is at least one line of text (or even a partial line)\n"
  " * available in the LineStream object.  If this returns true, the line may\n"
  " * then be retrieved via get_line().\n"
  " */";
#else
static const char *Dtool_LineStream_is_text_available_642_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string LineStream::get_line(void)
 */
static PyObject *Dtool_LineStream_get_line_643(PyObject *self, PyObject *) {
  LineStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LineStream, (void **)&local_this, "LineStream.get_line")) {
    return NULL;
  }
  // 1-inline std::string LineStream::get_line(void)
  std::string return_value = (*local_this).get_line();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineStream_get_line_643_comment =
  "C++ Interface:\n"
  "get_line(const LineStream self)\n"
  "\n"
  "/**\n"
  " * Extracts and returns the next line (or partial line) of text available in\n"
  " * the LineStream object.  Once the line has been extracted, you may call\n"
  " * has_newline() to determine whether or not there was an explicit newline\n"
  " * character written following this line.\n"
  " */";
#else
static const char *Dtool_LineStream_get_line_643_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool LineStream::has_newline(void) const
 */
static PyObject *Dtool_LineStream_has_newline_644(PyObject *self, PyObject *) {
  LineStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LineStream, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool LineStream::has_newline(void) const
  bool return_value = (*(const LineStream*)local_this).has_newline();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LineStream_has_newline_644_comment =
  "C++ Interface:\n"
  "has_newline(LineStream self)\n"
  "\n"
  "/**\n"
  " * Returns true if the line of text most recently returned by get_line() was\n"
  " * written out with a terminating newline, or false if a newline character has\n"
  " * not yet been written to the LineStream.\n"
  " */";
#else
static const char *Dtool_LineStream_has_newline_644_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline LineStream::LineStream(void)
 */
static int Dtool_Init_LineStream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LineStream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline LineStream::LineStream(void)
  LineStream *return_value = new LineStream();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LineStream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LineStream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LineStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_LineStream) {
    printf("LineStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  LineStream *local_this = (LineStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_LineStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_LineStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_LineStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (LineStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NeverFreeMemory
 */
/**
 * Python function wrapper for:
 * static inline std::size_t NeverFreeMemory::get_total_alloc(void)
 */
static PyObject *Dtool_NeverFreeMemory_get_total_alloc_647(PyObject *, PyObject *) {
  // 1-static inline std::size_t NeverFreeMemory::get_total_alloc(void)
  std::size_t return_value = NeverFreeMemory::get_total_alloc();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NeverFreeMemory_get_total_alloc_647_comment =
  "C++ Interface:\n"
  "get_total_alloc()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes consumed by all the pages allocated\n"
  " * internally by this object.\n"
  " */";
#else
static const char *Dtool_NeverFreeMemory_get_total_alloc_647_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t NeverFreeMemory::get_total_used(void)
 */
static PyObject *Dtool_NeverFreeMemory_get_total_used_648(PyObject *, PyObject *) {
  // 1-static inline std::size_t NeverFreeMemory::get_total_used(void)
  std::size_t return_value = NeverFreeMemory::get_total_used();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NeverFreeMemory_get_total_used_648_comment =
  "C++ Interface:\n"
  "get_total_used()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes requested by the application in calls to\n"
  " * NeverFreeMemory::alloc().\n"
  " */";
#else
static const char *Dtool_NeverFreeMemory_get_total_used_648_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t NeverFreeMemory::get_total_unused(void)
 */
static PyObject *Dtool_NeverFreeMemory_get_total_unused_649(PyObject *, PyObject *) {
  // 1-static inline std::size_t NeverFreeMemory::get_total_unused(void)
  std::size_t return_value = NeverFreeMemory::get_total_unused();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NeverFreeMemory_get_total_unused_649_comment =
  "C++ Interface:\n"
  "get_total_unused()\n"
  "\n"
  "/**\n"
  " * Returns the difference between get_total_alloc() and get_total_used().\n"
  " * This represents bytes in allocated pages that have not (yet) been used by\n"
  " * the application.\n"
  " */";
#else
static const char *Dtool_NeverFreeMemory_get_total_unused_649_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NeverFreeMemory::NeverFreeMemory(NeverFreeMemory const &) = default
 */
static int Dtool_Init_NeverFreeMemory(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NeverFreeMemory() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline NeverFreeMemory::NeverFreeMemory(NeverFreeMemory const &) = default
  NeverFreeMemory const *arg_this = (NeverFreeMemory *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NeverFreeMemory, 0, "NeverFreeMemory.NeverFreeMemory", true, true);
  if (arg_this != NULL) {
    NeverFreeMemory *return_value = new NeverFreeMemory(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NeverFreeMemory, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NeverFreeMemory(const NeverFreeMemory param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NeverFreeMemory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NeverFreeMemory) {
    printf("NeverFreeMemory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NeverFreeMemory *local_this = (NeverFreeMemory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NeverFreeMemory) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NeverFreeMemory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NeverFreeMemory) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Notify
 */
/**
 * Python function wrapper for:
 * void Notify::set_ostream_ptr(ostream *ostream_ptr, bool delete_later)
 */
static PyObject *Dtool_Notify_set_ostream_ptr_655(PyObject *self, PyObject *args, PyObject *kwds) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.set_ostream_ptr")) {
    return NULL;
  }
  // 1-void Notify::set_ostream_ptr(ostream *ostream_ptr, bool delete_later)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"ostream_ptr", "delete_later", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_ostream_ptr", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Notify.set_ostream_ptr", false, true);
    if (param1_this != NULL) {
      (*local_this).set_ostream_ptr(param1_this, (PyObject_IsTrue(param2) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ostream_ptr(const Notify self, ostream ostream_ptr, bool delete_later)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Notify_set_ostream_ptr_655_comment =
  "C++ Interface:\n"
  "set_ostream_ptr(const Notify self, ostream ostream_ptr, bool delete_later)\n";
#else
static const char *Dtool_Notify_set_ostream_ptr_655_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ostream *Notify::get_ostream_ptr(void) const
 */
static PyObject *Dtool_Notify_get_ostream_ptr_656(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Notify, (void **)&local_this)) {
    return NULL;
  }
  // 1-ostream *Notify::get_ostream_ptr(void) const
  ostream *return_value = (*(const Notify*)local_this).get_ostream_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_ostream_ptr_656_comment =
  "C++ Interface:\n"
  "get_ostream_ptr(Notify self)\n";
#else
static const char *Dtool_Notify_get_ostream_ptr_656_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Notify::clear_assert_handler(void)
 */
static PyObject *Dtool_Notify_clear_assert_handler_658(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.clear_assert_handler")) {
    return NULL;
  }
  // 1-void Notify::clear_assert_handler(void)
  (*local_this).clear_assert_handler();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Notify_clear_assert_handler_658_comment =
  "C++ Interface:\n"
  "clear_assert_handler(const Notify self)\n";
#else
static const char *Dtool_Notify_clear_assert_handler_658_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Notify::has_assert_handler(void) const
 */
static PyObject *Dtool_Notify_has_assert_handler_659(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Notify, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Notify::has_assert_handler(void) const
  bool return_value = (*(const Notify*)local_this).has_assert_handler();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Notify_has_assert_handler_659_comment =
  "C++ Interface:\n"
  "has_assert_handler(Notify self)\n";
#else
static const char *Dtool_Notify_has_assert_handler_659_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Notify::has_assert_failed(void) const
 */
static PyObject *Dtool_Notify_has_assert_failed_661(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Notify, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Notify::has_assert_failed(void) const
  bool return_value = (*(const Notify*)local_this).has_assert_failed();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Notify_has_assert_failed_661_comment =
  "C++ Interface:\n"
  "has_assert_failed(Notify self)\n"
  "\n"
  "/**\n"
  " * Returns true if an assertion test has failed (and not been ignored) since\n"
  " * the last call to clear_assert_failed().\n"
  " *\n"
  " * When an assertion test fails, the assert handler may decide either to\n"
  " * abort, return, or ignore the assertion.  Naturally, if it decides to abort,\n"
  " * this flag is irrelevant.  If it chooses to ignore the assertion, the flag\n"
  " * is not set.  However, if the assert handler chooses to return out of the\n"
  " * function (the normal case), it will also set this flag to indicate that an\n"
  " * assertion failure has occurred.\n"
  " *\n"
  " * This will also be the behavior in the absence of a user-defined assert\n"
  " * handler.\n"
  " */";
#else
static const char *Dtool_Notify_has_assert_failed_661_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Notify::get_assert_error_message(void) const
 */
static PyObject *Dtool_Notify_get_assert_error_message_662(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Notify, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Notify::get_assert_error_message(void) const
  std::string const &return_value = (*(const Notify*)local_this).get_assert_error_message();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_assert_error_message_662_comment =
  "C++ Interface:\n"
  "get_assert_error_message(Notify self)\n"
  "\n"
  "/**\n"
  " * Returns the error message that corresponds to the assertion that most\n"
  " * recently failed.\n"
  " */";
#else
static const char *Dtool_Notify_get_assert_error_message_662_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Notify::clear_assert_failed(void)
 */
static PyObject *Dtool_Notify_clear_assert_failed_663(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.clear_assert_failed")) {
    return NULL;
  }
  // 1-inline void Notify::clear_assert_failed(void)
  (*local_this).clear_assert_failed();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Notify_clear_assert_failed_663_comment =
  "C++ Interface:\n"
  "clear_assert_failed(const Notify self)\n"
  "\n"
  "/**\n"
  " * Resets the assert_failed flag that is set whenever an assertion test fails.\n"
  " * See has_assert_failed().\n"
  " */";
#else
static const char *Dtool_Notify_clear_assert_failed_663_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NotifyCategory *Notify::get_top_category(void)
 */
static PyObject *Dtool_Notify_get_top_category_664(PyObject *self, PyObject *) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.get_top_category")) {
    return NULL;
  }
  // 1-NotifyCategory *Notify::get_top_category(void)
  NotifyCategory *return_value = (*local_this).get_top_category();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_top_category_664_comment =
  "C++ Interface:\n"
  "get_top_category(const Notify self)\n";
#else
static const char *Dtool_Notify_get_top_category_664_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NotifyCategory *Notify::get_category(std::string const &fullname)
 * NotifyCategory *Notify::get_category(std::string const &basename, NotifyCategory *parent_category)
 * NotifyCategory *Notify::get_category(std::string const &basename, std::string const &parent_fullname)
 */
static PyObject *Dtool_Notify_get_category_665(PyObject *self, PyObject *args, PyObject *kwds) {
  Notify *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Notify, (void **)&local_this, "Notify.get_category")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "fullname");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'fullname' (pos 1) not found");
      }
      // 1-NotifyCategory *Notify::get_category(std::string const &fullname)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        NotifyCategory *return_value = (*local_this).get_category(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
      }
    }
    break;
  case 2:
    {
      {
        // -2 NotifyCategory *Notify::get_category(std::string const &basename, NotifyCategory *parent_category)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"basename", "parent_category", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:get_category", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          NotifyCategory *param2_this = (NotifyCategory *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NotifyCategory, 2, "Notify.get_category", false, false);
          if (param2_this != NULL) {
            NotifyCategory *return_value = (*local_this).get_category(std::string(param1_str, param1_len), param2_this);
            if (Dtool_CheckErrorOccurred()) {
              return NULL;
            }
            return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 NotifyCategory *Notify::get_category(std::string const &basename, std::string const &parent_fullname)
        char *param1_str = NULL;
        Py_ssize_t param1_len;
        char *param2_str = NULL;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"basename", "parent_fullname", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_category", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
          NotifyCategory *return_value = (*local_this).get_category(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          if (Dtool_CheckErrorOccurred()) {
            return NULL;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: NotifyCategory *Notify::get_category(std::string const &basename, NotifyCategory *parent_category)
      // No coercion possible: NotifyCategory *Notify::get_category(std::string const &basename, std::string const &parent_fullname)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_category() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_category(const Notify self, str fullname)\n"
      "get_category(const Notify self, str basename, NotifyCategory parent_category)\n"
      "get_category(const Notify self, str basename, str parent_fullname)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Notify_get_category_665_comment =
  "C++ Interface:\n"
  "get_category(const Notify self, str fullname)\n"
  "get_category(const Notify self, str basename, NotifyCategory parent_category)\n"
  "get_category(const Notify self, str basename, str parent_fullname)\n";
#else
static const char *Dtool_Notify_get_category_665_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ostream &Notify::out(void)
 */
static PyObject *Dtool_Notify_out_666(PyObject *, PyObject *) {
  // 1-static ostream &Notify::out(void)
  ostream *return_value = &(Notify::out());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_out_666_comment =
  "C++ Interface:\n"
  "out()\n";
#else
static const char *Dtool_Notify_out_666_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static ostream &Notify::null(void)
 */
static PyObject *Dtool_Notify_null_667(PyObject *, PyObject *) {
  // 1-static ostream &Notify::null(void)
  ostream *return_value = &(Notify::null());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_null_667_comment =
  "C++ Interface:\n"
  "null()\n";
#else
static const char *Dtool_Notify_null_667_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void Notify::write_string(std::string const &str)
 */
static PyObject *Dtool_Notify_write_string_668(PyObject *, PyObject *arg) {
  // 1-static void Notify::write_string(std::string const &str)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
    param0_str = NULL;
  }
#endif
  if (param0_str != NULL) {
    Notify::write_string(std::string(param0_str, param0_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_string(str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Notify_write_string_668_comment =
  "C++ Interface:\n"
  "write_string(str str)\n";
#else
static const char *Dtool_Notify_write_string_668_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static Notify *Notify::ptr(void)
 */
static PyObject *Dtool_Notify_ptr_669(PyObject *, PyObject *) {
  // 1-static Notify *Notify::ptr(void)
  Notify *return_value = Notify::ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Notify, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Notify_ptr_669_comment =
  "C++ Interface:\n"
  "ptr()\n";
#else
static const char *Dtool_Notify_ptr_669_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Notify::Notify(void)
 * inline Notify::Notify(Notify const &) = default
 */
static int Dtool_Init_Notify(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Notify::Notify(void)
      Notify *return_value = new Notify();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Notify, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Notify::Notify(Notify const &) = default
      Notify const *arg_this = (Notify *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Notify, 0, "Notify.Notify", true, true);
      if (arg_this != NULL) {
        Notify *return_value = new Notify(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Notify, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Notify() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Notify()\n"
      "Notify(const Notify param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Notify(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Notify) {
    printf("Notify ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Notify *local_this = (Notify *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Notify) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Notify(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Notify) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NotifyCategory
 */
/**
 * Python function wrapper for:
 * inline std::string NotifyCategory::get_fullname(void) const
 */
static PyObject *Dtool_NotifyCategory_get_fullname_675(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string NotifyCategory::get_fullname(void) const
  std::string return_value = (*(const NotifyCategory*)local_this).get_fullname();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_fullname_675_comment =
  "C++ Interface:\n"
  "get_fullname(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_fullname_675_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string NotifyCategory::get_basename(void) const
 */
static PyObject *Dtool_NotifyCategory_get_basename_676(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string NotifyCategory::get_basename(void) const
  std::string return_value = (*(const NotifyCategory*)local_this).get_basename();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_basename_676_comment =
  "C++ Interface:\n"
  "get_basename(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_basename_676_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline NotifySeverity NotifyCategory::get_severity(void) const
 */
static PyObject *Dtool_NotifyCategory_get_severity_677(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline NotifySeverity NotifyCategory::get_severity(void) const
  NotifySeverity return_value = (*(const NotifyCategory*)local_this).get_severity();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_severity_677_comment =
  "C++ Interface:\n"
  "get_severity(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NotifyCategory_get_severity_677_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NotifyCategory::set_severity(NotifySeverity severity)
 */
static PyObject *Dtool_NotifyCategory_set_severity_678(PyObject *self, PyObject *arg) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NotifyCategory, (void **)&local_this, "NotifyCategory.set_severity")) {
    return NULL;
  }
  // 1-inline void NotifyCategory::set_severity(NotifySeverity severity)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_severity((NotifySeverity)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_severity(const NotifyCategory self, int severity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_set_severity_678_comment =
  "C++ Interface:\n"
  "set_severity(const NotifyCategory self, int severity)\n"
  "\n"
  "/**\n"
  " * Sets the severity level of messages that will be reported from this\n"
  " * Category.  This allows any message of this severity level or higher.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_set_severity_678_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_on(NotifySeverity severity) const
 */
static PyObject *Dtool_NotifyCategory_is_on_683(PyObject *self, PyObject *arg) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_on(NotifySeverity severity) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const NotifyCategory*)local_this).is_on((NotifySeverity)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_on(NotifyCategory self, int severity)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_on_683_comment =
  "C++ Interface:\n"
  "is_on(NotifyCategory self, int severity)\n"
  "\n"
  "/**\n"
  " * Returns true if messages of the indicated severity level ought to be\n"
  " * reported for this Category.\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_on_683_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_spam(void) const
 */
static PyObject *Dtool_NotifyCategory_is_spam_684(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_spam(void) const
  bool return_value = (*(const NotifyCategory*)local_this).is_spam();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_spam_684_comment =
  "C++ Interface:\n"
  "is_spam(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_spam).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_spam_684_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_debug(void) const
 */
static PyObject *Dtool_NotifyCategory_is_debug_685(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_debug(void) const
  bool return_value = (*(const NotifyCategory*)local_this).is_debug();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_debug_685_comment =
  "C++ Interface:\n"
  "is_debug(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_debug).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_debug_685_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_info(void) const
 */
static PyObject *Dtool_NotifyCategory_is_info_686(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_info(void) const
  bool return_value = (*(const NotifyCategory*)local_this).is_info();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_info_686_comment =
  "C++ Interface:\n"
  "is_info(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_info).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_info_686_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_warning(void) const
 */
static PyObject *Dtool_NotifyCategory_is_warning_687(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_warning(void) const
  bool return_value = (*(const NotifyCategory*)local_this).is_warning();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_warning_687_comment =
  "C++ Interface:\n"
  "is_warning(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_warning).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_warning_687_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_error(void) const
 */
static PyObject *Dtool_NotifyCategory_is_error_688(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_error(void) const
  bool return_value = (*(const NotifyCategory*)local_this).is_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_error_688_comment =
  "C++ Interface:\n"
  "is_error(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_error).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_error_688_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NotifyCategory::is_fatal(void) const
 */
static PyObject *Dtool_NotifyCategory_is_fatal_689(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NotifyCategory::is_fatal(void) const
  bool return_value = (*(const NotifyCategory*)local_this).is_fatal();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_is_fatal_689_comment =
  "C++ Interface:\n"
  "is_fatal(NotifyCategory self)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write is_on(NS_fatal).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_is_fatal_689_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ostream &NotifyCategory::out(NotifySeverity severity, bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_out_690(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-ostream &NotifyCategory::out(NotifySeverity severity, bool prefix = true) const
  int param1;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"severity", "prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:out", (char **)keyword_list, &param1, &param2)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).out((NotifySeverity)param1, (PyObject_IsTrue(param2) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "out(NotifyCategory self, int severity, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_out_690_comment =
  "C++ Interface:\n"
  "out(NotifyCategory self, int severity, bool prefix)\n";
#else
static const char *Dtool_NotifyCategory_out_690_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream &NotifyCategory::spam(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_spam_691(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream &NotifyCategory::spam(bool prefix = true) const
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:spam", (char **)keyword_list, &param1)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).spam((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "spam(NotifyCategory self, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_spam_691_comment =
  "C++ Interface:\n"
  "spam(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_spam).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_spam_691_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream &NotifyCategory::debug(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_debug_692(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream &NotifyCategory::debug(bool prefix = true) const
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:debug", (char **)keyword_list, &param1)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).debug((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "debug(NotifyCategory self, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_debug_692_comment =
  "C++ Interface:\n"
  "debug(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_debug).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_debug_692_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream &NotifyCategory::info(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_info_693(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream &NotifyCategory::info(bool prefix = true) const
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:info", (char **)keyword_list, &param1)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).info((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "info(NotifyCategory self, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_info_693_comment =
  "C++ Interface:\n"
  "info(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_info).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_info_693_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream &NotifyCategory::warning(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_warning_694(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream &NotifyCategory::warning(bool prefix = true) const
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:warning", (char **)keyword_list, &param1)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).warning((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "warning(NotifyCategory self, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_warning_694_comment =
  "C++ Interface:\n"
  "warning(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_warning).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_warning_694_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream &NotifyCategory::error(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_error_695(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream &NotifyCategory::error(bool prefix = true) const
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:error", (char **)keyword_list, &param1)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).error((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "error(NotifyCategory self, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_error_695_comment =
  "C++ Interface:\n"
  "error(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_error).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_error_695_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream &NotifyCategory::fatal(bool prefix = true) const
 */
static PyObject *Dtool_NotifyCategory_fatal_696(PyObject *self, PyObject *args, PyObject *kwds) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream &NotifyCategory::fatal(bool prefix = true) const
  PyObject *param1 = Py_True;
  static const char *keyword_list[] = {"prefix", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:fatal", (char **)keyword_list, &param1)) {
    ostream *return_value = &((*(const NotifyCategory*)local_this).fatal((PyObject_IsTrue(param1) != 0)));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fatal(NotifyCategory self, bool prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_fatal_696_comment =
  "C++ Interface:\n"
  "fatal(NotifyCategory self, bool prefix)\n"
  "\n"
  "/**\n"
  " * A shorthand way to write out(NS_fatal).\n"
  " */";
#else
static const char *Dtool_NotifyCategory_fatal_696_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t NotifyCategory::get_num_children(void) const
 */
static PyObject *Dtool_NotifyCategory_get_num_children_697(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t NotifyCategory::get_num_children(void) const
  std::size_t return_value = (*(const NotifyCategory*)local_this).get_num_children();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_num_children_697_comment =
  "C++ Interface:\n"
  "get_num_children(NotifyCategory self)\n";
#else
static const char *Dtool_NotifyCategory_get_num_children_697_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * NotifyCategory *NotifyCategory::get_child(std::size_t i) const
 */
static PyObject *Dtool_NotifyCategory_get_child_698(PyObject *self, PyObject *arg) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  // 1-NotifyCategory *NotifyCategory::get_child(std::size_t i) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_child", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    NotifyCategory *return_value = (*(const NotifyCategory*)local_this).get_child((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(NotifyCategory self, int i)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_get_child_698_comment =
  "C++ Interface:\n"
  "get_child(NotifyCategory self, int i)\n";
#else
static const char *Dtool_NotifyCategory_get_child_698_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void NotifyCategory::set_server_delta(long int delta)
 */
static PyObject *Dtool_NotifyCategory_set_server_delta_702(PyObject *, PyObject *arg) {
  // 1-static void NotifyCategory::set_server_delta(long int delta)
  if (PyLongOrInt_Check(arg)) {
    NotifyCategory::set_server_delta(PyLongOrInt_AS_LONG(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_server_delta(int delta)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_set_server_delta_702_comment =
  "C++ Interface:\n"
  "set_server_delta(int delta)\n";
#else
static const char *Dtool_NotifyCategory_set_server_delta_702_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ConfigFlags *NotifyCategory::upcast_to_ConfigFlags(void)
 */
static PyObject *Dtool_NotifyCategory_upcast_to_ConfigFlags_673(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NotifyCategory, (void **)&local_this, "NotifyCategory.upcast_to_ConfigFlags")) {
    return NULL;
  }
  // 1-ConfigFlags *NotifyCategory::upcast_to_ConfigFlags(void)
  ConfigFlags *return_value = (ConfigFlags *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigFlags, false, false);
}

#ifndef NDEBUG
static const char *Dtool_NotifyCategory_upcast_to_ConfigFlags_673_comment =
  "C++ Interface:\n"
  "upcast_to_ConfigFlags(const NotifyCategory self)\n"
  "\n"
  "upcast from NotifyCategory to ConfigFlags";
#else
static const char *Dtool_NotifyCategory_upcast_to_ConfigFlags_673_comment = NULL;
#endif

static PyObject *Dtool_NotifyCategory_fullname_Getter(PyObject *self, void *) {
  const NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string NotifyCategory::get_fullname(void) const
  std::string return_value = (*(const NotifyCategory*)local_this).get_fullname();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NotifyCategory_basename_Getter(PyObject *self, void *) {
  const NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string NotifyCategory::get_basename(void) const
  std::string return_value = (*(const NotifyCategory*)local_this).get_basename();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_NotifyCategory_severity_Getter(PyObject *self, void *) {
  const NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline NotifySeverity NotifyCategory::get_severity(void) const
  NotifySeverity return_value = (*(const NotifyCategory*)local_this).get_severity();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_NotifyCategory_severity_Setter(PyObject *self, PyObject *arg, void *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NotifyCategory, (void **)&local_this, "NotifyCategory.severity")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete severity attribute");
    return -1;
  }
  // 1-inline void NotifyCategory::set_severity(NotifySeverity severity)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_severity((NotifySeverity)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_severity(const NotifyCategory self, int severity)\n");
  }
  return -1;
}

/**
 * sequence length function for property NotifyCategory::children
 */
static Py_ssize_t Dtool_NotifyCategory_children_Len(PyObject *self) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_children();
}

/**
 * sequence getter for property NotifyCategory::children
 */
static PyObject *Dtool_NotifyCategory_children_Getitem(PyObject *self, Py_ssize_t index) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_children()) {
    PyErr_SetString(PyExc_IndexError, "NotifyCategory.children[] index out of range");
    return NULL;
  }
  // 1-NotifyCategory *NotifyCategory::get_child(std::size_t i) const
  NotifyCategory *return_value = (*(const NotifyCategory*)local_this).get_child(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NotifyCategory, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(NotifyCategory self, index)\n");
  }
}

static PyObject *Dtool_NotifyCategory_children_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_NotifyCategory_children_Len;
  wrap->_getitem_func = &Dtool_NotifyCategory_children_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline NotifyCategory::NotifyCategory(NotifyCategory const &) = default
 */
static int Dtool_Init_NotifyCategory(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NotifyCategory() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline NotifyCategory::NotifyCategory(NotifyCategory const &) = default
  NotifyCategory const *arg_this = (NotifyCategory *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NotifyCategory, 0, "NotifyCategory.NotifyCategory", true, true);
  if (arg_this != NULL) {
    NotifyCategory *return_value = new NotifyCategory(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NotifyCategory, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NotifyCategory(const NotifyCategory param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_NotifyCategory_get_children(PyObject *self, PyObject *) {
  NotifyCategory *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NotifyCategory, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_children();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_NotifyCategory_get_child_698(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_NotifyCategory(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NotifyCategory) {
    printf("NotifyCategory ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NotifyCategory *local_this = (NotifyCategory *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NotifyCategory) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConfigFlags) {
    return (ConfigFlags *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NotifyCategory(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NotifyCategory) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConfigFlags) {
    ConfigFlags* other_this = (ConfigFlags*)from_this;
    return (NotifyCategory*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OEncryptStream
 */
/**
 * Python function wrapper for:
 * inline OEncryptStream &OEncryptStream::open(ostream *dest, bool owns_dest, std::string const &password)
 */
static PyObject *Dtool_OEncryptStream_open_707(PyObject *self, PyObject *args, PyObject *kwds) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.open")) {
    return NULL;
  }
  // 1-inline OEncryptStream &OEncryptStream::open(ostream *dest, bool owns_dest, std::string const &password)
  PyObject *param1;
  PyObject *param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"dest", "owns_dest", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:open", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OEncryptStream.open", false, true);
    if (param1_this != NULL) {
      OEncryptStream *return_value = &((*local_this).open(param1_this, (PyObject_IsTrue(param2) != 0), std::string(param3_str, param3_len)));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OEncryptStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OEncryptStream self, ostream dest, bool owns_dest, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_open_707_comment =
  "C++ Interface:\n"
  "open(const OEncryptStream self, ostream dest, bool owns_dest, str password)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OEncryptStream_open_707_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OEncryptStream &OEncryptStream::close(void)
 */
static PyObject *Dtool_OEncryptStream_close_708(PyObject *self, PyObject *) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.close")) {
    return NULL;
  }
  // 1-inline OEncryptStream &OEncryptStream::close(void)
  OEncryptStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OEncryptStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_close_708_comment =
  "C++ Interface:\n"
  "close(const OEncryptStream self)\n"
  "\n"
  "/**\n"
  " * Resets the EncryptStream to empty, but does not actually close the dest\n"
  " * ostream unless owns_dest was true.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_close_708_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OEncryptStream::set_algorithm(std::string const &algorithm)
 */
static PyObject *Dtool_OEncryptStream_set_algorithm_709(PyObject *self, PyObject *arg) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.set_algorithm")) {
    return NULL;
  }
  // 1-inline void OEncryptStream::set_algorithm(std::string const &algorithm)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_algorithm(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_algorithm(const OEncryptStream self, str algorithm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_set_algorithm_709_comment =
  "C++ Interface:\n"
  "set_algorithm(const OEncryptStream self, str algorithm)\n"
  "\n"
  "/**\n"
  " * Specifies the encryption algorithm that should be used for future calls to\n"
  " * open().  The default is whatever is specified by the encryption-algorithm\n"
  " * config variable.  The complete set of available algorithms is defined by\n"
  " * the current version of OpenSSL.\n"
  " *\n"
  " * If an invalid algorithm is specified, there is no immediate error return\n"
  " * code, but open() will fail.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_set_algorithm_709_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OEncryptStream::set_key_length(int key_length)
 */
static PyObject *Dtool_OEncryptStream_set_key_length_710(PyObject *self, PyObject *arg) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.set_key_length")) {
    return NULL;
  }
  // 1-inline void OEncryptStream::set_key_length(int key_length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_key_length((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_key_length(const OEncryptStream self, int key_length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_set_key_length_710_comment =
  "C++ Interface:\n"
  "set_key_length(const OEncryptStream self, int key_length)\n"
  "\n"
  "/**\n"
  " * Specifies the length of the key, in bits, that should be used to encrypt\n"
  " * the stream in future calls to open().  The default is whatever is specified\n"
  " * by the encryption-key-length config variable.\n"
  " *\n"
  " * If an invalid key_length for the chosen algorithm is specified, there is no\n"
  " * immediate error return code, but open() will fail.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_set_key_length_710_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OEncryptStream::set_iteration_count(int iteration_count)
 */
static PyObject *Dtool_OEncryptStream_set_iteration_count_711(PyObject *self, PyObject *arg) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.set_iteration_count")) {
    return NULL;
  }
  // 1-inline void OEncryptStream::set_iteration_count(int iteration_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_iteration_count((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_iteration_count(const OEncryptStream self, int iteration_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OEncryptStream_set_iteration_count_711_comment =
  "C++ Interface:\n"
  "set_iteration_count(const OEncryptStream self, int iteration_count)\n"
  "\n"
  "/**\n"
  " * Specifies the number of times to repeatedly hash the key before writing it\n"
  " * to the stream in future calls to open().  Its purpose is to make it\n"
  " * computationally more expensive for an attacker to search the key space\n"
  " * exhaustively.  This should be a multiple of 1,000 and should not exceed\n"
  " * about 65 million; the value 0 indicates just one application of the hashing\n"
  " * algorithm.\n"
  " *\n"
  " * The default is whatever is specified by the encryption-iteration-count\n"
  " * config variable.\n"
  " */";
#else
static const char *Dtool_OEncryptStream_set_iteration_count_711_comment = NULL;
#endif

static PyObject *Dtool_OEncryptStream_algorithm_Getter(PyObject *self, void *) {
  const OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OEncryptStream, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &OEncryptStream::get_algorithm(void) const
  std::string const &return_value = (*(const OEncryptStream*)local_this).get_algorithm();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OEncryptStream_algorithm_Setter(PyObject *self, PyObject *arg, void *) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.algorithm")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete algorithm attribute");
    return -1;
  }
  // 1-inline void OEncryptStream::set_algorithm(std::string const &algorithm)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_algorithm(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_algorithm(const OEncryptStream self, str algorithm)\n");
  }
  return -1;
}

static PyObject *Dtool_OEncryptStream_key_length_Getter(PyObject *self, void *) {
  const OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OEncryptStream, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int OEncryptStream::get_key_length(void) const
  int return_value = (*(const OEncryptStream*)local_this).get_key_length();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OEncryptStream_key_length_Setter(PyObject *self, PyObject *arg, void *) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.key_length")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete key_length attribute");
    return -1;
  }
  // 1-inline void OEncryptStream::set_key_length(int key_length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_key_length((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_key_length(const OEncryptStream self, int key_length)\n");
  }
  return -1;
}

static PyObject *Dtool_OEncryptStream_iteration_count_Getter(PyObject *self, void *) {
  const OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OEncryptStream, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int OEncryptStream::get_iteration_count(void) const
  int return_value = (*(const OEncryptStream*)local_this).get_iteration_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_OEncryptStream_iteration_count_Setter(PyObject *self, PyObject *arg, void *) {
  OEncryptStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OEncryptStream, (void **)&local_this, "OEncryptStream.iteration_count")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete iteration_count attribute");
    return -1;
  }
  // 1-inline void OEncryptStream::set_iteration_count(int iteration_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_iteration_count((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_iteration_count(const OEncryptStream self, int iteration_count)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline OEncryptStream::OEncryptStream(void)
 * inline OEncryptStream::OEncryptStream(ostream *dest, bool owns_dest, std::string const &password)
 */
static int Dtool_Init_OEncryptStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OEncryptStream::OEncryptStream(void)
      OEncryptStream *return_value = new OEncryptStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OEncryptStream, true, false);
    }
    break;
  case 3:
    {
      // 1-inline OEncryptStream::OEncryptStream(ostream *dest, bool owns_dest, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"dest", "owns_dest", "password", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:OEncryptStream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OEncryptStream.OEncryptStream", false, true);
        if (param0_this != NULL) {
          OEncryptStream *return_value = new OEncryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OEncryptStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OEncryptStream() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OEncryptStream()\n"
      "OEncryptStream(ostream dest, bool owns_dest, str password)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OEncryptStream(PyObject *args, OEncryptStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OEncryptStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline OEncryptStream::OEncryptStream(ostream *dest, bool owns_dest, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      if (PyArg_ParseTuple(args, "OOs#:OEncryptStream", &param0, &param1, &param2_str, &param2_len)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OEncryptStream.OEncryptStream", false, false);
        if (param0_this != NULL) {
          OEncryptStream *return_value = new OEncryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OEncryptStream(PyObject *args, OEncryptStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OEncryptStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline OEncryptStream::OEncryptStream(ostream *dest, bool owns_dest, std::string const &password)
      PyObject *param0;
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      if (PyArg_ParseTuple(args, "OOs#:OEncryptStream", &param0, &param1, &param2_str, &param2_len)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OEncryptStream.OEncryptStream", false, false);
        if (param0_this != NULL) {
          OEncryptStream *return_value = new OEncryptStream(param0_this, (PyObject_IsTrue(param1) != 0), std::string(param2_str, param2_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OEncryptStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OEncryptStream) {
    printf("OEncryptStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OEncryptStream *local_this = (OEncryptStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OEncryptStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OEncryptStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OEncryptStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (OEncryptStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OFileStream
 */
/**
 * Python function wrapper for:
 * inline void OFileStream::open(char const *filename, ios_base::openmode mode = ::ios_base::out)
 */
static PyObject *Dtool_OFileStream_open_722(PyObject *self, PyObject *args, PyObject *kwds) {
  OFileStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OFileStream, (void **)&local_this, "OFileStream.open")) {
    return NULL;
  }
  // 1-inline void OFileStream::open(char const *filename, ios_base::openmode mode = ::ios_base::out)
  char const *param1;
  int param2 = ios_base::out;
  static const char *keyword_list[] = {"filename", "mode", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:open", (char **)keyword_list, &param1, &param2)) {
    (*local_this).open((char const *)param1, (ios_base::openmode)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OFileStream self, str filename, int mode)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OFileStream_open_722_comment =
  "C++ Interface:\n"
  "open(const OFileStream self, str filename, int mode)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OFileStream_open_722_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void OFileStream::close(void)
 */
static PyObject *Dtool_OFileStream_close_723(PyObject *self, PyObject *) {
  OFileStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OFileStream, (void **)&local_this, "OFileStream.close")) {
    return NULL;
  }
  // 1-inline void OFileStream::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OFileStream_close_723_comment =
  "C++ Interface:\n"
  "close(const OFileStream self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OFileStream_close_723_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OFileStream::OFileStream(void)
 * inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode = ::ios_base::out)
 */
static int Dtool_Init_OFileStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OFileStream::OFileStream(void)
      OFileStream *return_value = new OFileStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OFileStream, true, false);
    }
    break;
  case 1:
  case 2:
    {
      // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode = ::ios_base::out)
      char const *param0;
      int param1 = ios_base::out;
      static const char *keyword_list[] = {"filename", "mode", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:OFileStream", (char **)keyword_list, &param0, &param1)) {
        OFileStream *return_value = new OFileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OFileStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OFileStream() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OFileStream()\n"
      "OFileStream(str filename, int mode)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OFileStream(PyObject *args, OFileStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OFileStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode)
    char const *param0;
    if (PyArg_Parse(arg, "z:OFileStream", &param0)) {
      OFileStream *return_value = new OFileStream((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:OFileStream", &param0, &param1)) {
        OFileStream *return_value = new OFileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OFileStream(PyObject *args, OFileStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OFileStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode)
    char const *param0;
    if (PyArg_Parse(arg, "z:OFileStream", &param0)) {
      OFileStream *return_value = new OFileStream((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline OFileStream::OFileStream(char const *filename, ios_base::openmode mode)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:OFileStream", &param0, &param1)) {
        OFileStream *return_value = new OFileStream((char const *)param0, (ios_base::openmode)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OFileStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OFileStream) {
    printf("OFileStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OFileStream *local_this = (OFileStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OFileStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OFileStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OFileStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (OFileStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OStreamWrapper
 */
/**
 * Python function wrapper for:
 * inline ostream *OStreamWrapper::get_ostream(void) const
 */
static PyObject *Dtool_OStreamWrapper_get_ostream_728(PyObject *self, PyObject *) {
  OStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OStreamWrapper, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream *OStreamWrapper::get_ostream(void) const
  ostream *return_value = (*(const OStreamWrapper*)local_this).get_ostream();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OStreamWrapper_get_ostream_728_comment =
  "C++ Interface:\n"
  "get_ostream(OStreamWrapper self)\n"
  "\n"
  "/**\n"
  " * Returns the ostream this object is wrapping.\n"
  " */";
#else
static const char *Dtool_OStreamWrapper_get_ostream_728_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * StreamWrapperBase *OStreamWrapper::upcast_to_StreamWrapperBase(void)
 */
static PyObject *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725(PyObject *self, PyObject *) {
  OStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OStreamWrapper, (void **)&local_this, "OStreamWrapper.upcast_to_StreamWrapperBase")) {
    return NULL;
  }
  // 1-StreamWrapperBase *OStreamWrapper::upcast_to_StreamWrapperBase(void)
  StreamWrapperBase *return_value = (StreamWrapperBase *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWrapperBase, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725_comment =
  "C++ Interface:\n"
  "upcast_to_StreamWrapperBase(const OStreamWrapper self)\n"
  "\n"
  "upcast from OStreamWrapper to StreamWrapperBase";
#else
static const char *Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * StreamWrapper *OStreamWrapper::downcast_to_StreamWrapper(void)
 */
static PyObject *Dtool_OStreamWrapper_downcast_to_StreamWrapper_875(PyObject *self, PyObject *) {
  OStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OStreamWrapper, (void **)&local_this, "OStreamWrapper.downcast_to_StreamWrapper")) {
    return NULL;
  }
  // 1-StreamWrapper *OStreamWrapper::downcast_to_StreamWrapper(void)
  StreamWrapper *return_value = (StreamWrapper *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OStreamWrapper_downcast_to_StreamWrapper_875_comment =
  "C++ Interface:\n"
  "downcast_to_StreamWrapper(const OStreamWrapper self)\n"
  "\n"
  "downcast from OStreamWrapper to StreamWrapper";
#else
static const char *Dtool_OStreamWrapper_downcast_to_StreamWrapper_875_comment = NULL;
#endif

static PyObject *Dtool_OStreamWrapper_ostream_Getter(PyObject *self, void *) {
  const OStreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OStreamWrapper, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ostream *OStreamWrapper::get_ostream(void) const
  ostream *return_value = (*(const OStreamWrapper*)local_this).get_ostream();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

/**
 * Python function wrapper for:
 * inline OStreamWrapper::OStreamWrapper(OStreamWrapper const &) = default
 * inline OStreamWrapper::OStreamWrapper(ostream &stream)
 */
static int Dtool_Init_OStreamWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OStreamWrapper() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline OStreamWrapper::OStreamWrapper(ostream &stream)
    PyObject *param0;
    static const char *keyword_list[] = {"stream", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OStreamWrapper", (char **)keyword_list, &param0)) {
      ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OStreamWrapper.OStreamWrapper", false, false);
      if (param0_this != NULL) {
        OStreamWrapper *return_value = new OStreamWrapper(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OStreamWrapper, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline OStreamWrapper::OStreamWrapper(ostream &stream)
  {
    // -2 inline OStreamWrapper::OStreamWrapper(OStreamWrapper const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:OStreamWrapper", (char **)keyword_list, &param0)) {
      OStreamWrapper const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_OStreamWrapper(param0, param0_this, param0_manage)) {
        OStreamWrapper *return_value = new OStreamWrapper(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OStreamWrapper, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OStreamWrapper(ostream stream)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OStreamWrapper(PyObject *args, OStreamWrapper const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OStreamWrapper, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline OStreamWrapper::OStreamWrapper(ostream &stream)
    ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "OStreamWrapper.OStreamWrapper", false, false);
    if (arg_this != NULL) {
      OStreamWrapper *return_value = new OStreamWrapper(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_OStreamWrapper(PyObject *args, OStreamWrapper *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OStreamWrapper, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline OStreamWrapper::OStreamWrapper(ostream &stream)
    ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "OStreamWrapper.OStreamWrapper", false, false);
    if (arg_this != NULL) {
      OStreamWrapper *return_value = new OStreamWrapper(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_OStreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OStreamWrapper) {
    printf("OStreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OStreamWrapper *local_this = (OStreamWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OStreamWrapper) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return (StreamWrapperBase *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OStreamWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OStreamWrapper) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< double >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< double > PointerToArray< double >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((double const *)(0))))
 */
static PyObject *Dtool_PointerToArray_double_empty_array_734(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< double > PointerToArray< double >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< double > *return_value = new PointerToArray< double >(PointerToArray< double >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_double, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< double > PointerToArray< double >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< double > *return_value = new PointerToArray< double >(PointerToArray< double >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_double, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_empty_array_734_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_double_empty_array_734_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::push_back(double const &x)
 */
static PyObject *Dtool_PointerToArray_double_push_back_736(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< double >::push_back(double const &x)
  if (PyNumber_Check(arg)) {
    (*local_this).push_back(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, double x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_push_back_736_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, double x)\n";
#else
static const char *Dtool_PointerToArray_double_push_back_736_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_double_pop_back_737(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< double >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_pop_back_737_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_pop_back_737_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double const &PointerToArray< double >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_double_get_element_738(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline double const &PointerToArray< double >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    double return_value = (*(const PointerToArray< double >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_element_738_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_double_get_element_738_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::set_element(unsigned long int n, double const &value)
 */
static PyObject *Dtool_PointerToArray_double_set_element_739(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< double >::set_element(unsigned long int n, double const &value)
  unsigned long param1;
  double param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kd:set_element", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_element((unsigned long int)param1, (double const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_set_element_739_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, double value)\n";
#else
static const char *Dtool_PointerToArray_double_set_element_739_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< double >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_double_get_data_742(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< double >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< double >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_data_742_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_get_data_742_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_double_set_data_743(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< double >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_set_data_743_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_double_set_data_743_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_double_get_subdata_744(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< double >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_subdata_744_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_double_get_subdata_744_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_double_set_subdata_745(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< double >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_set_subdata_745_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_double_set_subdata_745_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< double >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_double_get_ref_count_746(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< double >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< double >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_ref_count_746_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_get_ref_count_746_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< double >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_double_get_node_ref_count_747(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< double >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< double >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_node_ref_count_747_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_get_node_ref_count_747_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
 * PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< double >::PointerToArray(TypeHandle type_handle = (_get_type_handle((double const *)(0))))
 */
static int Dtool_Init_PointerToArray_double(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
      PointerToArray< double > *return_value = new PointerToArray< double >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< double > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_double, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_double, false, false);
          PointerToArray< double > *result = new PointerToArray< double >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< double > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< double > param0_local;
          PointerToArray< double > const *param0_this = Dtool_Coerce_PointerToArray_double(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< double > *Dtool_Coerce_PointerToArray_double(PyObject *args, PointerToArray< double > &coerced) {
  PointerToArray< double > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_double, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< double > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< double >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_double(&Dtool_PointerToArray_double._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_double) {
    printf("PointerToArray_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< double > *local_this = (PointerToArray< double > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_double) {
    return (PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return (PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_double) {
    PointerToArrayBase< double >* other_this = (PointerToArrayBase< double >*)from_this;
    return (PointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
    return (PointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< double >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< float >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< float > PointerToArray< float >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((float const *)(0))))
 */
static PyObject *Dtool_PointerToArray_float_empty_array_754(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< float > PointerToArray< float >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< float > *return_value = new PointerToArray< float >(PointerToArray< float >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_float, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< float > PointerToArray< float >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< float > *return_value = new PointerToArray< float >(PointerToArray< float >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_float, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_empty_array_754_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_float_empty_array_754_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::push_back(float const &x)
 */
static PyObject *Dtool_PointerToArray_float_push_back_756(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< float >::push_back(float const &x)
  if (PyNumber_Check(arg)) {
    (*local_this).push_back((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, float x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_push_back_756_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, float x)\n";
#else
static const char *Dtool_PointerToArray_float_push_back_756_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_float_pop_back_757(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< float >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_pop_back_757_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_pop_back_757_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float const &PointerToArray< float >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_float_get_element_758(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float const &PointerToArray< float >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    float return_value = (*(const PointerToArray< float >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_element_758_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_float_get_element_758_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::set_element(unsigned long int n, float const &value)
 */
static PyObject *Dtool_PointerToArray_float_set_element_759(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< float >::set_element(unsigned long int n, float const &value)
  unsigned long param1;
  float param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kf:set_element", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_element((unsigned long int)param1, (float const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_set_element_759_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, float value)\n";
#else
static const char *Dtool_PointerToArray_float_set_element_759_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< float >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_float_get_data_762(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< float >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< float >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_data_762_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_get_data_762_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_float_set_data_763(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< float >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_set_data_763_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_float_set_data_763_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_float_get_subdata_764(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< float >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_subdata_764_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_float_get_subdata_764_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_float_set_subdata_765(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< float >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_set_subdata_765_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_float_set_subdata_765_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< float >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_float_get_ref_count_766(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< float >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< float >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_ref_count_766_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_get_ref_count_766_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< float >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_float_get_node_ref_count_767(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< float >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< float >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_node_ref_count_767_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_get_node_ref_count_767_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
 * PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< float >::PointerToArray(TypeHandle type_handle = (_get_type_handle((float const *)(0))))
 */
static int Dtool_Init_PointerToArray_float(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
      PointerToArray< float > *return_value = new PointerToArray< float >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< float > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_float, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_float, false, false);
          PointerToArray< float > *result = new PointerToArray< float >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< float > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< float > param0_local;
          PointerToArray< float > const *param0_this = Dtool_Coerce_PointerToArray_float(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced) {
  PointerToArray< float > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_float, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< float > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< float >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_float(&Dtool_PointerToArray_float._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_float) {
    printf("PointerToArray_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< float > *local_this = (PointerToArray< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_float) {
    return (PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return (PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_float) {
    PointerToArrayBase< float >* other_this = (PointerToArrayBase< float >*)from_this;
    return (PointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
    return (PointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< float >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< int >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< int > PointerToArray< int >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((int const *)(0))))
 */
static PyObject *Dtool_PointerToArray_int_empty_array_774(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< int > PointerToArray< int >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< int > *return_value = new PointerToArray< int >(PointerToArray< int >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_int, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< int > PointerToArray< int >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< int > *return_value = new PointerToArray< int >(PointerToArray< int >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_int, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_empty_array_774_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_int_empty_array_774_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::push_back(int const &x)
 */
static PyObject *Dtool_PointerToArray_int_push_back_776(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< int >::push_back(int const &x)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).push_back((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_push_back_776_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, int x)\n";
#else
static const char *Dtool_PointerToArray_int_push_back_776_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_int_pop_back_777(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< int >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_pop_back_777_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_pop_back_777_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int const &PointerToArray< int >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_int_get_element_778(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int const &PointerToArray< int >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    int return_value = (*(const PointerToArray< int >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_element_778_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_int_get_element_778_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::set_element(unsigned long int n, int const &value)
 */
static PyObject *Dtool_PointerToArray_int_set_element_779(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< int >::set_element(unsigned long int n, int const &value)
  unsigned long param1;
  int param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ki:set_element", (char **)keyword_list, &param1, &param2)) {
    (*local_this).set_element((unsigned long int)param1, (int const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_set_element_779_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, int value)\n";
#else
static const char *Dtool_PointerToArray_int_set_element_779_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< int >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_int_get_data_782(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< int >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< int >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_data_782_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_get_data_782_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_int_set_data_783(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< int >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_set_data_783_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_int_set_data_783_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_int_get_subdata_784(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< int >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_subdata_784_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_int_get_subdata_784_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_int_set_subdata_785(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< int >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_set_subdata_785_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_int_set_subdata_785_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< int >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_int_get_ref_count_786(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< int >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< int >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_ref_count_786_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_get_ref_count_786_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< int >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_int_get_node_ref_count_787(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< int >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< int >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_node_ref_count_787_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_get_node_ref_count_787_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
 * PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< int >::PointerToArray(TypeHandle type_handle = (_get_type_handle((int const *)(0))))
 */
static int Dtool_Init_PointerToArray_int(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
      PointerToArray< int > *return_value = new PointerToArray< int >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< int > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_int, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_int, false, false);
          PointerToArray< int > *result = new PointerToArray< int >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< int > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< int > param0_local;
          PointerToArray< int > const *param0_this = Dtool_Coerce_PointerToArray_int(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< int > *Dtool_Coerce_PointerToArray_int(PyObject *args, PointerToArray< int > &coerced) {
  PointerToArray< int > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_int, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< int > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< int >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_int(&Dtool_PointerToArray_int._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_int) {
    printf("PointerToArray_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< int > *local_this = (PointerToArray< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_int) {
    return (PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return (PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_int) {
    PointerToArrayBase< int >* other_this = (PointerToArrayBase< int >*)from_this;
    return (PointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
    return (PointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< int >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToArray< unsigned char >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< unsigned char > PointerToArray< unsigned char >::empty_array(unsigned long int n, TypeHandle type_handle = (_get_type_handle((unsigned char const *)(0))))
 */
static PyObject *Dtool_PointerToArray_unsigned_char_empty_array_794(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "n");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'n' (pos 1) not found");
      }
      // 1-static inline PointerToArray< unsigned char > PointerToArray< unsigned char >::empty_array(unsigned long int n, TypeHandle type_handle)
      if (PyLongOrInt_Check(arg)) {
        unsigned long param0 = PyLong_AsUnsignedLong(arg);
        PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(PointerToArray< unsigned char >::empty_array((unsigned long int)param0));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-static inline PointerToArray< unsigned char > PointerToArray< unsigned char >::empty_array(unsigned long int n, TypeHandle type_handle)
      unsigned long param0;
      PyObject *param1;
      static const char *keyword_list[] = {"n", "type_handle", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "kO:empty_array", (char **)keyword_list, &param0, &param1)) {
        TypeHandle param1_local;
        TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
        }
        PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(PointerToArray< unsigned char >::empty_array((unsigned long int)param0, *param1_this));
        if (return_value == NULL) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return NULL;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "empty_array() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n)\n"
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_empty_array_794_comment =
  "C++ Interface:\n"
  "empty_array(int n)\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_empty_array_794_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::push_back(unsigned char const &x)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_push_back_796(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.push_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< unsigned char >::push_back(unsigned char const &x)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    (*local_this).push_back((unsigned char)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, int x)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_push_back_796_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, int x)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_push_back_796_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_pop_back_797(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.pop_back")) {
    return NULL;
  }
  // 1-inline void PointerToArray< unsigned char >::pop_back(void)
  (*local_this).pop_back();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_pop_back_797_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_pop_back_797_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char const &PointerToArray< unsigned char >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_element_798(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline unsigned char const &PointerToArray< unsigned char >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    unsigned char return_value = (*(const PointerToArray< unsigned char >*)local_this).get_element((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_element_798_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_element_798_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::set_element(unsigned long int n, unsigned char const &value)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_set_element_799(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.set_element")) {
    return NULL;
  }
  // 1-inline void PointerToArray< unsigned char >::set_element(unsigned long int n, unsigned char const &value)
  unsigned long param1;
  long param2;
  static const char *keyword_list[] = {"n", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kl:set_element", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0 || param2 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param2);
    }
#endif
    (*local_this).set_element((unsigned long int)param1, (unsigned char const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_set_element_799_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, int value)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_set_element_799_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< unsigned char >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_data_802(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< unsigned char >::get_data(void) const
  std::basic_string< char > return_value = (*(const PointerToArray< unsigned char >*)local_this).get_data();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_data_802_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_data_802_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::set_data(std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_set_data_803(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.set_data")) {
    return NULL;
  }
  // 1-inline void PointerToArray< unsigned char >::set_data(std::basic_string< char > const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_set_data_803_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, str data)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_set_data_803_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::basic_string< char > PointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_subdata_804(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::basic_string< char > PointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    std::basic_string< char > return_value = (*(const PointerToArray< unsigned char >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_subdata_804_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_subdata_804_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_set_subdata_805(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.set_subdata")) {
    return NULL;
  }
  // 1-inline void PointerToArray< unsigned char >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    (*local_this).set_subdata((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_set_subdata_805_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_set_subdata_805_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< unsigned char >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_ref_count_806(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< unsigned char >::get_ref_count(void) const
  int return_value = (*(const PointerToArray< unsigned char >*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_ref_count_806_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_ref_count_806_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< unsigned char >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_node_ref_count_807(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int PointerToArray< unsigned char >::get_node_ref_count(void) const
  int return_value = (*(const PointerToArray< unsigned char >*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_node_ref_count_807_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_node_ref_count_807_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
 * PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle = (_get_type_handle((unsigned char const *)(0))))
 */
static int Dtool_Init_PointerToArray_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
      PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< unsigned char > const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_PointerToArray_unsigned_char, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TypeHandle, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        static const char *keyword_list[] = {"source", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, NULL, &Dtool_PointerToArray_unsigned_char, false, false);
          PointerToArray< unsigned char > *result = new PointerToArray< unsigned char >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< unsigned char > *return_value = result;
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != (PyObject *)NULL) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (notify->has_assert_failed()) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          PointerToArray< unsigned char > param0_local;
          PointerToArray< unsigned char > const *param0_this = Dtool_Coerce_PointerToArray_unsigned_char(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        static const char *keyword_list[] = {"type_handle", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerToArray", (char **)keyword_list, &param0)) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != NULL)) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced) {
  PointerToArray< unsigned char > *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerToArray_unsigned_char, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< unsigned char > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_TypeHandle, (void **)&arg_this);
      if (arg_this != NULL) {
        coerced = PointerToArray< unsigned char >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return NULL;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_unsigned_char(&Dtool_PointerToArray_unsigned_char._PyType, NULL, NULL);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }

  }
  return NULL;
}

static void *Dtool_UpcastInterface_PointerToArray_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToArray_unsigned_char) {
    printf("PointerToArray_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToArray< unsigned char > *local_this = (PointerToArray< unsigned char > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToArray_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return (PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return (PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToArray_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToArray_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    PointerToArrayBase< unsigned char >* other_this = (PointerToArrayBase< unsigned char >*)from_this;
    return (PointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
    return (PointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< unsigned char >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PandaSystem
 */
/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_version_string(void)
 */
static PyObject *Dtool_PandaSystem_get_version_string_812(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_version_string(void)
  std::string return_value = PandaSystem::get_version_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_version_string_812_comment =
  "C++ Interface:\n"
  "get_version_string()\n";
#else
static const char *Dtool_PandaSystem_get_version_string_812_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_package_version_string(void)
 */
static PyObject *Dtool_PandaSystem_get_package_version_string_813(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_package_version_string(void)
  std::string return_value = PandaSystem::get_package_version_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_package_version_string_813_comment =
  "C++ Interface:\n"
  "get_package_version_string()\n";
#else
static const char *Dtool_PandaSystem_get_package_version_string_813_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_package_host_url(void)
 */
static PyObject *Dtool_PandaSystem_get_package_host_url_814(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_package_host_url(void)
  std::string return_value = PandaSystem::get_package_host_url();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_package_host_url_814_comment =
  "C++ Interface:\n"
  "get_package_host_url()\n";
#else
static const char *Dtool_PandaSystem_get_package_host_url_814_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_p3d_coreapi_version_string(void)
 */
static PyObject *Dtool_PandaSystem_get_p3d_coreapi_version_string_815(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_p3d_coreapi_version_string(void)
  std::string return_value = PandaSystem::get_p3d_coreapi_version_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_p3d_coreapi_version_string_815_comment =
  "C++ Interface:\n"
  "get_p3d_coreapi_version_string()\n";
#else
static const char *Dtool_PandaSystem_get_p3d_coreapi_version_string_815_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_major_version(void)
 */
static PyObject *Dtool_PandaSystem_get_major_version_816(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_major_version(void)
  int return_value = PandaSystem::get_major_version();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_major_version_816_comment =
  "C++ Interface:\n"
  "get_major_version()\n";
#else
static const char *Dtool_PandaSystem_get_major_version_816_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_minor_version(void)
 */
static PyObject *Dtool_PandaSystem_get_minor_version_817(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_minor_version(void)
  int return_value = PandaSystem::get_minor_version();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_minor_version_817_comment =
  "C++ Interface:\n"
  "get_minor_version()\n";
#else
static const char *Dtool_PandaSystem_get_minor_version_817_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int PandaSystem::get_sequence_version(void)
 */
static PyObject *Dtool_PandaSystem_get_sequence_version_818(PyObject *, PyObject *) {
  // 1-static int PandaSystem::get_sequence_version(void)
  int return_value = PandaSystem::get_sequence_version();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_sequence_version_818_comment =
  "C++ Interface:\n"
  "get_sequence_version()\n";
#else
static const char *Dtool_PandaSystem_get_sequence_version_818_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool PandaSystem::is_official_version(void)
 */
static PyObject *Dtool_PandaSystem_is_official_version_819(PyObject *, PyObject *) {
  // 1-static bool PandaSystem::is_official_version(void)
  bool return_value = PandaSystem::is_official_version();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_is_official_version_819_comment =
  "C++ Interface:\n"
  "is_official_version()\n";
#else
static const char *Dtool_PandaSystem_is_official_version_819_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_distributor(void)
 */
static PyObject *Dtool_PandaSystem_get_distributor_820(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_distributor(void)
  std::string return_value = PandaSystem::get_distributor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_distributor_820_comment =
  "C++ Interface:\n"
  "get_distributor()\n";
#else
static const char *Dtool_PandaSystem_get_distributor_820_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_compiler(void)
 */
static PyObject *Dtool_PandaSystem_get_compiler_821(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_compiler(void)
  std::string return_value = PandaSystem::get_compiler();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_compiler_821_comment =
  "C++ Interface:\n"
  "get_compiler()\n";
#else
static const char *Dtool_PandaSystem_get_compiler_821_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_build_date(void)
 */
static PyObject *Dtool_PandaSystem_get_build_date_822(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_build_date(void)
  std::string return_value = PandaSystem::get_build_date();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_build_date_822_comment =
  "C++ Interface:\n"
  "get_build_date()\n";
#else
static const char *Dtool_PandaSystem_get_build_date_822_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_git_commit(void)
 */
static PyObject *Dtool_PandaSystem_get_git_commit_823(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_git_commit(void)
  std::string return_value = PandaSystem::get_git_commit();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_git_commit_823_comment =
  "C++ Interface:\n"
  "get_git_commit()\n";
#else
static const char *Dtool_PandaSystem_get_git_commit_823_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string PandaSystem::get_platform(void)
 */
static PyObject *Dtool_PandaSystem_get_platform_824(PyObject *, PyObject *) {
  // 1-static std::string PandaSystem::get_platform(void)
  std::string return_value = PandaSystem::get_platform();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_platform_824_comment =
  "C++ Interface:\n"
  "get_platform()\n";
#else
static const char *Dtool_PandaSystem_get_platform_824_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PandaSystem::has_system(std::string const &system) const
 */
static PyObject *Dtool_PandaSystem_has_system_825(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool PandaSystem::has_system(std::string const &system) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const PandaSystem*)local_this).has_system(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_system(PandaSystem self, str system)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_has_system_825_comment =
  "C++ Interface:\n"
  "has_system(PandaSystem self, str system)\n";
#else
static const char *Dtool_PandaSystem_has_system_825_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t PandaSystem::get_num_systems(void) const
 */
static PyObject *Dtool_PandaSystem_get_num_systems_826(PyObject *self, PyObject *) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t PandaSystem::get_num_systems(void) const
  std::size_t return_value = (*(const PandaSystem*)local_this).get_num_systems();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_num_systems_826_comment =
  "C++ Interface:\n"
  "get_num_systems(PandaSystem self)\n";
#else
static const char *Dtool_PandaSystem_get_num_systems_826_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string PandaSystem::get_system(std::size_t n) const
 */
static PyObject *Dtool_PandaSystem_get_system_827(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string PandaSystem::get_system(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_system", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const PandaSystem*)local_this).get_system((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system(PandaSystem self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_system_827_comment =
  "C++ Interface:\n"
  "get_system(PandaSystem self, int n)\n";
#else
static const char *Dtool_PandaSystem_get_system_827_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string PandaSystem::get_system_tag(std::string const &system, std::string const &tag) const
 */
static PyObject *Dtool_PandaSystem_get_system_tag_830(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string PandaSystem::get_system_tag(std::string const &system, std::string const &tag) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"system", "tag", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:get_system_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    std::string return_value = (*(const PandaSystem*)local_this).get_system_tag(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system_tag(PandaSystem self, str system, str tag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_system_tag_830_comment =
  "C++ Interface:\n"
  "get_system_tag(PandaSystem self, str system, str tag)\n";
#else
static const char *Dtool_PandaSystem_get_system_tag_830_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::add_system(std::string const &system)
 */
static PyObject *Dtool_PandaSystem_add_system_831(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaSystem, (void **)&local_this, "PandaSystem.add_system")) {
    return NULL;
  }
  // 1-void PandaSystem::add_system(std::string const &system)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_system(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_system(const PandaSystem self, str system)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_add_system_831_comment =
  "C++ Interface:\n"
  "add_system(const PandaSystem self, str system)\n";
#else
static const char *Dtool_PandaSystem_add_system_831_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::set_system_tag(std::string const &system, std::string const &tag, std::string const &value)
 */
static PyObject *Dtool_PandaSystem_set_system_tag_832(PyObject *self, PyObject *args, PyObject *kwds) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaSystem, (void **)&local_this, "PandaSystem.set_system_tag")) {
    return NULL;
  }
  // 1-void PandaSystem::set_system_tag(std::string const &system, std::string const &tag, std::string const &value)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  char *param3_str = NULL;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"system", "tag", "value", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:set_system_tag", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
    (*local_this).set_system_tag(std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_system_tag(const PandaSystem self, str system, str tag, str value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_set_system_tag_832_comment =
  "C++ Interface:\n"
  "set_system_tag(const PandaSystem self, str system, str tag, str value)\n";
#else
static const char *Dtool_PandaSystem_set_system_tag_832_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool PandaSystem::heap_trim(std::size_t pad)
 */
static PyObject *Dtool_PandaSystem_heap_trim_833(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PandaSystem, (void **)&local_this, "PandaSystem.heap_trim")) {
    return NULL;
  }
  // 1-bool PandaSystem::heap_trim(std::size_t pad)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:heap_trim", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    bool return_value = (*local_this).heap_trim((std::size_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "heap_trim(const PandaSystem self, int pad)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_heap_trim_833_comment =
  "C++ Interface:\n"
  "heap_trim(const PandaSystem self, int pad)\n";
#else
static const char *Dtool_PandaSystem_heap_trim_833_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::output(ostream &out) const
 */
static PyObject *Dtool_PandaSystem_output_834(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PandaSystem::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PandaSystem.output", false, true);
  if (arg_this != NULL) {
    (*(const PandaSystem*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PandaSystem self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_output_834_comment =
  "C++ Interface:\n"
  "output(PandaSystem self, ostream out)\n";
#else
static const char *Dtool_PandaSystem_output_834_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PandaSystem::write(ostream &out) const
 */
static PyObject *Dtool_PandaSystem_write_835(PyObject *self, PyObject *arg) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PandaSystem::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PandaSystem.write", false, true);
  if (arg_this != NULL) {
    (*(const PandaSystem*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PandaSystem self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_write_835_comment =
  "C++ Interface:\n"
  "write(PandaSystem self, ostream out)\n";
#else
static const char *Dtool_PandaSystem_write_835_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static PandaSystem *PandaSystem::get_global_ptr(void)
 */
static PyObject *Dtool_PandaSystem_get_global_ptr_836(PyObject *, PyObject *) {
  // 1-static PandaSystem *PandaSystem::get_global_ptr(void)
  PandaSystem *return_value = PandaSystem::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PandaSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_global_ptr_836_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_PandaSystem_get_global_ptr_836_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PandaSystem::get_class_type(void)
 */
static PyObject *Dtool_PandaSystem_get_class_type_837(PyObject *, PyObject *) {
  // 1-static TypeHandle PandaSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(PandaSystem::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PandaSystem_get_class_type_837_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PandaSystem_get_class_type_837_comment = NULL;
#endif

/**
 * sequence length function for property PandaSystem::systems
 */
static Py_ssize_t Dtool_PandaSystem_systems_Len(PyObject *self) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_systems();
}

/**
 * sequence getter for property PandaSystem::systems
 */
static PyObject *Dtool_PandaSystem_systems_Getitem(PyObject *self, Py_ssize_t index) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_systems()) {
    PyErr_SetString(PyExc_IndexError, "PandaSystem.systems[] index out of range");
    return NULL;
  }
  // 1-std::string PandaSystem::get_system(std::size_t n) const
  std::string return_value = (*(const PandaSystem*)local_this).get_system(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system(PandaSystem self, index)\n");
  }
}

static PyObject *Dtool_PandaSystem_systems_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_PandaSystem_systems_Len;
  wrap->_getitem_func = &Dtool_PandaSystem_systems_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

static int Dtool_Init_PandaSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PandaSystem_get_systems(PyObject *self, PyObject *) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_systems();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PandaSystem_get_system_827(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PandaSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PandaSystem) {
    printf("PandaSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PandaSystem *local_this = (PandaSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PandaSystem) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PandaSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PandaSystem) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StreamReader
 */
/**
 * Python function wrapper for:
 * inline void StreamReader::operator =(StreamReader const &copy)
 */
static PyObject *Dtool_StreamReader_operator_840(PyObject *self, PyObject *arg) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.assign")) {
    return NULL;
  }
  // 1-inline void StreamReader::operator =(StreamReader const &copy)
  StreamReader const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_StreamReader(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "StreamReader.assign", "StreamReader");
  }
  (*local_this).operator =(*arg_this);
  StreamReader *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamReader, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StreamReader self, const StreamReader copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_operator_840_comment =
  "C++ Interface:\n"
  "assign(const StreamReader self, const StreamReader copy)\n";
#else
static const char *Dtool_StreamReader_operator_840_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline istream *StreamReader::get_istream(void) const
 */
static PyObject *Dtool_StreamReader_get_istream_842(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamReader, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline istream *StreamReader::get_istream(void) const
  istream *return_value = (*(const StreamReader*)local_this).get_istream();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_istream_842_comment =
  "C++ Interface:\n"
  "get_istream(StreamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the stream in use.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_istream_842_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool StreamReader::get_bool(void)
 */
static PyObject *Dtool_StreamReader_get_bool_844(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_bool")) {
    return NULL;
  }
  // 1-inline bool StreamReader::get_bool(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).get_bool();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_bool_844_comment =
  "C++ Interface:\n"
  "get_bool(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a boolean value.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_bool_844_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int8_t StreamReader::get_int8(void)
 */
static PyObject *Dtool_StreamReader_get_int8_845(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int8")) {
    return NULL;
  }
  // 1-inline int8_t StreamReader::get_int8(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int8_t return_value = (*local_this).get_int8();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int8_845_comment =
  "C++ Interface:\n"
  "get_int8(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 8-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int8_845_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint8_t StreamReader::get_uint8(void)
 */
static PyObject *Dtool_StreamReader_get_uint8_846(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint8")) {
    return NULL;
  }
  // 1-inline uint8_t StreamReader::get_uint8(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint8_t return_value = (*local_this).get_uint8();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint8_846_comment =
  "C++ Interface:\n"
  "get_uint8(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 8-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint8_846_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int16_t StreamReader::get_int16(void)
 */
static PyObject *Dtool_StreamReader_get_int16_847(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int16")) {
    return NULL;
  }
  // 1-inline int16_t StreamReader::get_int16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int16_t return_value = (*local_this).get_int16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int16_847_comment =
  "C++ Interface:\n"
  "get_int16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int16_847_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int32_t StreamReader::get_int32(void)
 */
static PyObject *Dtool_StreamReader_get_int32_848(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int32")) {
    return NULL;
  }
  // 1-inline int32_t StreamReader::get_int32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int32_t return_value = (*local_this).get_int32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int32_848_comment =
  "C++ Interface:\n"
  "get_int32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int32_848_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t StreamReader::get_int64(void)
 */
static PyObject *Dtool_StreamReader_get_int64_849(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_int64")) {
    return NULL;
  }
  // 1-inline int64_t StreamReader::get_int64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int64_t return_value = (*local_this).get_int64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_int64_849_comment =
  "C++ Interface:\n"
  "get_int64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_int64_849_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t StreamReader::get_uint16(void)
 */
static PyObject *Dtool_StreamReader_get_uint16_850(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint16")) {
    return NULL;
  }
  // 1-inline uint16_t StreamReader::get_uint16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint16_t return_value = (*local_this).get_uint16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint16_850_comment =
  "C++ Interface:\n"
  "get_uint16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint16_850_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t StreamReader::get_uint32(void)
 */
static PyObject *Dtool_StreamReader_get_uint32_851(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint32")) {
    return NULL;
  }
  // 1-inline uint32_t StreamReader::get_uint32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint32_t return_value = (*local_this).get_uint32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint32_851_comment =
  "C++ Interface:\n"
  "get_uint32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint32_851_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t StreamReader::get_uint64(void)
 */
static PyObject *Dtool_StreamReader_get_uint64_852(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_uint64")) {
    return NULL;
  }
  // 1-inline uint64_t StreamReader::get_uint64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint64_t return_value = (*local_this).get_uint64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_uint64_852_comment =
  "C++ Interface:\n"
  "get_uint64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_uint64_852_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float StreamReader::get_float32(void)
 */
static PyObject *Dtool_StreamReader_get_float32_853(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_float32")) {
    return NULL;
  }
  // 1-inline float StreamReader::get_float32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  float return_value = (*local_this).get_float32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_float32_853_comment =
  "C++ Interface:\n"
  "get_float32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit single-precision floating-point number.  Since this kind\n"
  " * of float is not necessarily portable across different architectures,\n"
  " * special care is required.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_float32_853_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 StreamReader::get_float64(void)
 */
static PyObject *Dtool_StreamReader_get_float64_854(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_float64")) {
    return NULL;
  }
  // 1-inline PN_float64 StreamReader::get_float64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PN_float64 return_value = (*local_this).get_float64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_float64_854_comment =
  "C++ Interface:\n"
  "get_float64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit floating-point number.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_float64_854_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int16_t StreamReader::get_be_int16(void)
 */
static PyObject *Dtool_StreamReader_get_be_int16_855(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_int16")) {
    return NULL;
  }
  // 1-inline int16_t StreamReader::get_be_int16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int16_t return_value = (*local_this).get_be_int16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_int16_855_comment =
  "C++ Interface:\n"
  "get_be_int16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed big-endian 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_int16_855_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int32_t StreamReader::get_be_int32(void)
 */
static PyObject *Dtool_StreamReader_get_be_int32_856(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_int32")) {
    return NULL;
  }
  // 1-inline int32_t StreamReader::get_be_int32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int32_t return_value = (*local_this).get_be_int32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_int32_856_comment =
  "C++ Interface:\n"
  "get_be_int32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed big-endian 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_int32_856_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t StreamReader::get_be_int64(void)
 */
static PyObject *Dtool_StreamReader_get_be_int64_857(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_int64")) {
    return NULL;
  }
  // 1-inline int64_t StreamReader::get_be_int64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int64_t return_value = (*local_this).get_be_int64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_int64_857_comment =
  "C++ Interface:\n"
  "get_be_int64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed big-endian 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_int64_857_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t StreamReader::get_be_uint16(void)
 */
static PyObject *Dtool_StreamReader_get_be_uint16_858(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_uint16")) {
    return NULL;
  }
  // 1-inline uint16_t StreamReader::get_be_uint16(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint16_t return_value = (*local_this).get_be_uint16();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_uint16_858_comment =
  "C++ Interface:\n"
  "get_be_uint16(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned big-endian 16-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_uint16_858_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t StreamReader::get_be_uint32(void)
 */
static PyObject *Dtool_StreamReader_get_be_uint32_859(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_uint32")) {
    return NULL;
  }
  // 1-inline uint32_t StreamReader::get_be_uint32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint32_t return_value = (*local_this).get_be_uint32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_uint32_859_comment =
  "C++ Interface:\n"
  "get_be_uint32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned big-endian 32-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_uint32_859_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t StreamReader::get_be_uint64(void)
 */
static PyObject *Dtool_StreamReader_get_be_uint64_860(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_uint64")) {
    return NULL;
  }
  // 1-inline uint64_t StreamReader::get_be_uint64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  uint64_t return_value = (*local_this).get_be_uint64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_uint64_860_comment =
  "C++ Interface:\n"
  "get_be_uint64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned big-endian 64-bit integer.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_uint64_860_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float StreamReader::get_be_float32(void)
 */
static PyObject *Dtool_StreamReader_get_be_float32_861(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_float32")) {
    return NULL;
  }
  // 1-inline float StreamReader::get_be_float32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  float return_value = (*local_this).get_be_float32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_float32_861_comment =
  "C++ Interface:\n"
  "get_be_float32(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit single-precision big-endian floating-point number.  Since\n"
  " * this kind of float is not necessarily portable across different\n"
  " * architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_float32_861_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 StreamReader::get_be_float64(void)
 */
static PyObject *Dtool_StreamReader_get_be_float64_862(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_be_float64")) {
    return NULL;
  }
  // 1-inline PN_float64 StreamReader::get_be_float64(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PN_float64 return_value = (*local_this).get_be_float64();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_be_float64_862_comment =
  "C++ Interface:\n"
  "get_be_float64(const StreamReader self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit big-endian floating-point number.\n"
  " */";
#else
static const char *Dtool_StreamReader_get_be_float64_862_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_string(void)
 */
static PyObject *Dtool_StreamReader_get_string_863(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_string")) {
    return NULL;
  }
  // 1-std::string StreamReader::get_string(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::string return_value = (*local_this).get_string();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_string_863_comment =
  "C++ Interface:\n"
  "get_string(const StreamReader self)\n";
#else
static const char *Dtool_StreamReader_get_string_863_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_string32(void)
 */
static PyObject *Dtool_StreamReader_get_string32_864(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_string32")) {
    return NULL;
  }
  // 1-std::string StreamReader::get_string32(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::string return_value = (*local_this).get_string32();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_string32_864_comment =
  "C++ Interface:\n"
  "get_string32(const StreamReader self)\n";
#else
static const char *Dtool_StreamReader_get_string32_864_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_z_string(void)
 */
static PyObject *Dtool_StreamReader_get_z_string_865(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_z_string")) {
    return NULL;
  }
  // 1-std::string StreamReader::get_z_string(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::string return_value = (*local_this).get_z_string();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_z_string_865_comment =
  "C++ Interface:\n"
  "get_z_string(const StreamReader self)\n";
#else
static const char *Dtool_StreamReader_get_z_string_865_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string StreamReader::get_fixed_string(std::size_t size)
 */
static PyObject *Dtool_StreamReader_get_fixed_string_866(PyObject *self, PyObject *arg) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.get_fixed_string")) {
    return NULL;
  }
  // 1-std::string StreamReader::get_fixed_string(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_fixed_string", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::string return_value = (*local_this).get_fixed_string((std::size_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_fixed_string(const StreamReader self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_get_fixed_string_866_comment =
  "C++ Interface:\n"
  "get_fixed_string(const StreamReader self, int size)\n";
#else
static const char *Dtool_StreamReader_get_fixed_string_866_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StreamReader::skip_bytes(std::size_t size)
 */
static PyObject *Dtool_StreamReader_skip_bytes_867(PyObject *self, PyObject *arg) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.skip_bytes")) {
    return NULL;
  }
  // 1-void StreamReader::skip_bytes(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:skip_bytes", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).skip_bytes((std::size_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "skip_bytes(const StreamReader self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_skip_bytes_867_comment =
  "C++ Interface:\n"
  "skip_bytes(const StreamReader self, int size)\n";
#else
static const char *Dtool_StreamReader_skip_bytes_867_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *StreamReader::extract_bytes(std::size_t size)
 */
static PyObject *Dtool_StreamReader_extract_bytes_868(PyObject *self, PyObject *arg) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.extract_bytes")) {
    return NULL;
  }
  // 1-PyObject *StreamReader::extract_bytes(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:extract_bytes", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PyObject *return_value = invoke_extension(local_this).extract_bytes((std::size_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_bytes(const StreamReader self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_extract_bytes_868_comment =
  "C++ Interface:\n"
  "extract_bytes(const StreamReader self, int size)\n";
#else
static const char *Dtool_StreamReader_extract_bytes_868_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *StreamReader::readline(void)
 */
static PyObject *Dtool_StreamReader_readline_869(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.readline")) {
    return NULL;
  }
  // 1-PyObject *StreamReader::readline(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = invoke_extension(local_this).readline();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_readline_869_comment =
  "C++ Interface:\n"
  "readline(const StreamReader self)\n";
#else
static const char *Dtool_StreamReader_readline_869_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *StreamReader::readlines(void)
 */
static PyObject *Dtool_StreamReader_readlines_870(PyObject *self, PyObject *) {
  StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamReader, (void **)&local_this, "StreamReader.readlines")) {
    return NULL;
  }
  // 1-PyObject *StreamReader::readlines(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = invoke_extension(local_this).readlines();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StreamReader_readlines_870_comment =
  "C++ Interface:\n"
  "readlines(const StreamReader self)\n";
#else
static const char *Dtool_StreamReader_readlines_870_comment = NULL;
#endif

static PyObject *Dtool_StreamReader_istream_Getter(PyObject *self, void *) {
  const StreamReader *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamReader, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline istream *StreamReader::get_istream(void) const
  istream *return_value = (*(const StreamReader*)local_this).get_istream();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
}

/**
 * Python function wrapper for:
 * inline StreamReader::StreamReader(StreamReader const &copy)
 * inline StreamReader::StreamReader(istream *in, bool owns_stream)
 */
static int Dtool_Init_StreamReader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline StreamReader::StreamReader(StreamReader const &copy)
      StreamReader const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_StreamReader(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "StreamReader.StreamReader", "StreamReader");
        return -1;
      }
      StreamReader *return_value = new StreamReader(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamReader, true, false);
    }
    break;
  case 2:
    {
      // 1-inline StreamReader::StreamReader(istream *in, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"in", "owns_stream", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:StreamReader", (char **)keyword_list, &param0, &param1)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "StreamReader.StreamReader", false, true);
        if (param0_this != NULL) {
          StreamReader *return_value = new StreamReader(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamReader, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StreamReader() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamReader(const StreamReader copy)\n"
      "StreamReader(istream in, bool owns_stream)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StreamReader(PyObject *args, StreamReader const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StreamReader, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline StreamReader::StreamReader(istream *in, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "StreamReader", 2, 2, &param0, &param1)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "StreamReader.StreamReader", false, false);
        if (param0_this != NULL) {
          StreamReader *return_value = new StreamReader(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_StreamReader(PyObject *args, StreamReader *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StreamReader, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline StreamReader::StreamReader(istream *in, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "StreamReader", 2, 2, &param0, &param1)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "StreamReader.StreamReader", false, false);
        if (param0_this != NULL) {
          StreamReader *return_value = new StreamReader(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StreamReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StreamReader) {
    printf("StreamReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StreamReader *local_this = (StreamReader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StreamReader) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StreamReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StreamReader) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StreamWrapper
 */
/**
 * Python function wrapper for:
 * inline iostream *StreamWrapper::get_iostream(void) const
 */
static PyObject *Dtool_StreamWrapper_get_iostream_878(PyObject *self, PyObject *) {
  StreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWrapper, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline iostream *StreamWrapper::get_iostream(void) const
  iostream *return_value = (*(const StreamWrapper*)local_this).get_iostream();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapper_get_iostream_878_comment =
  "C++ Interface:\n"
  "get_iostream(StreamWrapper self)\n"
  "\n"
  "/**\n"
  " * Returns the iostream this object is wrapping.\n"
  " */";
#else
static const char *Dtool_StreamWrapper_get_iostream_878_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * IStreamWrapper *StreamWrapper::upcast_to_IStreamWrapper(void)
 */
static PyObject *Dtool_StreamWrapper_upcast_to_IStreamWrapper_872(PyObject *self, PyObject *) {
  StreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapper, (void **)&local_this, "StreamWrapper.upcast_to_IStreamWrapper")) {
    return NULL;
  }
  // 1-IStreamWrapper *StreamWrapper::upcast_to_IStreamWrapper(void)
  IStreamWrapper *return_value = (IStreamWrapper *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IStreamWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapper_upcast_to_IStreamWrapper_872_comment =
  "C++ Interface:\n"
  "upcast_to_IStreamWrapper(const StreamWrapper self)\n"
  "\n"
  "upcast from StreamWrapper to IStreamWrapper";
#else
static const char *Dtool_StreamWrapper_upcast_to_IStreamWrapper_872_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * OStreamWrapper *StreamWrapper::upcast_to_OStreamWrapper(void)
 */
static PyObject *Dtool_StreamWrapper_upcast_to_OStreamWrapper_874(PyObject *self, PyObject *) {
  StreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWrapper, (void **)&local_this, "StreamWrapper.upcast_to_OStreamWrapper")) {
    return NULL;
  }
  // 1-OStreamWrapper *StreamWrapper::upcast_to_OStreamWrapper(void)
  OStreamWrapper *return_value = (OStreamWrapper *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OStreamWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWrapper_upcast_to_OStreamWrapper_874_comment =
  "C++ Interface:\n"
  "upcast_to_OStreamWrapper(const StreamWrapper self)\n"
  "\n"
  "upcast from StreamWrapper to OStreamWrapper";
#else
static const char *Dtool_StreamWrapper_upcast_to_OStreamWrapper_874_comment = NULL;
#endif

static PyObject *Dtool_StreamWrapper_iostream_Getter(PyObject *self, void *) {
  const StreamWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWrapper, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline iostream *StreamWrapper::get_iostream(void) const
  iostream *return_value = (*(const StreamWrapper*)local_this).get_iostream();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
}

/**
 * Python function wrapper for:
 * inline StreamWrapper::StreamWrapper(StreamWrapper const &) = default
 * inline StreamWrapper::StreamWrapper(iostream &stream)
 */
static int Dtool_Init_StreamWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "StreamWrapper() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline StreamWrapper::StreamWrapper(iostream &stream)
    PyObject *param0;
    static const char *keyword_list[] = {"stream", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:StreamWrapper", (char **)keyword_list, &param0)) {
      iostream *param0_this = (iostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_iostream, 0, "StreamWrapper.StreamWrapper", false, false);
      if (param0_this != NULL) {
        StreamWrapper *return_value = new StreamWrapper(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWrapper, true, false);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline StreamWrapper::StreamWrapper(iostream &stream)
  {
    // -2 inline StreamWrapper::StreamWrapper(StreamWrapper const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:StreamWrapper", (char **)keyword_list, &param0)) {
      StreamWrapper const *param0_this;
      bool param0_manage = false;
      if (Dtool_ConstCoerce_StreamWrapper(param0, param0_this, param0_manage)) {
        StreamWrapper *return_value = new StreamWrapper(*param0_this);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWrapper, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamWrapper(iostream stream)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StreamWrapper(PyObject *args, StreamWrapper const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StreamWrapper, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline StreamWrapper::StreamWrapper(iostream &stream)
    iostream *arg_this = (iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_iostream, 0, "StreamWrapper.StreamWrapper", false, false);
    if (arg_this != NULL) {
      StreamWrapper *return_value = new StreamWrapper(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_StreamWrapper(PyObject *args, StreamWrapper *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StreamWrapper, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline StreamWrapper::StreamWrapper(iostream &stream)
    iostream *arg_this = (iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_iostream, 0, "StreamWrapper.StreamWrapper", false, false);
    if (arg_this != NULL) {
      StreamWrapper *return_value = new StreamWrapper(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_StreamWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StreamWrapper) {
    printf("StreamWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StreamWrapper *local_this = (StreamWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StreamWrapper) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_IStreamWrapper) {
    return (IStreamWrapper *) local_this;
  }
  if (requested_type == Dtool_Ptr_OStreamWrapper) {
    return (OStreamWrapper *) local_this;
  }
  if (requested_type == Dtool_Ptr_StreamWrapperBase) {
    return (StreamWrapperBase *)(IStreamWrapper *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StreamWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StreamWrapper) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_IStreamWrapper) {
    IStreamWrapper* other_this = (IStreamWrapper*)from_this;
    return (StreamWrapper*)other_this;
  }
  if (from_type == Dtool_Ptr_OStreamWrapper) {
    OStreamWrapper* other_this = (OStreamWrapper*)from_this;
    return (StreamWrapper*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class StreamWriter
 */
/**
 * Python function wrapper for:
 * inline void StreamWriter::operator =(StreamWriter const &copy)
 */
static PyObject *Dtool_StreamWriter_operator_883(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.assign")) {
    return NULL;
  }
  // 1-inline void StreamWriter::operator =(StreamWriter const &copy)
  StreamWriter const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_StreamWriter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "StreamWriter.assign", "StreamWriter");
  }
  (*local_this).operator =(*arg_this);
  StreamWriter *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_StreamWriter, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const StreamWriter self, const StreamWriter copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_operator_883_comment =
  "C++ Interface:\n"
  "assign(const StreamWriter self, const StreamWriter copy)\n";
#else
static const char *Dtool_StreamWriter_operator_883_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ostream *StreamWriter::get_ostream(void) const
 */
static PyObject *Dtool_StreamWriter_get_ostream_885(PyObject *self, PyObject *) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWriter, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline ostream *StreamWriter::get_ostream(void) const
  ostream *return_value = (*(const StreamWriter*)local_this).get_ostream();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_get_ostream_885_comment =
  "C++ Interface:\n"
  "get_ostream(StreamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the stream in use.\n"
  " */";
#else
static const char *Dtool_StreamWriter_get_ostream_885_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_bool(bool value)
 */
static PyObject *Dtool_StreamWriter_add_bool_887(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_bool")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_bool(bool value)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).add_bool((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_bool(const StreamWriter self, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_bool_887_comment =
  "C++ Interface:\n"
  "add_bool(const StreamWriter self, bool value)\n"
  "\n"
  "/**\n"
  " * Adds a boolean value to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_bool_887_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int8(int8_t value)
 */
static PyObject *Dtool_StreamWriter_add_int8_888(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int8")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_int8(int8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < CHAR_MIN || param1 > CHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed byte",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_int8((int8_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int8(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int8_888_comment =
  "C++ Interface:\n"
  "add_int8(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 8-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int8_888_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint8(uint8_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint8_889(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint8")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_uint8(uint8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_uint8((uint8_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint8(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint8_889_comment =
  "C++ Interface:\n"
  "add_uint8(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 8-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint8_889_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int16(int16_t value)
 */
static PyObject *Dtool_StreamWriter_add_int16_890(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int16")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_int16((int16_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int16(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int16_890_comment =
  "C++ Interface:\n"
  "add_int16(const StreamWriter self, int value)\n"
  "\n"
  "// The default numeric packing is little-endian.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int16_890_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int32(int32_t value)
 */
static PyObject *Dtool_StreamWriter_add_int32_891(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_int32((int32_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int32(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int32_891_comment =
  "C++ Interface:\n"
  "add_int32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int32_891_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_int64(int64_t value)
 */
static PyObject *Dtool_StreamWriter_add_int64_892(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_int64")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_int64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_int64((int64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int64(const StreamWriter self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_int64_892_comment =
  "C++ Interface:\n"
  "add_int64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_int64_892_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint16(uint16_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint16_893(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint16")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_uint16((uint16_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint16(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint16_893_comment =
  "C++ Interface:\n"
  "add_uint16(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint16_893_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint32(uint32_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint32_894(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_uint32((uint32_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint32(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint32_894_comment =
  "C++ Interface:\n"
  "add_uint32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint32_894_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_uint64(uint64_t value)
 */
static PyObject *Dtool_StreamWriter_add_uint64_895(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_uint64")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_uint64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_uint64((uint64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint64(const StreamWriter self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_uint64_895_comment =
  "C++ Interface:\n"
  "add_uint64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit integer to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_uint64_895_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_float32(float value)
 */
static PyObject *Dtool_StreamWriter_add_float32_896(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_float32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_float32(float value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_float32((float)PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float32(const StreamWriter self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_float32_896_comment =
  "C++ Interface:\n"
  "add_float32(const StreamWriter self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision floating-point number to the stream.  Since\n"
  " * this kind of float is not necessarily portable across different\n"
  " * architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_float32_896_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_float64(PN_float64 value)
 */
static PyObject *Dtool_StreamWriter_add_float64_897(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_float64")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_float64(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float64(const StreamWriter self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_float64_897_comment =
  "C++ Interface:\n"
  "add_float64(const StreamWriter self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit floating-point number to the stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_float64_897_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_int16(int16_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_int16_898(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_int16")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_int16((int16_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int16(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_int16_898_comment =
  "C++ Interface:\n"
  "add_be_int16(const StreamWriter self, int value)\n"
  "\n"
  "// These functions pack numbers big-endian, in case that's desired.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_int16_898_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_int32(int32_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_int32_899(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_int32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_int32((int32_t)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int32(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_int32_899_comment =
  "C++ Interface:\n"
  "add_be_int32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_int32_899_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_int64(int64_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_int64_900(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_int64")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_be_int64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_int64((int64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int64(const StreamWriter self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_int64_900_comment =
  "C++ Interface:\n"
  "add_be_int64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_int64_900_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_uint16(uint16_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_uint16_901(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_uint16")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_uint16((uint16_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint16(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_uint16_901_comment =
  "C++ Interface:\n"
  "add_be_uint16(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_uint16_901_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_uint32(uint32_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_uint32_902(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_uint32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_uint32((uint32_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint32(const StreamWriter self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_uint32_902_comment =
  "C++ Interface:\n"
  "add_be_uint32(const StreamWriter self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_uint32_902_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_uint64(uint64_t value)
 */
static PyObject *Dtool_StreamWriter_add_be_uint64_903(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_uint64")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_be_uint64", &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_uint64((uint64_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint64(const StreamWriter self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_uint64_903_comment =
  "C++ Interface:\n"
  "add_be_uint64(const StreamWriter self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit big-endian integer to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_uint64_903_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_float32(float value)
 */
static PyObject *Dtool_StreamWriter_add_be_float32_904(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_float32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_float32(float value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_float32((float)PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float32(const StreamWriter self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_float32_904_comment =
  "C++ Interface:\n"
  "add_be_float32(const StreamWriter self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision big-endian floating-point number to the\n"
  " * stream.  Since this kind of float is not necessarily portable across\n"
  " * different architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_float32_904_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_be_float64(PN_float64 value)
 */
static PyObject *Dtool_StreamWriter_add_be_float64_905(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_be_float64")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_be_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_be_float64(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float64(const StreamWriter self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_be_float64_905_comment =
  "C++ Interface:\n"
  "add_be_float64(const StreamWriter self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit big-endian floating-point number to the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_be_float64_905_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_string(std::string const &str)
 */
static PyObject *Dtool_StreamWriter_add_string_906(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_string")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_string(std::string const &str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_string(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string(const StreamWriter self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_string_906_comment =
  "C++ Interface:\n"
  "add_string(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the stream.  This actually adds a count\n"
  " * followed by n bytes.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_string_906_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_string32(std::string const &str)
 */
static PyObject *Dtool_StreamWriter_add_string32_907(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_string32")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_string32(std::string const &str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_string32(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string32(const StreamWriter self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_string32_907_comment =
  "C++ Interface:\n"
  "add_string32(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the stream, using a 32-bit length field.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_string32_907_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_z_string(std::string str)
 */
static PyObject *Dtool_StreamWriter_add_z_string_908(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_z_string")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_z_string(std::string str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_z_string(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z_string(const StreamWriter self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_z_string_908_comment =
  "C++ Interface:\n"
  "add_z_string(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the stream, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_z_string_908_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::add_fixed_string(std::string const &str, std::size_t size)
 */
static PyObject *Dtool_StreamWriter_add_fixed_string_909(PyObject *self, PyObject *args, PyObject *kwds) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.add_fixed_string")) {
    return NULL;
  }
  // 1-inline void StreamWriter::add_fixed_string(std::string const &str, std::size_t size)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"str", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#n:add_fixed_string", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).add_fixed_string(std::string(param1_str, param1_len), (std::size_t)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_fixed_string(const StreamWriter self, str str, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_add_fixed_string_909_comment =
  "C++ Interface:\n"
  "add_fixed_string(const StreamWriter self, str str, int size)\n"
  "\n"
  "/**\n"
  " * Adds a fixed-length string to the stream.  If the string given is less than\n"
  " * the requested size, this will pad the string out with zeroes; if it is\n"
  " * greater than the requested size, this will silently truncate the string.\n"
  " */";
#else
static const char *Dtool_StreamWriter_add_fixed_string_909_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StreamWriter::pad_bytes(std::size_t size)
 */
static PyObject *Dtool_StreamWriter_pad_bytes_910(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.pad_bytes")) {
    return NULL;
  }
  // 1-void StreamWriter::pad_bytes(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:pad_bytes", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).pad_bytes((std::size_t)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pad_bytes(const StreamWriter self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_pad_bytes_910_comment =
  "C++ Interface:\n"
  "pad_bytes(const StreamWriter self, int size)\n";
#else
static const char *Dtool_StreamWriter_pad_bytes_910_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void StreamWriter::append_data(PyObject *data)
 */
static PyObject *Dtool_StreamWriter_append_data_911(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.append_data")) {
    return NULL;
  }
  // 1-void StreamWriter::append_data(PyObject *data)
  invoke_extension(local_this).append_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_data(const StreamWriter self, object data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_append_data_911_comment =
  "C++ Interface:\n"
  "append_data(const StreamWriter self, object data)\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the streamWriter.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the streamWriter.\n"
  " */";
#else
static const char *Dtool_StreamWriter_append_data_911_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::flush(void)
 */
static PyObject *Dtool_StreamWriter_flush_912(PyObject *self, PyObject *) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.flush")) {
    return NULL;
  }
  // 1-inline void StreamWriter::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_flush_912_comment =
  "C++ Interface:\n"
  "flush(const StreamWriter self)\n"
  "\n"
  "/**\n"
  " * Calls flush() on the underlying stream.\n"
  " */";
#else
static const char *Dtool_StreamWriter_flush_912_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void StreamWriter::write(std::string const &str)
 */
static PyObject *Dtool_StreamWriter_write_913(PyObject *self, PyObject *arg) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.write")) {
    return NULL;
  }
  // 1-inline void StreamWriter::write(std::string const &str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).write(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(const StreamWriter self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_StreamWriter_write_913_comment =
  "C++ Interface:\n"
  "write(const StreamWriter self, str str)\n"
  "\n"
  "/**\n"
  " * A synonym of append_data().  This is useful when assigning the StreamWriter\n"
  " * to sys.stderr and/or sys.stdout in Python.\n"
  " */";
#else
static const char *Dtool_StreamWriter_write_913_comment = NULL;
#endif

static PyObject *Dtool_StreamWriter_ostream_Getter(PyObject *self, void *) {
  const StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline ostream *StreamWriter::get_ostream(void) const
  ostream *return_value = (*(const StreamWriter*)local_this).get_ostream();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

static PyObject *Dtool_StreamWriter_softspace_Getter(PyObject *self, void *) {
  const StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_StreamWriter, (void **)&local_this)) {
    return NULL;
  }

  // 1-int StreamWriter::get_softspace(void) const
  int return_value = ((const StreamWriter*)local_this)->softspace;
  return Dtool_WrapValue(return_value);
}

static int Dtool_StreamWriter_softspace_Setter(PyObject *self, PyObject *arg, void *) {
  StreamWriter *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StreamWriter, (void **)&local_this, "StreamWriter.softspace")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete softspace attribute");
    return -1;
  }
  // 1-void StreamWriter::set_softspace(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->softspace = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_softspace(const StreamWriter self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline StreamWriter::StreamWriter(StreamWriter const &copy)
 * inline StreamWriter::StreamWriter(ostream *out, bool owns_stream)
 */
static int Dtool_Init_StreamWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline StreamWriter::StreamWriter(StreamWriter const &copy)
      StreamWriter const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_StreamWriter(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "StreamWriter.StreamWriter", "StreamWriter");
        return -1;
      }
      StreamWriter *return_value = new StreamWriter(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWriter, true, false);
    }
    break;
  case 2:
    {
      // 1-inline StreamWriter::StreamWriter(ostream *out, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"out", "owns_stream", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:StreamWriter", (char **)keyword_list, &param0, &param1)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "StreamWriter.StreamWriter", false, true);
        if (param0_this != NULL) {
          StreamWriter *return_value = new StreamWriter(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StreamWriter, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StreamWriter() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StreamWriter(const StreamWriter copy)\n"
      "StreamWriter(ostream out, bool owns_stream)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_StreamWriter(PyObject *args, StreamWriter const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StreamWriter, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline StreamWriter::StreamWriter(ostream *out, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "StreamWriter", 2, 2, &param0, &param1)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "StreamWriter.StreamWriter", false, false);
        if (param0_this != NULL) {
          StreamWriter *return_value = new StreamWriter(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_StreamWriter(PyObject *args, StreamWriter *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_StreamWriter, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline StreamWriter::StreamWriter(ostream *out, bool owns_stream)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "StreamWriter", 2, 2, &param0, &param1)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "StreamWriter.StreamWriter", false, false);
        if (param0_this != NULL) {
          StreamWriter *return_value = new StreamWriter(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_StreamWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_StreamWriter) {
    printf("StreamWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  StreamWriter *local_this = (StreamWriter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_StreamWriter) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_StreamWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_StreamWriter) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TextEncoder
 */
/**
 * Python function wrapper for:
 * inline void TextEncoder::set_encoding(TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_set_encoding_920(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_encoding")) {
    return NULL;
  }
  // 1-inline void TextEncoder::set_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_encoding((TextEncoder::Encoding)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encoding(const TextEncoder self, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_encoding_920_comment =
  "C++ Interface:\n"
  "set_encoding(const TextEncoder self, int encoding)\n"
  "\n"
  "/**\n"
  " * Specifies how the string set via set_text() is to be interpreted.  The\n"
  " * default, E_iso8859, means a standard string with one-byte characters (i.e.\n"
  " * ASCII).  Other encodings are possible to take advantage of character sets\n"
  " * with more than 256 characters.\n"
  " *\n"
  " * This affects only future calls to set_text(); it does not change text that\n"
  " * was set previously.\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_encoding_920_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextEncoder::Encoding TextEncoder::get_encoding(void) const
 */
static PyObject *Dtool_TextEncoder_get_encoding_921(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TextEncoder::Encoding TextEncoder::get_encoding(void) const
  TextEncoder::Encoding return_value = (*(const TextEncoder*)local_this).get_encoding();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_encoding_921_comment =
  "C++ Interface:\n"
  "get_encoding(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the encoding by which the string set via set_text() is to be\n"
  " * interpreted.  See set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_encoding_921_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_set_default_encoding_922(PyObject *, PyObject *arg) {
  // 1-static inline void TextEncoder::set_default_encoding(TextEncoder::Encoding encoding)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TextEncoder::set_default_encoding((TextEncoder::Encoding)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_encoding(int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_default_encoding_922_comment =
  "C++ Interface:\n"
  "set_default_encoding(int encoding)\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequently created\n"
  " * TextEncoder objects.  See set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_default_encoding_922_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
 */
static PyObject *Dtool_TextEncoder_get_default_encoding_923(PyObject *, PyObject *) {
  // 1-static inline TextEncoder::Encoding TextEncoder::get_default_encoding(void)
  TextEncoder::Encoding return_value = TextEncoder::get_default_encoding();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_default_encoding_923_comment =
  "C++ Interface:\n"
  "get_default_encoding()\n"
  "\n"
  "/**\n"
  " * Specifies the default encoding to be used for all subsequently created\n"
  " * TextEncoder objects.  See set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_default_encoding_923_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::set_text(std::string const &text)
 * inline void TextEncoder::set_text(std::string const &text, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_set_text_924(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_text")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "text");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'text' (pos 1) not found");
      }
      // 1-inline void TextEncoder::set_text(std::string const &text)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        (*local_this).set_text(std::string(param1_str, param1_len));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void TextEncoder::set_text(std::string const &text, TextEncoder::Encoding encoding)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
      int param2;
      static const char *keyword_list[] = {"text", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_text", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
        (*local_this).set_text(std::string(param1_str, param1_len), (TextEncoder::Encoding)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_text() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text(const TextEncoder self, str text)\n"
      "set_text(const TextEncoder self, str text, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_text_924_comment =
  "C++ Interface:\n"
  "set_text(const TextEncoder self, str text)\n"
  "set_text(const TextEncoder self, str text, int encoding)\n"
  "\n"
  "/**\n"
  " * Changes the text that is stored in the encoder.  The text should be encoded\n"
  " * according to the method indicated by set_encoding().  Subsequent calls to\n"
  " * get_text() will return this same string, while get_wtext() will return the\n"
  " * decoded version of the string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * The two-parameter version of set_text() accepts an explicit encoding; the\n"
  " * text is immediately decoded and stored as a wide-character string.\n"
  " * Subsequent calls to get_text() will return the same text re-encoded using\n"
  " * whichever encoding is specified by set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_text_924_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::clear_text(void)
 */
static PyObject *Dtool_TextEncoder_clear_text_925(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.clear_text")) {
    return NULL;
  }
  // 1-inline void TextEncoder::clear_text(void)
  (*local_this).clear_text();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_clear_text_925_comment =
  "C++ Interface:\n"
  "clear_text(const TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Removes the text from the TextEncoder.\n"
  " */";
#else
static const char *Dtool_TextEncoder_clear_text_925_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TextEncoder::has_text(void) const
 */
static PyObject *Dtool_TextEncoder_has_text_926(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TextEncoder::has_text(void) const
  bool return_value = (*(const TextEncoder*)local_this).has_text();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_has_text_926_comment =
  "C++ Interface:\n"
  "has_text(TextEncoder self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TextEncoder_has_text_926_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextEncoder::make_upper(void)
 */
static PyObject *Dtool_TextEncoder_make_upper_927(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.make_upper")) {
    return NULL;
  }
  // 1-void TextEncoder::make_upper(void)
  (*local_this).make_upper();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_make_upper_927_comment =
  "C++ Interface:\n"
  "make_upper(const TextEncoder self)\n";
#else
static const char *Dtool_TextEncoder_make_upper_927_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TextEncoder::make_lower(void)
 */
static PyObject *Dtool_TextEncoder_make_lower_928(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.make_lower")) {
    return NULL;
  }
  // 1-void TextEncoder::make_lower(void)
  (*local_this).make_lower();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_make_lower_928_comment =
  "C++ Interface:\n"
  "make_lower(const TextEncoder self)\n";
#else
static const char *Dtool_TextEncoder_make_lower_928_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextEncoder::get_text(void) const
 * inline std::string TextEncoder::get_text(TextEncoder::Encoding encoding) const
 */
static PyObject *Dtool_TextEncoder_get_text_929(PyObject *self, PyObject *args) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline std::string TextEncoder::get_text(void) const
      std::string return_value = (*(const TextEncoder*)local_this).get_text();
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline std::string TextEncoder::get_text(TextEncoder::Encoding encoding) const
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for signed integer",
                              arg_val);
        }
#endif
        std::string return_value = (*(const TextEncoder*)local_this).get_text((TextEncoder::Encoding)arg_val);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_text() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_text(TextEncoder self)\n"
      "get_text(TextEncoder self, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_text_929_comment =
  "C++ Interface:\n"
  "get_text(TextEncoder self)\n"
  "get_text(TextEncoder self, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the current text, as encoded via the current encoding system.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current text, as encoded via the indicated encoding system.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_text_929_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::append_text(std::string const &text)
 */
static PyObject *Dtool_TextEncoder_append_text_930(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.append_text")) {
    return NULL;
  }
  // 1-inline void TextEncoder::append_text(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).append_text(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_text(const TextEncoder self, str text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_append_text_930_comment =
  "C++ Interface:\n"
  "append_text(const TextEncoder self, str text)\n"
  "\n"
  "/**\n"
  " * Appends the indicates string to the end of the stored text.\n"
  " */";
#else
static const char *Dtool_TextEncoder_append_text_930_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::append_unicode_char(int character)
 */
static PyObject *Dtool_TextEncoder_append_unicode_char_931(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.append_unicode_char")) {
    return NULL;
  }
  // 1-inline void TextEncoder::append_unicode_char(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).append_unicode_char((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_unicode_char(const TextEncoder self, int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_append_unicode_char_931_comment =
  "C++ Interface:\n"
  "append_unicode_char(const TextEncoder self, int character)\n"
  "\n"
  "/**\n"
  " * Appends a single character to the end of the stored text.  This may be a\n"
  " * wide character, up to 16 bits in Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_append_unicode_char_931_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TextEncoder::get_num_chars(void) const
 */
static PyObject *Dtool_TextEncoder_get_num_chars_932(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t TextEncoder::get_num_chars(void) const
  std::size_t return_value = (*(const TextEncoder*)local_this).get_num_chars();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_num_chars_932_comment =
  "C++ Interface:\n"
  "get_num_chars(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters in the stored text.  This is a count of\n"
  " * wide characters, after the string has been decoded according to\n"
  " * set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_num_chars_932_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TextEncoder::get_unicode_char(std::size_t index) const
 */
static PyObject *Dtool_TextEncoder_get_unicode_char_933(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TextEncoder::get_unicode_char(std::size_t index) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_unicode_char", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    int return_value = (*(const TextEncoder*)local_this).get_unicode_char((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_unicode_char(TextEncoder self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_unicode_char_933_comment =
  "C++ Interface:\n"
  "get_unicode_char(TextEncoder self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the Unicode value of the nth character in the stored text.  This\n"
  " * may be a wide character (greater than 255), after the string has been\n"
  " * decoded according to set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_unicode_char_933_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::set_unicode_char(std::size_t index, int character)
 */
static PyObject *Dtool_TextEncoder_set_unicode_char_934(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_unicode_char")) {
    return NULL;
  }
  // 1-inline void TextEncoder::set_unicode_char(std::size_t index, int character)
  Py_ssize_t param1;
  int param2;
  static const char *keyword_list[] = {"index", "character", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:set_unicode_char", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_unicode_char((std::size_t)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_unicode_char(const TextEncoder self, int index, int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_unicode_char_934_comment =
  "C++ Interface:\n"
  "set_unicode_char(const TextEncoder self, int index, int character)\n"
  "\n"
  "/**\n"
  " * Sets the Unicode value of the nth character in the stored text.  This may\n"
  " * be a wide character (greater than 255), after the string has been decoded\n"
  " * according to set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_unicode_char_934_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextEncoder::get_encoded_char(std::size_t index) const
 * inline std::string TextEncoder::get_encoded_char(std::size_t index, TextEncoder::Encoding encoding) const
 */
static PyObject *Dtool_TextEncoder_get_encoded_char_935(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "index");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'index' (pos 1) not found");
      }
      // 1-inline std::string TextEncoder::get_encoded_char(std::size_t index) const
      Py_ssize_t param1;
      if (PyArg_Parse(arg, "n:get_encoded_char", &param1)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::string return_value = (*(const TextEncoder*)local_this).get_encoded_char((std::size_t)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-inline std::string TextEncoder::get_encoded_char(std::size_t index, TextEncoder::Encoding encoding) const
      Py_ssize_t param1;
      int param2;
      static const char *keyword_list[] = {"index", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ni:get_encoded_char", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param1 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param1);
        }
#endif
        std::string return_value = (*(const TextEncoder*)local_this).get_encoded_char((std::size_t)param1, (TextEncoder::Encoding)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_encoded_char() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_encoded_char(TextEncoder self, int index)\n"
      "get_encoded_char(TextEncoder self, int index, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_encoded_char_935_comment =
  "C++ Interface:\n"
  "get_encoded_char(TextEncoder self, int index)\n"
  "get_encoded_char(TextEncoder self, int index, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the nth char of the stored text, as a one-, two-, or three-byte\n"
  " * encoded string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the nth char of the stored text, as a one-, two-, or three-byte\n"
  " * encoded string.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_encoded_char_935_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextEncoder::get_text_as_ascii(void) const
 */
static PyObject *Dtool_TextEncoder_get_text_as_ascii_936(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string TextEncoder::get_text_as_ascii(void) const
  std::string return_value = (*(const TextEncoder*)local_this).get_text_as_ascii();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_text_as_ascii_936_comment =
  "C++ Interface:\n"
  "get_text_as_ascii(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the text associated with the node, converted as nearly as possible\n"
  " * to a fully-ASCII representation.  This means replacing accented letters\n"
  " * with their unaccented ASCII equivalents.\n"
  " *\n"
  " * It is possible that some characters in the string cannot be converted to\n"
  " * ASCII.  (The string may involve symbols like the copyright symbol, for\n"
  " * instance, or it might involve letters in some other alphabet such as Greek\n"
  " * or Cyrillic, or even Latin letters like thorn or eth that are not part of\n"
  " * the ASCII character set.)  In this case, as much of the string as possible\n"
  " * will be converted to ASCII, and the nonconvertible characters will remain\n"
  " * encoded in the encoding specified by set_encoding().\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_text_as_ascii_936_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string TextEncoder::reencode_text(std::string const &text, TextEncoder::Encoding from, TextEncoder::Encoding to)
 */
static PyObject *Dtool_TextEncoder_reencode_text_937(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline std::string TextEncoder::reencode_text(std::string const &text, TextEncoder::Encoding from, TextEncoder::Encoding to)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  int param1;
  int param2;
  static const char *keyword_list[] = {"text", "from", "to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ii:reencode_text", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
    std::string return_value = TextEncoder::reencode_text(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1, (TextEncoder::Encoding)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reencode_text(str text, int from, int to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_reencode_text_937_comment =
  "C++ Interface:\n"
  "reencode_text(str text, int from, int to)\n"
  "\n"
  "/**\n"
  " * Given the indicated text string, which is assumed to be encoded via the\n"
  " * encoding \"from\", decodes it and then reencodes it into the encoding \"to\",\n"
  " * and returns the newly encoded string.  This does not change or affect any\n"
  " * properties on the TextEncoder itself.\n"
  " */";
#else
static const char *Dtool_TextEncoder_reencode_text_937_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isalpha(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_isalpha_938(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isalpha(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = TextEncoder::unicode_isalpha((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isalpha(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isalpha_938_comment =
  "C++ Interface:\n"
  "unicode_isalpha(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is an alphabetic letter, false\n"
  " * otherwise.  This is akin to ctype's isalpha(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isalpha_938_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isdigit(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_isdigit_939(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isdigit(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = TextEncoder::unicode_isdigit((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isdigit(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isdigit_939_comment =
  "C++ Interface:\n"
  "unicode_isdigit(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a numeric digit, false\n"
  " * otherwise.  This is akin to ctype's isdigit(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isdigit_939_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_ispunct(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_ispunct_940(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_ispunct(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = TextEncoder::unicode_ispunct((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_ispunct(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_ispunct_940_comment =
  "C++ Interface:\n"
  "unicode_ispunct(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a punctuation mark, false\n"
  " * otherwise.  This is akin to ctype's ispunct(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_ispunct_940_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_islower(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_islower_941(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_islower(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = TextEncoder::unicode_islower((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_islower(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_islower_941_comment =
  "C++ Interface:\n"
  "unicode_islower(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a lowercase letter, false\n"
  " * otherwise.  This is akin to ctype's islower(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_islower_941_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isupper(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_isupper_942(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isupper(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = TextEncoder::unicode_isupper((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isupper(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isupper_942_comment =
  "C++ Interface:\n"
  "unicode_isupper(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is an uppercase letter, false\n"
  " * otherwise.  This is akin to ctype's isupper(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isupper_942_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool TextEncoder::unicode_isspace(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_isspace_943(PyObject *, PyObject *arg) {
  // 1-static inline bool TextEncoder::unicode_isspace(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = TextEncoder::unicode_isspace((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_isspace(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_isspace_943_comment =
  "C++ Interface:\n"
  "unicode_isspace(int character)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated character is a whitespace letter, false\n"
  " * otherwise.  This is akin to ctype's isspace(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_isspace_943_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int TextEncoder::unicode_toupper(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_toupper_944(PyObject *, PyObject *arg) {
  // 1-static inline int TextEncoder::unicode_toupper(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = TextEncoder::unicode_toupper((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_toupper(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_toupper_944_comment =
  "C++ Interface:\n"
  "unicode_toupper(int character)\n"
  "\n"
  "/**\n"
  " * Returns the uppercase equivalent of the given Unicode character.  This is\n"
  " * akin to ctype's toupper(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_toupper_944_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int TextEncoder::unicode_tolower(int character)
 */
static PyObject *Dtool_TextEncoder_unicode_tolower_945(PyObject *, PyObject *arg) {
  // 1-static inline int TextEncoder::unicode_tolower(int character)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = TextEncoder::unicode_tolower((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unicode_tolower(int character)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_unicode_tolower_945_comment =
  "C++ Interface:\n"
  "unicode_tolower(int character)\n"
  "\n"
  "/**\n"
  " * Returns the uppercase equivalent of the given Unicode character.  This is\n"
  " * akin to ctype's tolower(), extended to Unicode.\n"
  " */";
#else
static const char *Dtool_TextEncoder_unicode_tolower_945_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string TextEncoder::upper(std::string const &source)
 * static inline std::string TextEncoder::upper(std::string const &source, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_upper_946(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "source");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'source' (pos 1) not found");
      }
      // 1-static inline std::string TextEncoder::upper(std::string const &source)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        std::string return_value = TextEncoder::upper(std::string(param0_str, param0_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-static inline std::string TextEncoder::upper(std::string const &source, TextEncoder::Encoding encoding)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"source", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:upper", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        std::string return_value = TextEncoder::upper(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "upper() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "upper(str source)\n"
      "upper(str source, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_upper_946_comment =
  "C++ Interface:\n"
  "upper(str source)\n"
  "upper(str source, int encoding)\n"
  "\n"
  "/**\n"
  " * Converts the string to uppercase, assuming the string is encoded in the\n"
  " * default encoding.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the string to uppercase, assuming the string is encoded in the\n"
  " * indicated encoding.\n"
  " */";
#else
static const char *Dtool_TextEncoder_upper_946_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string TextEncoder::lower(std::string const &source)
 * static inline std::string TextEncoder::lower(std::string const &source, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_lower_947(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "source");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'source' (pos 1) not found");
      }
      // 1-static inline std::string TextEncoder::lower(std::string const &source)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
        param0_str = NULL;
      }
#endif
      if (param0_str != NULL) {
        std::string return_value = TextEncoder::lower(std::string(param0_str, param0_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-static inline std::string TextEncoder::lower(std::string const &source, TextEncoder::Encoding encoding)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"source", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:lower", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        std::string return_value = TextEncoder::lower(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "lower() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower(str source)\n"
      "lower(str source, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_lower_947_comment =
  "C++ Interface:\n"
  "lower(str source)\n"
  "lower(str source, int encoding)\n"
  "\n"
  "/**\n"
  " * Converts the string to lowercase, assuming the string is encoded in the\n"
  " * default encoding.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the string to lowercase, assuming the string is encoded in the\n"
  " * indicated encoding.\n"
  " */";
#else
static const char *Dtool_TextEncoder_lower_947_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::set_wtext(std::wstring const &wtext)
 */
static PyObject *Dtool_TextEncoder_set_wtext_948(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.set_wtext")) {
    return NULL;
  }
  // 1-inline void TextEncoder::set_wtext(std::wstring const &wtext)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:set_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).set_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wtext(const TextEncoder self, unicode wtext)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_set_wtext_948_comment =
  "C++ Interface:\n"
  "set_wtext(const TextEncoder self, unicode wtext)\n"
  "\n"
  "// Direct support for wide-character strings.  Now publishable with the new\n"
  "// wstring support in interrogate.\n"
  "\n"
  "/**\n"
  " * Changes the text that is stored in the encoder.  Subsequent calls to\n"
  " * get_wtext() will return this same string, while get_text() will return the\n"
  " * encoded version of the string.\n"
  " */";
#else
static const char *Dtool_TextEncoder_set_wtext_948_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring const &TextEncoder::get_wtext(void) const
 */
static PyObject *Dtool_TextEncoder_get_wtext_949(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::wstring const &TextEncoder::get_wtext(void) const
  std::wstring const &return_value = (*(const TextEncoder*)local_this).get_wtext();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_wtext_949_comment =
  "C++ Interface:\n"
  "get_wtext(TextEncoder self)\n"
  "\n"
  "/**\n"
  " * Returns the text associated with the TextEncoder, as a wide-character\n"
  " * string.\n"
  " */";
#else
static const char *Dtool_TextEncoder_get_wtext_949_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TextEncoder::append_wtext(std::wstring const &text)
 */
static PyObject *Dtool_TextEncoder_append_wtext_950(PyObject *self, PyObject *arg) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TextEncoder, (void **)&local_this, "TextEncoder.append_wtext")) {
    return NULL;
  }
  // 1-inline void TextEncoder::append_wtext(std::wstring const &text)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:append_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).append_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_wtext(const TextEncoder self, unicode text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_append_wtext_950_comment =
  "C++ Interface:\n"
  "append_wtext(const TextEncoder self, unicode text)\n"
  "\n"
  "/**\n"
  " * Appends the indicates string to the end of the stored wide-character text.\n"
  " */";
#else
static const char *Dtool_TextEncoder_append_wtext_950_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring TextEncoder::get_wtext_as_ascii(void) const
 */
static PyObject *Dtool_TextEncoder_get_wtext_as_ascii_951(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::wstring TextEncoder::get_wtext_as_ascii(void) const
  std::wstring return_value = (*(const TextEncoder*)local_this).get_wtext_as_ascii();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_get_wtext_as_ascii_951_comment =
  "C++ Interface:\n"
  "get_wtext_as_ascii(TextEncoder self)\n";
#else
static const char *Dtool_TextEncoder_get_wtext_as_ascii_951_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TextEncoder::is_wtext(void) const
 */
static PyObject *Dtool_TextEncoder_is_wtext_952(PyObject *self, PyObject *) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TextEncoder::is_wtext(void) const
  bool return_value = (*(const TextEncoder*)local_this).is_wtext();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_is_wtext_952_comment =
  "C++ Interface:\n"
  "is_wtext(TextEncoder self)\n";
#else
static const char *Dtool_TextEncoder_is_wtext_952_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string TextEncoder::encode_wchar(wchar_t ch, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_encode_wchar_953(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static std::string TextEncoder::encode_wchar(wchar_t ch, TextEncoder::Encoding encoding)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param0;
  #else
  PyUnicodeObject *param0;
  #endif
  int param1;
  static const char *keyword_list[] = {"ch", "encoding", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Ui:encode_wchar", (char **)keyword_list, &param0, &param1)) {
    wchar_t param0_chars[2];
    if (PyUnicode_AsWideChar(param0, param0_chars, 2) == 1) {
      std::string return_value = TextEncoder::encode_wchar(param0_chars[0], (TextEncoder::Encoding)param1);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_wchar(unicode char ch, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_encode_wchar_953_comment =
  "C++ Interface:\n"
  "encode_wchar(unicode char ch, int encoding)\n";
#else
static const char *Dtool_TextEncoder_encode_wchar_953_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TextEncoder::encode_wtext(std::wstring const &wtext) const
 * static std::string TextEncoder::encode_wtext(std::wstring const &wtext, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_encode_wtext_954(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "wtext");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'wtext' (pos 1) not found");
      }
      // 1-inline std::string TextEncoder::encode_wtext(std::wstring const &wtext) const
      #if PY_VERSION_HEX >= 0x03020000
      PyObject *param1;
      #else
      PyUnicodeObject *param1;
      #endif
      if (PyArg_Parse(arg, "U:encode_wtext", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param1_len;
        wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
        Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
        wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
        PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
        std::string return_value = (*(const TextEncoder*)local_this).encode_wtext(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param1_str);
#endif
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-static std::string TextEncoder::encode_wtext(std::wstring const &wtext, TextEncoder::Encoding encoding)
      #if PY_VERSION_HEX >= 0x03020000
      PyObject *param0;
      #else
      PyUnicodeObject *param0;
      #endif
      int param1;
      static const char *keyword_list[] = {"wtext", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Ui:encode_wtext", (char **)keyword_list, &param0, &param1)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param0_len;
        wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
        Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
        wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
        PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
        std::string return_value = TextEncoder::encode_wtext(std::wstring(param0_str, param0_len), (TextEncoder::Encoding)param1);
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param0_str);
#endif
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "encode_wtext() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_wtext(TextEncoder self, unicode wtext)\n"
      "encode_wtext(unicode wtext, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_encode_wtext_954_comment =
  "C++ Interface:\n"
  "encode_wtext(TextEncoder self, unicode wtext)\n"
  "encode_wtext(unicode wtext, int encoding)\n"
  "\n"
  "/**\n"
  " * Encodes a wide-text string into a single-char string, according to the\n"
  " * current encoding.\n"
  " */";
#else
static const char *Dtool_TextEncoder_encode_wtext_954_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring TextEncoder::decode_text(std::string const &text) const
 * static std::wstring TextEncoder::decode_text(std::string const &text, TextEncoder::Encoding encoding)
 */
static PyObject *Dtool_TextEncoder_decode_text_955(PyObject *self, PyObject *args, PyObject *kwds) {
  TextEncoder *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TextEncoder, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "text");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'text' (pos 1) not found");
      }
      // 1-inline std::wstring TextEncoder::decode_text(std::string const &text) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        std::wstring return_value = (*(const TextEncoder*)local_this).decode_text(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-static std::wstring TextEncoder::decode_text(std::string const &text, TextEncoder::Encoding encoding)
      char *param0_str = NULL;
      Py_ssize_t param0_len;
      int param1;
      static const char *keyword_list[] = {"text", "encoding", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:decode_text", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        std::wstring return_value = TextEncoder::decode_text(std::string(param0_str, param0_len), (TextEncoder::Encoding)param1);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "decode_text() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_text(TextEncoder self, str text)\n"
      "decode_text(str text, int encoding)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TextEncoder_decode_text_955_comment =
  "C++ Interface:\n"
  "decode_text(TextEncoder self, str text)\n"
  "decode_text(str text, int encoding)\n"
  "\n"
  "/**\n"
  " * Returns the given wstring decoded to a single-byte string, via the current\n"
  " * encoding system.\n"
  " */";
#else
static const char *Dtool_TextEncoder_decode_text_955_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TextEncoder::TextEncoder(void)
 * inline TextEncoder::TextEncoder(TextEncoder const &copy)
 */
static int Dtool_Init_TextEncoder(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TextEncoder::TextEncoder(void)
      TextEncoder *return_value = new TextEncoder();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextEncoder, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline TextEncoder::TextEncoder(TextEncoder const &copy)
      TextEncoder const *arg_this = (TextEncoder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextEncoder, 0, "TextEncoder.TextEncoder", true, true);
      if (arg_this != NULL) {
        TextEncoder *return_value = new TextEncoder(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TextEncoder, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TextEncoder() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TextEncoder()\n"
      "TextEncoder(const TextEncoder copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TextEncoder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TextEncoder) {
    printf("TextEncoder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TextEncoder *local_this = (TextEncoder *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TextEncoder) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TextEncoder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TextEncoder) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TypeHandle
 */
/**
 * Python function wrapper for:
 * static TypeHandle TypeHandle::make(PyTypeObject *classobj)
 */
static PyObject *Dtool_TypeHandle_make_959(PyObject *, PyObject *arg) {
  // 1-static TypeHandle TypeHandle::make(PyTypeObject *classobj)
  if (PyType_Check(arg)) {
    TypeHandle *return_value = new TypeHandle(Extension<TypeHandle>::make((PyTypeObject *)arg));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(type classobj)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_make_959_comment =
  "C++ Interface:\n"
  "make(type classobj)\n";
#else
static const char *Dtool_TypeHandle_make_959_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::compare_to(TypeHandle const &other) const
 */
static PyObject *Dtool_TypeHandle_compare_to_966(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TypeHandle::compare_to(TypeHandle const &other) const
  TypeHandle arg_local;
  TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TypeHandle.compare_to", "TypeHandle");
  }
  int return_value = (*(const TypeHandle*)local_this).compare_to(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(TypeHandle self, const TypeHandle other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_compare_to_966_comment =
  "C++ Interface:\n"
  "compare_to(TypeHandle self, const TypeHandle other)\n"
  "\n"
  "/**\n"
  " * Sorts TypeHandles arbitrarily (according to <, >, etc.).  Returns a number\n"
  " * less than 0 if this type sorts before the other one, greater than zero if\n"
  " * it sorts after, 0 if they are equivalent.\n"
  " */";
#else
static const char *Dtool_TypeHandle_compare_to_966_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t TypeHandle::get_hash(void) const
 */
static PyObject *Dtool_TypeHandle_get_hash_967(PyObject *self, PyObject *) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t TypeHandle::get_hash(void) const
  std::size_t return_value = (*(const TypeHandle*)local_this).get_hash();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_hash_967_comment =
  "C++ Interface:\n"
  "get_hash(TypeHandle self)\n"
  "\n"
  "/**\n"
  " * Returns a hash code suitable for phash_map.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_hash_967_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string TypeHandle::get_name(TypedObject *object = (TypedObject *)(0)) const
 */
static PyObject *Dtool_TypeHandle_get_name_968(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string TypeHandle::get_name(TypedObject *object = (TypedObject *)(0)) const
  PyObject *param1 = NULL;
  static const char *keyword_list[] = {"object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:get_name", (char **)keyword_list, &param1)) {
    TypedObject *param1_this = (TypedObject *)(0);
    if (param1 != (PyObject *)NULL) {
      param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedObject, 1, "TypeHandle.get_name", false, true);
    }
    if ((param1 == NULL || param1_this != NULL)) {
      std::string return_value = (*(const TypeHandle*)local_this).get_name(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_name(TypeHandle self, TypedObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_name_968_comment =
  "C++ Interface:\n"
  "get_name(TypeHandle self, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the name of the type.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_name_968_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = (TypedObject *)(0)) const
 */
static PyObject *Dtool_TypeHandle_is_derived_from_969(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TypeHandle::is_derived_from(TypeHandle parent, TypedObject *object = (TypedObject *)(0)) const
  PyObject *param1;
  PyObject *param2 = NULL;
  static const char *keyword_list[] = {"parent", "object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:is_derived_from", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeHandle.is_derived_from", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)(0);
    if (param2 != (PyObject *)NULL) {
      param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeHandle.is_derived_from", false, true);
    }
    if ((param2 == NULL || param2_this != NULL)) {
      bool return_value = (*(const TypeHandle*)local_this).is_derived_from(*param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_derived_from(TypeHandle self, TypeHandle parent, TypedObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_is_derived_from_969_comment =
  "C++ Interface:\n"
  "is_derived_from(TypeHandle self, TypeHandle parent, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns true if this type is derived from the indicated type, false\n"
  " * otherwise.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_is_derived_from_969_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::get_num_parent_classes(TypedObject *object = (TypedObject *)(0)) const
 */
static PyObject *Dtool_TypeHandle_get_num_parent_classes_970(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TypeHandle::get_num_parent_classes(TypedObject *object = (TypedObject *)(0)) const
  PyObject *param1 = NULL;
  static const char *keyword_list[] = {"object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:get_num_parent_classes", (char **)keyword_list, &param1)) {
    TypedObject *param1_this = (TypedObject *)(0);
    if (param1 != (PyObject *)NULL) {
      param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedObject, 1, "TypeHandle.get_num_parent_classes", false, true);
    }
    if ((param1 == NULL || param1_this != NULL)) {
      int return_value = (*(const TypeHandle*)local_this).get_num_parent_classes(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_parent_classes(TypeHandle self, TypedObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_num_parent_classes_970_comment =
  "C++ Interface:\n"
  "get_num_parent_classes(TypeHandle self, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the number of parent classes that this type is known to have.  This\n"
  " * may then be used to index into get_parent_class().  The result will be 0 if\n"
  " * this class does not inherit from any other classes, 1 if normal, single\n"
  " * inheritance is in effect, or greater than one if multiple inheritance is in\n"
  " * effect.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_num_parent_classes_970_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle TypeHandle::get_parent_class(int index) const
 */
static PyObject *Dtool_TypeHandle_get_parent_class_971(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypeHandle TypeHandle::get_parent_class(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle((*(const TypeHandle*)local_this).get_parent_class((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_class(TypeHandle self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_parent_class_971_comment =
  "C++ Interface:\n"
  "get_parent_class(TypeHandle self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth parent class of this type.  The index should be in the\n"
  " * range 0 <= index < get_num_parent_classes().\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_parent_class_971_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::get_num_child_classes(TypedObject *object = (TypedObject *)(0)) const
 */
static PyObject *Dtool_TypeHandle_get_num_child_classes_972(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TypeHandle::get_num_child_classes(TypedObject *object = (TypedObject *)(0)) const
  PyObject *param1 = NULL;
  static const char *keyword_list[] = {"object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|O:get_num_child_classes", (char **)keyword_list, &param1)) {
    TypedObject *param1_this = (TypedObject *)(0);
    if (param1 != (PyObject *)NULL) {
      param1_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedObject, 1, "TypeHandle.get_num_child_classes", false, true);
    }
    if ((param1 == NULL || param1_this != NULL)) {
      int return_value = (*(const TypeHandle*)local_this).get_num_child_classes(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_child_classes(TypeHandle self, TypedObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_num_child_classes_972_comment =
  "C++ Interface:\n"
  "get_num_child_classes(TypeHandle self, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the number of child classes that this type is known to have.  This\n"
  " * may then be used to index into get_child_class().\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_num_child_classes_972_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle TypeHandle::get_child_class(int index) const
 */
static PyObject *Dtool_TypeHandle_get_child_class_973(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypeHandle TypeHandle::get_child_class(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle((*(const TypeHandle*)local_this).get_child_class((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_class(TypeHandle self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_child_class_973_comment =
  "C++ Interface:\n"
  "get_child_class(TypeHandle self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth child class of this type.  The index should be in the range\n"
  " * 0 <= index < get_num_child_classes().\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_child_class_973_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = (TypedObject *)(0)) const
 */
static PyObject *Dtool_TypeHandle_get_parent_towards_974(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline TypeHandle TypeHandle::get_parent_towards(TypeHandle ancestor, TypedObject *object = (TypedObject *)(0)) const
  PyObject *param1;
  PyObject *param2 = NULL;
  static const char *keyword_list[] = {"ancestor", "object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_parent_towards", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeHandle.get_parent_towards", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)(0);
    if (param2 != (PyObject *)NULL) {
      param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeHandle.get_parent_towards", false, true);
    }
    if ((param2 == NULL || param2_this != NULL)) {
      TypeHandle *return_value = new TypeHandle((*(const TypeHandle*)local_this).get_parent_towards(*param1_this, param2_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_towards(TypeHandle self, TypeHandle ancestor, TypedObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_parent_towards_974_comment =
  "C++ Interface:\n"
  "get_parent_towards(TypeHandle self, TypeHandle ancestor, TypedObject object)\n"
  "\n"
  "/**\n"
  " * Returns the parent class that is in a direct line of inheritance to the\n"
  " * indicated ancestor class.  This is useful in the presence of multiple\n"
  " * inheritance to try to determine what properties an unknown type may have.\n"
  " *\n"
  " * The return value is TypeHandle::none() if the type does not inherit from\n"
  " * the ancestor.  If ancestor is the same as this type, the return value is\n"
  " * this type.\n"
  " *\n"
  " * The \"object\" pointer is an optional pointer to the TypedObject class that\n"
  " * owns this TypeHandle.  It is only used in case the TypeHandle is\n"
  " * inadvertantly undefined.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_parent_towards_974_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t TypeHandle::get_memory_usage(TypeHandle::MemoryClass memory_class) const
 */
static PyObject *Dtool_TypeHandle_get_memory_usage_976(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t TypeHandle::get_memory_usage(TypeHandle::MemoryClass memory_class) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = (*(const TypeHandle*)local_this).get_memory_usage((TypeHandle::MemoryClass)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_memory_usage(TypeHandle self, int memory_class)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_memory_usage_976_comment =
  "C++ Interface:\n"
  "get_memory_usage(TypeHandle self, int memory_class)\n";
#else
static const char *Dtool_TypeHandle_get_memory_usage_976_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
 */
static PyObject *Dtool_TypeHandle_inc_memory_usage_977(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeHandle, (void **)&local_this, "TypeHandle.inc_memory_usage")) {
    return NULL;
  }
  // 1-void TypeHandle::inc_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
  int param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"memory_class", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "in:inc_memory_usage", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    (*local_this).inc_memory_usage((TypeHandle::MemoryClass)param1, (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "inc_memory_usage(const TypeHandle self, int memory_class, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_inc_memory_usage_977_comment =
  "C++ Interface:\n"
  "inc_memory_usage(const TypeHandle self, int memory_class, int size)\n";
#else
static const char *Dtool_TypeHandle_inc_memory_usage_977_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
 */
static PyObject *Dtool_TypeHandle_dec_memory_usage_978(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeHandle, (void **)&local_this, "TypeHandle.dec_memory_usage")) {
    return NULL;
  }
  // 1-void TypeHandle::dec_memory_usage(TypeHandle::MemoryClass memory_class, std::size_t size)
  int param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"memory_class", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "in:dec_memory_usage", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    (*local_this).dec_memory_usage((TypeHandle::MemoryClass)param1, (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dec_memory_usage(const TypeHandle self, int memory_class, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_dec_memory_usage_978_comment =
  "C++ Interface:\n"
  "dec_memory_usage(const TypeHandle self, int memory_class, int size)\n";
#else
static const char *Dtool_TypeHandle_dec_memory_usage_978_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TypeHandle::get_index(void) const
 */
static PyObject *Dtool_TypeHandle_get_index_979(PyObject *self, PyObject *) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TypeHandle::get_index(void) const
  int return_value = (*(const TypeHandle*)local_this).get_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_get_index_979_comment =
  "C++ Interface:\n"
  "get_index(TypeHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the integer index associated with this TypeHandle.  Each different\n"
  " * TypeHandle will have a different index.  However, you probably shouldn't be\n"
  " * using this method; you should just treat the TypeHandles as opaque classes.\n"
  " * This is provided for the convenience of non-C++ scripting languages to\n"
  " * build a hashtable of TypeHandles.\n"
  " */";
#else
static const char *Dtool_TypeHandle_get_index_979_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void TypeHandle::output(ostream &out) const
 */
static PyObject *Dtool_TypeHandle_output_980(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void TypeHandle::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "TypeHandle.output", false, true);
  if (arg_this != NULL) {
    (*(const TypeHandle*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(TypeHandle self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_output_980_comment =
  "C++ Interface:\n"
  "output(TypeHandle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TypeHandle_output_980_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline TypeHandle TypeHandle::none(void)
 */
static PyObject *Dtool_TypeHandle_none_981(PyObject *, PyObject *) {
  // 1-static inline TypeHandle TypeHandle::none(void)
  TypeHandle *return_value = new TypeHandle(TypeHandle::none());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypeHandle_none_981_comment =
  "C++ Interface:\n"
  "none()\n"
  "\n"
  "/**\n"
  " * Returns a special zero-valued TypeHandle that is used to indicate no type.\n"
  " */";
#else
static const char *Dtool_TypeHandle_none_981_comment = NULL;
#endif

static PyObject *Dtool_TypeHandle_index_Getter(PyObject *self, void *) {
  const TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int TypeHandle::get_index(void) const
  int return_value = (*(const TypeHandle*)local_this).get_index();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TypeHandle_name_Getter(PyObject *self, void *) {
  const TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string TypeHandle::get_name(TypedObject *object) const
  std::string return_value = (*(const TypeHandle*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property TypeHandle::parent_classes
 */
static Py_ssize_t Dtool_TypeHandle_parent_classes_Len(PyObject *self) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_parent_classes();
}

/**
 * sequence getter for property TypeHandle::parent_classes
 */
static PyObject *Dtool_TypeHandle_parent_classes_Getitem(PyObject *self, Py_ssize_t index) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_parent_classes()) {
    PyErr_SetString(PyExc_IndexError, "TypeHandle.parent_classes[] index out of range");
    return NULL;
  }
  // 1-inline TypeHandle TypeHandle::get_parent_class(int index) const
  TypeHandle *return_value = new TypeHandle((*(const TypeHandle*)local_this).get_parent_class(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_class(TypeHandle self, index)\n");
  }
}

static PyObject *Dtool_TypeHandle_parent_classes_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_TypeHandle_parent_classes_Len;
  wrap->_getitem_func = &Dtool_TypeHandle_parent_classes_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TypeHandle::child_classes
 */
static Py_ssize_t Dtool_TypeHandle_child_classes_Len(PyObject *self) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_child_classes();
}

/**
 * sequence getter for property TypeHandle::child_classes
 */
static PyObject *Dtool_TypeHandle_child_classes_Getitem(PyObject *self, Py_ssize_t index) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_child_classes()) {
    PyErr_SetString(PyExc_IndexError, "TypeHandle.child_classes[] index out of range");
    return NULL;
  }
  // 1-inline TypeHandle TypeHandle::get_child_class(int index) const
  TypeHandle *return_value = new TypeHandle((*(const TypeHandle*)local_this).get_child_class(index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_class(TypeHandle self, index)\n");
  }
}

static PyObject *Dtool_TypeHandle_child_classes_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_TypeHandle_child_classes_Len;
  wrap->_getitem_func = &Dtool_TypeHandle_child_classes_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline TypeHandle::TypeHandle(void) = default
 * inline TypeHandle::TypeHandle(TypeHandle const &) = default
 */
static int Dtool_Init_TypeHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TypeHandle::TypeHandle(void) = default
      TypeHandle *return_value = new TypeHandle(TypeHandle::none());
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypeHandle, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline TypeHandle::TypeHandle(TypeHandle const &) = default
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if (!(arg_this != NULL)) {
        Dtool_Raise_ArgTypeError(arg, 0, "TypeHandle.TypeHandle", "TypeHandle");
        return -1;
      }
      TypeHandle *return_value = new TypeHandle(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypeHandle, true, false);
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TypeHandle() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TypeHandle()\n"
      "TypeHandle(const TypeHandle param0)\n");
  }
  return -1;
}

TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  TypeHandle *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TypeHandle, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const TypeHandle *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static TypeHandle TypeHandle::make(PyTypeObject *classobj)
    if (PyType_Check(arg)) {
      coerced = Extension<TypeHandle>::make((PyTypeObject *)arg);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != (PyObject *)NULL) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  }
  return NULL;
}

static void *Dtool_UpcastInterface_TypeHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TypeHandle) {
    printf("TypeHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TypeHandle *local_this = (TypeHandle *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TypeHandle) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TypeHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TypeHandle) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TypeRegistry
 */
/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::register_dynamic_type(std::string const &name)
 */
static PyObject *Dtool_TypeRegistry_register_dynamic_type_990(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.register_dynamic_type")) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::register_dynamic_type(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    TypeHandle *return_value = new TypeHandle((*local_this).register_dynamic_type(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_dynamic_type(const TypeRegistry self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_register_dynamic_type_990_comment =
  "C++ Interface:\n"
  "register_dynamic_type(const TypeRegistry self, str name)\n";
#else
static const char *Dtool_TypeRegistry_register_dynamic_type_990_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::record_derivation(TypeHandle child, TypeHandle parent)
 */
static PyObject *Dtool_TypeRegistry_record_derivation_991(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.record_derivation")) {
    return NULL;
  }
  // 1-void TypeRegistry::record_derivation(TypeHandle child, TypeHandle parent)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"child", "parent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:record_derivation", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.record_derivation", "TypeHandle");
    }
    TypeHandle param2_local;
    TypeHandle *param2_this = Dtool_Coerce_TypeHandle(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypeRegistry.record_derivation", "TypeHandle");
    }
    (*local_this).record_derivation(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "record_derivation(const TypeRegistry self, TypeHandle child, TypeHandle parent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_record_derivation_991_comment =
  "C++ Interface:\n"
  "record_derivation(const TypeRegistry self, TypeHandle child, TypeHandle parent)\n";
#else
static const char *Dtool_TypeRegistry_record_derivation_991_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::record_alternate_name(TypeHandle type, std::string const &name)
 */
static PyObject *Dtool_TypeRegistry_record_alternate_name_992(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.record_alternate_name")) {
    return NULL;
  }
  // 1-void TypeRegistry::record_alternate_name(TypeHandle type, std::string const &name)
  PyObject *param1;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"type", "name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:record_alternate_name", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.record_alternate_name", "TypeHandle");
    }
    (*local_this).record_alternate_name(*param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "record_alternate_name(const TypeRegistry self, TypeHandle type, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_record_alternate_name_992_comment =
  "C++ Interface:\n"
  "record_alternate_name(const TypeRegistry self, TypeHandle type, str name)\n";
#else
static const char *Dtool_TypeRegistry_record_alternate_name_992_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::find_type(std::string const &name) const
 */
static PyObject *Dtool_TypeRegistry_find_type_993(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::find_type(std::string const &name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    TypeHandle *return_value = new TypeHandle((*(const TypeRegistry*)local_this).find_type(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_type(TypeRegistry self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_find_type_993_comment =
  "C++ Interface:\n"
  "find_type(TypeRegistry self, str name)\n";
#else
static const char *Dtool_TypeRegistry_find_type_993_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::find_type_by_id(int id) const
 */
static PyObject *Dtool_TypeRegistry_find_type_by_id_994(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::find_type_by_id(int id) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle((*(const TypeRegistry*)local_this).find_type_by_id((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_type_by_id(TypeRegistry self, int id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_find_type_by_id_994_comment =
  "C++ Interface:\n"
  "find_type_by_id(TypeRegistry self, int id)\n";
#else
static const char *Dtool_TypeRegistry_find_type_by_id_994_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string TypeRegistry::get_name(TypeHandle type, TypedObject *object) const
 */
static PyObject *Dtool_TypeRegistry_get_name_995(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string TypeRegistry::get_name(TypeHandle type, TypedObject *object) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"type", "object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_name", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_name", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeRegistry.get_name", false, true);
    if (param2_this != NULL) {
      std::string return_value = (*(const TypeRegistry*)local_this).get_name(*param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_name(TypeRegistry self, TypeHandle type, TypedObject object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_name_995_comment =
  "C++ Interface:\n"
  "get_name(TypeRegistry self, TypeHandle type, TypedObject object)\n";
#else
static const char *Dtool_TypeRegistry_get_name_995_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object)
 */
static PyObject *Dtool_TypeRegistry_is_derived_from_996(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.is_derived_from")) {
    return NULL;
  }
  // 1-bool TypeRegistry::is_derived_from(TypeHandle child, TypeHandle base, TypedObject *child_object)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"child", "base", "child_object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:is_derived_from", (char **)keyword_list, &param1, &param2, &param3)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.is_derived_from", "TypeHandle");
    }
    TypeHandle param2_local;
    TypeHandle *param2_this = Dtool_Coerce_TypeHandle(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypeRegistry.is_derived_from", "TypeHandle");
    }
    TypedObject *param3_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_TypedObject, 3, "TypeRegistry.is_derived_from", false, true);
    if (param3_this != NULL) {
      bool return_value = (*local_this).is_derived_from(*param1_this, *param2_this, param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_derived_from(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_is_derived_from_996_comment =
  "C++ Interface:\n"
  "is_derived_from(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n";
#else
static const char *Dtool_TypeRegistry_is_derived_from_996_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_typehandles(void)
 */
static PyObject *Dtool_TypeRegistry_get_num_typehandles_997(PyObject *self, PyObject *) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_num_typehandles")) {
    return NULL;
  }
  // 1-int TypeRegistry::get_num_typehandles(void)
  int return_value = (*local_this).get_num_typehandles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_typehandles_997_comment =
  "C++ Interface:\n"
  "get_num_typehandles(const TypeRegistry self)\n";
#else
static const char *Dtool_TypeRegistry_get_num_typehandles_997_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_typehandle(int n)
 */
static PyObject *Dtool_TypeRegistry_get_typehandle_998(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_typehandle")) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::get_typehandle(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle((*local_this).get_typehandle((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typehandle(const TypeRegistry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_typehandle_998_comment =
  "C++ Interface:\n"
  "get_typehandle(const TypeRegistry self, int n)\n";
#else
static const char *Dtool_TypeRegistry_get_typehandle_998_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_root_classes(void)
 */
static PyObject *Dtool_TypeRegistry_get_num_root_classes_1000(PyObject *self, PyObject *) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_num_root_classes")) {
    return NULL;
  }
  // 1-int TypeRegistry::get_num_root_classes(void)
  int return_value = (*local_this).get_num_root_classes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_root_classes_1000_comment =
  "C++ Interface:\n"
  "get_num_root_classes(const TypeRegistry self)\n";
#else
static const char *Dtool_TypeRegistry_get_num_root_classes_1000_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_root_class(int n)
 */
static PyObject *Dtool_TypeRegistry_get_root_class_1001(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_root_class")) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::get_root_class(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle((*local_this).get_root_class((int)arg_val));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_root_class(const TypeRegistry self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_root_class_1001_comment =
  "C++ Interface:\n"
  "get_root_class(const TypeRegistry self, int n)\n";
#else
static const char *Dtool_TypeRegistry_get_root_class_1001_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const
 */
static PyObject *Dtool_TypeRegistry_get_num_parent_classes_1003(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-int TypeRegistry::get_num_parent_classes(TypeHandle child, TypedObject *child_object) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"child", "child_object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_num_parent_classes", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_num_parent_classes", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeRegistry.get_num_parent_classes", false, true);
    if (param2_this != NULL) {
      int return_value = (*(const TypeRegistry*)local_this).get_num_parent_classes(*param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_parent_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_parent_classes_1003_comment =
  "C++ Interface:\n"
  "get_num_parent_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n";
#else
static const char *Dtool_TypeRegistry_get_num_parent_classes_1003_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const
 */
static PyObject *Dtool_TypeRegistry_get_parent_class_1004(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::get_parent_class(TypeHandle child, int index) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"child", "index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_parent_class", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_parent_class", "TypeHandle");
    }
    TypeHandle *return_value = new TypeHandle((*(const TypeRegistry*)local_this).get_parent_class(*param1_this, (int)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_class(TypeRegistry self, TypeHandle child, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_parent_class_1004_comment =
  "C++ Interface:\n"
  "get_parent_class(TypeRegistry self, TypeHandle child, int index)\n";
#else
static const char *Dtool_TypeRegistry_get_parent_class_1004_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const
 */
static PyObject *Dtool_TypeRegistry_get_num_child_classes_1005(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-int TypeRegistry::get_num_child_classes(TypeHandle child, TypedObject *child_object) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"child", "child_object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_num_child_classes", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_num_child_classes", "TypeHandle");
    }
    TypedObject *param2_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedObject, 2, "TypeRegistry.get_num_child_classes", false, true);
    if (param2_this != NULL) {
      int return_value = (*(const TypeRegistry*)local_this).get_num_child_classes(*param1_this, param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_child_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_num_child_classes_1005_comment =
  "C++ Interface:\n"
  "get_num_child_classes(TypeRegistry self, TypeHandle child, TypedObject child_object)\n";
#else
static const char *Dtool_TypeRegistry_get_num_child_classes_1005_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const
 */
static PyObject *Dtool_TypeRegistry_get_child_class_1006(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::get_child_class(TypeHandle child, int index) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"child", "index", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:get_child_class", (char **)keyword_list, &param1, &param2)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_child_class", "TypeHandle");
    }
    TypeHandle *return_value = new TypeHandle((*(const TypeRegistry*)local_this).get_child_class(*param1_this, (int)param2));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_class(TypeRegistry self, TypeHandle child, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_child_class_1006_comment =
  "C++ Interface:\n"
  "get_child_class(TypeRegistry self, TypeHandle child, int index)\n";
#else
static const char *Dtool_TypeRegistry_get_child_class_1006_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object)
 */
static PyObject *Dtool_TypeRegistry_get_parent_towards_1007(PyObject *self, PyObject *args, PyObject *kwds) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypeRegistry, (void **)&local_this, "TypeRegistry.get_parent_towards")) {
    return NULL;
  }
  // 1-TypeHandle TypeRegistry::get_parent_towards(TypeHandle child, TypeHandle base, TypedObject *child_object)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"child", "base", "child_object", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_parent_towards", (char **)keyword_list, &param1, &param2, &param3)) {
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypeRegistry.get_parent_towards", "TypeHandle");
    }
    TypeHandle param2_local;
    TypeHandle *param2_this = Dtool_Coerce_TypeHandle(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "TypeRegistry.get_parent_towards", "TypeHandle");
    }
    TypedObject *param3_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_TypedObject, 3, "TypeRegistry.get_parent_towards", false, true);
    if (param3_this != NULL) {
      TypeHandle *return_value = new TypeHandle((*local_this).get_parent_towards(*param1_this, *param2_this, param3_this));
      if (return_value == NULL) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parent_towards(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_get_parent_towards_1007_comment =
  "C++ Interface:\n"
  "get_parent_towards(const TypeRegistry self, TypeHandle child, TypeHandle base, TypedObject child_object)\n";
#else
static const char *Dtool_TypeRegistry_get_parent_towards_1007_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void TypeRegistry::reregister_types(void)
 */
static PyObject *Dtool_TypeRegistry_reregister_types_1008(PyObject *, PyObject *) {
  // 1-static void TypeRegistry::reregister_types(void)
  TypeRegistry::reregister_types();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_reregister_types_1008_comment =
  "C++ Interface:\n"
  "reregister_types()\n";
#else
static const char *Dtool_TypeRegistry_reregister_types_1008_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void TypeRegistry::write(ostream &out) const
 */
static PyObject *Dtool_TypeRegistry_write_1009(PyObject *self, PyObject *arg) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  // 1-void TypeRegistry::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "TypeRegistry.write", false, true);
  if (arg_this != NULL) {
    (*(const TypeRegistry*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(TypeRegistry self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_write_1009_comment =
  "C++ Interface:\n"
  "write(TypeRegistry self, ostream out)\n";
#else
static const char *Dtool_TypeRegistry_write_1009_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeRegistry *TypeRegistry::ptr(void)
 */
static PyObject *Dtool_TypeRegistry_ptr_1010(PyObject *, PyObject *) {
  // 1-static TypeRegistry *TypeRegistry::ptr(void)
  TypeRegistry *return_value = TypeRegistry::ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TypeRegistry_ptr_1010_comment =
  "C++ Interface:\n"
  "ptr()\n"
  "\n"
  "// ptr() returns the pointer to the global TypeRegistry object.";
#else
static const char *Dtool_TypeRegistry_ptr_1010_comment = NULL;
#endif

/**
 * sequence length function for property TypeRegistry::typehandles
 */
static Py_ssize_t Dtool_TypeRegistry_typehandles_Len(PyObject *self) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_typehandles();
}

/**
 * sequence getter for property TypeRegistry::typehandles
 */
static PyObject *Dtool_TypeRegistry_typehandles_Getitem(PyObject *self, Py_ssize_t index) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_typehandles()) {
    PyErr_SetString(PyExc_IndexError, "TypeRegistry.typehandles[] index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-TypeHandle TypeRegistry::get_typehandle(int n)
    TypeHandle *return_value = new TypeHandle((*local_this).get_typehandle(index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call TypeRegistry.get_typehandle() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typehandle(const TypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_TypeRegistry_typehandles_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_TypeRegistry_typehandles_Len;
  wrap->_getitem_func = &Dtool_TypeRegistry_typehandles_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * sequence length function for property TypeRegistry::root_classes
 */
static Py_ssize_t Dtool_TypeRegistry_root_classes_Len(PyObject *self) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_root_classes();
}

/**
 * sequence getter for property TypeRegistry::root_classes
 */
static PyObject *Dtool_TypeRegistry_root_classes_Getitem(PyObject *self, Py_ssize_t index) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_root_classes()) {
    PyErr_SetString(PyExc_IndexError, "TypeRegistry.root_classes[] index out of range");
    return NULL;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-TypeHandle TypeRegistry::get_root_class(int n)
    TypeHandle *return_value = new TypeHandle((*local_this).get_root_class(index));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call TypeRegistry.get_root_class() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_root_class(const TypeRegistry self, index)\n");
  }
}

static PyObject *Dtool_TypeRegistry_root_classes_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_TypeRegistry_root_classes_Len;
  wrap->_getitem_func = &Dtool_TypeRegistry_root_classes_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline TypeRegistry::TypeRegistry(TypeRegistry const &) = default
 */
static int Dtool_Init_TypeRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TypeRegistry() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline TypeRegistry::TypeRegistry(TypeRegistry const &) = default
  TypeRegistry const *arg_this = (TypeRegistry *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypeRegistry, 0, "TypeRegistry.TypeRegistry", true, true);
  if (arg_this != NULL) {
    TypeRegistry *return_value = new TypeRegistry(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TypeRegistry, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TypeRegistry(const TypeRegistry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TypeRegistry_get_typehandles(PyObject *self, PyObject *) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_typehandles();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TypeRegistry_get_typehandle_998(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_TypeRegistry_get_root_classes(PyObject *self, PyObject *) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_root_classes();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_TypeRegistry_get_root_class_1001(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_TypeRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TypeRegistry) {
    printf("TypeRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TypeRegistry *local_this = (TypeRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TypeRegistry) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TypeRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TypeRegistry) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TypedObject
 */
/**
 * Python function wrapper for:
 * virtual TypeHandle TypedObject::get_type(void) const = 0
 */
static PyObject *Dtool_TypedObject_get_type_1019(PyObject *self, PyObject *) {
  TypedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual TypeHandle TypedObject::get_type(void) const = 0
  TypeHandle *return_value = new TypeHandle((*(const TypedObject*)local_this).get_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_get_type_1019_comment =
  "C++ Interface:\n"
  "get_type(TypedObject self)\n"
  "\n"
  "// Derived classes should override this function to return get_class_type().\n"
  "\n"
  "// Derived classes should override this function to return get_class_type().";
#else
static const char *Dtool_TypedObject_get_type_1019_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TypedObject::get_type_index(void) const
 */
static PyObject *Dtool_TypedObject_get_type_index_1021(PyObject *self, PyObject *) {
  TypedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TypedObject::get_type_index(void) const
  int return_value = (*(const TypedObject*)local_this).get_type_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_get_type_index_1021_comment =
  "C++ Interface:\n"
  "get_type_index(TypedObject self)\n"
  "\n"
  "/**\n"
  " * Returns the internal index number associated with this object's TypeHandle,\n"
  " * a unique number for each different type.  This is equivalent to\n"
  " * get_type().get_index().\n"
  " */";
#else
static const char *Dtool_TypedObject_get_type_index_1021_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TypedObject::is_of_type(TypeHandle handle) const
 */
static PyObject *Dtool_TypedObject_is_of_type_1022(PyObject *self, PyObject *arg) {
  TypedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TypedObject::is_of_type(TypeHandle handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TypedObject.is_of_type", "TypeHandle");
  }
  bool return_value = (*(const TypedObject*)local_this).is_of_type(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_of_type(TypedObject self, TypeHandle handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_is_of_type_1022_comment =
  "C++ Interface:\n"
  "is_of_type(TypedObject self, TypeHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns true if the current object is or derives from the indicated type.\n"
  " */";
#else
static const char *Dtool_TypedObject_is_of_type_1022_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool TypedObject::is_exact_type(TypeHandle handle) const
 */
static PyObject *Dtool_TypedObject_is_exact_type_1023(PyObject *self, PyObject *arg) {
  TypedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedObject, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool TypedObject::is_exact_type(TypeHandle handle) const
  TypeHandle arg_local;
  TypeHandle *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "TypedObject.is_exact_type", "TypeHandle");
  }
  bool return_value = (*(const TypedObject*)local_this).is_exact_type(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_exact_type(TypedObject self, TypeHandle handle)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_is_exact_type_1023_comment =
  "C++ Interface:\n"
  "is_exact_type(TypedObject self, TypeHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns true if the current object is the indicated type exactly.\n"
  " */";
#else
static const char *Dtool_TypedObject_is_exact_type_1023_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedObject::get_class_type(void)
 */
static PyObject *Dtool_TypedObject_get_class_type_1024(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TypedObject::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_get_class_type_1024_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedObject_get_class_type_1024_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *TypedObject::downcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_TypedObject_downcast_to_TypedReferenceCount_1209(PyObject *self, PyObject *) {
  TypedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedObject, (void **)&local_this, "TypedObject.downcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *TypedObject::downcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedObject_downcast_to_TypedReferenceCount_1209_comment =
  "C++ Interface:\n"
  "downcast_to_TypedReferenceCount(const TypedObject self)\n"
  "\n"
  "downcast from TypedObject to TypedReferenceCount";
#else
static const char *Dtool_TypedObject_downcast_to_TypedReferenceCount_1209_comment = NULL;
#endif

static PyObject *Dtool_TypedObject_type_Getter(PyObject *self, void *) {
  const TypedObject *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypedObject, (void **)&local_this)) {
    return NULL;
  }

  // 1-virtual TypeHandle TypedObject::get_type(void) const = 0
  TypeHandle *return_value = new TypeHandle((*(const TypedObject*)local_this).get_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

static int Dtool_Init_TypedObject(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TypedObject) {
    printf("TypedObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TypedObject *local_this = (TypedObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TypedObject) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TypedObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class fstream
 */
/**
 * Python function wrapper for:
 * void fstream::close(void)
 */
static PyObject *Dtool_fstream_close_1027(PyObject *self, PyObject *) {
  fstream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_fstream, (void **)&local_this, "fstream.close")) {
    return NULL;
  }
  // 1-void fstream::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_fstream_close_1027_comment =
  "C++ Interface:\n"
  "close(const fstream self)\n";
#else
static const char *Dtool_fstream_close_1027_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * fstream::fstream(void)
 */
static int Dtool_Init_fstream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "fstream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-fstream::fstream(void)
  fstream *return_value = new fstream();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_fstream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "fstream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_fstream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_fstream) {
    printf("fstream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  fstream *local_this = (fstream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_fstream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_iostream) {
    return (iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *)(iostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_fstream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_fstream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_iostream) {
    iostream* other_this = (iostream*)from_this;
    return (fstream*)other_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (fstream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (fstream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ifstream
 */
/**
 * Python function wrapper for:
 * void ifstream::close(void)
 */
static PyObject *Dtool_ifstream_close_1031(PyObject *self, PyObject *) {
  ifstream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ifstream, (void **)&local_this, "ifstream.close")) {
    return NULL;
  }
  // 1-void ifstream::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ifstream_close_1031_comment =
  "C++ Interface:\n"
  "close(const ifstream self)\n";
#else
static const char *Dtool_ifstream_close_1031_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ifstream::ifstream(void)
 */
static int Dtool_Init_ifstream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ifstream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-ifstream::ifstream(void)
  ifstream *return_value = new ifstream();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ifstream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ifstream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ifstream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ifstream) {
    printf("ifstream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ifstream *local_this = (ifstream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ifstream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ifstream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ifstream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (ifstream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ofstream
 */
/**
 * Python function wrapper for:
 * void ofstream::close(void)
 */
static PyObject *Dtool_ofstream_close_1035(PyObject *self, PyObject *) {
  ofstream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ofstream, (void **)&local_this, "ofstream.close")) {
    return NULL;
  }
  // 1-void ofstream::close(void)
  (*local_this).close();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ofstream_close_1035_comment =
  "C++ Interface:\n"
  "close(const ofstream self)\n";
#else
static const char *Dtool_ofstream_close_1035_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ofstream::ofstream(void)
 */
static int Dtool_Init_ofstream(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ofstream() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-ofstream::ofstream(void)
  ofstream *return_value = new ofstream();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ofstream, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ofstream()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ofstream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ofstream) {
    printf("ofstream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ofstream *local_this = (ofstream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ofstream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ofstream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ofstream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (ofstream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MemoryUsage
 */
/**
 * Python function wrapper for:
 * static inline bool MemoryUsage::is_tracking(void)
 */
static PyObject *Dtool_MemoryUsage_is_tracking_1039(PyObject *, PyObject *) {
  // 1-static inline bool MemoryUsage::is_tracking(void)
  bool return_value = MemoryUsage::is_tracking();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_is_tracking_1039_comment =
  "C++ Interface:\n"
  "is_tracking()\n"
  "\n"
  "/**\n"
  " * Returns true if the MemoryUsage object is currently tracking memory (e.g.\n"
  " * track-memory-usage is configured #t).\n"
  " */";
#else
static const char *Dtool_MemoryUsage_is_tracking_1039_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline bool MemoryUsage::is_counting(void)
 */
static PyObject *Dtool_MemoryUsage_is_counting_1040(PyObject *, PyObject *) {
  // 1-static inline bool MemoryUsage::is_counting(void)
  bool return_value = MemoryUsage::is_counting();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_is_counting_1040_comment =
  "C++ Interface:\n"
  "is_counting()\n"
  "\n"
  "/**\n"
  " * Returns true if the MemoryUsage object is currently at least counting\n"
  " * memory (e.g.  this is a Windows debug build), even if it's not fully\n"
  " * tracking it.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_is_counting_1040_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_current_cpp_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_current_cpp_size_1041(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_current_cpp_size(void)
  std::size_t return_value = MemoryUsage::get_current_cpp_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_current_cpp_size_1041_comment =
  "C++ Interface:\n"
  "get_current_cpp_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes of allocated memory consumed by C++\n"
  " * objects, not including the memory previously frozen.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_current_cpp_size_1041_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_total_cpp_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_total_cpp_size_1042(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_total_cpp_size(void)
  std::size_t return_value = MemoryUsage::get_total_cpp_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_total_cpp_size_1042_comment =
  "C++ Interface:\n"
  "get_total_cpp_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes of allocated memory consumed by C++\n"
  " * objects, including the memory previously frozen.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_total_cpp_size_1042_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_heap_single_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_heap_single_size_1043(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_single_size(void)
  std::size_t return_value = MemoryUsage::get_panda_heap_single_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_heap_single_size_1043_comment =
  "C++ Interface:\n"
  "get_panda_heap_single_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes allocated from the heap from code within\n"
  " * Panda, for individual objects.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_heap_single_size_1043_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_heap_array_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_heap_array_size_1044(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_array_size(void)
  std::size_t return_value = MemoryUsage::get_panda_heap_array_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_heap_array_size_1044_comment =
  "C++ Interface:\n"
  "get_panda_heap_array_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes allocated from the heap from code within\n"
  " * Panda, for arrays.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_heap_array_size_1044_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_heap_overhead(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_heap_overhead_1045(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_overhead(void)
  std::size_t return_value = MemoryUsage::get_panda_heap_overhead();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_heap_overhead_1045_comment =
  "C++ Interface:\n"
  "get_panda_heap_overhead()\n"
  "\n"
  "/**\n"
  " * Returns the extra bytes allocated from the system that are not immediately\n"
  " * used for holding allocated objects.  This can only be determined if\n"
  " * ALTERNATIVE_MALLOC is enabled.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_heap_overhead_1045_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_mmap_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_mmap_size_1046(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_mmap_size(void)
  std::size_t return_value = MemoryUsage::get_panda_mmap_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_mmap_size_1046_comment =
  "C++ Interface:\n"
  "get_panda_mmap_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes allocated from the virtual memory pool\n"
  " * from code within Panda.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_mmap_size_1046_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_external_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_external_size_1047(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_external_size(void)
  std::size_t return_value = MemoryUsage::get_external_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_external_size_1047_comment =
  "C++ Interface:\n"
  "get_external_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes of allocated memory in the heap that\n"
  " * Panda didn't seem to be responsible for.  This includes a few bytes for\n"
  " * very low-level objects (like ConfigVariables) that cannot use Panda memory\n"
  " * tracking because they are so very low-level.\n"
  " *\n"
  " * This also includes all of the memory that might have been allocated by a\n"
  " * high-level interpreter, like Python.\n"
  " *\n"
  " * This number is only available if Panda is able to hook into the actual heap\n"
  " * callback.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_external_size_1047_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_total_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_total_size_1048(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_total_size(void)
  std::size_t return_value = MemoryUsage::get_total_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_total_size_1048_comment =
  "C++ Interface:\n"
  "get_total_size()\n"
  "\n"
  "/**\n"
  " * Returns the total size of allocated memory consumed by the process, as\n"
  " * nearly as can be determined.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_total_size_1048_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline int MemoryUsage::get_num_pointers(void)
 */
static PyObject *Dtool_MemoryUsage_get_num_pointers_1049(PyObject *, PyObject *) {
  // 1-static inline int MemoryUsage::get_num_pointers(void)
  int return_value = MemoryUsage::get_num_pointers();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_num_pointers_1049_comment =
  "C++ Interface:\n"
  "get_num_pointers()\n"
  "\n"
  "/**\n"
  " * Returns the number of pointers currently active.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_num_pointers_1049_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers(MemoryUsagePointers &result)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_1050(PyObject *, PyObject *arg) {
  // 1-static inline void MemoryUsage::get_pointers(MemoryUsagePointers &result)
  MemoryUsagePointers *arg_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers", false, true);
  if (arg_this != NULL) {
    MemoryUsage::get_pointers(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers(MemoryUsagePointers result)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_1050_comment =
  "C++ Interface:\n"
  "get_pointers(MemoryUsagePointers result)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all pointers\n"
  " * currently active.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_1050_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers_of_type(MemoryUsagePointers &result, TypeHandle type)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_of_type_1051(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void MemoryUsage::get_pointers_of_type(MemoryUsagePointers &result, TypeHandle type)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"result", "type", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_pointers_of_type", (char **)keyword_list, &param0, &param1)) {
    MemoryUsagePointers *param0_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers_of_type", false, true);
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MemoryUsage.get_pointers_of_type", "TypeHandle");
    }
    if (param0_this != NULL) {
      MemoryUsage::get_pointers_of_type(*param0_this, *param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers_of_type(MemoryUsagePointers result, TypeHandle type)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_of_type_1051_comment =
  "C++ Interface:\n"
  "get_pointers_of_type(MemoryUsagePointers result, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all pointers of the\n"
  " * indicated type currently active.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_of_type_1051_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers_of_age(MemoryUsagePointers &result, double from, double to)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_of_age_1052(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void MemoryUsage::get_pointers_of_age(MemoryUsagePointers &result, double from, double to)
  PyObject *param0;
  double param1;
  double param2;
  static const char *keyword_list[] = {"result", "from", "to", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:get_pointers_of_age", (char **)keyword_list, &param0, &param1, &param2)) {
    MemoryUsagePointers *param0_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers_of_age", false, true);
    if (param0_this != NULL) {
      MemoryUsage::get_pointers_of_age(*param0_this, (double)param1, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers_of_age(MemoryUsagePointers result, double from, double to)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_of_age_1052_comment =
  "C++ Interface:\n"
  "get_pointers_of_age(MemoryUsagePointers result, double from, double to)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all pointers that\n"
  " * were allocated within the range of the indicated number of seconds ago.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_of_age_1052_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers_with_zero_count(MemoryUsagePointers &result)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_with_zero_count_1053(PyObject *, PyObject *arg) {
  // 1-static inline void MemoryUsage::get_pointers_with_zero_count(MemoryUsagePointers &result)
  MemoryUsagePointers *arg_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers_with_zero_count", false, true);
  if (arg_this != NULL) {
    MemoryUsage::get_pointers_with_zero_count(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers_with_zero_count(MemoryUsagePointers result)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_with_zero_count_1053_comment =
  "C++ Interface:\n"
  "get_pointers_with_zero_count(MemoryUsagePointers result)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all currently\n"
  " * active pointers (that is, pointers allocated since the last call to\n"
  " * freeze(), and not yet freed) that have a zero reference count.\n"
  " *\n"
  " * Generally, an undeleted pointer with a zero reference count means its\n"
  " * reference count has never been incremented beyond zero (since once it has\n"
  " * been incremented, the only way it can return to zero would free the\n"
  " * pointer).  This may include objects that are allocated statically or on the\n"
  " * stack, which are never intended to be deleted.  Or, it might represent a\n"
  " * programmer or compiler error.\n"
  " *\n"
  " * This function has the side-effect of incrementing each of their reference\n"
  " * counts by one, thus preventing them from ever being freed--but since they\n"
  " * hadn't been freed anyway, probably no additional harm is done.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_with_zero_count_1053_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::freeze(void)
 */
static PyObject *Dtool_MemoryUsage_freeze_1054(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::freeze(void)
  MemoryUsage::freeze();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_freeze_1054_comment =
  "C++ Interface:\n"
  "freeze()\n"
  "\n"
  "/**\n"
  " * 'Freezes' all pointers currently stored so that they are no longer\n"
  " * reported; only newly allocate pointers from this point on will appear in\n"
  " * future information requests.  This makes it easier to differentiate between\n"
  " * continuous leaks and one-time memory allocations.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_freeze_1054_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_current_types(void)
 */
static PyObject *Dtool_MemoryUsage_show_current_types_1055(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_current_types(void)
  MemoryUsage::show_current_types();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_current_types_1055_comment =
  "C++ Interface:\n"
  "show_current_types()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of types of all of the active pointers.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_current_types_1055_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_trend_types(void)
 */
static PyObject *Dtool_MemoryUsage_show_trend_types_1056(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_trend_types(void)
  MemoryUsage::show_trend_types();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_trend_types_1056_comment =
  "C++ Interface:\n"
  "show_trend_types()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of types of all of the pointers allocated and freed\n"
  " * since the last call to freeze().\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_trend_types_1056_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_current_ages(void)
 */
static PyObject *Dtool_MemoryUsage_show_current_ages_1057(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_current_ages(void)
  MemoryUsage::show_current_ages();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_current_ages_1057_comment =
  "C++ Interface:\n"
  "show_current_ages()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of ages of all of the active pointers.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_current_ages_1057_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_trend_ages(void)
 */
static PyObject *Dtool_MemoryUsage_show_trend_ages_1058(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_trend_ages(void)
  MemoryUsage::show_trend_ages();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_trend_ages_1058_comment =
  "C++ Interface:\n"
  "show_trend_ages()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of ages of all of the pointers allocated and freed\n"
  " * since the last call to freeze().\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_trend_ages_1058_comment = NULL;
#endif

static int Dtool_Init_MemoryUsage(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MemoryUsage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MemoryUsage) {
    printf("MemoryUsage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MemoryUsage *local_this = (MemoryUsage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MemoryUsage) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MemoryUsage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MemoryUsage) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int ReferenceCount::get_ref_count(void) const
 */
static PyObject *Dtool_ReferenceCount_get_ref_count_1065(PyObject *self, PyObject *) {
  ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int ReferenceCount::get_ref_count(void) const
  int return_value = (*(const ReferenceCount*)local_this).get_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_get_ref_count_1065_comment =
  "C++ Interface:\n"
  "get_ref_count(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_get_ref_count_1065_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void ReferenceCount::ref(void) const
 */
static PyObject *Dtool_ReferenceCount_ref_1066(PyObject *self, PyObject *) {
  ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void ReferenceCount::ref(void) const
  (*(const ReferenceCount*)local_this).ref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_ref_1066_comment =
  "C++ Interface:\n"
  "ref(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the reference count.  User code should avoid using\n"
  " * ref() and unref() directly, which can result in missed reference counts.\n"
  " * Instead, let a PointerTo object manage the reference counting\n"
  " * automatically.\n"
  " *\n"
  " * This function is const, even though it changes the object, because\n"
  " * generally fiddling with an object's reference count isn't considered part\n"
  " * of fiddling with the object.  An object might be const in other ways, but\n"
  " * we still need to accurately count the number of references to it.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_ref_1066_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual inline bool ReferenceCount::unref(void) const
 */
static PyObject *Dtool_ReferenceCount_unref_1067(PyObject *self, PyObject *) {
  ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual inline bool ReferenceCount::unref(void) const
  bool return_value = (*(const ReferenceCount*)local_this).unref();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_unref_1067_comment =
  "C++ Interface:\n"
  "unref(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the reference count.  Note that the object will not\n"
  " * be implicitly deleted by unref() simply because the reference count drops\n"
  " * to zero.  (Having a member function delete itself is problematic.) However,\n"
  " * see the helper function unref_delete().\n"
  " *\n"
  " * User code should avoid using ref() and unref() directly, which can result\n"
  " * in missed reference counts.  Instead, let a PointerTo object manage the\n"
  " * reference counting automatically.\n"
  " *\n"
  " * This function is const, even though it changes the object, because\n"
  " * generally fiddling with an object's reference count isn't considered part\n"
  " * of fiddling with the object.  An object might be const in other ways, but\n"
  " * we still need to accurately count the number of references to it.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_unref_1067_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_ReferenceCount_test_ref_count_integrity_1069(PyObject *self, PyObject *) {
  ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ReferenceCount::test_ref_count_integrity(void) const
  bool return_value = (*(const ReferenceCount*)local_this).test_ref_count_integrity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_test_ref_count_integrity_1069_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.  Returns true if ok, false otherwise.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_test_ref_count_integrity_1069_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool ReferenceCount::test_ref_count_nonzero(void) const
 */
static PyObject *Dtool_ReferenceCount_test_ref_count_nonzero_1070(PyObject *self, PyObject *) {
  ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool ReferenceCount::test_ref_count_nonzero(void) const
  bool return_value = (*(const ReferenceCount*)local_this).test_ref_count_nonzero();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_test_ref_count_nonzero_1070_comment =
  "C++ Interface:\n"
  "test_ref_count_nonzero(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't zero, or\n"
  " * completely bogus.  Returns true if ok, false otherwise.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_test_ref_count_nonzero_1070_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_ReferenceCount_get_class_type_1071(PyObject *, PyObject *) {
  // 1-static TypeHandle ReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(ReferenceCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_get_class_type_1071_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ReferenceCount_get_class_type_1071_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *ReferenceCount::downcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211(PyObject *self, PyObject *) {
  ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ReferenceCount, (void **)&local_this, "ReferenceCount.downcast_to_TypedReferenceCount")) {
    return NULL;
  }
  // 1-TypedReferenceCount *ReferenceCount::downcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211_comment =
  "C++ Interface:\n"
  "downcast_to_TypedReferenceCount(const ReferenceCount self)\n"
  "\n"
  "downcast from ReferenceCount to TypedReferenceCount";
#else
static const char *Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211_comment = NULL;
#endif

static PyObject *Dtool_ReferenceCount_ref_count_Getter(PyObject *self, void *) {
  const ReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ReferenceCount::get_ref_count(void) const
  int return_value = (*(const ReferenceCount*)local_this).get_ref_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ReferenceCount) {
    printf("ReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ReferenceCount *local_this = (ReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Buffer
 */
/**
 * Python function wrapper for:
 * inline int Buffer::get_length(void) const
 */
static PyObject *Dtool_Buffer_get_length_1073(PyObject *self, PyObject *) {
  Buffer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Buffer, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Buffer::get_length(void) const
  int return_value = (*(const Buffer*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffer_get_length_1073_comment =
  "C++ Interface:\n"
  "get_length(Buffer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Buffer_get_length_1073_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Buffer::Buffer(Buffer const &) = default
 */
static int Dtool_Init_Buffer(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Buffer() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline Buffer::Buffer(Buffer const &) = default
  Buffer const *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Buffer.Buffer", true, true);
  if (arg_this != NULL) {
    Buffer *return_value = new Buffer(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Buffer, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Buffer(const Buffer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Buffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Buffer) {
    printf("Buffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Buffer *local_this = (Buffer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Buffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Buffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Buffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Buffer*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PStatCollectorForwardBase
 */
/**
 * Python function wrapper for:
 * virtual void PStatCollectorForwardBase::add_level(double level) = 0
 */
static PyObject *Dtool_PStatCollectorForwardBase_add_level_1083(PyObject *self, PyObject *arg) {
  PStatCollectorForwardBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollectorForwardBase, (void **)&local_this, "PStatCollectorForwardBase.add_level")) {
    return NULL;
  }
  // 1-virtual void PStatCollectorForwardBase::add_level(double level) = 0
  if (PyNumber_Check(arg)) {
    (*local_this).add_level(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const PStatCollectorForwardBase self, double level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollectorForwardBase_add_level_1083_comment =
  "C++ Interface:\n"
  "add_level(const PStatCollectorForwardBase self, double level)\n";
#else
static const char *Dtool_PStatCollectorForwardBase_add_level_1083_comment = NULL;
#endif

static int Dtool_Init_PStatCollectorForwardBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PStatCollectorForwardBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PStatCollectorForwardBase) {
    printf("PStatCollectorForwardBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PStatCollectorForwardBase *local_this = (PStatCollectorForwardBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PStatCollectorForwardBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PStatCollectorForwardBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PStatCollectorForwardBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PStatCollectorForwardBase*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class NodeReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int NodeReferenceCount::get_node_ref_count(void) const
 */
static PyObject *Dtool_NodeReferenceCount_get_node_ref_count_1085(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int NodeReferenceCount::get_node_ref_count(void) const
  int return_value = (*(const NodeReferenceCount*)local_this).get_node_ref_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_get_node_ref_count_1085_comment =
  "C++ Interface:\n"
  "get_node_ref_count(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_get_node_ref_count_1085_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void NodeReferenceCount::node_ref(void) const
 */
static PyObject *Dtool_NodeReferenceCount_node_ref_1086(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void NodeReferenceCount::node_ref(void) const
  (*(const NodeReferenceCount*)local_this).node_ref();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_node_ref_1086_comment =
  "C++ Interface:\n"
  "node_ref(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the node reference count and the normal reference\n"
  " * count simultaneously.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_node_ref_1086_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeReferenceCount::node_unref(void) const
 */
static PyObject *Dtool_NodeReferenceCount_node_unref_1087(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NodeReferenceCount::node_unref(void) const
  bool return_value = (*(const NodeReferenceCount*)local_this).node_unref();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_node_unref_1087_comment =
  "C++ Interface:\n"
  "node_unref(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the node reference count and the normal reference\n"
  " * count simultaneously.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_node_unref_1087_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_NodeReferenceCount_test_ref_count_integrity_1088(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NodeReferenceCount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool NodeReferenceCount::test_ref_count_integrity(void) const
  bool return_value = (*(const NodeReferenceCount*)local_this).test_ref_count_integrity();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_test_ref_count_integrity_1088_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_test_ref_count_integrity_1088_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_NodeReferenceCount_get_class_type_1089(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(NodeReferenceCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_get_class_type_1089_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeReferenceCount_get_class_type_1089_comment = NULL;
#endif

static int Dtool_Init_NodeReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NodeReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_NodeReferenceCount) {
    printf("NodeReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  NodeReferenceCount *local_this = (NodeReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_NodeReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_NodeReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_NodeReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NodeReferenceCount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Datagram
 */
/**
 * Python function wrapper for:
 * inline void Datagram::operator =(Datagram const &copy)
 */
static PyObject *Dtool_Datagram_operator_1092(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.assign")) {
    return NULL;
  }
  // 1-inline void Datagram::operator =(Datagram const &copy)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Datagram.assign", "Datagram");
  }
  (*local_this).operator =(*arg_this);
  Datagram *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Datagram self, const Datagram copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_operator_1092_comment =
  "C++ Interface:\n"
  "assign(const Datagram self, const Datagram copy)\n";
#else
static const char *Dtool_Datagram_operator_1092_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void Datagram::clear(void)
 */
static PyObject *Dtool_Datagram_clear_1093(PyObject *self, PyObject *) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.clear")) {
    return NULL;
  }
  // 1-virtual void Datagram::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Datagram_clear_1093_comment =
  "C++ Interface:\n"
  "clear(const Datagram self)\n"
  "\n"
  "/**\n"
  " * Resets the datagram to empty, in preparation for building up a new\n"
  " * datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_clear_1093_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Datagram::dump_hex(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_Datagram_dump_hex_1094(PyObject *self, PyObject *args, PyObject *kwds) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Datagram::dump_hex(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:dump_hex", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Datagram.dump_hex", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const Datagram*)local_this).dump_hex(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dump_hex(Datagram self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_dump_hex_1094_comment =
  "C++ Interface:\n"
  "dump_hex(Datagram self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Writes a representation of the entire datagram contents, as a sequence of\n"
  " * hex (and ASCII) values.\n"
  " */";
#else
static const char *Dtool_Datagram_dump_hex_1094_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_bool(bool value)
 */
static PyObject *Dtool_Datagram_add_bool_1095(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_bool")) {
    return NULL;
  }
  // 1-inline void Datagram::add_bool(bool value)
  (*local_this).add_bool((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_bool(const Datagram self, bool value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_bool_1095_comment =
  "C++ Interface:\n"
  "add_bool(const Datagram self, bool value)\n"
  "\n"
  "/**\n"
  " * Adds a boolean value to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_bool_1095_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int8(int8_t value)
 */
static PyObject *Dtool_Datagram_add_int8_1096(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int8")) {
    return NULL;
  }
  // 1-inline void Datagram::add_int8(int8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < CHAR_MIN || param1 > CHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed byte",
                          param1);
    }
#endif
    (*local_this).add_int8((int8_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int8(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int8_1096_comment =
  "C++ Interface:\n"
  "add_int8(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 8-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int8_1096_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint8(uint8_t value)
 */
static PyObject *Dtool_Datagram_add_uint8_1097(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint8")) {
    return NULL;
  }
  // 1-inline void Datagram::add_uint8(uint8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    (*local_this).add_uint8((uint8_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint8(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint8_1097_comment =
  "C++ Interface:\n"
  "add_uint8(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 8-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint8_1097_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int16(int16_t value)
 */
static PyObject *Dtool_Datagram_add_int16_1098(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int16")) {
    return NULL;
  }
  // 1-inline void Datagram::add_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
    (*local_this).add_int16((int16_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int16(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int16_1098_comment =
  "C++ Interface:\n"
  "add_int16(const Datagram self, int value)\n"
  "\n"
  "// The default numeric packing is little-endian.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int16_1098_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int32(int32_t value)
 */
static PyObject *Dtool_Datagram_add_int32_1099(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_int32((int32_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int32(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int32_1099_comment =
  "C++ Interface:\n"
  "add_int32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int32_1099_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int64(int64_t value)
 */
static PyObject *Dtool_Datagram_add_int64_1100(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int64")) {
    return NULL;
  }
  // 1-inline void Datagram::add_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_int64", &param1)) {
    (*local_this).add_int64((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int64(const Datagram self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int64_1100_comment =
  "C++ Interface:\n"
  "add_int64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int64_1100_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint16(uint16_t value)
 */
static PyObject *Dtool_Datagram_add_uint16_1101(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint16")) {
    return NULL;
  }
  // 1-inline void Datagram::add_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).add_uint16((uint16_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint16(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint16_1101_comment =
  "C++ Interface:\n"
  "add_uint16(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint16_1101_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint32(uint32_t value)
 */
static PyObject *Dtool_Datagram_add_uint32_1102(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).add_uint32((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint32(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint32_1102_comment =
  "C++ Interface:\n"
  "add_uint32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint32_1102_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint64(uint64_t value)
 */
static PyObject *Dtool_Datagram_add_uint64_1103(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint64")) {
    return NULL;
  }
  // 1-inline void Datagram::add_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_uint64", &param1)) {
    (*local_this).add_uint64((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint64(const Datagram self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint64_1103_comment =
  "C++ Interface:\n"
  "add_uint64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint64_1103_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_float32(PN_float32 value)
 */
static PyObject *Dtool_Datagram_add_float32_1104(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_float32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_float32(PN_float32 value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_float32((PN_float32)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float32(const Datagram self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_float32_1104_comment =
  "C++ Interface:\n"
  "add_float32(const Datagram self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision floating-point number to the datagram.\n"
  " * Since this kind of float is not necessarily portable across different\n"
  " * architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_Datagram_add_float32_1104_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_float64(PN_float64 value)
 */
static PyObject *Dtool_Datagram_add_float64_1105(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_float64")) {
    return NULL;
  }
  // 1-inline void Datagram::add_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_float64(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float64(const Datagram self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_float64_1105_comment =
  "C++ Interface:\n"
  "add_float64(const Datagram self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit floating-point number to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_float64_1105_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_stdfloat(PN_stdfloat value)
 */
static PyObject *Dtool_Datagram_add_stdfloat_1106(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_stdfloat")) {
    return NULL;
  }
  // 1-inline void Datagram::add_stdfloat(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_stdfloat((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stdfloat(const Datagram self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_stdfloat_1106_comment =
  "C++ Interface:\n"
  "add_stdfloat(const Datagram self, float value)\n"
  "\n"
  "/**\n"
  " * Adds either a 32-bit or a 64-bit floating-point number, according to\n"
  " * set_stdfloat_double().\n"
  " */";
#else
static const char *Dtool_Datagram_add_stdfloat_1106_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_int16(int16_t value)
 */
static PyObject *Dtool_Datagram_add_be_int16_1107(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_int16")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
    (*local_this).add_be_int16((int16_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int16(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_int16_1107_comment =
  "C++ Interface:\n"
  "add_be_int16(const Datagram self, int value)\n"
  "\n"
  "// These functions pack numbers big-endian, in case that's desired.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_int16_1107_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_int32(int32_t value)
 */
static PyObject *Dtool_Datagram_add_be_int32_1108(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_int32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).add_be_int32((int32_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int32(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_int32_1108_comment =
  "C++ Interface:\n"
  "add_be_int32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_int32_1108_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_int64(int64_t value)
 */
static PyObject *Dtool_Datagram_add_be_int64_1109(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_int64")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_be_int64", &param1)) {
    (*local_this).add_be_int64((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int64(const Datagram self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_int64_1109_comment =
  "C++ Interface:\n"
  "add_be_int64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_int64_1109_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_uint16(uint16_t value)
 */
static PyObject *Dtool_Datagram_add_be_uint16_1110(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_uint16")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    (*local_this).add_be_uint16((uint16_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint16(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_uint16_1110_comment =
  "C++ Interface:\n"
  "add_be_uint16(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_uint16_1110_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_uint32(uint32_t value)
 */
static PyObject *Dtool_Datagram_add_be_uint32_1111(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_uint32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    (*local_this).add_be_uint32((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint32(const Datagram self, int value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_uint32_1111_comment =
  "C++ Interface:\n"
  "add_be_uint32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_uint32_1111_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_uint64(uint64_t value)
 */
static PyObject *Dtool_Datagram_add_be_uint64_1112(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_uint64")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_be_uint64", &param1)) {
    (*local_this).add_be_uint64((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint64(const Datagram self, long value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_uint64_1112_comment =
  "C++ Interface:\n"
  "add_be_uint64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_uint64_1112_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_float32(PN_float32 value)
 */
static PyObject *Dtool_Datagram_add_be_float32_1113(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_float32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_float32(PN_float32 value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_be_float32((PN_float32)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float32(const Datagram self, float value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_float32_1113_comment =
  "C++ Interface:\n"
  "add_be_float32(const Datagram self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision big-endian floating-point number to the\n"
  " * datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_float32_1113_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_float64(PN_float64 value)
 */
static PyObject *Dtool_Datagram_add_be_float64_1114(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_float64")) {
    return NULL;
  }
  // 1-inline void Datagram::add_be_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
    (*local_this).add_be_float64(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float64(const Datagram self, double value)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_float64_1114_comment =
  "C++ Interface:\n"
  "add_be_float64(const Datagram self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit big-endian floating-point number to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_float64_1114_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_string(std::string const &str)
 */
static PyObject *Dtool_Datagram_add_string_1115(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_string")) {
    return NULL;
  }
  // 1-inline void Datagram::add_string(std::string const &str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_string(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string(const Datagram self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_string_1115_comment =
  "C++ Interface:\n"
  "add_string(const Datagram self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the datagram.  This actually adds a count\n"
  " * followed by n bytes.\n"
  " */";
#else
static const char *Dtool_Datagram_add_string_1115_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_string32(std::string const &str)
 */
static PyObject *Dtool_Datagram_add_string32_1116(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_string32")) {
    return NULL;
  }
  // 1-inline void Datagram::add_string32(std::string const &str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_string32(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string32(const Datagram self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_string32_1116_comment =
  "C++ Interface:\n"
  "add_string32(const Datagram self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the datagram, using a 32-bit length field\n"
  " * to allow very long strings.\n"
  " */";
#else
static const char *Dtool_Datagram_add_string32_1116_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_z_string(std::string str)
 */
static PyObject *Dtool_Datagram_add_z_string_1117(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_z_string")) {
    return NULL;
  }
  // 1-inline void Datagram::add_z_string(std::string str)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).add_z_string(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z_string(const Datagram self, str str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_z_string_1117_comment =
  "C++ Interface:\n"
  "add_z_string(const Datagram self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the datagram, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_Datagram_add_z_string_1117_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_fixed_string(std::string const &str, std::size_t size)
 */
static PyObject *Dtool_Datagram_add_fixed_string_1118(PyObject *self, PyObject *args, PyObject *kwds) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_fixed_string")) {
    return NULL;
  }
  // 1-inline void Datagram::add_fixed_string(std::string const &str, std::size_t size)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"str", "size", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#n:add_fixed_string", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    (*local_this).add_fixed_string(std::string(param1_str, param1_len), (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_fixed_string(const Datagram self, str str, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_fixed_string_1118_comment =
  "C++ Interface:\n"
  "add_fixed_string(const Datagram self, str str, int size)\n"
  "\n"
  "/**\n"
  " * Adds a fixed-length string to the datagram.  If the string given is less\n"
  " * than the requested size, this will pad the string out with zeroes; if it is\n"
  " * greater than the requested size, this will silently truncate the string.\n"
  " */";
#else
static const char *Dtool_Datagram_add_fixed_string_1118_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Datagram::add_wstring(std::wstring const &str)
 */
static PyObject *Dtool_Datagram_add_wstring_1119(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_wstring")) {
    return NULL;
  }
  // 1-void Datagram::add_wstring(std::wstring const &str)
  #if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
  #else
  PyUnicodeObject *param1;
  #endif
  if (PyArg_Parse(arg, "U:add_wstring", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    (*local_this).add_wstring(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_wstring(const Datagram self, unicode str)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_wstring_1119_comment =
  "C++ Interface:\n"
  "add_wstring(const Datagram self, unicode str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length wstring to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_wstring_1119_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Datagram::pad_bytes(std::size_t size)
 */
static PyObject *Dtool_Datagram_pad_bytes_1120(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.pad_bytes")) {
    return NULL;
  }
  // 1-void Datagram::pad_bytes(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:pad_bytes", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).pad_bytes((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pad_bytes(const Datagram self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_pad_bytes_1120_comment =
  "C++ Interface:\n"
  "pad_bytes(const Datagram self, int size)\n"
  "\n"
  "/**\n"
  " * Adds the indicated number of zero bytes to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_pad_bytes_1120_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::append_data(std::string const &data)
 */
static PyObject *Dtool_Datagram_append_data_1121(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.append_data")) {
    return NULL;
  }
  // 1-inline void Datagram::append_data(std::string const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).append_data(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_data(const Datagram self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_append_data_1121_comment =
  "C++ Interface:\n"
  "append_data(const Datagram self, str data)\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the datagram.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_append_data_1121_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Datagram::get_message(void) const
 */
static PyObject *Dtool_Datagram_get_message_1123(PyObject *self, PyObject *) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string Datagram::get_message(void) const
  std::string return_value = (*(const Datagram*)local_this).get_message();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_message_1123_comment =
  "C++ Interface:\n"
  "get_message(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns the datagram's data as a string.\n"
  " */";
#else
static const char *Dtool_Datagram_get_message_1123_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Datagram::get_length(void) const
 */
static PyObject *Dtool_Datagram_get_length_1125(PyObject *self, PyObject *) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t Datagram::get_length(void) const
  std::size_t return_value = (*(const Datagram*)local_this).get_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_length_1125_comment =
  "C++ Interface:\n"
  "get_length(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes in the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_get_length_1125_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::set_array(PTA_uchar data)
 */
static PyObject *Dtool_Datagram_set_array_1126(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.set_array")) {
    return NULL;
  }
  // 1-inline void Datagram::set_array(PTA_uchar data)
  PointerToArray< unsigned char > arg_local;
  PTA_uchar *arg_this = Dtool_Coerce_PointerToArray_unsigned_char(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Datagram.set_array", "PointerToArray");
  }
  (*local_this).set_array(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_array(const Datagram self, PointerToArray data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_set_array_1126_comment =
  "C++ Interface:\n"
  "set_array(const Datagram self, PointerToArray data)\n"
  "\n"
  "/**\n"
  " * Replaces the data in the Datagram with the data in the indicated PTA_uchar.\n"
  " * This is assignment by reference: subsequent changes to the Datagram will\n"
  " * also change the source PTA_uchar.\n"
  " */";
#else
static const char *Dtool_Datagram_set_array_1126_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::copy_array(CPTA_uchar data)
 */
static PyObject *Dtool_Datagram_copy_array_1127(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.copy_array")) {
    return NULL;
  }
  // 1-inline void Datagram::copy_array(CPTA_uchar data)
  ConstPointerToArray< unsigned char > arg_local;
  CPTA_uchar *arg_this = Dtool_Coerce_ConstPointerToArray_unsigned_char(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Datagram.copy_array", "ConstPointerToArray");
  }
  (*local_this).copy_array(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_array(const Datagram self, ConstPointerToArray data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_copy_array_1127_comment =
  "C++ Interface:\n"
  "copy_array(const Datagram self, ConstPointerToArray data)\n"
  "\n"
  "/**\n"
  " * Replaces the data in the Datagram with a copy of the data in the indicated\n"
  " * CPTA_uchar.  Unlike set_array(), a complete copy is made of the data;\n"
  " * subsequent changes to the Datagram will *not* change the source CPTA_uchar.\n"
  " */";
#else
static const char *Dtool_Datagram_copy_array_1127_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_uchar Datagram::get_array(void) const
 */
static PyObject *Dtool_Datagram_get_array_1128(PyObject *self, PyObject *) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CPTA_uchar Datagram::get_array(void) const
  CPTA_uchar *return_value = new CPTA_uchar((*(const Datagram*)local_this).get_array());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_array_1128_comment =
  "C++ Interface:\n"
  "get_array(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the actual data in the Datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_get_array_1128_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PTA_uchar Datagram::modify_array(void)
 */
static PyObject *Dtool_Datagram_modify_array_1129(PyObject *self, PyObject *) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.modify_array")) {
    return NULL;
  }
  // 1-inline PTA_uchar Datagram::modify_array(void)
  PTA_uchar *return_value = new PTA_uchar((*local_this).modify_array());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_modify_array_1129_comment =
  "C++ Interface:\n"
  "modify_array(const Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the actual data in the Datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_modify_array_1129_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::set_stdfloat_double(bool stdfloat_double)
 */
static PyObject *Dtool_Datagram_set_stdfloat_double_1130(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.set_stdfloat_double")) {
    return NULL;
  }
  // 1-inline void Datagram::set_stdfloat_double(bool stdfloat_double)
  (*local_this).set_stdfloat_double((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stdfloat_double(const Datagram self, bool stdfloat_double)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_set_stdfloat_double_1130_comment =
  "C++ Interface:\n"
  "set_stdfloat_double(const Datagram self, bool stdfloat_double)\n"
  "\n"
  "/**\n"
  " * Changes the stdfloat_double flag, which defines the operation performed by\n"
  " * add_stdfloat() and DatagramIterator::get_stdfloat().  When this is true,\n"
  " * add_stdfloat() adds a 64-bit floating-point number; when it is false, it\n"
  " * adds a 32-bit floating-point number.  The default is based on the\n"
  " * STDFLOAT_DOUBLE compilation flag.\n"
  " */";
#else
static const char *Dtool_Datagram_set_stdfloat_double_1130_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Datagram::get_stdfloat_double(void) const
 */
static PyObject *Dtool_Datagram_get_stdfloat_double_1131(PyObject *self, PyObject *) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Datagram::get_stdfloat_double(void) const
  bool return_value = (*(const Datagram*)local_this).get_stdfloat_double();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_stdfloat_double_1131_comment =
  "C++ Interface:\n"
  "get_stdfloat_double(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns the stdfloat_double flag.  See set_stdfloat_double().\n"
  " */";
#else
static const char *Dtool_Datagram_get_stdfloat_double_1131_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Datagram::output(ostream &out) const
 */
static PyObject *Dtool_Datagram_output_1135(PyObject *self, PyObject *arg) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Datagram::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Datagram.output", false, true);
  if (arg_this != NULL) {
    (*(const Datagram*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Datagram self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_output_1135_comment =
  "C++ Interface:\n"
  "output(Datagram self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Datagram_output_1135_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Datagram::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_Datagram_write_1136(PyObject *self, PyObject *args, PyObject *kwds) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Datagram::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Datagram.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const Datagram*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Datagram self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_write_1136_comment =
  "C++ Interface:\n"
  "write(Datagram self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Datagram_write_1136_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Datagram::get_class_type(void)
 */
static PyObject *Dtool_Datagram_get_class_type_1137(PyObject *, PyObject *) {
  // 1-static TypeHandle Datagram::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Datagram::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_class_type_1137_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Datagram_get_class_type_1137_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Datagram::Datagram(void)
 * inline Datagram::Datagram(Datagram const &copy)
 * inline Datagram::Datagram(std::string const &data)
 */
static int Dtool_Init_Datagram(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Datagram::Datagram(void)
      Datagram *return_value = new Datagram();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Datagram::Datagram(Datagram const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Datagram", (char **)keyword_list, &param0)) {
          Datagram const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Datagram, (void **)&param0_this);
          if (param0_this != NULL) {
            Datagram *return_value = new Datagram(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline Datagram::Datagram(std::string const &data)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"data", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Datagram", (char **)keyword_list, &param0_str, &param0_len)) {
          Datagram *return_value = new Datagram(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline Datagram::Datagram(Datagram const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Datagram", (char **)keyword_list, &param0)) {
          Datagram const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_Datagram(param0, param0_this, param0_manage)) {
            Datagram *return_value = new Datagram(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Datagram::Datagram(std::string const &data)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Datagram() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Datagram()\n"
      "Datagram(const Datagram copy)\n"
      "Datagram(str data)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Datagram, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Datagram::Datagram(std::string const &data)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Datagram *return_value = new Datagram(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Datagram, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline Datagram::Datagram(std::string const &data)
    char *param0_str = NULL;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, &param0_str, &param0_len) == -1) {
      param0_str = NULL;
    }
#endif
    if (param0_str != NULL) {
      Datagram *return_value = new Datagram(std::string(param0_str, param0_len));
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_Datagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Datagram) {
    printf("Datagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Datagram *local_this = (Datagram *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Datagram) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Datagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Datagram) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Datagram*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DatagramGenerator
 */
/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::get_datagram(Datagram &data) = 0
 */
static PyObject *Dtool_DatagramGenerator_get_datagram_1140(PyObject *self, PyObject *arg) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_datagram")) {
    return NULL;
  }
  // 1-virtual bool DatagramGenerator::get_datagram(Datagram &data) = 0
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramGenerator.get_datagram", "Datagram");
  }
  bool return_value = (*local_this).get_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram(const DatagramGenerator self, Datagram data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_datagram_1140_comment =
  "C++ Interface:\n"
  "get_datagram(const DatagramGenerator self, Datagram data)\n";
#else
static const char *Dtool_DatagramGenerator_get_datagram_1140_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::save_datagram(SubfileInfo &info)
 */
static PyObject *Dtool_DatagramGenerator_save_datagram_1141(PyObject *self, PyObject *arg) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.save_datagram")) {
    return NULL;
  }
  // 1-virtual bool DatagramGenerator::save_datagram(SubfileInfo &info)
  SubfileInfo *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_SubfileInfo(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramGenerator.save_datagram", "SubfileInfo");
  }
  bool return_value = (*local_this).save_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_datagram(const DatagramGenerator self, SubfileInfo info)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_save_datagram_1141_comment =
  "C++ Interface:\n"
  "save_datagram(const DatagramGenerator self, SubfileInfo info)\n"
  "\n"
  "/**\n"
  " * Skips over the next datagram without extracting it, but saves the relevant\n"
  " * file information in the SubfileInfo object so that its data may be read\n"
  " * later.  For non-file-based datagram generators, this may mean creating a\n"
  " * temporary file and copying the contents of the datagram to disk.\n"
  " *\n"
  " * Returns true on success, false on failure or if this method is\n"
  " * unimplemented.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_save_datagram_1141_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::is_eof(void) = 0
 */
static PyObject *Dtool_DatagramGenerator_is_eof_1142(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.is_eof")) {
    return NULL;
  }
  // 1-virtual bool DatagramGenerator::is_eof(void) = 0
  bool return_value = (*local_this).is_eof();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_is_eof_1142_comment =
  "C++ Interface:\n"
  "is_eof(const DatagramGenerator self)\n";
#else
static const char *Dtool_DatagramGenerator_is_eof_1142_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::is_error(void) = 0
 */
static PyObject *Dtool_DatagramGenerator_is_error_1143(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.is_error")) {
    return NULL;
  }
  // 1-virtual bool DatagramGenerator::is_error(void) = 0
  bool return_value = (*local_this).is_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_is_error_1143_comment =
  "C++ Interface:\n"
  "is_error(const DatagramGenerator self)\n";
#else
static const char *Dtool_DatagramGenerator_is_error_1143_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual Filename const &DatagramGenerator::get_filename(void)
 */
static PyObject *Dtool_DatagramGenerator_get_filename_1144(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_filename")) {
    return NULL;
  }
  // 1-virtual Filename const &DatagramGenerator::get_filename(void)
  Filename const *return_value = &((*local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_filename_1144_comment =
  "C++ Interface:\n"
  "get_filename(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that provides the source for these datagrams, if any,\n"
  " * or empty string if the datagrams do not originate from a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_filename_1144_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual time_t DatagramGenerator::get_timestamp(void) const
 */
static PyObject *Dtool_DatagramGenerator_get_timestamp_1145(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramGenerator, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual time_t DatagramGenerator::get_timestamp(void) const
  time_t return_value = (*(const DatagramGenerator*)local_this).get_timestamp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_timestamp_1145_comment =
  "C++ Interface:\n"
  "get_timestamp(DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the on-disk timestamp of the file that was read, at the time it was\n"
  " * opened, if that is available, or 0 if it is not.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_timestamp_1145_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual FileReference const *DatagramGenerator::get_file(void)
 */
static PyObject *Dtool_DatagramGenerator_get_file_1146(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_file")) {
    return NULL;
  }
  // 1-virtual FileReference const *DatagramGenerator::get_file(void)
  FileReference const *return_value = (*local_this).get_file();
  if (return_value != (FileReference const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (FileReference const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_file_1146_comment =
  "C++ Interface:\n"
  "get_file(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the FileReference that provides the source for these datagrams, if\n"
  " * any, or NULL if the datagrams do not originate from a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_file_1146_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual VirtualFile *DatagramGenerator::get_vfile(void)
 */
static PyObject *Dtool_DatagramGenerator_get_vfile_1147(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_vfile")) {
    return NULL;
  }
  // 1-virtual VirtualFile *DatagramGenerator::get_vfile(void)
  VirtualFile *return_value = (*local_this).get_vfile();
  if (return_value != (VirtualFile *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (VirtualFile *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFile, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_vfile_1147_comment =
  "C++ Interface:\n"
  "get_vfile(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the VirtualFile that provides the source for these datagrams, if\n"
  " * any, or NULL if the datagrams do not originate from a VirtualFile.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_vfile_1147_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual streamoff DatagramGenerator::get_file_pos(void)
 */
static PyObject *Dtool_DatagramGenerator_get_file_pos_1148(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_file_pos")) {
    return NULL;
  }
  // 1-virtual streamoff DatagramGenerator::get_file_pos(void)
  streamoff return_value = (*local_this).get_file_pos();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_file_pos_1148_comment =
  "C++ Interface:\n"
  "get_file_pos(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the current file position within the data stream, if any, or 0 if\n"
  " * the file position is not meaningful or cannot be determined.\n"
  " *\n"
  " * For DatagramGenerators that return a meaningful file position, this will be\n"
  " * pointing to the first byte following the datagram returned after a call to\n"
  " * get_datagram().\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_file_pos_1148_comment = NULL;
#endif

static int Dtool_Init_DatagramGenerator(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DatagramGenerator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DatagramGenerator) {
    printf("DatagramGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DatagramGenerator *local_this = (DatagramGenerator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DatagramGenerator) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DatagramGenerator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DatagramIterator
 */
/**
 * Python function wrapper for:
 * inline void DatagramIterator::operator =(DatagramIterator const &copy)
 */
static PyObject *Dtool_DatagramIterator_operator_1151(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.assign")) {
    return NULL;
  }
  // 1-inline void DatagramIterator::operator =(DatagramIterator const &copy)
  DatagramIterator arg_local;
  DatagramIterator const *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramIterator.assign", "DatagramIterator");
  }
  (*local_this).operator =(*arg_this);
  DatagramIterator *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramIterator, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const DatagramIterator self, const DatagramIterator copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_operator_1151_comment =
  "C++ Interface:\n"
  "assign(const DatagramIterator self, const DatagramIterator copy)\n";
#else
static const char *Dtool_DatagramIterator_operator_1151_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool DatagramIterator::get_bool(void)
 */
static PyObject *Dtool_DatagramIterator_get_bool_1153(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_bool")) {
    return NULL;
  }
  // 1-inline bool DatagramIterator::get_bool(void)
  bool return_value = (*local_this).get_bool();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_bool_1153_comment =
  "C++ Interface:\n"
  "get_bool(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a boolean value.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_bool_1153_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int8_t DatagramIterator::get_int8(void)
 */
static PyObject *Dtool_DatagramIterator_get_int8_1154(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int8")) {
    return NULL;
  }
  // 1-inline int8_t DatagramIterator::get_int8(void)
  int8_t return_value = (*local_this).get_int8();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int8_1154_comment =
  "C++ Interface:\n"
  "get_int8(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 8-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int8_1154_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint8_t DatagramIterator::get_uint8(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint8_1155(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint8")) {
    return NULL;
  }
  // 1-inline uint8_t DatagramIterator::get_uint8(void)
  uint8_t return_value = (*local_this).get_uint8();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint8_1155_comment =
  "C++ Interface:\n"
  "get_uint8(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 8-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint8_1155_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int16_t DatagramIterator::get_int16(void)
 */
static PyObject *Dtool_DatagramIterator_get_int16_1156(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int16")) {
    return NULL;
  }
  // 1-inline int16_t DatagramIterator::get_int16(void)
  int16_t return_value = (*local_this).get_int16();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int16_1156_comment =
  "C++ Interface:\n"
  "get_int16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 16-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int16_1156_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int32_t DatagramIterator::get_int32(void)
 */
static PyObject *Dtool_DatagramIterator_get_int32_1157(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int32")) {
    return NULL;
  }
  // 1-inline int32_t DatagramIterator::get_int32(void)
  int32_t return_value = (*local_this).get_int32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int32_1157_comment =
  "C++ Interface:\n"
  "get_int32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 32-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int32_1157_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DatagramIterator::get_int64(void)
 */
static PyObject *Dtool_DatagramIterator_get_int64_1158(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int64")) {
    return NULL;
  }
  // 1-inline int64_t DatagramIterator::get_int64(void)
  int64_t return_value = (*local_this).get_int64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int64_1158_comment =
  "C++ Interface:\n"
  "get_int64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 64-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int64_1158_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t DatagramIterator::get_uint16(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint16_1159(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint16")) {
    return NULL;
  }
  // 1-inline uint16_t DatagramIterator::get_uint16(void)
  uint16_t return_value = (*local_this).get_uint16();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint16_1159_comment =
  "C++ Interface:\n"
  "get_uint16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 16-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint16_1159_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t DatagramIterator::get_uint32(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint32_1160(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint32")) {
    return NULL;
  }
  // 1-inline uint32_t DatagramIterator::get_uint32(void)
  uint32_t return_value = (*local_this).get_uint32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint32_1160_comment =
  "C++ Interface:\n"
  "get_uint32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 32-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint32_1160_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DatagramIterator::get_uint64(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint64_1161(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint64")) {
    return NULL;
  }
  // 1-inline uint64_t DatagramIterator::get_uint64(void)
  uint64_t return_value = (*local_this).get_uint64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint64_1161_comment =
  "C++ Interface:\n"
  "get_uint64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 64-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint64_1161_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 DatagramIterator::get_float32(void)
 */
static PyObject *Dtool_DatagramIterator_get_float32_1162(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_float32")) {
    return NULL;
  }
  // 1-inline PN_float32 DatagramIterator::get_float32(void)
  PN_float32 return_value = (*local_this).get_float32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_float32_1162_comment =
  "C++ Interface:\n"
  "get_float32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit single-precision floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_float32_1162_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 DatagramIterator::get_float64(void)
 */
static PyObject *Dtool_DatagramIterator_get_float64_1163(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_float64")) {
    return NULL;
  }
  // 1-inline PN_float64 DatagramIterator::get_float64(void)
  PN_float64 return_value = (*local_this).get_float64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_float64_1163_comment =
  "C++ Interface:\n"
  "get_float64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_float64_1163_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DatagramIterator::get_stdfloat(void)
 */
static PyObject *Dtool_DatagramIterator_get_stdfloat_1164(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_stdfloat")) {
    return NULL;
  }
  // 1-inline PN_stdfloat DatagramIterator::get_stdfloat(void)
  PN_stdfloat return_value = (*local_this).get_stdfloat();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_stdfloat_1164_comment =
  "C++ Interface:\n"
  "get_stdfloat(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts either a 32-bit or a 64-bit floating-point number, according to\n"
  " * Datagram::set_stdfloat_double().\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_stdfloat_1164_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int16_t DatagramIterator::get_be_int16(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_int16_1165(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_int16")) {
    return NULL;
  }
  // 1-inline int16_t DatagramIterator::get_be_int16(void)
  int16_t return_value = (*local_this).get_be_int16();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_int16_1165_comment =
  "C++ Interface:\n"
  "get_be_int16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 16-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_int16_1165_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int32_t DatagramIterator::get_be_int32(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_int32_1166(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_int32")) {
    return NULL;
  }
  // 1-inline int32_t DatagramIterator::get_be_int32(void)
  int32_t return_value = (*local_this).get_be_int32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_int32_1166_comment =
  "C++ Interface:\n"
  "get_be_int32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 32-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_int32_1166_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DatagramIterator::get_be_int64(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_int64_1167(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_int64")) {
    return NULL;
  }
  // 1-inline int64_t DatagramIterator::get_be_int64(void)
  int64_t return_value = (*local_this).get_be_int64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_int64_1167_comment =
  "C++ Interface:\n"
  "get_be_int64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 64-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_int64_1167_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t DatagramIterator::get_be_uint16(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_uint16_1168(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_uint16")) {
    return NULL;
  }
  // 1-inline uint16_t DatagramIterator::get_be_uint16(void)
  uint16_t return_value = (*local_this).get_be_uint16();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_uint16_1168_comment =
  "C++ Interface:\n"
  "get_be_uint16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 16-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_uint16_1168_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t DatagramIterator::get_be_uint32(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_uint32_1169(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_uint32")) {
    return NULL;
  }
  // 1-inline uint32_t DatagramIterator::get_be_uint32(void)
  uint32_t return_value = (*local_this).get_be_uint32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_uint32_1169_comment =
  "C++ Interface:\n"
  "get_be_uint32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 32-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_uint32_1169_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DatagramIterator::get_be_uint64(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_uint64_1170(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_uint64")) {
    return NULL;
  }
  // 1-inline uint64_t DatagramIterator::get_be_uint64(void)
  uint64_t return_value = (*local_this).get_be_uint64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_uint64_1170_comment =
  "C++ Interface:\n"
  "get_be_uint64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 64-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_uint64_1170_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 DatagramIterator::get_be_float32(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_float32_1171(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_float32")) {
    return NULL;
  }
  // 1-inline PN_float32 DatagramIterator::get_be_float32(void)
  PN_float32 return_value = (*local_this).get_be_float32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_float32_1171_comment =
  "C++ Interface:\n"
  "get_be_float32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit big-endian single-precision floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_float32_1171_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 DatagramIterator::get_be_float64(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_float64_1172(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_float64")) {
    return NULL;
  }
  // 1-inline PN_float64 DatagramIterator::get_be_float64(void)
  PN_float64 return_value = (*local_this).get_be_float64();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_float64_1172_comment =
  "C++ Interface:\n"
  "get_be_float64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit big-endian floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_float64_1172_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_string(void)
 */
static PyObject *Dtool_DatagramIterator_get_string_1173(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_string")) {
    return NULL;
  }
  // 1-std::string DatagramIterator::get_string(void)
  std::string return_value = (*local_this).get_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_string_1173_comment =
  "C++ Interface:\n"
  "get_string(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_string_1173_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_string32(void)
 */
static PyObject *Dtool_DatagramIterator_get_string32_1174(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_string32")) {
    return NULL;
  }
  // 1-std::string DatagramIterator::get_string32(void)
  std::string return_value = (*local_this).get_string32();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_string32_1174_comment =
  "C++ Interface:\n"
  "get_string32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string with a 32-bit length field.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_string32_1174_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_z_string(void)
 */
static PyObject *Dtool_DatagramIterator_get_z_string_1175(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_z_string")) {
    return NULL;
  }
  // 1-std::string DatagramIterator::get_z_string(void)
  std::string return_value = (*local_this).get_z_string();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_z_string_1175_comment =
  "C++ Interface:\n"
  "get_z_string(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_z_string_1175_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_fixed_string(std::size_t size)
 */
static PyObject *Dtool_DatagramIterator_get_fixed_string_1176(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_fixed_string")) {
    return NULL;
  }
  // 1-std::string DatagramIterator::get_fixed_string(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_fixed_string", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*local_this).get_fixed_string((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_fixed_string(const DatagramIterator self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_fixed_string_1176_comment =
  "C++ Interface:\n"
  "get_fixed_string(const DatagramIterator self, int size)\n"
  "\n"
  "/**\n"
  " * Extracts a fixed-length string.  However, if a zero byte occurs within the\n"
  " * string, it marks the end of the string.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_fixed_string_1176_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::wstring DatagramIterator::get_wstring(void)
 */
static PyObject *Dtool_DatagramIterator_get_wstring_1177(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_wstring")) {
    return NULL;
  }
  // 1-std::wstring DatagramIterator::get_wstring(void)
  std::wstring return_value = (*local_this).get_wstring();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_wstring_1177_comment =
  "C++ Interface:\n"
  "get_wstring(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length wstring (with a 32-bit length field).\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_wstring_1177_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void DatagramIterator::skip_bytes(std::size_t size)
 */
static PyObject *Dtool_DatagramIterator_skip_bytes_1178(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.skip_bytes")) {
    return NULL;
  }
  // 1-inline void DatagramIterator::skip_bytes(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:skip_bytes", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).skip_bytes((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "skip_bytes(const DatagramIterator self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_skip_bytes_1178_comment =
  "C++ Interface:\n"
  "skip_bytes(const DatagramIterator self, int size)\n"
  "\n"
  "/**\n"
  " * Skips over the indicated number of bytes in the datagram.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_skip_bytes_1178_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::extract_bytes(std::size_t size)
 */
static PyObject *Dtool_DatagramIterator_extract_bytes_1179(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.extract_bytes")) {
    return NULL;
  }
  // 1-std::string DatagramIterator::extract_bytes(std::size_t size)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:extract_bytes", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*local_this).extract_bytes((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_bytes(const DatagramIterator self, int size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_extract_bytes_1179_comment =
  "C++ Interface:\n"
  "extract_bytes(const DatagramIterator self, int size)\n"
  "\n"
  "/**\n"
  " * Extracts the indicated number of bytes in the datagram and returns them as\n"
  " * a string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Extracts the indicated number of bytes in the datagram into the given\n"
  " * character buffer.  Assumes that the buffer is big enough to hold the\n"
  " * requested number of bytes.  Returns the number of bytes that were\n"
  " * successfully written.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_extract_bytes_1179_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string DatagramIterator::get_remaining_bytes(void) const
 */
static PyObject *Dtool_DatagramIterator_get_remaining_bytes_1180(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string DatagramIterator::get_remaining_bytes(void) const
  std::string return_value = (*(const DatagramIterator*)local_this).get_remaining_bytes();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_remaining_bytes_1180_comment =
  "C++ Interface:\n"
  "get_remaining_bytes(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Returns the remaining bytes in the datagram as a string, but does not\n"
  " * extract them from the iterator.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_remaining_bytes_1180_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DatagramIterator::get_remaining_size(void) const
 */
static PyObject *Dtool_DatagramIterator_get_remaining_size_1181(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t DatagramIterator::get_remaining_size(void) const
  std::size_t return_value = (*(const DatagramIterator*)local_this).get_remaining_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_remaining_size_1181_comment =
  "C++ Interface:\n"
  "get_remaining_size(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Return the bytes left in the datagram.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_remaining_size_1181_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Datagram const &DatagramIterator::get_datagram(void) const
 */
static PyObject *Dtool_DatagramIterator_get_datagram_1182(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Datagram const &DatagramIterator::get_datagram(void) const
  Datagram const *return_value = &((*(const DatagramIterator*)local_this).get_datagram());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, false, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_datagram_1182_comment =
  "C++ Interface:\n"
  "get_datagram(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Return the datagram of this iterator.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_datagram_1182_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DatagramIterator::get_current_index(void) const
 */
static PyObject *Dtool_DatagramIterator_get_current_index_1183(PyObject *self, PyObject *) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t DatagramIterator::get_current_index(void) const
  std::size_t return_value = (*(const DatagramIterator*)local_this).get_current_index();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_current_index_1183_comment =
  "C++ Interface:\n"
  "get_current_index(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Returns the current position within the datagram of the next piece of data\n"
  " * to extract.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_current_index_1183_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DatagramIterator::output(ostream &out) const
 */
static PyObject *Dtool_DatagramIterator_output_1184(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DatagramIterator::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "DatagramIterator.output", false, true);
  if (arg_this != NULL) {
    (*(const DatagramIterator*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DatagramIterator self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_output_1184_comment =
  "C++ Interface:\n"
  "output(DatagramIterator self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_output_1184_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void DatagramIterator::write(ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_DatagramIterator_write_1185(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }
  // 1-void DatagramIterator::write(ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "DatagramIterator.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != NULL) {
      (*(const DatagramIterator*)local_this).write(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DatagramIterator self, ostream out, int indent)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_write_1185_comment =
  "C++ Interface:\n"
  "write(DatagramIterator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_write_1185_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DatagramIterator::get_class_type(void)
 */
static PyObject *Dtool_DatagramIterator_get_class_type_1186(PyObject *, PyObject *) {
  // 1-static TypeHandle DatagramIterator::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(DatagramIterator::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_class_type_1186_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DatagramIterator_get_class_type_1186_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline DatagramIterator::DatagramIterator(void)
 * inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset = 0)
 * inline DatagramIterator::DatagramIterator(DatagramIterator const &copy)
 */
static int Dtool_Init_DatagramIterator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DatagramIterator::DatagramIterator(void)
      DatagramIterator *return_value = new DatagramIterator();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset = 0)
        PyObject *param0;
        Py_ssize_t param1 = 0;
        static const char *keyword_list[] = {"datagram", "offset", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|n:DatagramIterator", (char **)keyword_list, &param0, &param1)) {
          Datagram const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Datagram, (void **)&param0_this);
#ifndef NDEBUG
          if (param1 < 0) {
            PyErr_Format(PyExc_OverflowError,
                         "can't convert negative value %zd to size_t",
                         param1);
            return -1;
          }
#endif
          if (param0_this != NULL) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this, (std::size_t)param1);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DatagramIterator::DatagramIterator(DatagramIterator const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DatagramIterator", (char **)keyword_list, &param0)) {
          DatagramIterator const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_DatagramIterator, (void **)&param0_this);
          if (param0_this != NULL) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset = 0)
        PyObject *param0;
        Py_ssize_t param1 = 0;
        static const char *keyword_list[] = {"datagram", "offset", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|n:DatagramIterator", (char **)keyword_list, &param0, &param1)) {
          Datagram const *param0_this;
          bool param0_manage = false;
#ifndef NDEBUG
          if (param1 < 0) {
            PyErr_Format(PyExc_OverflowError,
                         "can't convert negative value %zd to size_t",
                         param1);
            return -1;
          }
#endif
          if (Dtool_ConstCoerce_Datagram(param0, param0_this, param0_manage)) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this, (std::size_t)param1);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DatagramIterator::DatagramIterator(DatagramIterator const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:DatagramIterator", (char **)keyword_list, &param0)) {
          DatagramIterator param0_local;
          DatagramIterator const *param0_this = Dtool_Coerce_DatagramIterator(param0, param0_local);
          if ((param0_this != NULL)) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DatagramIterator() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramIterator()\n"
      "DatagramIterator(const Datagram datagram, int offset)\n"
      "DatagramIterator(const DatagramIterator copy)\n");
  }
  return -1;
}

DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  DatagramIterator *local_this;
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_DatagramIterator, (void**)&local_this);
  if (local_this != NULL) {
    if (((Dtool_PyInstDef *)args)->_is_const) {
      // This is a const object.  Make a copy.
      coerced = *(const DatagramIterator *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset)
    Datagram const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Datagram, (void **)&arg_this);
    if (arg_this != NULL) {
      coerced = DatagramIterator(*arg_this);
      if (_PyErr_OCCURRED()) {
        return NULL;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset)
      PyObject *param0;
      Py_ssize_t param1;
      if (PyArg_ParseTuple(args, "On:DatagramIterator", &param0, &param1)) {
        Datagram const *param0_this;
        DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Datagram, (void **)&param0_this);
#ifndef NDEBUG
        if (param1 < 0) {
          PyErr_Format(PyExc_OverflowError,
                       "can't convert negative value %zd to size_t",
                       param1);
          return NULL;
        }
#endif
        if (param0_this != NULL) {
          coerced = DatagramIterator(*param0_this, (std::size_t)param1);
          if (_PyErr_OCCURRED()) {
            return NULL;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return NULL;
}

static void *Dtool_UpcastInterface_DatagramIterator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DatagramIterator) {
    printf("DatagramIterator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DatagramIterator *local_this = (DatagramIterator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DatagramIterator) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DatagramIterator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DatagramIterator) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class DatagramSink
 */
/**
 * Python function wrapper for:
 * virtual bool DatagramSink::put_datagram(Datagram const &data) = 0
 */
static PyObject *Dtool_DatagramSink_put_datagram_1189(PyObject *self, PyObject *arg) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.put_datagram")) {
    return NULL;
  }
  // 1-virtual bool DatagramSink::put_datagram(Datagram const &data) = 0
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramSink.put_datagram", "Datagram");
  }
  bool return_value = (*local_this).put_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put_datagram(const DatagramSink self, const Datagram data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_put_datagram_1189_comment =
  "C++ Interface:\n"
  "put_datagram(const DatagramSink self, const Datagram data)\n";
#else
static const char *Dtool_DatagramSink_put_datagram_1189_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSink::copy_datagram(SubfileInfo &result, Filename const &filename)
 * virtual bool DatagramSink::copy_datagram(SubfileInfo &result, SubfileInfo const &source)
 */
static PyObject *Dtool_DatagramSink_copy_datagram_1190(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.copy_datagram")) {
    return NULL;
  }
  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, Filename const &filename)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SubfileInfo, 1, "DatagramSink.copy_datagram", false, false);
      Filename const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_Filename, (void **)&param2_this);
      if (param1_this != NULL && param2_this != NULL) {
        bool return_value = (*local_this).copy_datagram(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, SubfileInfo const &source)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SubfileInfo, 1, "DatagramSink.copy_datagram", false, false);
      SubfileInfo const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_SubfileInfo, (void **)&param2_this);
      if (param1_this != NULL && param2_this != NULL) {
        bool return_value = (*local_this).copy_datagram(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, Filename const &filename)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this;
      bool param1_manage = false;
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if (Dtool_Coerce_SubfileInfo(param1, param1_this, param1_manage) && (param2_this != NULL)) {
        bool return_value = (*local_this).copy_datagram(*param1_this, *param2_this);
        if (param1_manage) {
          delete param1_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, SubfileInfo const &source)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "source", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this;
      bool param1_manage = false;
      SubfileInfo const *param2_this;
      bool param2_manage = false;
      if (Dtool_Coerce_SubfileInfo(param1, param1_this, param1_manage) && Dtool_ConstCoerce_SubfileInfo(param2, param2_this, param2_manage)) {
        bool return_value = (*local_this).copy_datagram(*param1_this, *param2_this);
        if (param1_manage) {
          delete param1_this;
        }
        if (param2_manage) {
          delete param2_this;
        }
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_datagram(const DatagramSink self, SubfileInfo result, const Filename filename)\n"
      "copy_datagram(const DatagramSink self, SubfileInfo result, const SubfileInfo source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_copy_datagram_1190_comment =
  "C++ Interface:\n"
  "copy_datagram(const DatagramSink self, SubfileInfo result, const Filename filename)\n"
  "copy_datagram(const DatagramSink self, SubfileInfo result, const SubfileInfo source)\n"
  "\n"
  "/**\n"
  " * Copies the file data from the entire indicated file (via the vfs) as the\n"
  " * next datagram.  This is intended to support potentially very large\n"
  " * datagrams.\n"
  " *\n"
  " * Returns true on success, false on failure or if this method is\n"
  " * unimplemented.  On true, fills \"result\" with the information that\n"
  " * references the copied file, if possible.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the file data from the range of the indicated file (outside of the\n"
  " * vfs) as the next datagram.  This is intended to support potentially very\n"
  " * large datagrams.\n"
  " *\n"
  " * Returns true on success, false on failure or if this method is\n"
  " * unimplemented.  On true, fills \"result\" with the information that\n"
  " * references the copied file, if possible.\n"
  " */";
#else
static const char *Dtool_DatagramSink_copy_datagram_1190_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSink::is_error(void) = 0
 */
static PyObject *Dtool_DatagramSink_is_error_1191(PyObject *self, PyObject *) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.is_error")) {
    return NULL;
  }
  // 1-virtual bool DatagramSink::is_error(void) = 0
  bool return_value = (*local_this).is_error();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_is_error_1191_comment =
  "C++ Interface:\n"
  "is_error(const DatagramSink self)\n";
#else
static const char *Dtool_DatagramSink_is_error_1191_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void DatagramSink::flush(void) = 0
 */
static PyObject *Dtool_DatagramSink_flush_1192(PyObject *self, PyObject *) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.flush")) {
    return NULL;
  }
  // 1-virtual void DatagramSink::flush(void) = 0
  (*local_this).flush();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_flush_1192_comment =
  "C++ Interface:\n"
  "flush(const DatagramSink self)\n";
#else
static const char *Dtool_DatagramSink_flush_1192_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual Filename const &DatagramSink::get_filename(void)
 */
static PyObject *Dtool_DatagramSink_get_filename_1193(PyObject *self, PyObject *) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.get_filename")) {
    return NULL;
  }
  // 1-virtual Filename const &DatagramSink::get_filename(void)
  Filename const *return_value = &((*local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_get_filename_1193_comment =
  "C++ Interface:\n"
  "get_filename(const DatagramSink self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that provides the target for these datagrams, if any,\n"
  " * or empty string if the datagrams do not get written to a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramSink_get_filename_1193_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual FileReference const *DatagramSink::get_file(void)
 */
static PyObject *Dtool_DatagramSink_get_file_1194(PyObject *self, PyObject *) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.get_file")) {
    return NULL;
  }
  // 1-virtual FileReference const *DatagramSink::get_file(void)
  FileReference const *return_value = (*local_this).get_file();
  if (return_value != (FileReference const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (FileReference const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_get_file_1194_comment =
  "C++ Interface:\n"
  "get_file(const DatagramSink self)\n"
  "\n"
  "/**\n"
  " * Returns the FileReference that provides the target for these datagrams, if\n"
  " * any, or NULL if the datagrams do not written to a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramSink_get_file_1194_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual streamoff DatagramSink::get_file_pos(void)
 */
static PyObject *Dtool_DatagramSink_get_file_pos_1195(PyObject *self, PyObject *) {
  DatagramSink *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.get_file_pos")) {
    return NULL;
  }
  // 1-virtual streamoff DatagramSink::get_file_pos(void)
  streamoff return_value = (*local_this).get_file_pos();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_get_file_pos_1195_comment =
  "C++ Interface:\n"
  "get_file_pos(const DatagramSink self)\n"
  "\n"
  "/**\n"
  " * Returns the current file position within the data stream, if any, or 0 if\n"
  " * the file position is not meaningful or cannot be determined.\n"
  " *\n"
  " * For DatagramSinks that return a meaningful file position, this will be\n"
  " * pointing to the first byte following the datagram returned after a call to\n"
  " * put_datagram().\n"
  " */";
#else
static const char *Dtool_DatagramSink_get_file_pos_1195_comment = NULL;
#endif

static int Dtool_Init_DatagramSink(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DatagramSink(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_DatagramSink) {
    printf("DatagramSink ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  DatagramSink *local_this = (DatagramSink *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_DatagramSink) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_DatagramSink(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_DatagramSink) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TypedReferenceCount
 */
/**
 * Python function wrapper for:
 * static TypeHandle TypedReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_TypedReferenceCount_get_class_type_1212(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TypedReferenceCount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedReferenceCount_get_class_type_1212_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedReferenceCount_get_class_type_1212_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedObject *TypedReferenceCount::upcast_to_TypedObject(void)
 */
static PyObject *Dtool_TypedReferenceCount_upcast_to_TypedObject_1208(PyObject *self, PyObject *) {
  TypedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedReferenceCount, (void **)&local_this, "TypedReferenceCount.upcast_to_TypedObject")) {
    return NULL;
  }
  // 1-TypedObject *TypedReferenceCount::upcast_to_TypedObject(void)
  TypedObject *return_value = (TypedObject *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedObject, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedReferenceCount_upcast_to_TypedObject_1208_comment =
  "C++ Interface:\n"
  "upcast_to_TypedObject(const TypedReferenceCount self)\n"
  "\n"
  "upcast from TypedReferenceCount to TypedObject";
#else
static const char *Dtool_TypedReferenceCount_upcast_to_TypedObject_1208_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210(PyObject *self, PyObject *) {
  TypedReferenceCount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedReferenceCount, (void **)&local_this, "TypedReferenceCount.upcast_to_ReferenceCount")) {
    return NULL;
  }
  // 1-ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const TypedReferenceCount self)\n"
  "\n"
  "upcast from TypedReferenceCount to ReferenceCount";
#else
static const char *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210_comment = NULL;
#endif

static int Dtool_Init_TypedReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TypedReferenceCount) {
    printf("TypedReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TypedReferenceCount *local_this = (TypedReferenceCount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TypedReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TypedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedReferenceCount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class FileReference
 */
/**
 * Python function wrapper for:
 * inline Filename const &FileReference::get_filename(void) const
 */
static PyObject *Dtool_FileReference_get_filename_1216(PyObject *self, PyObject *) {
  FileReference *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FileReference, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &FileReference::get_filename(void) const
  Filename const *return_value = &((*(const FileReference*)local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_FileReference_get_filename_1216_comment =
  "C++ Interface:\n"
  "get_filename(FileReference self)\n"
  "\n"
  "/**\n"
  " * Returns the filename of the reference.\n"
  " */";
#else
static const char *Dtool_FileReference_get_filename_1216_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FileReference::get_class_type(void)
 */
static PyObject *Dtool_FileReference_get_class_type_1217(PyObject *, PyObject *) {
  // 1-static TypeHandle FileReference::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(FileReference::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FileReference_get_class_type_1217_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FileReference_get_class_type_1217_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline FileReference::FileReference(FileReference const &) = default
 * inline FileReference::FileReference(Filename const &filename)
 */
static int Dtool_Init_FileReference(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FileReference() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline FileReference::FileReference(FileReference const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FileReference", (char **)keyword_list, &param0)) {
      FileReference const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_FileReference, (void **)&param0_this);
      if (param0_this != NULL) {
        FileReference *return_value = new FileReference(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline FileReference::FileReference(Filename const &filename)
    PyObject *param0;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FileReference", (char **)keyword_list, &param0)) {
      Filename const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
      if (param0_this != NULL) {
        FileReference *return_value = new FileReference(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline FileReference::FileReference(FileReference const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FileReference", (char **)keyword_list, &param0)) {
      CPT(FileReference) param0_this;
      if (Dtool_ConstCoerce_FileReference(param0, param0_this)) {
        FileReference *return_value = new FileReference(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline FileReference::FileReference(Filename const &filename)
    PyObject *param0;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:FileReference", (char **)keyword_list, &param0)) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != NULL)) {
        FileReference *return_value = new FileReference(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FileReference(const FileReference param0)\n"
      "FileReference(const Filename filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FileReference, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FileReference::FileReference(Filename const &filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      FileReference *return_value = new FileReference(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_FileReference, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FileReference::FileReference(Filename const &filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      FileReference *return_value = new FileReference(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_FileReference(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_FileReference) {
    printf("FileReference ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  FileReference *local_this = (FileReference *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_FileReference) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_FileReference(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_FileReference) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FileReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FileReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (FileReference*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Ramfile
 */
/**
 * Python function wrapper for:
 * inline void Ramfile::seek(std::size_t pos)
 */
static PyObject *Dtool_Ramfile_seek_1221(PyObject *self, PyObject *arg) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.seek")) {
    return NULL;
  }
  // 1-inline void Ramfile::seek(std::size_t pos)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:seek", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).seek((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const Ramfile self, int pos)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_seek_1221_comment =
  "C++ Interface:\n"
  "seek(const Ramfile self, int pos)\n"
  "\n"
  "/**\n"
  " * Moves the data pointer to the indicated byte position.  It is not an error\n"
  " * to move the pointer past the end of data.\n"
  " */";
#else
static const char *Dtool_Ramfile_seek_1221_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Ramfile::tell(void) const
 */
static PyObject *Dtool_Ramfile_tell_1222(PyObject *self, PyObject *) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Ramfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t Ramfile::tell(void) const
  std::size_t return_value = (*(const Ramfile*)local_this).tell();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_tell_1222_comment =
  "C++ Interface:\n"
  "tell(Ramfile self)\n"
  "\n"
  "/**\n"
  " * Returns the current data pointer position as a byte offset from the\n"
  " * beginning of the stream.\n"
  " */";
#else
static const char *Dtool_Ramfile_tell_1222_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::read(std::size_t length)
 */
static PyObject *Dtool_Ramfile_read_1223(PyObject *self, PyObject *arg) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.read")) {
    return NULL;
  }
  // 1-PyObject *Ramfile::read(std::size_t length)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:read", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    PyObject *return_value = invoke_extension(local_this).read((std::size_t)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const Ramfile self, int length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_read_1223_comment =
  "C++ Interface:\n"
  "read(const Ramfile self, int length)\n"
  "\n"
  "/**\n"
  " * Extracts and returns the indicated number of characters from the current\n"
  " * data pointer, and advances the data pointer.  If the data pointer exceeds\n"
  " * the end of the buffer, returns empty string.\n"
  " *\n"
  " * The interface here is intentionally designed to be similar to that for\n"
  " * Python's file.read() function.\n"
  " */";
#else
static const char *Dtool_Ramfile_read_1223_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::readline(void)
 */
static PyObject *Dtool_Ramfile_readline_1224(PyObject *self, PyObject *) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.readline")) {
    return NULL;
  }
  // 1-PyObject *Ramfile::readline(void)
  PyObject *return_value = invoke_extension(local_this).readline();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_readline_1224_comment =
  "C++ Interface:\n"
  "readline(const Ramfile self)\n"
  "\n"
  "/**\n"
  " * Assumes the stream represents a text file, and extracts one line up to and\n"
  " * including the trailing newline character.  Returns empty string when the\n"
  " * end of file is reached.\n"
  " *\n"
  " * The interface here is intentionally designed to be similar to that for\n"
  " * Python's file.readline() function.\n"
  " */";
#else
static const char *Dtool_Ramfile_readline_1224_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::readlines(void)
 */
static PyObject *Dtool_Ramfile_readlines_1225(PyObject *self, PyObject *) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.readlines")) {
    return NULL;
  }
  // 1-PyObject *Ramfile::readlines(void)
  PyObject *return_value = invoke_extension(local_this).readlines();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_readlines_1225_comment =
  "C++ Interface:\n"
  "readlines(const Ramfile self)\n";
#else
static const char *Dtool_Ramfile_readlines_1225_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::get_data(void) const
 */
static PyObject *Dtool_Ramfile_get_data_1226(PyObject *self, PyObject *) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Ramfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *Ramfile::get_data(void) const
  PyObject *return_value = invoke_extension((const Ramfile*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_get_data_1226_comment =
  "C++ Interface:\n"
  "get_data(Ramfile self)\n"
  "\n"
  "/**\n"
  " * Returns the entire buffer contents as a string, regardless of the current\n"
  " * data pointer.\n"
  " */";
#else
static const char *Dtool_Ramfile_get_data_1226_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Ramfile::get_data_size(void) const
 */
static PyObject *Dtool_Ramfile_get_data_size_1227(PyObject *self, PyObject *) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Ramfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t Ramfile::get_data_size(void) const
  std::size_t return_value = (*(const Ramfile*)local_this).get_data_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_get_data_size_1227_comment =
  "C++ Interface:\n"
  "get_data_size(Ramfile self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the entire buffer contents.\n"
  " */";
#else
static const char *Dtool_Ramfile_get_data_size_1227_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Ramfile::clear(void)
 */
static PyObject *Dtool_Ramfile_clear_1228(PyObject *self, PyObject *) {
  Ramfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.clear")) {
    return NULL;
  }
  // 1-inline void Ramfile::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_clear_1228_comment =
  "C++ Interface:\n"
  "clear(const Ramfile self)\n"
  "\n"
  "/**\n"
  " * Empties the current buffer contents.\n"
  " */";
#else
static const char *Dtool_Ramfile_clear_1228_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Ramfile::Ramfile(void)
 * inline Ramfile::Ramfile(Ramfile const &) = default
 */
static int Dtool_Init_Ramfile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Ramfile::Ramfile(void)
      Ramfile *return_value = new Ramfile();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Ramfile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline Ramfile::Ramfile(Ramfile const &) = default
      Ramfile const *arg_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Ramfile, 0, "Ramfile.Ramfile", true, true);
      if (arg_this != NULL) {
        Ramfile *return_value = new Ramfile(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Ramfile, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Ramfile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Ramfile()\n"
      "Ramfile(const Ramfile param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Ramfile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Ramfile) {
    printf("Ramfile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Ramfile *local_this = (Ramfile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Ramfile) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Ramfile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Ramfile) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class HashVal
 */
/**
 * Python function wrapper for:
 * inline void HashVal::operator =(HashVal const &copy)
 */
static PyObject *Dtool_HashVal_operator_1232(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.assign")) {
    return NULL;
  }
  // 1-inline void HashVal::operator =(HashVal const &copy)
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    HashVal *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const HashVal self, const HashVal copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_operator_1232_comment =
  "C++ Interface:\n"
  "assign(const HashVal self, const HashVal copy)\n";
#else
static const char *Dtool_HashVal_operator_1232_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int HashVal::compare_to(HashVal const &other) const
 */
static PyObject *Dtool_HashVal_compare_to_1236(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int HashVal::compare_to(HashVal const &other) const
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const HashVal*)local_this).compare_to(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(HashVal self, const HashVal other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_compare_to_1236_comment =
  "C++ Interface:\n"
  "compare_to(HashVal self, const HashVal other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_compare_to_1236_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::merge_with(HashVal const &other)
 */
static PyObject *Dtool_HashVal_merge_with_1237(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.merge_with")) {
    return NULL;
  }
  // 1-inline void HashVal::merge_with(HashVal const &other)
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.merge_with", true, true);
  if (arg_this != NULL) {
    (*local_this).merge_with(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge_with(const HashVal self, const HashVal other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_merge_with_1237_comment =
  "C++ Interface:\n"
  "merge_with(const HashVal self, const HashVal other)\n"
  "\n"
  "/**\n"
  " * Generates a new HashVal representing the xor of this one and the other one.\n"
  " */";
#else
static const char *Dtool_HashVal_merge_with_1237_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::output_dec(ostream &out) const
 */
static PyObject *Dtool_HashVal_output_dec_1238(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void HashVal::output_dec(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HashVal.output_dec", false, true);
  if (arg_this != NULL) {
    (*(const HashVal*)local_this).output_dec(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_dec(HashVal self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_dec_1238_comment =
  "C++ Interface:\n"
  "output_dec(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the HashVal as four unsigned decimal integers.\n"
  " */";
#else
static const char *Dtool_HashVal_output_dec_1238_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::input_dec(istream &in)
 */
static PyObject *Dtool_HashVal_input_dec_1239(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.input_dec")) {
    return NULL;
  }
  // 1-inline void HashVal::input_dec(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "HashVal.input_dec", false, true);
  if (arg_this != NULL) {
    (*local_this).input_dec(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input_dec(const HashVal self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_input_dec_1239_comment =
  "C++ Interface:\n"
  "input_dec(const HashVal self, istream in)\n"
  "\n"
  "/**\n"
  " * Inputs the HashVal as four unsigned decimal integers.\n"
  " */";
#else
static const char *Dtool_HashVal_input_dec_1239_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HashVal::output_hex(ostream &out) const
 */
static PyObject *Dtool_HashVal_output_hex_1240(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HashVal::output_hex(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HashVal.output_hex", false, true);
  if (arg_this != NULL) {
    (*(const HashVal*)local_this).output_hex(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(HashVal self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_hex_1240_comment =
  "C++ Interface:\n"
  "output_hex(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the HashVal as a 32-digit hexadecimal number.\n"
  " */";
#else
static const char *Dtool_HashVal_output_hex_1240_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HashVal::input_hex(istream &in)
 */
static PyObject *Dtool_HashVal_input_hex_1241(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.input_hex")) {
    return NULL;
  }
  // 1-void HashVal::input_hex(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "HashVal.input_hex", false, true);
  if (arg_this != NULL) {
    (*local_this).input_hex(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input_hex(const HashVal self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_input_hex_1241_comment =
  "C++ Interface:\n"
  "input_hex(const HashVal self, istream in)\n"
  "\n"
  "/**\n"
  " * Inputs the HashVal as a 32-digit hexadecimal number.\n"
  " */";
#else
static const char *Dtool_HashVal_input_hex_1241_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HashVal::output_binary(ostream &out) const
 */
static PyObject *Dtool_HashVal_output_binary_1242(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-void HashVal::output_binary(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HashVal.output_binary", false, true);
  if (arg_this != NULL) {
    (*(const HashVal*)local_this).output_binary(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(HashVal self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_binary_1242_comment =
  "C++ Interface:\n"
  "output_binary(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the HashVal as a binary stream of bytes in order.  This is not the\n"
  " * same order generated by write_stream().\n"
  " */";
#else
static const char *Dtool_HashVal_output_binary_1242_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HashVal::input_binary(istream &in)
 */
static PyObject *Dtool_HashVal_input_binary_1243(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.input_binary")) {
    return NULL;
  }
  // 1-void HashVal::input_binary(istream &in)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "HashVal.input_binary", false, true);
  if (arg_this != NULL) {
    (*local_this).input_binary(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input_binary(const HashVal self, istream in)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_input_binary_1243_comment =
  "C++ Interface:\n"
  "input_binary(const HashVal self, istream in)\n"
  "\n"
  "/**\n"
  " * Inputs the HashVal as a binary stream of bytes in order.  This is not the\n"
  " * same order expected by read_stream().\n"
  " */";
#else
static const char *Dtool_HashVal_input_binary_1243_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::output(ostream &out) const
 */
static PyObject *Dtool_HashVal_output_1244(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void HashVal::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "HashVal.output", false, true);
  if (arg_this != NULL) {
    (*(const HashVal*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(HashVal self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_1244_comment =
  "C++ Interface:\n"
  "output(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_output_1244_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HashVal::as_dec(void) const
 */
static PyObject *Dtool_HashVal_as_dec_1245(PyObject *self, PyObject *) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HashVal::as_dec(void) const
  std::string return_value = (*(const HashVal*)local_this).as_dec();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HashVal_as_dec_1245_comment =
  "C++ Interface:\n"
  "as_dec(HashVal self)\n"
  "\n"
  "/**\n"
  " * Returns the HashVal as a string with four decimal numbers.\n"
  " */";
#else
static const char *Dtool_HashVal_as_dec_1245_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::set_from_dec(std::string const &text)
 */
static PyObject *Dtool_HashVal_set_from_dec_1246(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.set_from_dec")) {
    return NULL;
  }
  // 1-bool HashVal::set_from_dec(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).set_from_dec(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_dec(const HashVal self, str text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_set_from_dec_1246_comment =
  "C++ Interface:\n"
  "set_from_dec(const HashVal self, str text)\n"
  "\n"
  "/**\n"
  " * Sets the HashVal from a string with four decimal numbers.  Returns true if\n"
  " * valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_HashVal_set_from_dec_1246_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HashVal::as_hex(void) const
 */
static PyObject *Dtool_HashVal_as_hex_1247(PyObject *self, PyObject *) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HashVal::as_hex(void) const
  std::string return_value = (*(const HashVal*)local_this).as_hex();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HashVal_as_hex_1247_comment =
  "C++ Interface:\n"
  "as_hex(HashVal self)\n"
  "\n"
  "/**\n"
  " * Returns the HashVal as a 32-byte hexadecimal string.\n"
  " */";
#else
static const char *Dtool_HashVal_as_hex_1247_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::set_from_hex(std::string const &text)
 */
static PyObject *Dtool_HashVal_set_from_hex_1248(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.set_from_hex")) {
    return NULL;
  }
  // 1-bool HashVal::set_from_hex(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).set_from_hex(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_hex(const HashVal self, str text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_set_from_hex_1248_comment =
  "C++ Interface:\n"
  "set_from_hex(const HashVal self, str text)\n"
  "\n"
  "/**\n"
  " * Sets the HashVal from a 32-byte hexademical string.  Returns true if\n"
  " * successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_HashVal_set_from_hex_1248_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string HashVal::as_bin(void) const
 */
static PyObject *Dtool_HashVal_as_bin_1249(PyObject *self, PyObject *) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string HashVal::as_bin(void) const
  std::string return_value = (*(const HashVal*)local_this).as_bin();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HashVal_as_bin_1249_comment =
  "C++ Interface:\n"
  "as_bin(HashVal self)\n"
  "\n"
  "/**\n"
  " * Returns the HashVal as a 16-byte binary string.\n"
  " */";
#else
static const char *Dtool_HashVal_as_bin_1249_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::set_from_bin(std::string const &text)
 */
static PyObject *Dtool_HashVal_set_from_bin_1250(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.set_from_bin")) {
    return NULL;
  }
  // 1-bool HashVal::set_from_bin(std::string const &text)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*local_this).set_from_bin(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_bin(const HashVal self, str text)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_set_from_bin_1250_comment =
  "C++ Interface:\n"
  "set_from_bin(const HashVal self, str text)\n"
  "\n"
  "/**\n"
  " * Sets the HashVal from a 16-byte binary string.  Returns true if successful,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_HashVal_set_from_bin_1250_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_HashVal_write_datagram_1251(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void HashVal::write_datagram(Datagram &destination) const
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.write_datagram", "Datagram");
  }
  (*(const HashVal*)local_this).write_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(HashVal self, Datagram destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_write_datagram_1251_comment =
  "C++ Interface:\n"
  "write_datagram(HashVal self, Datagram destination)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_write_datagram_1251_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_HashVal_read_datagram_1252(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.read_datagram")) {
    return NULL;
  }
  // 1-inline void HashVal::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.read_datagram", "DatagramIterator");
  }
  (*local_this).read_datagram(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const HashVal self, DatagramIterator source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_read_datagram_1252_comment =
  "C++ Interface:\n"
  "read_datagram(const HashVal self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_read_datagram_1252_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::write_stream(StreamWriter &destination) const
 */
static PyObject *Dtool_HashVal_write_stream_1253(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void HashVal::write_stream(StreamWriter &destination) const
  StreamWriter *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_StreamWriter(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.write_stream", "StreamWriter");
  }
  (*(const HashVal*)local_this).write_stream(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_stream(HashVal self, StreamWriter destination)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_write_stream_1253_comment =
  "C++ Interface:\n"
  "write_stream(HashVal self, StreamWriter destination)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_write_stream_1253_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::read_stream(StreamReader &source)
 */
static PyObject *Dtool_HashVal_read_stream_1254(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.read_stream")) {
    return NULL;
  }
  // 1-inline void HashVal::read_stream(StreamReader &source)
  StreamReader *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_StreamReader(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.read_stream", "StreamReader");
  }
  (*local_this).read_stream(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_stream(const HashVal self, StreamReader source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_read_stream_1254_comment =
  "C++ Interface:\n"
  "read_stream(const HashVal self, StreamReader source)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_read_stream_1254_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::hash_file(Filename const &filename)
 */
static PyObject *Dtool_HashVal_hash_file_1255(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_file")) {
    return NULL;
  }
  // 1-bool HashVal::hash_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.hash_file", "Filename");
  }
  bool return_value = (*local_this).hash_file(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_file(const HashVal self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_file_1255_comment =
  "C++ Interface:\n"
  "hash_file(const HashVal self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Generates the hash value from the indicated file.  Returns true on success,\n"
  " * false if the file cannot be read.  This method is only defined if we have\n"
  " * the OpenSSL library (which provides md5 functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_file_1255_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::hash_stream(istream &stream)
 */
static PyObject *Dtool_HashVal_hash_stream_1256(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_stream")) {
    return NULL;
  }
  // 1-bool HashVal::hash_stream(istream &stream)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "HashVal.hash_stream", false, true);
  if (arg_this != NULL) {
    bool return_value = (*local_this).hash_stream(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_stream(const HashVal self, istream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_stream_1256_comment =
  "C++ Interface:\n"
  "hash_stream(const HashVal self, istream stream)\n"
  "\n"
  "/**\n"
  " * Generates the hash value from the indicated file.  Returns true on success,\n"
  " * false if the file cannot be read.  This method is only defined if we have\n"
  " * the OpenSSL library (which provides md5 functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_stream_1256_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::hash_ramfile(Ramfile const &ramfile)
 */
static PyObject *Dtool_HashVal_hash_ramfile_1257(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_ramfile")) {
    return NULL;
  }
  // 1-inline void HashVal::hash_ramfile(Ramfile const &ramfile)
  Ramfile const *arg_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Ramfile, 1, "HashVal.hash_ramfile", true, true);
  if (arg_this != NULL) {
    (*local_this).hash_ramfile(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_ramfile(const HashVal self, const Ramfile ramfile)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_ramfile_1257_comment =
  "C++ Interface:\n"
  "hash_ramfile(const HashVal self, const Ramfile ramfile)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_ramfile_1257_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::hash_string(std::string const &data)
 */
static PyObject *Dtool_HashVal_hash_string_1258(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_string")) {
    return NULL;
  }
  // 1-inline void HashVal::hash_string(std::string const &data)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).hash_string(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_string(const HashVal self, str data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_string_1258_comment =
  "C++ Interface:\n"
  "hash_string(const HashVal self, str data)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_string_1258_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::hash_bytes(pvector< unsigned char > const &data)
 */
static PyObject *Dtool_HashVal_hash_bytes_1259(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_bytes")) {
    return NULL;
  }
  // 1-inline void HashVal::hash_bytes(pvector< unsigned char > const &data)
  unsigned char *param1_str = NULL;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    (*local_this).hash_bytes(pvector< unsigned char >(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_bytes(const HashVal self, bytes data)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_bytes_1259_comment =
  "C++ Interface:\n"
  "hash_bytes(const HashVal self, bytes data)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_bytes_1259_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void HashVal::hash_buffer(char const *buffer, int length)
 */
static PyObject *Dtool_HashVal_hash_buffer_1260(PyObject *self, PyObject *args, PyObject *kwds) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_buffer")) {
    return NULL;
  }
  // 1-void HashVal::hash_buffer(char const *buffer, int length)
  char const *param1;
  int param2;
  static const char *keyword_list[] = {"buffer", "length", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "zi:hash_buffer", (char **)keyword_list, &param1, &param2)) {
    (*local_this).hash_buffer((char const *)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_buffer(const HashVal self, str buffer, int length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_buffer_1260_comment =
  "C++ Interface:\n"
  "hash_buffer(const HashVal self, str buffer, int length)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_buffer_1260_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HashVal::HashVal(void)
 * inline HashVal::HashVal(HashVal const &copy)
 */
static int Dtool_Init_HashVal(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline HashVal::HashVal(void)
      HashVal *return_value = new HashVal();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HashVal, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline HashVal::HashVal(HashVal const &copy)
      HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 0, "HashVal.HashVal", true, true);
      if (arg_this != NULL) {
        HashVal *return_value = new HashVal(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HashVal, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HashVal() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HashVal()\n"
      "HashVal(const HashVal copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_HashVal(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_HashVal) {
    printf("HashVal ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  HashVal *local_this = (HashVal *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_HashVal) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_HashVal(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_HashVal) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class MemoryUsagePointers
 */
/**
 * Python function wrapper for:
 * std::size_t MemoryUsagePointers::get_num_pointers(void) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_num_pointers_1265(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t MemoryUsagePointers::get_num_pointers(void) const
  std::size_t return_value = (*(const MemoryUsagePointers*)local_this).get_num_pointers();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_num_pointers_1265_comment =
  "C++ Interface:\n"
  "get_num_pointers(MemoryUsagePointers self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pointers in the set.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_num_pointers_1265_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *MemoryUsagePointers::get_pointer(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_pointer_1266(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-ReferenceCount *MemoryUsagePointers::get_pointer(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_pointer", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ReferenceCount *return_value = (*(const MemoryUsagePointers*)local_this).get_pointer((std::size_t)param1);
    if (return_value != (ReferenceCount *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (ReferenceCount *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointer(MemoryUsagePointers self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_pointer_1266_comment =
  "C++ Interface:\n"
  "get_pointer(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pointer of the set.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_pointer_1266_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypedObject *MemoryUsagePointers::get_typed_pointer(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_typed_pointer_1268(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-TypedObject *MemoryUsagePointers::get_typed_pointer(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_typed_pointer", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    TypedObject *return_value = (*(const MemoryUsagePointers*)local_this).get_typed_pointer((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedObject, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typed_pointer(MemoryUsagePointers self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_typed_pointer_1268_comment =
  "C++ Interface:\n"
  "get_typed_pointer(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pointer of the set, typecast to a TypedObject if possible.\n"
  " * If the pointer is not a TypedObject or if the cast cannot be made, returns\n"
  " * NULL.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_typed_pointer_1268_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * TypeHandle MemoryUsagePointers::get_type(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_type_1270(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-TypeHandle MemoryUsagePointers::get_type(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_type", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    TypeHandle *return_value = new TypeHandle((*(const MemoryUsagePointers*)local_this).get_type((std::size_t)param1));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(MemoryUsagePointers self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_type_1270_comment =
  "C++ Interface:\n"
  "get_type(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the actual type of the nth pointer, if it is known.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_type_1270_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string MemoryUsagePointers::get_type_name(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_type_name_1271(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string MemoryUsagePointers::get_type_name(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_type_name", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    std::string return_value = (*(const MemoryUsagePointers*)local_this).get_type_name((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_name(MemoryUsagePointers self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_type_name_1271_comment =
  "C++ Interface:\n"
  "get_type_name(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type name of the nth pointer, if it is known.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_type_name_1271_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double MemoryUsagePointers::get_age(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_age_1272(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-double MemoryUsagePointers::get_age(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_age", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    double return_value = (*(const MemoryUsagePointers*)local_this).get_age((std::size_t)param1);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_age(MemoryUsagePointers self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_age_1272_comment =
  "C++ Interface:\n"
  "get_age(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the age of the nth pointer: the number of seconds elapsed between\n"
  " * the time it was allocated and the time it was added to this set via a call\n"
  " * to MemoryUsage::get_pointers().\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_age_1272_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *MemoryUsagePointers::get_python_pointer(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_python_pointer_1273(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *MemoryUsagePointers::get_python_pointer(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_python_pointer", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    PyObject *return_value = invoke_extension((const MemoryUsagePointers*)local_this).get_python_pointer((std::size_t)param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_python_pointer(MemoryUsagePointers self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_python_pointer_1273_comment =
  "C++ Interface:\n"
  "get_python_pointer(MemoryUsagePointers self, int n)\n";
#else
static const char *Dtool_MemoryUsagePointers_get_python_pointer_1273_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MemoryUsagePointers::clear(void)
 */
static PyObject *Dtool_MemoryUsagePointers_clear_1274(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MemoryUsagePointers, (void **)&local_this, "MemoryUsagePointers.clear")) {
    return NULL;
  }
  // 1-void MemoryUsagePointers::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_clear_1274_comment =
  "C++ Interface:\n"
  "clear(const MemoryUsagePointers self)\n"
  "\n"
  "/**\n"
  " * Empties the set of pointers.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_clear_1274_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void MemoryUsagePointers::output(ostream &out) const
 */
static PyObject *Dtool_MemoryUsagePointers_output_1275(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  // 1-void MemoryUsagePointers::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "MemoryUsagePointers.output", false, true);
  if (arg_this != NULL) {
    (*(const MemoryUsagePointers*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MemoryUsagePointers self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_output_1275_comment =
  "C++ Interface:\n"
  "output(MemoryUsagePointers self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_output_1275_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * MemoryUsagePointers::MemoryUsagePointers(void)
 * inline MemoryUsagePointers::MemoryUsagePointers(MemoryUsagePointers const &) = default
 */
static int Dtool_Init_MemoryUsagePointers(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-MemoryUsagePointers::MemoryUsagePointers(void)
      MemoryUsagePointers *return_value = new MemoryUsagePointers();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MemoryUsagePointers, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline MemoryUsagePointers::MemoryUsagePointers(MemoryUsagePointers const &) = default
      MemoryUsagePointers const *arg_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsagePointers.MemoryUsagePointers", true, true);
      if (arg_this != NULL) {
        MemoryUsagePointers *return_value = new MemoryUsagePointers(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MemoryUsagePointers, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MemoryUsagePointers() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MemoryUsagePointers()\n"
      "MemoryUsagePointers(const MemoryUsagePointers param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MemoryUsagePointers_get_pointers(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_pointers();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MemoryUsagePointers_get_pointer_1266(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MemoryUsagePointers_get_typed_pointers(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_pointers();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MemoryUsagePointers_get_typed_pointer_1268(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_MemoryUsagePointers(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_MemoryUsagePointers) {
    printf("MemoryUsagePointers ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  MemoryUsagePointers *local_this = (MemoryUsagePointers *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_MemoryUsagePointers) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_MemoryUsagePointers(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_MemoryUsagePointers) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ISubStream
 */
/**
 * Python function wrapper for:
 * inline ISubStream &ISubStream::open(IStreamWrapper *source, streamoff start, streamoff end)
 */
static PyObject *Dtool_ISubStream_open_1278(PyObject *self, PyObject *args, PyObject *kwds) {
  ISubStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISubStream, (void **)&local_this, "ISubStream.open")) {
    return NULL;
  }
  // 1-inline ISubStream &ISubStream::open(IStreamWrapper *source, streamoff start, streamoff end)
  PyObject *param1;
  long param2;
  long param3;
  static const char *keyword_list[] = {"source", "start", "end", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oll:open", (char **)keyword_list, &param1, &param2, &param3)) {
    IStreamWrapper *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_IStreamWrapper(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "ISubStream.open", "IStreamWrapper");
    }
    ISubStream *return_value = &((*local_this).open(param1_this, (streamoff)param2, (streamoff)param3));
    if (param1_manage) {
      delete param1_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ISubStream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const ISubStream self, IStreamWrapper source, int start, int end)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ISubStream_open_1278_comment =
  "C++ Interface:\n"
  "open(const ISubStream self, IStreamWrapper source, int start, int end)\n"
  "\n"
  "/**\n"
  " * Starts the SubStream reading from the indicated source, with the first\n"
  " * character being the character at position \"start\" within the source, for\n"
  " * end - start total characters.  The character at \"end\" within the source\n"
  " * will never be read; this will appear to be EOF.\n"
  " *\n"
  " * If end is zero, it indicates that the ISubStream will continue until the\n"
  " * end of the source stream.\n"
  " */";
#else
static const char *Dtool_ISubStream_open_1278_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ISubStream &ISubStream::close(void)
 */
static PyObject *Dtool_ISubStream_close_1279(PyObject *self, PyObject *) {
  ISubStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISubStream, (void **)&local_this, "ISubStream.close")) {
    return NULL;
  }
  // 1-inline ISubStream &ISubStream::close(void)
  ISubStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ISubStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ISubStream_close_1279_comment =
  "C++ Interface:\n"
  "close(const ISubStream self)\n"
  "\n"
  "/**\n"
  " * Resets the SubStream to empty, but does not actually close the source\n"
  " * istream.\n"
  " */";
#else
static const char *Dtool_ISubStream_close_1279_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ISubStream::ISubStream(void)
 * inline ISubStream::ISubStream(IStreamWrapper *source, streamoff start, streamoff end)
 */
static int Dtool_Init_ISubStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ISubStream::ISubStream(void)
      ISubStream *return_value = new ISubStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ISubStream, true, false);
    }
    break;
  case 3:
    {
      // 1-inline ISubStream::ISubStream(IStreamWrapper *source, streamoff start, streamoff end)
      PyObject *param0;
      long param1;
      long param2;
      static const char *keyword_list[] = {"source", "start", "end", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oll:ISubStream", (char **)keyword_list, &param0, &param1, &param2)) {
        IStreamWrapper *param0_this;
        bool param0_manage = false;
        if (!Dtool_Coerce_IStreamWrapper(param0, param0_this, param0_manage)) {
          Dtool_Raise_ArgTypeError(param0, 0, "ISubStream.ISubStream", "IStreamWrapper");
          return -1;
        }
        ISubStream *return_value = new ISubStream(param0_this, (streamoff)param1, (streamoff)param2);
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ISubStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ISubStream() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ISubStream()\n"
      "ISubStream(IStreamWrapper source, int start, int end)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ISubStream(PyObject *args, ISubStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ISubStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline ISubStream::ISubStream(IStreamWrapper *source, streamoff start, streamoff end)
      PyObject *param0;
      long param1;
      long param2;
      if (PyArg_ParseTuple(args, "Oll:ISubStream", &param0, &param1, &param2)) {
        IStreamWrapper *param0_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_IStreamWrapper, 0, "ISubStream.ISubStream", false, false);
        if (param0_this != NULL) {
          ISubStream *return_value = new ISubStream(param0_this, (streamoff)param1, (streamoff)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ISubStream(PyObject *args, ISubStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ISubStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      // 1-inline ISubStream::ISubStream(IStreamWrapper *source, streamoff start, streamoff end)
      PyObject *param0;
      long param1;
      long param2;
      if (PyArg_ParseTuple(args, "Oll:ISubStream", &param0, &param1, &param2)) {
        IStreamWrapper *param0_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_IStreamWrapper, 0, "ISubStream.ISubStream", false, false);
        if (param0_this != NULL) {
          ISubStream *return_value = new ISubStream(param0_this, (streamoff)param1, (streamoff)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ISubStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ISubStream) {
    printf("ISubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ISubStream *local_this = (ISubStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ISubStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ISubStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ISubStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (ISubStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OSubStream
 */
/**
 * Python function wrapper for:
 * inline OSubStream &OSubStream::open(OStreamWrapper *dest, streamoff start, streamoff end, bool append = false)
 */
static PyObject *Dtool_OSubStream_open_1283(PyObject *self, PyObject *args, PyObject *kwds) {
  OSubStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSubStream, (void **)&local_this, "OSubStream.open")) {
    return NULL;
  }
  // 1-inline OSubStream &OSubStream::open(OStreamWrapper *dest, streamoff start, streamoff end, bool append = false)
  PyObject *param1;
  long param2;
  long param3;
  PyObject *param4 = Py_False;
  static const char *keyword_list[] = {"dest", "start", "end", "append", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oll|O:open", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    OStreamWrapper *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_OStreamWrapper(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OSubStream.open", "OStreamWrapper");
    }
    OSubStream *return_value = &((*local_this).open(param1_this, (streamoff)param2, (streamoff)param3, (PyObject_IsTrue(param4) != 0)));
    if (param1_manage) {
      delete param1_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OSubStream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OSubStream self, OStreamWrapper dest, int start, int end, bool append)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OSubStream_open_1283_comment =
  "C++ Interface:\n"
  "open(const OSubStream self, OStreamWrapper dest, int start, int end, bool append)\n"
  "\n"
  "/**\n"
  " * Starts the SubStream reading from the indicated dest, with the first\n"
  " * character being the character at position \"start\" within the dest, for end\n"
  " * - start total characters.  The character at \"end\" within the dest will\n"
  " * never be read; this will appear to be EOF.\n"
  " *\n"
  " * If end is zero, it indicates that the OSubStream will continue until the\n"
  " * end of the dest stream.\n"
  " */";
#else
static const char *Dtool_OSubStream_open_1283_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OSubStream &OSubStream::close(void)
 */
static PyObject *Dtool_OSubStream_close_1284(PyObject *self, PyObject *) {
  OSubStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSubStream, (void **)&local_this, "OSubStream.close")) {
    return NULL;
  }
  // 1-inline OSubStream &OSubStream::close(void)
  OSubStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OSubStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OSubStream_close_1284_comment =
  "C++ Interface:\n"
  "close(const OSubStream self)\n"
  "\n"
  "/**\n"
  " * Resets the SubStream to empty, but does not actually close the dest\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_OSubStream_close_1284_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OSubStream::OSubStream(void)
 * inline OSubStream::OSubStream(OStreamWrapper *dest, streamoff start, streamoff end, bool append = false)
 */
static int Dtool_Init_OSubStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OSubStream::OSubStream(void)
      OSubStream *return_value = new OSubStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OSubStream, true, false);
    }
    break;
  case 3:
  case 4:
    {
      // 1-inline OSubStream::OSubStream(OStreamWrapper *dest, streamoff start, streamoff end, bool append = false)
      PyObject *param0;
      long param1;
      long param2;
      PyObject *param3 = Py_False;
      static const char *keyword_list[] = {"dest", "start", "end", "append", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oll|O:OSubStream", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OStreamWrapper *param0_this;
        bool param0_manage = false;
        if (!Dtool_Coerce_OStreamWrapper(param0, param0_this, param0_manage)) {
          Dtool_Raise_ArgTypeError(param0, 0, "OSubStream.OSubStream", "OStreamWrapper");
          return -1;
        }
        OSubStream *return_value = new OSubStream(param0_this, (streamoff)param1, (streamoff)param2, (PyObject_IsTrue(param3) != 0));
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OSubStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OSubStream() takes 0, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OSubStream()\n"
      "OSubStream(OStreamWrapper dest, int start, int end, bool append)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OSubStream(PyObject *args, OSubStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OSubStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 4) {
      // 1-inline OSubStream::OSubStream(OStreamWrapper *dest, streamoff start, streamoff end, bool append = false)
      PyObject *param0;
      long param1;
      long param2;
      PyObject *param3 = Py_False;
      if (PyArg_ParseTuple(args, "Oll|O:OSubStream", &param0, &param1, &param2, &param3)) {
        OStreamWrapper *param0_this = (OStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OStreamWrapper, 0, "OSubStream.OSubStream", false, false);
        if (param0_this != NULL) {
          OSubStream *return_value = new OSubStream(param0_this, (streamoff)param1, (streamoff)param2, (PyObject_IsTrue(param3) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OSubStream(PyObject *args, OSubStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OSubStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 4) {
      // 1-inline OSubStream::OSubStream(OStreamWrapper *dest, streamoff start, streamoff end, bool append = false)
      PyObject *param0;
      long param1;
      long param2;
      PyObject *param3 = Py_False;
      if (PyArg_ParseTuple(args, "Oll|O:OSubStream", &param0, &param1, &param2, &param3)) {
        OStreamWrapper *param0_this = (OStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OStreamWrapper, 0, "OSubStream.OSubStream", false, false);
        if (param0_this != NULL) {
          OSubStream *return_value = new OSubStream(param0_this, (streamoff)param1, (streamoff)param2, (PyObject_IsTrue(param3) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OSubStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OSubStream) {
    printf("OSubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OSubStream *local_this = (OSubStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OSubStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OSubStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OSubStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (OSubStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SubStream
 */
/**
 * Python function wrapper for:
 * inline SubStream &SubStream::open(StreamWrapper *nested, streamoff start, streamoff end, bool append = false)
 */
static PyObject *Dtool_SubStream_open_1288(PyObject *self, PyObject *args, PyObject *kwds) {
  SubStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SubStream, (void **)&local_this, "SubStream.open")) {
    return NULL;
  }
  // 1-inline SubStream &SubStream::open(StreamWrapper *nested, streamoff start, streamoff end, bool append = false)
  PyObject *param1;
  long param2;
  long param3;
  PyObject *param4 = Py_False;
  static const char *keyword_list[] = {"nested", "start", "end", "append", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oll|O:open", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    StreamWrapper *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_StreamWrapper(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "SubStream.open", "StreamWrapper");
    }
    SubStream *return_value = &((*local_this).open(param1_this, (streamoff)param2, (streamoff)param3, (PyObject_IsTrue(param4) != 0)));
    if (param1_manage) {
      delete param1_this;
    }
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubStream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const SubStream self, StreamWrapper nested, int start, int end, bool append)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SubStream_open_1288_comment =
  "C++ Interface:\n"
  "open(const SubStream self, StreamWrapper nested, int start, int end, bool append)\n"
  "\n"
  "/**\n"
  " * Starts the SubStream reading and writing from the indicated nested stream,\n"
  " * within the indicated range.  \"end\" is the first character outside of the\n"
  " * range.\n"
  " *\n"
  " * If end is zero, it indicates that the SubStream will continue until the end\n"
  " * of the nested stream.\n"
  " */";
#else
static const char *Dtool_SubStream_open_1288_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SubStream &SubStream::close(void)
 */
static PyObject *Dtool_SubStream_close_1289(PyObject *self, PyObject *) {
  SubStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SubStream, (void **)&local_this, "SubStream.close")) {
    return NULL;
  }
  // 1-inline SubStream &SubStream::close(void)
  SubStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SubStream_close_1289_comment =
  "C++ Interface:\n"
  "close(const SubStream self)\n"
  "\n"
  "/**\n"
  " * Resets the SubStream to empty, but does not actually close the nested\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_SubStream_close_1289_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SubStream::SubStream(void)
 * inline SubStream::SubStream(StreamWrapper *nested, streamoff start, streamoff end, bool append = false)
 */
static int Dtool_Init_SubStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SubStream::SubStream(void)
      SubStream *return_value = new SubStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubStream, true, false);
    }
    break;
  case 3:
  case 4:
    {
      // 1-inline SubStream::SubStream(StreamWrapper *nested, streamoff start, streamoff end, bool append = false)
      PyObject *param0;
      long param1;
      long param2;
      PyObject *param3 = Py_False;
      static const char *keyword_list[] = {"nested", "start", "end", "append", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oll|O:SubStream", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        StreamWrapper *param0_this;
        bool param0_manage = false;
        if (!Dtool_Coerce_StreamWrapper(param0, param0_this, param0_manage)) {
          Dtool_Raise_ArgTypeError(param0, 0, "SubStream.SubStream", "StreamWrapper");
          return -1;
        }
        SubStream *return_value = new SubStream(param0_this, (streamoff)param1, (streamoff)param2, (PyObject_IsTrue(param3) != 0));
        if (param0_manage) {
          delete param0_this;
        }
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SubStream() takes 0, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SubStream()\n"
      "SubStream(StreamWrapper nested, int start, int end, bool append)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SubStream(PyObject *args, SubStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SubStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 4) {
      // 1-inline SubStream::SubStream(StreamWrapper *nested, streamoff start, streamoff end, bool append = false)
      PyObject *param0;
      long param1;
      long param2;
      PyObject *param3 = Py_False;
      if (PyArg_ParseTuple(args, "Oll|O:SubStream", &param0, &param1, &param2, &param3)) {
        StreamWrapper *param0_this = (StreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_StreamWrapper, 0, "SubStream.SubStream", false, false);
        if (param0_this != NULL) {
          SubStream *return_value = new SubStream(param0_this, (streamoff)param1, (streamoff)param2, (PyObject_IsTrue(param3) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_SubStream(PyObject *args, SubStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SubStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 3 && size <= 4) {
      // 1-inline SubStream::SubStream(StreamWrapper *nested, streamoff start, streamoff end, bool append = false)
      PyObject *param0;
      long param1;
      long param2;
      PyObject *param3 = Py_False;
      if (PyArg_ParseTuple(args, "Oll|O:SubStream", &param0, &param1, &param2, &param3)) {
        StreamWrapper *param0_this = (StreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_StreamWrapper, 0, "SubStream.SubStream", false, false);
        if (param0_this != NULL) {
          SubStream *return_value = new SubStream(param0_this, (streamoff)param1, (streamoff)param2, (PyObject_IsTrue(param3) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SubStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SubStream) {
    printf("SubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SubStream *local_this = (SubStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SubStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_iostream) {
    return (iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *)(iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *)(iostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SubStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SubStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_iostream) {
    iostream* other_this = (iostream*)from_this;
    return (SubStream*)other_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (SubStream*)other_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (SubStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OpenSSLWrapper
 */
/**
 * Python function wrapper for:
 * void OpenSSLWrapper::clear_certificates(void)
 */
static PyObject *Dtool_OpenSSLWrapper_clear_certificates_1292(PyObject *self, PyObject *) {
  OpenSSLWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.clear_certificates")) {
    return NULL;
  }
  // 1-void OpenSSLWrapper::clear_certificates(void)
  (*local_this).clear_certificates();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_clear_certificates_1292_comment =
  "C++ Interface:\n"
  "clear_certificates(const OpenSSLWrapper self)\n"
  "\n"
  "/**\n"
  " * Removes all the certificates from the global store, including the compiled-\n"
  " * in certificates loaded from ca_bundle_data.c.  You can add new certificates\n"
  " * by calling load_certificates().\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_clear_certificates_1292_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OpenSSLWrapper::load_certificates(Filename const &filename)
 */
static PyObject *Dtool_OpenSSLWrapper_load_certificates_1293(PyObject *self, PyObject *arg) {
  OpenSSLWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.load_certificates")) {
    return NULL;
  }
  // 1-int OpenSSLWrapper::load_certificates(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OpenSSLWrapper.load_certificates", "Filename");
  }
  int return_value = (*local_this).load_certificates(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates(const OpenSSLWrapper self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_load_certificates_1293_comment =
  "C++ Interface:\n"
  "load_certificates(const OpenSSLWrapper self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Reads the PEM-formatted certificate(s) (delimited by -----BEGIN\n"
  " * CERTIFICATE----- and -----END CERTIFICATE-----) from the indicated file and\n"
  " * adds them to the global store object, retrieved via get_x509_store().\n"
  " *\n"
  " * Returns the number of certificates read on success, or 0 on failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_load_certificates_1293_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OpenSSLWrapper::load_certificates_from_pem_ram(char const *data, std::size_t data_size)
 * inline int OpenSSLWrapper::load_certificates_from_pem_ram(std::string const &data)
 */
static PyObject *Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294(PyObject *self, PyObject *args, PyObject *kwds) {
  OpenSSLWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.load_certificates_from_pem_ram")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "data");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'data' (pos 1) not found");
      }
      // 1-inline int OpenSSLWrapper::load_certificates_from_pem_ram(std::string const &data)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        int return_value = (*local_this).load_certificates_from_pem_ram(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int OpenSSLWrapper::load_certificates_from_pem_ram(char const *data, std::size_t data_size)
      char const *param1;
      Py_ssize_t param2;
      static const char *keyword_list[] = {"data", "data_size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zn:load_certificates_from_pem_ram", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        int return_value = (*local_this).load_certificates_from_pem_ram((char const *)param1, (std::size_t)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_certificates_from_pem_ram() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data)\n"
      "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data, int data_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294_comment =
  "C++ Interface:\n"
  "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data)\n"
  "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data, int data_size)\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be PEM-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be PEM-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int OpenSSLWrapper::load_certificates_from_der_ram(char const *data, std::size_t data_size)
 * inline int OpenSSLWrapper::load_certificates_from_der_ram(std::string const &data)
 */
static PyObject *Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295(PyObject *self, PyObject *args, PyObject *kwds) {
  OpenSSLWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.load_certificates_from_der_ram")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "data");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'data' (pos 1) not found");
      }
      // 1-inline int OpenSSLWrapper::load_certificates_from_der_ram(std::string const &data)
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        int return_value = (*local_this).load_certificates_from_der_ram(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-int OpenSSLWrapper::load_certificates_from_der_ram(char const *data, std::size_t data_size)
      char const *param1;
      Py_ssize_t param2;
      static const char *keyword_list[] = {"data", "data_size", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zn:load_certificates_from_der_ram", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        int return_value = (*local_this).load_certificates_from_der_ram((char const *)param1, (std::size_t)param2);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_certificates_from_der_ram() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates_from_der_ram(const OpenSSLWrapper self, str data)\n"
      "load_certificates_from_der_ram(const OpenSSLWrapper self, str data, int data_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295_comment =
  "C++ Interface:\n"
  "load_certificates_from_der_ram(const OpenSSLWrapper self, str data)\n"
  "load_certificates_from_der_ram(const OpenSSLWrapper self, str data, int data_size)\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be DER-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be DER-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OpenSSLWrapper::notify_ssl_errors(void)
 */
static PyObject *Dtool_OpenSSLWrapper_notify_ssl_errors_1297(PyObject *self, PyObject *) {
  OpenSSLWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.notify_ssl_errors")) {
    return NULL;
  }
  // 1-void OpenSSLWrapper::notify_ssl_errors(void)
  (*local_this).notify_ssl_errors();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_notify_ssl_errors_1297_comment =
  "C++ Interface:\n"
  "notify_ssl_errors(const OpenSSLWrapper self)\n"
  "\n"
  "/**\n"
  " * A convenience function that is itself a wrapper around the OpenSSL\n"
  " * convenience function to output the recent OpenSSL errors.  This function\n"
  " * sends the error string to express_cat.warning().  If REPORT_OPENSSL_ERRORS\n"
  " * is not defined, the function does nothing.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_notify_ssl_errors_1297_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void OpenSSLWrapper::notify_debug_ssl_errors(void)
 */
static PyObject *Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298(PyObject *self, PyObject *) {
  OpenSSLWrapper *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.notify_debug_ssl_errors")) {
    return NULL;
  }
  // 1-void OpenSSLWrapper::notify_debug_ssl_errors(void)
  (*local_this).notify_debug_ssl_errors();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298_comment =
  "C++ Interface:\n"
  "notify_debug_ssl_errors(const OpenSSLWrapper self)\n"
  "\n"
  "/**\n"
  " * As notify_ssl_errors(), but sends the output to debug instead of warning.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static OpenSSLWrapper *OpenSSLWrapper::get_global_ptr(void)
 */
static PyObject *Dtool_OpenSSLWrapper_get_global_ptr_1299(PyObject *, PyObject *) {
  // 1-static OpenSSLWrapper *OpenSSLWrapper::get_global_ptr(void)
  OpenSSLWrapper *return_value = OpenSSLWrapper::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OpenSSLWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_get_global_ptr_1299_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_get_global_ptr_1299_comment = NULL;
#endif

static int Dtool_Init_OpenSSLWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_OpenSSLWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OpenSSLWrapper) {
    printf("OpenSSLWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OpenSSLWrapper *local_this = (OpenSSLWrapper *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OpenSSLWrapper) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OpenSSLWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OpenSSLWrapper) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Multifile
 */
/**
 * Python function wrapper for:
 * bool Multifile::open_read(Filename const &multifile_name, streamoff const &offset = 0)
 * bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, streamoff const &offset = 0)
 */
static PyObject *Dtool_Multifile_open_read_1302(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_read")) {
    return NULL;
  }
  {
    // -2 bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, streamoff const &offset = 0)
    PyObject *param1;
    PyObject *param2 = Py_False;
    long param3 = 0;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", "offset", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Ol:open_read", (char **)keyword_list, &param1, &param2, &param3)) {
      IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_IStreamWrapper, 1, "Multifile.open_read", false, false);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_read(param1_this, (PyObject_IsTrue(param2) != 0), (streamoff const &)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool Multifile::open_read(Filename const &multifile_name, streamoff const &offset = 0)
    PyObject *param1;
    long param2 = 0;
    static const char *keyword_list[] = {"multifile_name", "offset", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|l:open_read", (char **)keyword_list, &param1, &param2)) {
      Filename const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_read(*param1_this, (streamoff const &)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, streamoff const &offset = 0)
    PyObject *param1;
    PyObject *param2 = Py_False;
    long param3 = 0;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", "offset", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|Ol:open_read", (char **)keyword_list, &param1, &param2, &param3)) {
      IStreamWrapper *param1_this;
      bool param1_manage = false;
      if (Dtool_Coerce_IStreamWrapper(param1, param1_this, param1_manage)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_read(param1_this, (PyObject_IsTrue(param2) != 0), (streamoff const &)param3);
        if (param1_manage) {
          delete param1_this;
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool Multifile::open_read(Filename const &multifile_name, streamoff const &offset = 0)
    PyObject *param1;
    long param2 = 0;
    static const char *keyword_list[] = {"multifile_name", "offset", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|l:open_read", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_read(*param1_this, (streamoff const &)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read(const Multifile self, IStreamWrapper multifile_stream, bool owns_pointer, int offset)\n"
      "open_read(const Multifile self, const Filename multifile_name, int offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_read_1302_comment =
  "C++ Interface:\n"
  "open_read(const Multifile self, IStreamWrapper multifile_stream, bool owns_pointer, int offset)\n"
  "open_read(const Multifile self, const Filename multifile_name, int offset)\n"
  "\n"
  "/**\n"
  " * Opens the named Multifile on disk for reading.  The Multifile index is read\n"
  " * in, and the list of subfiles becomes available; individual subfiles may\n"
  " * then be extracted or read, but the list of subfiles may not be modified.\n"
  " *\n"
  " * Also see the version of open_read() which accepts an istream.  Returns true\n"
  " * on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens an anonymous Multifile for reading using an istream.  There must be\n"
  " * seek functionality via seekg() and tellg() on the istream.\n"
  " *\n"
  " * If owns_pointer is true, then the Multifile assumes ownership of the stream\n"
  " * pointer and will delete it when the multifile is closed, including if this\n"
  " * function returns false.\n"
  " */";
#else
static const char *Dtool_Multifile_open_read_1302_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::open_write(Filename const &multifile_name)
 * bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer = false)
 */
static PyObject *Dtool_Multifile_open_write_1303(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_write")) {
    return NULL;
  }
  {
    // -2 bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer = false)
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "Multifile.open_write", false, false);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_write(param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Multifile::open_write(ostream *multifile_stream, bool owns_pointer = false)
  {
    // -2 bool Multifile::open_write(Filename const &multifile_name)
    PyObject *param1;
    static const char *keyword_list[] = {"multifile_name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open_write", (char **)keyword_list, &param1)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write(const Multifile self, ostream multifile_stream, bool owns_pointer)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_write_1303_comment =
  "C++ Interface:\n"
  "open_write(const Multifile self, ostream multifile_stream, bool owns_pointer)\n"
  "\n"
  "/**\n"
  " * Opens the named Multifile on disk for writing.  If there already exists a\n"
  " * file by that name, it is truncated.  The Multifile is then prepared for\n"
  " * accepting a brand new set of subfiles, which will be written to the\n"
  " * indicated filename.  Individual subfiles may not be extracted or read.\n"
  " *\n"
  " * Also see the version of open_write() which accepts an ostream.  Returns\n"
  " * true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens an anonymous Multifile for writing using an ostream.  There must be\n"
  " * seek functionality via seekp() and tellp() on the pstream.\n"
  " *\n"
  " * If owns_pointer is true, then the Multifile assumes ownership of the stream\n"
  " * pointer and will delete it when the multifile is closed, including if this\n"
  " * function returns false.\n"
  " */";
#else
static const char *Dtool_Multifile_open_write_1303_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::open_read_write(Filename const &multifile_name)
 * bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer = false)
 */
static PyObject *Dtool_Multifile_open_read_write_1304(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_read_write")) {
    return NULL;
  }
  {
    // -2 bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer = false)
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read_write", (char **)keyword_list, &param1, &param2)) {
      iostream *param1_this = (iostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_iostream, 1, "Multifile.open_read_write", false, false);
      if (param1_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_read_write(param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Multifile::open_read_write(iostream *multifile_stream, bool owns_pointer = false)
  {
    // -2 bool Multifile::open_read_write(Filename const &multifile_name)
    PyObject *param1;
    static const char *keyword_list[] = {"multifile_name", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:open_read_write", (char **)keyword_list, &param1)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).open_read_write(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write(const Multifile self, iostream multifile_stream, bool owns_pointer)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_read_write_1304_comment =
  "C++ Interface:\n"
  "open_read_write(const Multifile self, iostream multifile_stream, bool owns_pointer)\n"
  "\n"
  "/**\n"
  " * Opens the named Multifile on disk for reading and writing.  If there\n"
  " * already exists a file by that name, its index is read.  Subfiles may be\n"
  " * added or removed, and the resulting changes will be written to the named\n"
  " * file.\n"
  " *\n"
  " * Also see the version of open_read_write() which accepts an iostream.\n"
  " * Returns true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens an anonymous Multifile for reading and writing using an iostream.\n"
  " * There must be seek functionality via seekg()/seekp() and tellg()/tellp() on\n"
  " * the iostream.\n"
  " *\n"
  " * If owns_pointer is true, then the Multifile assumes ownership of the stream\n"
  " * pointer and will delete it when the multifile is closed, including if this\n"
  " * function returns false.\n"
  " */";
#else
static const char *Dtool_Multifile_open_read_write_1304_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::close(void)
 */
static PyObject *Dtool_Multifile_close_1305(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.close")) {
    return NULL;
  }
  // 1-void Multifile::close(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).close();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Multifile_close_1305_comment =
  "C++ Interface:\n"
  "close(const Multifile self)\n"
  "\n"
  "/**\n"
  " * Closes the Multifile if it is open.  All changes are flushed to disk, and\n"
  " * the file becomes invalid for further operations until the next call to\n"
  " * open().\n"
  " */";
#else
static const char *Dtool_Multifile_close_1305_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Multifile::get_multifile_name(void) const
 */
static PyObject *Dtool_Multifile_get_multifile_name_1306(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &Multifile::get_multifile_name(void) const
  Filename const *return_value = &((*(const Multifile*)local_this).get_multifile_name());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_multifile_name_1306_comment =
  "C++ Interface:\n"
  "get_multifile_name(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the filename of the Multifile, if it is available.\n"
  " */";
#else
static const char *Dtool_Multifile_get_multifile_name_1306_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_multifile_name(Filename const &multifile_name)
 */
static PyObject *Dtool_Multifile_set_multifile_name_1307(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_multifile_name")) {
    return NULL;
  }
  // 1-inline void Multifile::set_multifile_name(Filename const &multifile_name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Multifile.set_multifile_name", "Filename");
  }
  (*local_this).set_multifile_name(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multifile_name(const Multifile self, const Filename multifile_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_multifile_name_1307_comment =
  "C++ Interface:\n"
  "set_multifile_name(const Multifile self, const Filename multifile_name)\n"
  "\n"
  "/**\n"
  " * Replaces the filename of the Multifile.  This is primarily used for\n"
  " * documentation purposes only; changing this name does not open the indicated\n"
  " * file.  See open_read() or open_write() for that.\n"
  " */";
#else
static const char *Dtool_Multifile_set_multifile_name_1307_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::is_read_valid(void) const
 */
static PyObject *Dtool_Multifile_is_read_valid_1308(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Multifile::is_read_valid(void) const
  bool return_value = (*(const Multifile*)local_this).is_read_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_read_valid_1308_comment =
  "C++ Interface:\n"
  "is_read_valid(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Multifile has been opened for read mode and there have\n"
  " * been no errors, and individual Subfile contents may be extracted.\n"
  " */";
#else
static const char *Dtool_Multifile_is_read_valid_1308_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::is_write_valid(void) const
 */
static PyObject *Dtool_Multifile_is_write_valid_1309(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Multifile::is_write_valid(void) const
  bool return_value = (*(const Multifile*)local_this).is_write_valid();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_write_valid_1309_comment =
  "C++ Interface:\n"
  "is_write_valid(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Multifile has been opened for write mode and there have\n"
  " * been no errors, and Subfiles may be added or removed from the Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_is_write_valid_1309_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::needs_repack(void) const
 */
static PyObject *Dtool_Multifile_needs_repack_1310(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Multifile::needs_repack(void) const
  bool return_value = (*(const Multifile*)local_this).needs_repack();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_needs_repack_1310_comment =
  "C++ Interface:\n"
  "needs_repack(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Multifile index is suboptimal and should be repacked.\n"
  " * Call repack() to achieve this.\n"
  " */";
#else
static const char *Dtool_Multifile_needs_repack_1310_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline time_t Multifile::get_timestamp(void) const
 */
static PyObject *Dtool_Multifile_get_timestamp_1311(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline time_t Multifile::get_timestamp(void) const
  time_t return_value = (*(const Multifile*)local_this).get_timestamp();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_timestamp_1311_comment =
  "C++ Interface:\n"
  "get_timestamp(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the modification timestamp of the overall Multifile.  This\n"
  " * indicates the most recent date at which subfiles were added or removed from\n"
  " * the Multifile.  Note that it is logically possible for an individual\n"
  " * subfile to have a more recent timestamp than the overall timestamp.\n"
  " */";
#else
static const char *Dtool_Multifile_get_timestamp_1311_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_record_timestamp(bool record_timestamp)
 */
static PyObject *Dtool_Multifile_set_record_timestamp_1312(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_record_timestamp")) {
    return NULL;
  }
  // 1-inline void Multifile::set_record_timestamp(bool record_timestamp)
  (*local_this).set_record_timestamp((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_record_timestamp(const Multifile self, bool record_timestamp)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_record_timestamp_1312_comment =
  "C++ Interface:\n"
  "set_record_timestamp(const Multifile self, bool record_timestamp)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether timestamps should be recorded within the\n"
  " * Multifile or not.  The default is true, indicating the Multifile will\n"
  " * record timestamps for the overall file and also for each subfile.\n"
  " *\n"
  " * If this is false, the Multifile will not record timestamps internally.  In\n"
  " * this case, the return value from get_timestamp() or get_subfile_timestamp()\n"
  " * will be estimations.\n"
  " *\n"
  " * You may want to set this false to minimize the bitwise difference between\n"
  " * independently-generated Multifiles.\n"
  " */";
#else
static const char *Dtool_Multifile_set_record_timestamp_1312_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::get_record_timestamp(void) const
 */
static PyObject *Dtool_Multifile_get_record_timestamp_1313(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Multifile::get_record_timestamp(void) const
  bool return_value = (*(const Multifile*)local_this).get_record_timestamp();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_record_timestamp_1313_comment =
  "C++ Interface:\n"
  "get_record_timestamp(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating whether timestamps should be recorded within\n"
  " * the Multifile or not.  See set_record_timestamp().\n"
  " */";
#else
static const char *Dtool_Multifile_get_record_timestamp_1313_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::set_scale_factor(std::size_t scale_factor)
 */
static PyObject *Dtool_Multifile_set_scale_factor_1314(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_scale_factor")) {
    return NULL;
  }
  // 1-void Multifile::set_scale_factor(std::size_t scale_factor)
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:set_scale_factor", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    (*local_this).set_scale_factor((std::size_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const Multifile self, int scale_factor)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_scale_factor_1314_comment =
  "C++ Interface:\n"
  "set_scale_factor(const Multifile self, int scale_factor)\n"
  "\n"
  "/**\n"
  " * Changes the internal scale factor for this Multifile.\n"
  " *\n"
  " * This is normally 1, but it may be set to any arbitrary value (greater than\n"
  " * zero) to support Multifile archives that exceed 4GB, if necessary.\n"
  " * (Individual subfiles may still not exceed 4GB.)\n"
  " *\n"
  " * All addresses within the file are rounded up to the next multiple of\n"
  " * _scale_factor, and zeros are written to the file to fill the resulting\n"
  " * gaps.  Then the address is divided by _scale_factor and written out as a\n"
  " * 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB\n"
  " * files, 3 supports 12GB files, etc.\n"
  " *\n"
  " * Calling this function on an already-existing Multifile will have no\n"
  " * immediate effect until a future call to repack() or close() (or until the\n"
  " * Multifile is destructed).\n"
  " */";
#else
static const char *Dtool_Multifile_set_scale_factor_1314_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Multifile::get_scale_factor(void) const
 */
static PyObject *Dtool_Multifile_get_scale_factor_1315(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t Multifile::get_scale_factor(void) const
  std::size_t return_value = (*(const Multifile*)local_this).get_scale_factor();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_scale_factor_1315_comment =
  "C++ Interface:\n"
  "get_scale_factor(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the internal scale factor for this Multifile.  See\n"
  " * set_scale_factor().\n"
  " */";
#else
static const char *Dtool_Multifile_get_scale_factor_1315_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_flag(bool flag)
 */
static PyObject *Dtool_Multifile_set_encryption_flag_1316(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_flag")) {
    return NULL;
  }
  // 1-inline void Multifile::set_encryption_flag(bool flag)
  (*local_this).set_encryption_flag((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_flag(const Multifile self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_flag_1316_comment =
  "C++ Interface:\n"
  "set_encryption_flag(const Multifile self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether subsequently-added subfiles should be\n"
  " * encrypted before writing them to the multifile.  If true, subfiles will be\n"
  " * encrypted; if false (the default), they will be written without encryption.\n"
  " *\n"
  " * When true, subfiles will be encrypted with the password specified by\n"
  " * set_encryption_password().  It is possible to apply a different password to\n"
  " * different files, but the resulting file can't be mounted via VFS.\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_flag_1316_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::get_encryption_flag(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_flag_1317(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Multifile::get_encryption_flag(void) const
  bool return_value = (*(const Multifile*)local_this).get_encryption_flag();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_flag_1317_comment =
  "C++ Interface:\n"
  "get_encryption_flag(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating whether subsequently-added subfiles should be\n"
  " * encrypted before writing them to the multifile.  See set_encryption_flag().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_flag_1317_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_password(std::string const &encryption_password)
 */
static PyObject *Dtool_Multifile_set_encryption_password_1318(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_password")) {
    return NULL;
  }
  // 1-inline void Multifile::set_encryption_password(std::string const &encryption_password)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_encryption_password(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_password(const Multifile self, str encryption_password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_password_1318_comment =
  "C++ Interface:\n"
  "set_encryption_password(const Multifile self, str encryption_password)\n"
  "\n"
  "/**\n"
  " * Specifies the password that will be used to encrypt subfiles subsequently\n"
  " * added to the multifile, if the encryption flag is also set true (see\n"
  " * set_encryption_flag()).\n"
  " *\n"
  " * It is possible to apply a different password to different files, but the\n"
  " * resulting file can't be mounted via VFS.  Changing this value may cause an\n"
  " * implicit call to flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_password_1318_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Multifile::get_encryption_password(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_password_1319(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Multifile::get_encryption_password(void) const
  std::string const &return_value = (*(const Multifile*)local_this).get_encryption_password();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_password_1319_comment =
  "C++ Interface:\n"
  "get_encryption_password(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the password that will be used to encrypt subfiles subsequently\n"
  " * added to the multifile.  See set_encryption_password().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_password_1319_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_algorithm(std::string const &encryption_algorithm)
 */
static PyObject *Dtool_Multifile_set_encryption_algorithm_1320(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_algorithm")) {
    return NULL;
  }
  // 1-inline void Multifile::set_encryption_algorithm(std::string const &encryption_algorithm)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_encryption_algorithm(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_algorithm(const Multifile self, str encryption_algorithm)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_algorithm_1320_comment =
  "C++ Interface:\n"
  "set_encryption_algorithm(const Multifile self, str encryption_algorithm)\n"
  "\n"
  "/**\n"
  " * Specifies the encryption algorithm that should be used for future calls to\n"
  " * add_subfile().  The default is whatever is specified by the encryption-\n"
  " * algorithm config variable.  The complete set of available algorithms is\n"
  " * defined by the current version of OpenSSL.\n"
  " *\n"
  " * If an invalid algorithm is specified, there is no immediate error return\n"
  " * code, but flush() will fail and the file will be invalid.\n"
  " *\n"
  " * It is possible to apply a different encryption algorithm to different\n"
  " * files, and unlike the password, this does not interfere with mounting the\n"
  " * multifile via VFS.  Changing this value may cause an implicit call to\n"
  " * flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_algorithm_1320_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Multifile::get_encryption_algorithm(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_algorithm_1321(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Multifile::get_encryption_algorithm(void) const
  std::string const &return_value = (*(const Multifile*)local_this).get_encryption_algorithm();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_algorithm_1321_comment =
  "C++ Interface:\n"
  "get_encryption_algorithm(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption algorithm that was specified by\n"
  " * set_encryption_algorithm().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_algorithm_1321_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_key_length(int encryption_key_length)
 */
static PyObject *Dtool_Multifile_set_encryption_key_length_1322(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_key_length")) {
    return NULL;
  }
  // 1-inline void Multifile::set_encryption_key_length(int encryption_key_length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_encryption_key_length((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_key_length(const Multifile self, int encryption_key_length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_key_length_1322_comment =
  "C++ Interface:\n"
  "set_encryption_key_length(const Multifile self, int encryption_key_length)\n"
  "\n"
  "/**\n"
  " * Specifies the length of the key, in bits, that should be used to encrypt\n"
  " * the stream in future calls to add_subfile().  The default is whatever is\n"
  " * specified by the encryption-key-length config variable.\n"
  " *\n"
  " * If an invalid key_length for the chosen algorithm is specified, there is no\n"
  " * immediate error return code, but flush() will fail and the file will be\n"
  " * invalid.\n"
  " *\n"
  " * It is possible to apply a different key length to different files, and\n"
  " * unlike the password, this does not interfere with mounting the multifile\n"
  " * via VFS. Changing this value may cause an implicit call to flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_key_length_1322_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Multifile::get_encryption_key_length(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_key_length_1323(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Multifile::get_encryption_key_length(void) const
  int return_value = (*(const Multifile*)local_this).get_encryption_key_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_key_length_1323_comment =
  "C++ Interface:\n"
  "get_encryption_key_length(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption key length, in bits, that was specified by\n"
  " * set_encryption_key_length().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_key_length_1323_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count)
 */
static PyObject *Dtool_Multifile_set_encryption_iteration_count_1324(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_iteration_count")) {
    return NULL;
  }
  // 1-inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_encryption_iteration_count((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_iteration_count(const Multifile self, int encryption_iteration_count)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_iteration_count_1324_comment =
  "C++ Interface:\n"
  "set_encryption_iteration_count(const Multifile self, int encryption_iteration_count)\n"
  "\n"
  "/**\n"
  " * Specifies the number of times to repeatedly hash the key before writing it\n"
  " * to the stream in future calls to add_subfile().  Its purpose is to make it\n"
  " * computationally more expensive for an attacker to search the key space\n"
  " * exhaustively.  This should be a multiple of 1,000 and should not exceed\n"
  " * about 65 million; the value 0 indicates just one application of the hashing\n"
  " * algorithm.\n"
  " *\n"
  " * The default is whatever is specified by the multifile-encryption-iteration-\n"
  " * count config variable.\n"
  " *\n"
  " * It is possible to apply a different iteration count to different files, and\n"
  " * unlike the password, this does not interfere with mounting the multifile\n"
  " * via VFS.  Changing this value causes an implicit call to flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_iteration_count_1324_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Multifile::get_encryption_iteration_count(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_iteration_count_1325(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int Multifile::get_encryption_iteration_count(void) const
  int return_value = (*(const Multifile*)local_this).get_encryption_iteration_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_iteration_count_1325_comment =
  "C++ Interface:\n"
  "get_encryption_iteration_count(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the value that was specified by set_encryption_iteration_count().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_iteration_count_1325_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::add_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
 * std::string Multifile::add_subfile(std::string const &subfile_name, istream *subfile_data, int compression_level)
 */
static PyObject *Dtool_Multifile_add_subfile_1326(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.add_subfile")) {
    return NULL;
  }
  {
    // -2 std::string Multifile::add_subfile(std::string const &subfile_name, istream *subfile_data, int compression_level)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"subfile_name", "subfile_data", "compression_level", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:add_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      istream *param2_this = (istream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_istream, 2, "Multifile.add_subfile", false, false);
      if (param2_this != NULL) {
        std::string return_value = (*local_this).add_subfile(std::string(param1_str, param1_len), param2_this, (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: std::string Multifile::add_subfile(std::string const &subfile_name, istream *subfile_data, int compression_level)
  {
    // -2 std::string Multifile::add_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"subfile_name", "filename", "compression_level", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:add_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if ((param2_this != NULL)) {
        std::string return_value = (*local_this).add_subfile(std::string(param1_str, param1_len), *param2_this, (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_subfile(const Multifile self, str subfile_name, istream subfile_data, int compression_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_add_subfile_1326_comment =
  "C++ Interface:\n"
  "add_subfile(const Multifile self, str subfile_name, istream subfile_data, int compression_level)\n"
  "\n"
  "/**\n"
  " * Adds a file on disk as a subfile to the Multifile.  The file named by\n"
  " * filename will be read and added to the Multifile at the next call to\n"
  " * flush().  If there already exists a subfile with the indicated name, it is\n"
  " * replaced without examining its contents (but see also update_subfile).\n"
  " *\n"
  " * Either Filename:::set_binary() or set_text() must have been called\n"
  " * previously to specify the nature of the source file.  If set_text() was\n"
  " * called, the text flag will be set on the subfile.\n"
  " *\n"
  " * Returns the subfile name on success (it might have been modified slightly),\n"
  " * or empty string on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a file from a stream as a subfile to the Multifile.  The indicated\n"
  " * istream will be read and its contents added to the Multifile at the next\n"
  " * call to flush(). The file will be added as a binary subfile.\n"
  " *\n"
  " * Note that the istream must remain untouched and unused by any other code\n"
  " * until flush() is called.  At that time, the Multifile will read the entire\n"
  " * contents of the istream from the current file position to the end of the\n"
  " * file.  Subsequently, the Multifile will *not* close or delete the istream.\n"
  " * It is the caller's responsibility to ensure that the istream pointer does\n"
  " * not destruct during the lifetime of the Multifile.\n"
  " *\n"
  " * Returns the subfile name on success (it might have been modified slightly),\n"
  " * or empty string on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_add_subfile_1326_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::update_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
 */
static PyObject *Dtool_Multifile_update_subfile_1327(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.update_subfile")) {
    return NULL;
  }
  // 1-std::string Multifile::update_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"subfile_name", "filename", "compression_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:update_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.update_subfile", "Filename");
    }
    std::string return_value = (*local_this).update_subfile(std::string(param1_str, param1_len), *param2_this, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_update_subfile_1327_comment =
  "C++ Interface:\n"
  "update_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)\n"
  "\n"
  "/**\n"
  " * Adds a file on disk to the subfile.  If a subfile already exists with the\n"
  " * same name, its contents are compared byte-for-byte to the disk file, and it\n"
  " * is replaced only if it is different; otherwise, the multifile is left\n"
  " * unchanged.\n"
  " *\n"
  " * Either Filename:::set_binary() or set_text() must have been called\n"
  " * previously to specify the nature of the source file.  If set_text() was\n"
  " * called, the text flag will be set on the subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_update_subfile_1327_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, std::string const &password = "")
 * bool Multifile::add_signature(Filename const &composite, std::string const &password = "")
 */
static PyObject *Dtool_Multifile_add_signature_1328(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.add_signature")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "composite");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'composite' (pos 1) not found");
      }
      // 1-bool Multifile::add_signature(Filename const &composite, std::string const &password)
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if (!(arg_this != NULL)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "Multifile.add_signature", "Filename");
      }
      bool return_value = (*local_this).add_signature(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 2:
    {
      // 1-bool Multifile::add_signature(Filename const &composite, std::string const &password)
      PyObject *param1;
      char *param2_str = NULL;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"composite", "password", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add_signature", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Multifile.add_signature", "Filename");
        }
        bool return_value = (*local_this).add_signature(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, std::string const &password = "")
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      const char *param4_str = "";
      Py_ssize_t param4_len = 0;
      static const char *keyword_list[] = {"certificate", "chain", "pkey", "password", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|s#:add_signature", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Multifile.add_signature", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.add_signature", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Multifile.add_signature", "Filename");
        }
        bool return_value = (*local_this).add_signature(*param1_this, *param2_this, *param3_this, std::string(param4_str, param4_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_signature() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_signature(const Multifile self, const Filename composite)\n"
      "add_signature(const Multifile self, const Filename composite, str password)\n"
      "add_signature(const Multifile self, const Filename certificate, const Filename chain, const Filename pkey, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_add_signature_1328_comment =
  "C++ Interface:\n"
  "add_signature(const Multifile self, const Filename composite)\n"
  "add_signature(const Multifile self, const Filename composite, str password)\n"
  "add_signature(const Multifile self, const Filename certificate, const Filename chain, const Filename pkey, str password)\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * The chain filename may be empty if the certificate does not require an\n"
  " * authenticating certificate chain (e.g.  because it is self-signed).\n"
  " *\n"
  " * The specified private key must match the certificate, and the Multifile\n"
  " * must be open in read-write mode.  The private key is only used for\n"
  " * generating the signature; it is not written to the Multifile and cannot be\n"
  " * retrieved from the Multifile later.  (However, the certificate *can* be\n"
  " * retrieved from the Multifile later, to identify the entity that created the\n"
  " * signature.)\n"
  " *\n"
  " * This implicitly causes a repack() operation if one is needed.  Returns true\n"
  " * on success, false on failure.\n"
  " *\n"
  " * This flavor of add_signature() reads the certificate and private key from a\n"
  " * PEM-formatted file, for instance as generated by the openssl command.  If\n"
  " * the private key file is password-encrypted, the third parameter will be\n"
  " * used as the password to decrypt it.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * This flavor of add_signature() reads the certificate, private key, and\n"
  " * certificate chain from the same PEM-formatted file.  It takes the first\n"
  " * private key found as the intended key, and then uses the first certificate\n"
  " * found that matches that key as the signing certificate.  Any other\n"
  " * certificates in the file are taken to be part of the chain.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * If chain is non-NULL, it represents the certificate chain that validates\n"
  " * the certificate.\n"
  " *\n"
  " * The specified private key must match the certificate, and the Multifile\n"
  " * must be open in read-write mode.  The private key is only used for\n"
  " * generating the signature; it is not written to the Multifile and cannot be\n"
  " * retrieved from the Multifile later.  (However, the certificate *can* be\n"
  " * retrieved from the Multifile later, to identify the entity that created the\n"
  " * signature.)\n"
  " *\n"
  " * This implicitly causes a repack() operation if one is needed.  Returns true\n"
  " * on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * The signature certificate is the first certificate on the CertChain object.\n"
  " * Any remaining certificates are support certificates to authenticate the\n"
  " * first one.\n"
  " *\n"
  " * The specified private key must match the certificate, and the Multifile\n"
  " * must be open in read-write mode.  The private key is only used for\n"
  " * generating the signature; it is not written to the Multifile and cannot be\n"
  " * retrieved from the Multifile later.  (However, the certificate *can* be\n"
  " * retrieved from the Multifile later, to identify the entity that created the\n"
  " * signature.)\n"
  " *\n"
  " * This implicitly causes a repack() operation if one is needed.  Returns true\n"
  " * on success, false on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_add_signature_1328_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Multifile::get_num_signatures(void) const
 */
static PyObject *Dtool_Multifile_get_num_signatures_1329(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Multifile::get_num_signatures(void) const
  int return_value = (*(const Multifile*)local_this).get_num_signatures();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_num_signatures_1329_comment =
  "C++ Interface:\n"
  "get_num_signatures(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of matching signatures found on the Multifile.  These\n"
  " * signatures may be iterated via get_signature() and related methods.\n"
  " *\n"
  " * A signature on this list is guaranteed to match the Multifile contents,\n"
  " * proving that the Multifile has been unmodified since the signature was\n"
  " * applied.  However, this does not guarantee that the certificate itself is\n"
  " * actually from who it says it is from; only that it matches the Multifile\n"
  " * contents.  See validate_signature_certificate() to authenticate a\n"
  " * particular certificate.\n"
  " */";
#else
static const char *Dtool_Multifile_get_num_signatures_1329_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::get_signature_subject_name(int n) const
 */
static PyObject *Dtool_Multifile_get_signature_subject_name_1330(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Multifile::get_signature_subject_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const Multifile*)local_this).get_signature_subject_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_signature_subject_name(Multifile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_signature_subject_name_1330_comment =
  "C++ Interface:\n"
  "get_signature_subject_name(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the \"subject name\" for the nth signature found on the Multifile.\n"
  " * This is a string formatted according to RFC2253 that should more-or-less\n"
  " * identify a particular certificate; when paired with the public key (see\n"
  " * get_signature_public_key()), it can uniquely identify a certificate.  See\n"
  " * the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_get_signature_subject_name_1330_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::get_signature_friendly_name(int n) const
 */
static PyObject *Dtool_Multifile_get_signature_friendly_name_1331(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Multifile::get_signature_friendly_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const Multifile*)local_this).get_signature_friendly_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_signature_friendly_name(Multifile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_signature_friendly_name_1331_comment =
  "C++ Interface:\n"
  "get_signature_friendly_name(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns a \"friendly name\" for the nth signature found on the Multifile.\n"
  " * This attempts to extract out the most meaningful part of the subject name.\n"
  " * It returns the emailAddress, if it is defined; otherwise, it returns the\n"
  " * commonName.\n"
  " *\n"
  " * See the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_get_signature_friendly_name_1331_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::get_signature_public_key(int n) const
 */
static PyObject *Dtool_Multifile_get_signature_public_key_1332(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string Multifile::get_signature_public_key(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (*(const Multifile*)local_this).get_signature_public_key((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_signature_public_key(Multifile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_signature_public_key_1332_comment =
  "C++ Interface:\n"
  "get_signature_public_key(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the public key used for the nth signature found on the Multifile.\n"
  " * This is encoded in DER form and returned as a string of hex digits.\n"
  " *\n"
  " * This can be used, in conjunction with the subject name (see\n"
  " * get_signature_subject_name()), to uniquely identify a particular\n"
  " * certificate and its subsequent reissues.  See the comments in\n"
  " * get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_get_signature_public_key_1332_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::print_signature_certificate(int n, ostream &out) const
 */
static PyObject *Dtool_Multifile_print_signature_certificate_1333(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Multifile::print_signature_certificate(int n, ostream &out) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "out", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:print_signature_certificate", (char **)keyword_list, &param1, &param2)) {
    ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ostream, 2, "Multifile.print_signature_certificate", false, true);
    if (param2_this != NULL) {
      (*(const Multifile*)local_this).print_signature_certificate((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "print_signature_certificate(Multifile self, int n, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_print_signature_certificate_1333_comment =
  "C++ Interface:\n"
  "print_signature_certificate(Multifile self, int n, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the certificate for the nth signature, in user-readable verbose\n"
  " * form, to the indicated stream.  See the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_print_signature_certificate_1333_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::write_signature_certificate(int n, ostream &out) const
 */
static PyObject *Dtool_Multifile_write_signature_certificate_1334(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Multifile::write_signature_certificate(int n, ostream &out) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "out", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:write_signature_certificate", (char **)keyword_list, &param1, &param2)) {
    ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ostream, 2, "Multifile.write_signature_certificate", false, true);
    if (param2_this != NULL) {
      (*(const Multifile*)local_this).write_signature_certificate((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_signature_certificate(Multifile self, int n, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_write_signature_certificate_1334_comment =
  "C++ Interface:\n"
  "write_signature_certificate(Multifile self, int n, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the certificate for the nth signature, in PEM form, to the indicated\n"
  " * stream.  See the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_write_signature_certificate_1334_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Multifile::validate_signature_certificate(int n) const
 */
static PyObject *Dtool_Multifile_validate_signature_certificate_1335(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Multifile::validate_signature_certificate(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (*(const Multifile*)local_this).validate_signature_certificate((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "validate_signature_certificate(Multifile self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_validate_signature_certificate_1335_comment =
  "C++ Interface:\n"
  "validate_signature_certificate(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Checks that the certificate used for the nth signature is a valid,\n"
  " * authorized certificate with some known certificate authority.  Returns 0 if\n"
  " * it is valid, -1 if there is some error, or the corresponding OpenSSL error\n"
  " * code if it is invalid, out-of-date, or self-signed.\n"
  " */";
#else
static const char *Dtool_Multifile_validate_signature_certificate_1335_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::flush(void)
 */
static PyObject *Dtool_Multifile_flush_1336(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.flush")) {
    return NULL;
  }
  // 1-bool Multifile::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_flush_1336_comment =
  "C++ Interface:\n"
  "flush(const Multifile self)\n"
  "\n"
  "/**\n"
  " * Writes all contents of the Multifile to disk.  Until flush() is called,\n"
  " * add_subfile() and remove_subfile() do not actually do anything to disk.  At\n"
  " * this point, all of the recently-added subfiles are read and their contents\n"
  " * are added to the end of the Multifile, and the recently-removed subfiles\n"
  " * are marked gone from the Multifile.\n"
  " *\n"
  " * This may result in a suboptimal index.  To guarantee that the index is\n"
  " * written at the beginning of the file, call repack() instead of flush().\n"
  " *\n"
  " * It is not necessary to call flush() explicitly unless you are concerned\n"
  " * about reading the recently-added subfiles immediately.\n"
  " *\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_flush_1336_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::repack(void)
 */
static PyObject *Dtool_Multifile_repack_1337(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.repack")) {
    return NULL;
  }
  // 1-bool Multifile::repack(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).repack();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_repack_1337_comment =
  "C++ Interface:\n"
  "repack(const Multifile self)\n"
  "\n"
  "/**\n"
  " * Forces a complete rewrite of the Multifile and all of its contents, so that\n"
  " * its index will appear at the beginning of the file with all of the subfiles\n"
  " * listed in alphabetical order.  This is considered optimal for reading, and\n"
  " * is the standard configuration; but it is not essential to do this.\n"
  " *\n"
  " * It is only valid to call this if the Multifile was opened using\n"
  " * open_read_write() and an explicit filename, rather than an iostream.  Also,\n"
  " * we must have write permission to the directory containing the Multifile.\n"
  " *\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_repack_1337_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Multifile::get_num_subfiles(void) const
 */
static PyObject *Dtool_Multifile_get_num_subfiles_1338(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Multifile::get_num_subfiles(void) const
  int return_value = (*(const Multifile*)local_this).get_num_subfiles();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_num_subfiles_1338_comment =
  "C++ Interface:\n"
  "get_num_subfiles(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subfiles within the Multifile.  The subfiles may be\n"
  " * accessed in alphabetical order by iterating through [0 ..\n"
  " * get_num_subfiles()).\n"
  " */";
#else
static const char *Dtool_Multifile_get_num_subfiles_1338_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Multifile::find_subfile(std::string const &subfile_name) const
 */
static PyObject *Dtool_Multifile_find_subfile_1339(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-int Multifile::find_subfile(std::string const &subfile_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    int return_value = (*(const Multifile*)local_this).find_subfile(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_subfile(Multifile self, str subfile_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_find_subfile_1339_comment =
  "C++ Interface:\n"
  "find_subfile(Multifile self, str subfile_name)\n"
  "\n"
  "/**\n"
  " * Returns the index of the subfile with the indicated name, or -1 if the\n"
  " * named subfile is not within the Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_find_subfile_1339_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::has_directory(std::string const &subfile_name) const
 */
static PyObject *Dtool_Multifile_has_directory_1340(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Multifile::has_directory(std::string const &subfile_name) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    bool return_value = (*(const Multifile*)local_this).has_directory(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_directory(Multifile self, str subfile_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_has_directory_1340_comment =
  "C++ Interface:\n"
  "has_directory(Multifile self, str subfile_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile name is the directory prefix to one\n"
  " * or more files within the Multifile.  That is, the Multifile contains at\n"
  " * least one file named \"subfile_name/...\".\n"
  " */";
#else
static const char *Dtool_Multifile_has_directory_1340_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::remove_subfile(int index)
 * inline bool Multifile::remove_subfile(std::string const &subfile_name)
 */
static PyObject *Dtool_Multifile_remove_subfile_1342(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.remove_subfile")) {
    return NULL;
  }
  {
    // -2 inline bool Multifile::remove_subfile(std::string const &subfile_name)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      bool return_value = (*local_this).remove_subfile(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 void Multifile::remove_subfile(int index)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      (*local_this).remove_subfile((int)arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline bool Multifile::remove_subfile(std::string const &subfile_name)
  // No coercion possible: void Multifile::remove_subfile(int index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_subfile(const Multifile self, str subfile_name)\n"
      "remove_subfile(const Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_remove_subfile_1342_comment =
  "C++ Interface:\n"
  "remove_subfile(const Multifile self, str subfile_name)\n"
  "remove_subfile(const Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the named subfile from the Multifile, if it exists; returns true if\n"
  " * successfully removed, or false if it did not exist in the first place.  The\n"
  " * file will not actually be removed from the disk until the next call to\n"
  " * flush().\n"
  " *\n"
  " * Note that this does not actually remove the data from the indicated\n"
  " * subfile; it simply removes it from the index.  The Multifile will not be\n"
  " * reduced in size after this operation, until the next call to repack().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the nth subfile from the Multifile.  This will cause all subsequent\n"
  " * index numbers to decrease by one.  The file will not actually be removed\n"
  " * from the disk until the next call to flush().\n"
  " *\n"
  " * Note that this does not actually remove the data from the indicated\n"
  " * subfile; it simply removes it from the index.  The Multifile will not be\n"
  " * reduced in size after this operation, until the next call to repack().\n"
  " */";
#else
static const char *Dtool_Multifile_remove_subfile_1342_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::string const &Multifile::get_subfile_name(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_name_1343(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::string const &Multifile::get_subfile_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string const &return_value = (*(const Multifile*)local_this).get_subfile_name((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_name(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_name_1343_comment =
  "C++ Interface:\n"
  "get_subfile_name(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_name_1343_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t Multifile::get_subfile_length(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_length_1345(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t Multifile::get_subfile_length(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = (*(const Multifile*)local_this).get_subfile_length((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_length(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_length_1345_comment =
  "C++ Interface:\n"
  "get_subfile_length(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the uncompressed data length of the nth subfile.  This might return\n"
  " * 0 if the subfile has recently been added and flush() has not yet been\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_length_1345_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * time_t Multifile::get_subfile_timestamp(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_timestamp_1346(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-time_t Multifile::get_subfile_timestamp(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    time_t return_value = (*(const Multifile*)local_this).get_subfile_timestamp((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_timestamp(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_timestamp_1346_comment =
  "C++ Interface:\n"
  "get_subfile_timestamp(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the modification time of the nth subfile.  If this is called on an\n"
  " * older .mf file, which did not store individual timestamps in the file (or\n"
  " * if get_record_timestamp() is false), this will return the modification time\n"
  " * of the overall multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_timestamp_1346_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::is_subfile_compressed(int index) const
 */
static PyObject *Dtool_Multifile_is_subfile_compressed_1347(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Multifile::is_subfile_compressed(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const Multifile*)local_this).is_subfile_compressed((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_subfile_compressed(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_subfile_compressed_1347_comment =
  "C++ Interface:\n"
  "is_subfile_compressed(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile has been compressed when stored\n"
  " * within the archive, false otherwise.\n"
  " */";
#else
static const char *Dtool_Multifile_is_subfile_compressed_1347_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::is_subfile_encrypted(int index) const
 */
static PyObject *Dtool_Multifile_is_subfile_encrypted_1348(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Multifile::is_subfile_encrypted(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const Multifile*)local_this).is_subfile_encrypted((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_subfile_encrypted(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_subfile_encrypted_1348_comment =
  "C++ Interface:\n"
  "is_subfile_encrypted(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile has been encrypted when stored within\n"
  " * the archive, false otherwise.\n"
  " */";
#else
static const char *Dtool_Multifile_is_subfile_encrypted_1348_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::is_subfile_text(int index) const
 */
static PyObject *Dtool_Multifile_is_subfile_text_1349(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool Multifile::is_subfile_text(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = (*(const Multifile*)local_this).is_subfile_text((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_subfile_text(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_subfile_text_1349_comment =
  "C++ Interface:\n"
  "is_subfile_text(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile represents text data, or false if it\n"
  " * represents binary data.  If the file is text data, it may have been\n"
  " * processed by end-of-line conversion when it was added.  (But the actual\n"
  " * bits in the multifile will represent the standard Unix end-of-line\n"
  " * convention, e.g.  \\n instead of \\r\\n.)\n"
  " */";
#else
static const char *Dtool_Multifile_is_subfile_text_1349_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * streamoff Multifile::get_index_end(void) const
 */
static PyObject *Dtool_Multifile_get_index_end_1350(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-streamoff Multifile::get_index_end(void) const
  streamoff return_value = (*(const Multifile*)local_this).get_index_end();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_index_end_1350_comment =
  "C++ Interface:\n"
  "get_index_end(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the first byte that is guaranteed to follow any index byte already\n"
  " * written to disk in the Multifile.\n"
  " *\n"
  " * This number is largely meaningless in many cases, but if needs_repack() is\n"
  " * false, and the file is flushed, this will indicate the number of bytes in\n"
  " * the header + index.  Everything at this byte position and later will be\n"
  " * actual data.\n"
  " */";
#else
static const char *Dtool_Multifile_get_index_end_1350_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * streamoff Multifile::get_subfile_internal_start(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_internal_start_1351(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-streamoff Multifile::get_subfile_internal_start(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    streamoff return_value = (*(const Multifile*)local_this).get_subfile_internal_start((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_internal_start(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_internal_start_1351_comment =
  "C++ Interface:\n"
  "get_subfile_internal_start(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the starting byte position within the Multifile at which the\n"
  " * indicated subfile begins.  This may be used, with\n"
  " * get_subfile_internal_length(), for low-level access to the subfile, but\n"
  " * usually it is better to use open_read_subfile() instead (which\n"
  " * automatically decrypts and/or uncompresses the subfile data).\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_internal_start_1351_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * std::size_t Multifile::get_subfile_internal_length(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_internal_length_1352(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-std::size_t Multifile::get_subfile_internal_length(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = (*(const Multifile*)local_this).get_subfile_internal_length((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_internal_length(Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_internal_length_1352_comment =
  "C++ Interface:\n"
  "get_subfile_internal_length(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes the indicated subfile consumes within the\n"
  " * archive.  For compressed subfiles, this will generally be smaller than\n"
  " * get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be\n"
  " * slightly different, for noncompressed and nonencrypted subfiles, it will be\n"
  " * equal.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_internal_length_1352_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string Multifile::read_subfile(int index)
 */
static PyObject *Dtool_Multifile_read_subfile_1353(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.read_subfile")) {
    return NULL;
  }
  // 1-inline std::string Multifile::read_subfile(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::string return_value = (*local_this).read_subfile((int)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_subfile(const Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_read_subfile_1353_comment =
  "C++ Interface:\n"
  "read_subfile(const Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns a string that contains the entire contents of the indicated\n"
  " * subfile.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills a string with the entire contents of the indicated subfile.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills a pvector with the entire contents of the indicated subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_read_subfile_1353_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * istream *Multifile::open_read_subfile(int index)
 */
static PyObject *Dtool_Multifile_open_read_subfile_1354(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_read_subfile")) {
    return NULL;
  }
  // 1-istream *Multifile::open_read_subfile(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    istream *return_value = (*local_this).open_read_subfile((int)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_subfile(const Multifile self, int index)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_read_subfile_1354_comment =
  "C++ Interface:\n"
  "open_read_subfile(const Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns an istream that may be used to read the indicated subfile.  You may\n"
  " * seek() within this istream to your heart's content; even though it will be\n"
  " * a reference to the already-opened pfstream of the Multifile itself, byte 0\n"
  " * appears to be the beginning of the subfile and EOF appears to be the end of\n"
  " * the subfile.\n"
  " *\n"
  " * The returned istream will have been allocated via new; you should pass the\n"
  " * pointer to close_read_subfile() when you are finished with it to delete it\n"
  " * and release its resources.\n"
  " *\n"
  " * Any future calls to repack() or close() (or the Multifile destructor) will\n"
  " * invalidate all currently open subfile pointers.\n"
  " *\n"
  " * The return value will be NULL if the stream cannot be opened for some\n"
  " * reason.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant of open_read_subfile() is used internally only, and accepts a\n"
  " * pointer to the internal Subfile object, which is assumed to be valid and\n"
  " * written to the multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_open_read_subfile_1354_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void Multifile::close_read_subfile(istream *stream)
 */
static PyObject *Dtool_Multifile_close_read_subfile_1355(PyObject *, PyObject *arg) {
  // 1-static void Multifile::close_read_subfile(istream *stream)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 0, "Multifile.close_read_subfile", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    Multifile::close_read_subfile(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_subfile(istream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_close_read_subfile_1355_comment =
  "C++ Interface:\n"
  "close_read_subfile(istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_subfile().  This\n"
  " * really just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_Multifile_close_read_subfile_1355_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::extract_subfile(int index, Filename const &filename)
 */
static PyObject *Dtool_Multifile_extract_subfile_1356(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.extract_subfile")) {
    return NULL;
  }
  // 1-bool Multifile::extract_subfile(int index, Filename const &filename)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "filename", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:extract_subfile", (char **)keyword_list, &param1, &param2)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.extract_subfile", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).extract_subfile((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_subfile(const Multifile self, int index, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_extract_subfile_1356_comment =
  "C++ Interface:\n"
  "extract_subfile(const Multifile self, int index, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Extracts the nth subfile into a file with the given name.\n"
  " */";
#else
static const char *Dtool_Multifile_extract_subfile_1356_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::extract_subfile_to(int index, ostream &out)
 */
static PyObject *Dtool_Multifile_extract_subfile_to_1357(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.extract_subfile_to")) {
    return NULL;
  }
  // 1-bool Multifile::extract_subfile_to(int index, ostream &out)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "out", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:extract_subfile_to", (char **)keyword_list, &param1, &param2)) {
    ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ostream, 2, "Multifile.extract_subfile_to", false, true);
    if (param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = (*local_this).extract_subfile_to((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_subfile_to(const Multifile self, int index, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_extract_subfile_to_1357_comment =
  "C++ Interface:\n"
  "extract_subfile_to(const Multifile self, int index, ostream out)\n"
  "\n"
  "/**\n"
  " * Extracts the nth subfile to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_Multifile_extract_subfile_to_1357_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::compare_subfile(int index, Filename const &filename)
 */
static PyObject *Dtool_Multifile_compare_subfile_1358(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.compare_subfile")) {
    return NULL;
  }
  // 1-bool Multifile::compare_subfile(int index, Filename const &filename)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "filename", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:compare_subfile", (char **)keyword_list, &param1, &param2)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.compare_subfile", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).compare_subfile((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_subfile(const Multifile self, int index, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_compare_subfile_1358_comment =
  "C++ Interface:\n"
  "compare_subfile(const Multifile self, int index, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Performs a byte-for-byte comparison of the indicated file on disk with the\n"
  " * nth subfile.  Returns true if the files are equivalent, or false if they\n"
  " * are different (or the file is missing).\n"
  " *\n"
  " * If Filename::set_binary() or set_text() has already been called, it\n"
  " * specifies the nature of the source file.  If this is different from the\n"
  " * text flag of the subfile, the comparison will always return false.  If this\n"
  " * has not been specified, it will be set from the text flag of the subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_compare_subfile_1358_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::output(ostream &out) const
 */
static PyObject *Dtool_Multifile_output_1359(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-void Multifile::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Multifile.output", false, true);
  if (arg_this != NULL) {
    (*(const Multifile*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Multifile self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_output_1359_comment =
  "C++ Interface:\n"
  "output(Multifile self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Multifile_output_1359_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::ls(ostream &out = ::cout) const
 */
static PyObject *Dtool_Multifile_ls_1360(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void Multifile::ls(ostream &out) const
      (*(const Multifile*)local_this).ls();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-void Multifile::ls(ostream &out) const
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Multifile.ls", false, true);
      if (arg_this != NULL) {
        (*(const Multifile*)local_this).ls(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "ls() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(Multifile self)\n"
      "ls(Multifile self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_ls_1360_comment =
  "C++ Interface:\n"
  "ls(Multifile self)\n"
  "ls(Multifile self, ostream out)\n"
  "\n"
  "/**\n"
  " * Shows a list of all subfiles within the Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_ls_1360_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string Multifile::get_magic_number(void)
 */
static PyObject *Dtool_Multifile_get_magic_number_1361(PyObject *, PyObject *) {
  // 1-static inline std::string Multifile::get_magic_number(void)
  std::string return_value = Multifile::get_magic_number();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_magic_number_1361_comment =
  "C++ Interface:\n"
  "get_magic_number()\n"
  "\n"
  "/**\n"
  " * Returns a string with the first n bytes written to a Multifile, to identify\n"
  " * it as a Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_get_magic_number_1361_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void Multifile::set_header_prefix(std::string const &header_prefix)
 */
static PyObject *Dtool_Multifile_set_header_prefix_1362(PyObject *self, PyObject *arg) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_header_prefix")) {
    return NULL;
  }
  // 1-void Multifile::set_header_prefix(std::string const &header_prefix)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_header_prefix(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_header_prefix(const Multifile self, str header_prefix)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_header_prefix_1362_comment =
  "C++ Interface:\n"
  "set_header_prefix(const Multifile self, str header_prefix)\n"
  "\n"
  "/**\n"
  " * Sets the string which is written to the Multifile before the Multifile\n"
  " * header.  This string must begin with a hash mark and end with a newline\n"
  " * character; and if it includes embedded newline characters, each one must be\n"
  " * followed by a hash mark.  If these conditions are not initially true, the\n"
  " * string will be modified as necessary to make it so.\n"
  " *\n"
  " * This is primarily useful as a simple hack to allow p3d applications to be\n"
  " * run directly from the command line on Unix-like systems.\n"
  " *\n"
  " * The return value is true if successful, or false on failure (for instance,\n"
  " * because the header prefix violates the above rules).\n"
  " */";
#else
static const char *Dtool_Multifile_set_header_prefix_1362_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Multifile::get_header_prefix(void) const
 */
static PyObject *Dtool_Multifile_get_header_prefix_1363(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Multifile::get_header_prefix(void) const
  std::string const &return_value = (*(const Multifile*)local_this).get_header_prefix();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_header_prefix_1363_comment =
  "C++ Interface:\n"
  "get_header_prefix(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the string that preceded the Multifile header on the file, if any.\n"
  " * See set_header_prefix().\n"
  " */";
#else
static const char *Dtool_Multifile_get_header_prefix_1363_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Multifile::Multifile(void)
 */
static int Dtool_Init_Multifile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Multifile() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-Multifile::Multifile(void)
  Multifile *return_value = new Multifile();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Multifile, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Multifile()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Multifile_get_subfile_names(PyObject *self, PyObject *) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_subfiles();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Multifile_get_subfile_name_1343(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Multifile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Multifile) {
    printf("Multifile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Multifile *local_this = (Multifile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Multifile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Multifile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Multifile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Multifile*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Namable
 */
/**
 * Python function wrapper for:
 * inline Namable &Namable::operator =(Namable const &other)
 */
static PyObject *Dtool_Namable_operator_1366(PyObject *self, PyObject *arg) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.assign")) {
    return NULL;
  }
  // 1-inline Namable &Namable::operator =(Namable const &other)
  Namable const *arg_this = (Namable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Namable, 1, "Namable.assign", true, true);
  if (arg_this != NULL) {
    (*local_this).operator =(*arg_this);
    Namable *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Namable self, const Namable other)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Namable_operator_1366_comment =
  "C++ Interface:\n"
  "assign(const Namable self, const Namable other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Namable_operator_1366_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Namable::set_name(std::string const &name)
 */
static PyObject *Dtool_Namable_set_name_1367(PyObject *self, PyObject *arg) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.set_name")) {
    return NULL;
  }
  // 1-inline void Namable::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const Namable self, str name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Namable_set_name_1367_comment =
  "C++ Interface:\n"
  "set_name(const Namable self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Namable_set_name_1367_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Namable::clear_name(void)
 */
static PyObject *Dtool_Namable_clear_name_1368(PyObject *self, PyObject *) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.clear_name")) {
    return NULL;
  }
  // 1-inline void Namable::clear_name(void)
  (*local_this).clear_name();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Namable_clear_name_1368_comment =
  "C++ Interface:\n"
  "clear_name(const Namable self)\n"
  "\n"
  "/**\n"
  " * Resets the Namable's name to empty.\n"
  " */";
#else
static const char *Dtool_Namable_clear_name_1368_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Namable::has_name(void) const
 */
static PyObject *Dtool_Namable_has_name_1369(PyObject *self, PyObject *) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Namable::has_name(void) const
  bool return_value = (*(const Namable*)local_this).has_name();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Namable_has_name_1369_comment =
  "C++ Interface:\n"
  "has_name(Namable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Namable has a nonempty name set, false if the name is\n"
  " * empty.\n"
  " */";
#else
static const char *Dtool_Namable_has_name_1369_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Namable::get_name(void) const
 */
static PyObject *Dtool_Namable_get_name_1370(PyObject *self, PyObject *) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::string const &Namable::get_name(void) const
  std::string const &return_value = (*(const Namable*)local_this).get_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Namable_get_name_1370_comment =
  "C++ Interface:\n"
  "get_name(Namable self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Namable_get_name_1370_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Namable::output(ostream &out) const
 */
static PyObject *Dtool_Namable_output_1372(PyObject *self, PyObject *arg) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void Namable::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "Namable.output", false, true);
  if (arg_this != NULL) {
    (*(const Namable*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Namable self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Namable_output_1372_comment =
  "C++ Interface:\n"
  "output(Namable self, ostream out)\n"
  "\n"
  "// In the absence of any definition to the contrary, outputting a Namable\n"
  "// will write out its name.\n"
  "\n"
  "/**\n"
  " * Outputs the Namable.  This function simply writes the name to the output\n"
  " * stream; most Namable derivatives will probably redefine this.\n"
  " */";
#else
static const char *Dtool_Namable_output_1372_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Namable::get_class_type(void)
 */
static PyObject *Dtool_Namable_get_class_type_1373(PyObject *, PyObject *) {
  // 1-static TypeHandle Namable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(Namable::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Namable_get_class_type_1373_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Namable_get_class_type_1373_comment = NULL;
#endif

static PyObject *Dtool_Namable_name_Getter(PyObject *self, void *) {
  const Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &Namable::get_name(void) const
  std::string const &return_value = (*(const Namable*)local_this).get_name();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Namable_name_Setter(PyObject *self, PyObject *arg, void *) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.name")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void Namable::set_name(std::string const &name)
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    (*local_this).set_name(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const Namable self, str name)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline Namable::Namable(Namable const &copy)
 * inline explicit Namable::Namable(std::string const &initial_name = "")
 */
static int Dtool_Init_Namable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit Namable::Namable(std::string const &initial_name)
      Namable *return_value = new Namable();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Namable, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Namable::Namable(Namable const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:Namable", (char **)keyword_list, &param0)) {
          Namable const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Namable, (void **)&param0_this);
          if (param0_this != NULL) {
            Namable *return_value = new Namable(*param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Namable, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit Namable::Namable(std::string const &initial_name)
        char *param0_str = NULL;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"initial_name", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Namable", (char **)keyword_list, &param0_str, &param0_len)) {
          Namable *return_value = new Namable(std::string(param0_str, param0_len));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Namable, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Namable::Namable(Namable const &copy)
      // No coercion possible: inline explicit Namable::Namable(std::string const &initial_name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Namable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Namable()\n"
      "Namable(const Namable copy)\n"
      "Namable(str initial_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Namable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Namable) {
    printf("Namable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Namable *local_this = (Namable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Namable) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Namable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Namable) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class SubfileInfo
 */
/**
 * Python function wrapper for:
 * inline void SubfileInfo::operator =(SubfileInfo const &copy)
 */
static PyObject *Dtool_SubfileInfo_operator_1377(PyObject *self, PyObject *arg) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SubfileInfo, (void **)&local_this, "SubfileInfo.assign")) {
    return NULL;
  }
  // 1-inline void SubfileInfo::operator =(SubfileInfo const &copy)
  SubfileInfo const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_SubfileInfo(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SubfileInfo.assign", "SubfileInfo");
  }
  (*local_this).operator =(*arg_this);
  SubfileInfo *return_value = local_this;
  if (arg_manage) {
    delete arg_this;
  }
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubfileInfo, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const SubfileInfo self, const SubfileInfo copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_operator_1377_comment =
  "C++ Interface:\n"
  "assign(const SubfileInfo self, const SubfileInfo copy)\n";
#else
static const char *Dtool_SubfileInfo_operator_1377_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool SubfileInfo::is_empty(void) const
 */
static PyObject *Dtool_SubfileInfo_is_empty_1378(PyObject *self, PyObject *) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool SubfileInfo::is_empty(void) const
  bool return_value = (*(const SubfileInfo*)local_this).is_empty();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_is_empty_1378_comment =
  "C++ Interface:\n"
  "is_empty(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns true if this SubfileInfo doesn't define any file, false if it has\n"
  " * real data.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_is_empty_1378_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline FileReference const *SubfileInfo::get_file(void) const
 */
static PyObject *Dtool_SubfileInfo_get_file_1379(PyObject *self, PyObject *) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline FileReference const *SubfileInfo::get_file(void) const
  FileReference const *return_value = (*(const SubfileInfo*)local_this).get_file();
  if (return_value != (FileReference const *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (FileReference const *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_file_1379_comment =
  "C++ Interface:\n"
  "get_file(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns the FileReference that represents this file.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_file_1379_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &SubfileInfo::get_filename(void) const
 */
static PyObject *Dtool_SubfileInfo_get_filename_1380(PyObject *self, PyObject *) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &SubfileInfo::get_filename(void) const
  Filename const *return_value = &((*(const SubfileInfo*)local_this).get_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_filename_1380_comment =
  "C++ Interface:\n"
  "get_filename(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * A shortcut to the filename.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_filename_1380_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline streamoff SubfileInfo::get_start(void) const
 */
static PyObject *Dtool_SubfileInfo_get_start_1381(PyObject *self, PyObject *) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline streamoff SubfileInfo::get_start(void) const
  streamoff return_value = (*(const SubfileInfo*)local_this).get_start();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_start_1381_comment =
  "C++ Interface:\n"
  "get_start(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns the offset within the file at which this file data begins.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_start_1381_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline streamsize SubfileInfo::get_size(void) const
 */
static PyObject *Dtool_SubfileInfo_get_size_1382(PyObject *self, PyObject *) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline streamsize SubfileInfo::get_size(void) const
  streamsize return_value = (*(const SubfileInfo*)local_this).get_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_size_1382_comment =
  "C++ Interface:\n"
  "get_size(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns the number of consecutive bytes, beginning at get_start(), that\n"
  " * correspond to this file data.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_size_1382_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void SubfileInfo::output(ostream &out) const
 */
static PyObject *Dtool_SubfileInfo_output_1383(PyObject *self, PyObject *arg) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }
  // 1-void SubfileInfo::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "SubfileInfo.output", false, true);
  if (arg_this != NULL) {
    (*(const SubfileInfo*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SubfileInfo self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_output_1383_comment =
  "C++ Interface:\n"
  "output(SubfileInfo self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SubfileInfo_output_1383_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline SubfileInfo::SubfileInfo(void)
 * inline SubfileInfo::SubfileInfo(FileReference const *file, streamoff start, streamsize size)
 * inline SubfileInfo::SubfileInfo(Filename const &filename, streamoff start, streamsize size)
 * inline SubfileInfo::SubfileInfo(SubfileInfo const &copy)
 */
static int Dtool_Init_SubfileInfo(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SubfileInfo::SubfileInfo(void)
      SubfileInfo *return_value = new SubfileInfo();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "copy");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'copy' (pos 1) not found");
        return -1;
      }
      // 1-inline SubfileInfo::SubfileInfo(SubfileInfo const &copy)
      SubfileInfo const *arg_this;
      bool arg_manage = false;
      if (!Dtool_ConstCoerce_SubfileInfo(arg, arg_this, arg_manage)) {
        Dtool_Raise_ArgTypeError(arg, 0, "SubfileInfo.SubfileInfo", "SubfileInfo");
        return -1;
      }
      SubfileInfo *return_value = new SubfileInfo(*arg_this);
      if (arg_manage) {
        delete arg_this;
      }
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
    }
    break;
  case 3:
    {
      {
        // -2 inline SubfileInfo::SubfileInfo(FileReference const *file, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"file", "start", "size", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oln:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          FileReference const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_FileReference, (void **)&param0_this);
          if (param0_this != NULL) {
            SubfileInfo *return_value = new SubfileInfo(param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline SubfileInfo::SubfileInfo(Filename const &filename, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"filename", "start", "size", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oln:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            SubfileInfo *return_value = new SubfileInfo(*param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline SubfileInfo::SubfileInfo(FileReference const *file, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"file", "start", "size", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oln:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          CPT(FileReference) param0_this;
          if (Dtool_ConstCoerce_FileReference(param0, param0_this)) {
            SubfileInfo *return_value = new SubfileInfo(MOVE(param0_this), (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline SubfileInfo::SubfileInfo(Filename const &filename, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"filename", "start", "size", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oln:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != NULL)) {
            SubfileInfo *return_value = new SubfileInfo(*param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SubfileInfo() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SubfileInfo()\n"
      "SubfileInfo(const SubfileInfo copy)\n"
      "SubfileInfo(const FileReference file, int start, int size)\n"
      "SubfileInfo(const Filename filename, int start, int size)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_SubfileInfo(PyObject *args, SubfileInfo const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SubfileInfo, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      {
        // -2 inline SubfileInfo::SubfileInfo(FileReference const *file, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        if (PyArg_ParseTuple(args, "Oln:SubfileInfo", &param0, &param1, &param2)) {
          FileReference const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_FileReference, (void **)&param0_this);
          if (param0_this != NULL) {
            SubfileInfo *return_value = new SubfileInfo(param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline SubfileInfo::SubfileInfo(Filename const &filename, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        if (PyArg_ParseTuple(args, "Oln:SubfileInfo", &param0, &param1, &param2)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            SubfileInfo *return_value = new SubfileInfo(*param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_SubfileInfo(PyObject *args, SubfileInfo *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_SubfileInfo, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 3) {
      {
        // -2 inline SubfileInfo::SubfileInfo(FileReference const *file, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        if (PyArg_ParseTuple(args, "Oln:SubfileInfo", &param0, &param1, &param2)) {
          FileReference const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_FileReference, (void **)&param0_this);
          if (param0_this != NULL) {
            SubfileInfo *return_value = new SubfileInfo(param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline SubfileInfo::SubfileInfo(Filename const &filename, streamoff start, streamsize size)
        PyObject *param0;
        long param1;
        Py_ssize_t param2;
        if (PyArg_ParseTuple(args, "Oln:SubfileInfo", &param0, &param1, &param2)) {
          Filename const *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
          if (param0_this != NULL) {
            SubfileInfo *return_value = new SubfileInfo(*param0_this, (streamoff)param1, (streamsize)param2);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return false;
            }
            if (_PyErr_OCCURRED()) {
              delete return_value;
              return false;
            } else {
              coerced = return_value;
              manage = true;
              return true;
            }
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_SubfileInfo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_SubfileInfo) {
    printf("SubfileInfo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  SubfileInfo *local_this = (SubfileInfo *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_SubfileInfo) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_SubfileInfo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_SubfileInfo) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFile
 */
/**
 * Python function wrapper for:
 * virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0
 */
static PyObject *Dtool_VirtualFile_get_file_system_1386(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0
  VirtualFileSystem *return_value = (*(const VirtualFile*)local_this).get_file_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_file_system_1386_comment =
  "C++ Interface:\n"
  "get_file_system(VirtualFile self)\n";
#else
static const char *Dtool_VirtualFile_get_file_system_1386_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual Filename VirtualFile::get_filename(void) const = 0
 */
static PyObject *Dtool_VirtualFile_get_filename_1387(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual Filename VirtualFile::get_filename(void) const = 0
  Filename *return_value = new Filename((*(const VirtualFile*)local_this).get_filename());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_filename_1387_comment =
  "C++ Interface:\n"
  "get_filename(VirtualFile self)\n";
#else
static const char *Dtool_VirtualFile_get_filename_1387_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &VirtualFile::get_original_filename(void) const
 */
static PyObject *Dtool_VirtualFile_get_original_filename_1388(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &VirtualFile::get_original_filename(void) const
  Filename const *return_value = &((*(const VirtualFile*)local_this).get_original_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_original_filename_1388_comment =
  "C++ Interface:\n"
  "get_original_filename(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns the original filename as it was used to locate this VirtualFile.\n"
  " * This is usually, but not always, the same string returned by\n"
  " * get_filename().\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_original_filename_1388_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::has_file(void) const
 */
static PyObject *Dtool_VirtualFile_has_file_1389(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::has_file(void) const
  bool return_value = (*(const VirtualFile*)local_this).has_file();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_has_file_1389_comment =
  "C++ Interface:\n"
  "has_file(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file exists, false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_has_file_1389_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::is_directory(void) const
 */
static PyObject *Dtool_VirtualFile_is_directory_1390(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::is_directory(void) const
  bool return_value = (*(const VirtualFile*)local_this).is_directory();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_is_directory_1390_comment =
  "C++ Interface:\n"
  "is_directory(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file represents a directory (and scan_directory() may\n"
  " * be called), false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_is_directory_1390_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::is_regular_file(void) const
 */
static PyObject *Dtool_VirtualFile_is_regular_file_1391(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::is_regular_file(void) const
  bool return_value = (*(const VirtualFile*)local_this).is_regular_file();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_is_regular_file_1391_comment =
  "C++ Interface:\n"
  "is_regular_file(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file represents a regular file (and read_file() may be\n"
  " * called), false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_is_regular_file_1391_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::is_writable(void) const
 */
static PyObject *Dtool_VirtualFile_is_writable_1392(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::is_writable(void) const
  bool return_value = (*(const VirtualFile*)local_this).is_writable();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_is_writable_1392_comment =
  "C++ Interface:\n"
  "is_writable(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file may be written to, which implies write_file() may\n"
  " * be called (unless it is a directory instead of a regular file).\n"
  " */";
#else
static const char *Dtool_VirtualFile_is_writable_1392_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::delete_file(void)
 */
static PyObject *Dtool_VirtualFile_delete_file_1393(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.delete_file")) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::delete_file(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).delete_file();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_delete_file_1393_comment =
  "C++ Interface:\n"
  "delete_file(const VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Attempts to delete this file or directory.  This can remove a single file\n"
  " * or an empty directory.  It will not remove a nonempty directory.  Returns\n"
  " * true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_delete_file_1393_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::rename_file(VirtualFile *new_file)
 */
static PyObject *Dtool_VirtualFile_rename_file_1394(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.rename_file")) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::rename_file(VirtualFile *new_file)
  VirtualFile *arg_this = (VirtualFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFile, 1, "VirtualFile.rename_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).rename_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rename_file(const VirtualFile self, VirtualFile new_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_rename_file_1394_comment =
  "C++ Interface:\n"
  "rename_file(const VirtualFile self, VirtualFile new_file)\n"
  "\n"
  "/**\n"
  " * Attempts to move or rename this file or directory.  If the original file is\n"
  " * an ordinary file, it will quietly replace any already-existing file in the\n"
  " * new filename (but not a directory).  If the original file is a directory,\n"
  " * the new filename must not already exist.\n"
  " *\n"
  " * If the file is a directory, the new filename must be within the same mount\n"
  " * point.  If the file is an ordinary file, the new filename may be anywhere;\n"
  " * but if it is not within the same mount point then the rename operation is\n"
  " * automatically performed as a two-step copy-and-delete operation.\n"
  " */";
#else
static const char *Dtool_VirtualFile_rename_file_1394_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::copy_file(VirtualFile *new_file)
 */
static PyObject *Dtool_VirtualFile_copy_file_1395(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.copy_file")) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::copy_file(VirtualFile *new_file)
  VirtualFile *arg_this = (VirtualFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFile, 1, "VirtualFile.copy_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).copy_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_file(const VirtualFile self, VirtualFile new_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_copy_file_1395_comment =
  "C++ Interface:\n"
  "copy_file(const VirtualFile self, VirtualFile new_file)\n"
  "\n"
  "/**\n"
  " * Attempts to copy the contents of this file to the indicated file.  Returns\n"
  " * true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_copy_file_1395_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFileList > VirtualFile::scan_directory(void) const
 */
static PyObject *Dtool_VirtualFile_scan_directory_1396(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< VirtualFileList > VirtualFile::scan_directory(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< VirtualFileList > return_value = (*(const VirtualFile*)local_this).scan_directory();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  VirtualFileList *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_VirtualFileList, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_scan_directory_1396_comment =
  "C++ Interface:\n"
  "scan_directory(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory (that is, is_directory() returns true),\n"
  " * this returns the list of files within the directory at the current time.\n"
  " * Returns NULL if the file is not a directory or if the directory cannot be\n"
  " * read.\n"
  " */";
#else
static const char *Dtool_VirtualFile_scan_directory_1396_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualFile::output(ostream &out) const
 */
static PyObject *Dtool_VirtualFile_output_1397(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-void VirtualFile::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFile.output", false, true);
  if (arg_this != NULL) {
    (*(const VirtualFile*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VirtualFile self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_output_1397_comment =
  "C++ Interface:\n"
  "output(VirtualFile self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VirtualFile_output_1397_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualFile::ls(ostream &out = ::cout) const
 */
static PyObject *Dtool_VirtualFile_ls_1398(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void VirtualFile::ls(ostream &out) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*(const VirtualFile*)local_this).ls();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-void VirtualFile::ls(ostream &out) const
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFile.ls", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*(const VirtualFile*)local_this).ls(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "ls() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(VirtualFile self)\n"
      "ls(VirtualFile self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_ls_1398_comment =
  "C++ Interface:\n"
  "ls(VirtualFile self)\n"
  "ls(VirtualFile self, ostream out)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory, lists its contents.\n"
  " */";
#else
static const char *Dtool_VirtualFile_ls_1398_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualFile::ls_all(ostream &out = ::cout) const
 */
static PyObject *Dtool_VirtualFile_ls_all_1399(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void VirtualFile::ls_all(ostream &out) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      (*(const VirtualFile*)local_this).ls_all();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-void VirtualFile::ls_all(ostream &out) const
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFile.ls_all", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        (*(const VirtualFile*)local_this).ls_all(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "ls_all() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls_all(VirtualFile self)\n"
      "ls_all(VirtualFile self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_ls_all_1399_comment =
  "C++ Interface:\n"
  "ls_all(VirtualFile self)\n"
  "ls_all(VirtualFile self, ostream out)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory, recursively lists its contents and\n"
  " * those of all subdirectories.\n"
  " */";
#else
static const char *Dtool_VirtualFile_ls_all_1399_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFile::read_file(bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFile_read_file_1400(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *VirtualFile::read_file(bool auto_unwrap) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PyObject *return_value = invoke_extension((const VirtualFile*)local_this).read_file((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_file(VirtualFile self, bool auto_unwrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_read_file_1400_comment =
  "C++ Interface:\n"
  "read_file(VirtualFile self, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Returns the entire contents of the file as a string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills up the indicated string with the contents of the file, if it is a\n"
  " * regular file.  Returns true on success, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills up the indicated pvector with the contents of the file, if it is a\n"
  " * regular file.  Returns true on success, false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_read_file_1400_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual istream *VirtualFile::open_read_file(bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFile_open_read_file_1401(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual istream *VirtualFile::open_read_file(bool auto_unwrap) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  istream *return_value = (*(const VirtualFile*)local_this).open_read_file((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_file(VirtualFile self, bool auto_unwrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_read_file_1401_comment =
  "C++ Interface:\n"
  "open_read_file(VirtualFile self, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Opens the file for reading.  Returns a newly allocated istream on success\n"
  " * (which you should eventually delete when you are done reading). Returns\n"
  " * NULL on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_read_file_1401_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFile::close_read_file(istream *stream) const
 */
static PyObject *Dtool_VirtualFile_close_read_file_1402(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void VirtualFile::close_read_file(istream *stream) const
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "VirtualFile.close_read_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*(const VirtualFile*)local_this).close_read_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_file(VirtualFile self, istream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_close_read_file_1402_comment =
  "C++ Interface:\n"
  "close_read_file(VirtualFile self, istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_file().  This really\n"
  " * just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFile_close_read_file_1402_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::was_read_successful(void) const
 */
static PyObject *Dtool_VirtualFile_was_read_successful_1403(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::was_read_successful(void) const
  bool return_value = (*(const VirtualFile*)local_this).was_read_successful();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_was_read_successful_1403_comment =
  "C++ Interface:\n"
  "was_read_successful(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Call this method after a reading the istream returned by open_read_file()\n"
  " * to completion.  If it returns true, the file was read completely and\n"
  " * without error; if it returns false, there may have been some errors or a\n"
  " * truncated file read.  This is particularly likely if the stream is a\n"
  " * VirtualFileHTTP.\n"
  " */";
#else
static const char *Dtool_VirtualFile_was_read_successful_1403_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFile::write_file(PyObject *data, bool auto_wrap)
 */
static PyObject *Dtool_VirtualFile_write_file_1404(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.write_file")) {
    return NULL;
  }
  // 1-PyObject *VirtualFile::write_file(PyObject *data, bool auto_wrap)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "auto_wrap", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write_file", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PyObject *return_value = invoke_extension(local_this).write_file(param1, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_file(const VirtualFile self, object data, bool auto_wrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_write_file_1404_comment =
  "C++ Interface:\n"
  "write_file(const VirtualFile self, object data, bool auto_wrap)\n"
  "\n"
  "/**\n"
  " * Writes the entire contents of the file as a string, if it is writable.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the indicated data to the file, if it is writable.  Returns true on\n"
  " * success, false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_write_file_1404_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual ostream *VirtualFile::open_write_file(bool auto_wrap, bool truncate)
 */
static PyObject *Dtool_VirtualFile_open_write_file_1405(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_write_file")) {
    return NULL;
  }
  // 1-virtual ostream *VirtualFile::open_write_file(bool auto_wrap, bool truncate)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"auto_wrap", "truncate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open_write_file", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ostream *return_value = (*local_this).open_write_file((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write_file(const VirtualFile self, bool auto_wrap, bool truncate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_write_file_1405_comment =
  "C++ Interface:\n"
  "open_write_file(const VirtualFile self, bool auto_wrap, bool truncate)\n"
  "\n"
  "/**\n"
  " * Opens the file for writing.  Returns a newly allocated ostream on success\n"
  " * (which you should eventually delete when you are done writing). Returns\n"
  " * NULL on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_write_file_1405_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual ostream *VirtualFile::open_append_file(void)
 */
static PyObject *Dtool_VirtualFile_open_append_file_1406(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_append_file")) {
    return NULL;
  }
  // 1-virtual ostream *VirtualFile::open_append_file(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ostream *return_value = (*local_this).open_append_file();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_append_file_1406_comment =
  "C++ Interface:\n"
  "open_append_file(const VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Works like open_write_file(), but the file is opened in append mode.  Like\n"
  " * open_write_file, the returned pointer should eventually be passed to\n"
  " * close_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_append_file_1406_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFile::close_write_file(ostream *stream)
 */
static PyObject *Dtool_VirtualFile_close_write_file_1407(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.close_write_file")) {
    return NULL;
  }
  // 1-virtual void VirtualFile::close_write_file(ostream *stream)
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFile.close_write_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).close_write_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_write_file(const VirtualFile self, ostream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_close_write_file_1407_comment =
  "C++ Interface:\n"
  "close_write_file(const VirtualFile self, ostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_write_file().  This really\n"
  " * just deletes the ostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFile_close_write_file_1407_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual iostream *VirtualFile::open_read_write_file(bool truncate)
 */
static PyObject *Dtool_VirtualFile_open_read_write_file_1408(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_read_write_file")) {
    return NULL;
  }
  // 1-virtual iostream *VirtualFile::open_read_write_file(bool truncate)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  iostream *return_value = (*local_this).open_read_write_file((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write_file(const VirtualFile self, bool truncate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_read_write_file_1408_comment =
  "C++ Interface:\n"
  "open_read_write_file(const VirtualFile self, bool truncate)\n"
  "\n"
  "/**\n"
  " * Opens the file for writing.  Returns a newly allocated iostream on success\n"
  " * (which you should eventually delete when you are done writing). Returns\n"
  " * NULL on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_read_write_file_1408_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual iostream *VirtualFile::open_read_append_file(void)
 */
static PyObject *Dtool_VirtualFile_open_read_append_file_1409(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_read_append_file")) {
    return NULL;
  }
  // 1-virtual iostream *VirtualFile::open_read_append_file(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  iostream *return_value = (*local_this).open_read_append_file();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_read_append_file_1409_comment =
  "C++ Interface:\n"
  "open_read_append_file(const VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Works like open_read_write_file(), but the file is opened in append mode.\n"
  " * Like open_read_write_file, the returned pointer should eventually be passed\n"
  " * to close_read_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_read_append_file_1409_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFile::close_read_write_file(iostream *stream)
 */
static PyObject *Dtool_VirtualFile_close_read_write_file_1410(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.close_read_write_file")) {
    return NULL;
  }
  // 1-virtual void VirtualFile::close_read_write_file(iostream *stream)
  iostream *arg_this = (iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_iostream, 1, "VirtualFile.close_read_write_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).close_read_write_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_write_file(const VirtualFile self, iostream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_close_read_write_file_1410_comment =
  "C++ Interface:\n"
  "close_read_write_file(const VirtualFile self, iostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_write_file().  This\n"
  " * really just deletes the iostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFile_close_read_write_file_1410_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual streamsize VirtualFile::get_file_size(void) const
 * virtual streamsize VirtualFile::get_file_size(istream *stream) const
 */
static PyObject *Dtool_VirtualFile_get_file_size_1411(PyObject *self, PyObject *args) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual streamsize VirtualFile::get_file_size(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      streamsize return_value = (*(const VirtualFile*)local_this).get_file_size();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-virtual streamsize VirtualFile::get_file_size(istream *stream) const
      istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 1, "VirtualFile.get_file_size", false, true);
      if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        streamsize return_value = (*(const VirtualFile*)local_this).get_file_size(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_file_size() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file_size(VirtualFile self)\n"
      "get_file_size(VirtualFile self, istream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_file_size_1411_comment =
  "C++ Interface:\n"
  "get_file_size(VirtualFile self)\n"
  "get_file_size(VirtualFile self, istream stream)\n"
  "\n"
  "/**\n"
  " * Returns the current size on disk (or wherever it is) of the already-open\n"
  " * file.  Pass in the stream that was returned by open_read_file(); some\n"
  " * implementations may require this stream to determine the size.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current size on disk (or wherever it is) of the file before it\n"
  " * has been opened.\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_file_size_1411_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual time_t VirtualFile::get_timestamp(void) const
 */
static PyObject *Dtool_VirtualFile_get_timestamp_1412(PyObject *self, PyObject *) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual time_t VirtualFile::get_timestamp(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  time_t return_value = (*(const VirtualFile*)local_this).get_timestamp();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_timestamp_1412_comment =
  "C++ Interface:\n"
  "get_timestamp(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns a time_t value that represents the time the file was last modified,\n"
  " * to within whatever precision the operating system records this information\n"
  " * (on a Windows95 system, for instance, this may only be accurate to within 2\n"
  " * seconds).\n"
  " *\n"
  " * If the timestamp cannot be determined, either because it is not supported\n"
  " * by the operating system or because there is some error (such as file not\n"
  " * found), returns 0.\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_timestamp_1412_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::get_system_info(SubfileInfo &info)
 */
static PyObject *Dtool_VirtualFile_get_system_info_1413(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.get_system_info")) {
    return NULL;
  }
  // 1-virtual bool VirtualFile::get_system_info(SubfileInfo &info)
  SubfileInfo *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_SubfileInfo(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFile.get_system_info", "SubfileInfo");
  }
  bool return_value = (*local_this).get_system_info(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system_info(const VirtualFile self, SubfileInfo info)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_system_info_1413_comment =
  "C++ Interface:\n"
  "get_system_info(const VirtualFile self, SubfileInfo info)\n"
  "\n"
  "/**\n"
  " * Populates the SubfileInfo structure with the data representing where the\n"
  " * file actually resides on disk, if this is knowable.  Returns true if the\n"
  " * file might reside on disk, and the info is populated, or false if it does\n"
  " * not (or it is not known where the file resides), in which case the info is\n"
  " * meaningless.\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_system_info_1413_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFile::get_class_type(void)
 */
static PyObject *Dtool_VirtualFile_get_class_type_1414(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFile::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFile::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_class_type_1414_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFile_get_class_type_1414_comment = NULL;
#endif

static int Dtool_Init_VirtualFile(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFile) {
    printf("VirtualFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFile *local_this = (VirtualFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFile*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileComposite
 */
/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileComposite::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileComposite_get_class_type_1417(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileComposite::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileComposite::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileComposite_get_class_type_1417_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileComposite_get_class_type_1417_comment = NULL;
#endif

static int Dtool_Init_VirtualFileComposite(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileComposite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileComposite) {
    printf("VirtualFileComposite ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileComposite *local_this = (VirtualFileComposite *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileComposite) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFile) {
    return (VirtualFile *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileComposite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileComposite) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    VirtualFile* other_this = (VirtualFile*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileMount
 */
/**
 * Python function wrapper for:
 * inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const
 */
static PyObject *Dtool_VirtualFileMount_get_file_system_1420(PyObject *self, PyObject *) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const
  VirtualFileSystem *return_value = (*(const VirtualFileMount*)local_this).get_file_system();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_file_system_1420_comment =
  "C++ Interface:\n"
  "get_file_system(VirtualFileMount self)\n"
  "\n"
  "/**\n"
  " * Returns the file system this mount object is attached to.\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_get_file_system_1420_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &VirtualFileMount::get_mount_point(void) const
 */
static PyObject *Dtool_VirtualFileMount_get_mount_point_1421(PyObject *self, PyObject *) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &VirtualFileMount::get_mount_point(void) const
  Filename const *return_value = &((*(const VirtualFileMount*)local_this).get_mount_point());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_mount_point_1421_comment =
  "C++ Interface:\n"
  "get_mount_point(VirtualFileMount self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the directory within the virtual file system that this\n"
  " * mount object is attached to.  This directory name will end with a slash.\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_get_mount_point_1421_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int VirtualFileMount::get_mount_flags(void) const
 */
static PyObject *Dtool_VirtualFileMount_get_mount_flags_1422(PyObject *self, PyObject *) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int VirtualFileMount::get_mount_flags(void) const
  int return_value = (*(const VirtualFileMount*)local_this).get_mount_flags();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_mount_flags_1422_comment =
  "C++ Interface:\n"
  "get_mount_flags(VirtualFileMount self)\n"
  "\n"
  "/**\n"
  " * Returns the set of flags passed by the user to the\n"
  " * VirtualFileSystem::mount() command.\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_get_mount_flags_1422_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFileMount::output(ostream &out) const
 */
static PyObject *Dtool_VirtualFileMount_output_1423(PyObject *self, PyObject *arg) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void VirtualFileMount::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFileMount.output", false, true);
  if (arg_this != NULL) {
    (*(const VirtualFileMount*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VirtualFileMount self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_output_1423_comment =
  "C++ Interface:\n"
  "output(VirtualFileMount self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_output_1423_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFileMount::write(ostream &out) const
 */
static PyObject *Dtool_VirtualFileMount_write_1424(PyObject *self, PyObject *arg) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-virtual void VirtualFileMount::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFileMount.write", false, true);
  if (arg_this != NULL) {
    (*(const VirtualFileMount*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VirtualFileMount self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_write_1424_comment =
  "C++ Interface:\n"
  "write(VirtualFileMount self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_write_1424_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMount::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMount_get_class_type_1425(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileMount::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_class_type_1425_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMount_get_class_type_1425_comment = NULL;
#endif

static int Dtool_Init_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileMount) {
    printf("VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileMount *local_this = (VirtualFileMount *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMount*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileMountMultifile
 */
/**
 * Python function wrapper for:
 * inline Multifile *VirtualFileMountMultifile::get_multifile(void) const
 */
static PyObject *Dtool_VirtualFileMountMultifile_get_multifile_1428(PyObject *self, PyObject *) {
  VirtualFileMountMultifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMountMultifile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Multifile *VirtualFileMountMultifile::get_multifile(void) const
  Multifile *return_value = (*(const VirtualFileMountMultifile*)local_this).get_multifile();
  if (return_value != (Multifile *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (Multifile *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Multifile, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountMultifile_get_multifile_1428_comment =
  "C++ Interface:\n"
  "get_multifile(VirtualFileMountMultifile self)\n"
  "\n"
  "/**\n"
  " * Returns the Multifile pointer that this mount object is based on.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountMultifile_get_multifile_1428_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountMultifile::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountMultifile_get_class_type_1429(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountMultifile::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileMountMultifile::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountMultifile_get_class_type_1429_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountMultifile_get_class_type_1429_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
 */
static int Dtool_Init_VirtualFileMountMultifile(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountMultifile() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "multifile");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'multifile' (pos 1) not found");
    return -1;
  }
  // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
  Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", false, true);
  if (arg_this != NULL) {
    VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountMultifile, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountMultifile(Multifile multifile)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VirtualFileMountMultifile(PyObject *args, CPT(VirtualFileMountMultifile) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualFileMountMultifile, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", false, false);
    if (arg_this != NULL) {
      VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_VirtualFileMountMultifile(PyObject *args, PT(VirtualFileMountMultifile) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualFileMountMultifile, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", false, false);
    if (arg_this != NULL) {
      VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_VirtualFileMountMultifile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileMountMultifile) {
    printf("VirtualFileMountMultifile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileMountMultifile *local_this = (VirtualFileMountMultifile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileMountMultifile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileMountMultifile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountMultifile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileMountRamdisk
 */
/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountRamdisk::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountRamdisk_get_class_type_1432(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountRamdisk::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileMountRamdisk::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountRamdisk_get_class_type_1432_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountRamdisk_get_class_type_1432_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * VirtualFileMountRamdisk::VirtualFileMountRamdisk(void)
 */
static int Dtool_Init_VirtualFileMountRamdisk(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountRamdisk() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-VirtualFileMountRamdisk::VirtualFileMountRamdisk(void)
  VirtualFileMountRamdisk *return_value = new VirtualFileMountRamdisk();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountRamdisk, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountRamdisk()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileMountRamdisk(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileMountRamdisk) {
    printf("VirtualFileMountRamdisk ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileMountRamdisk *local_this = (VirtualFileMountRamdisk *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileMountRamdisk) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileMountRamdisk(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountRamdisk) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileMountSystem
 */
/**
 * Python function wrapper for:
 * inline Filename const &VirtualFileMountSystem::get_physical_filename(void) const
 */
static PyObject *Dtool_VirtualFileMountSystem_get_physical_filename_1436(PyObject *self, PyObject *) {
  VirtualFileMountSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMountSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline Filename const &VirtualFileMountSystem::get_physical_filename(void) const
  Filename const *return_value = &((*(const VirtualFileMountSystem*)local_this).get_physical_filename());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountSystem_get_physical_filename_1436_comment =
  "C++ Interface:\n"
  "get_physical_filename(VirtualFileMountSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the source file on the OS filesystem of the directory\n"
  " * or file that is mounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountSystem_get_physical_filename_1436_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountSystem::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountSystem_get_class_type_1437(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileMountSystem::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountSystem_get_class_type_1437_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountSystem_get_class_type_1437_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
 */
static int Dtool_Init_VirtualFileMountSystem(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountSystem() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "physical_filename");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'physical_filename' (pos 1) not found");
    return -1;
  }
  // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 0, "VirtualFileMountSystem.VirtualFileMountSystem", "Filename");
    return -1;
  }
  VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*arg_this);
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountSystem, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountSystem(const Filename physical_filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VirtualFileMountSystem(PyObject *args, CPT(VirtualFileMountSystem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualFileMountSystem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_VirtualFileMountSystem(PyObject *args, PT(VirtualFileMountSystem) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_VirtualFileMountSystem, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_VirtualFileMountSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileMountSystem) {
    printf("VirtualFileMountSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileMountSystem *local_this = (VirtualFileMountSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileMountSystem) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileMountSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountSystem) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileSimple
 */
/**
 * Python function wrapper for:
 * inline VirtualFileMount *VirtualFileSimple::get_mount(void) const
 */
static PyObject *Dtool_VirtualFileSimple_get_mount_1440(PyObject *self, PyObject *) {
  VirtualFileSimple *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSimple, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline VirtualFileMount *VirtualFileSimple::get_mount(void) const
  VirtualFileMount *return_value = (*(const VirtualFileSimple*)local_this).get_mount();
  if (return_value != (VirtualFileMount *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (VirtualFileMount *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFileMount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSimple_get_mount_1440_comment =
  "C++ Interface:\n"
  "get_mount(VirtualFileSimple self)\n"
  "\n"
  "/**\n"
  " * Returns the VirtualFileMount this file is associated with.\n"
  " */";
#else
static const char *Dtool_VirtualFileSimple_get_mount_1440_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSimple::is_implicit_pz_file(void) const
 */
static PyObject *Dtool_VirtualFileSimple_is_implicit_pz_file_1441(PyObject *self, PyObject *) {
  VirtualFileSimple *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSimple, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool VirtualFileSimple::is_implicit_pz_file(void) const
  bool return_value = (*(const VirtualFileSimple*)local_this).is_implicit_pz_file();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSimple_is_implicit_pz_file_1441_comment =
  "C++ Interface:\n"
  "is_implicit_pz_file(VirtualFileSimple self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file is a .pz file that should be implicitly\n"
  " * decompressed on load, or false if it is not a .pz file or if it should not\n"
  " * be decompressed.\n"
  " */";
#else
static const char *Dtool_VirtualFileSimple_is_implicit_pz_file_1441_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileSimple::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileSimple_get_class_type_1442(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileSimple::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(VirtualFileSimple::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSimple_get_class_type_1442_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileSimple_get_class_type_1442_comment = NULL;
#endif

static int Dtool_Init_VirtualFileSimple(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileSimple(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileSimple) {
    printf("VirtualFileSimple ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileSimple *local_this = (VirtualFileSimple *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileSimple) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFile) {
    return (VirtualFile *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileSimple(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileSimple) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    VirtualFile* other_this = (VirtualFile*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TemporaryFile
 */
/**
 * Python function wrapper for:
 * static TypeHandle TemporaryFile::get_class_type(void)
 */
static PyObject *Dtool_TemporaryFile_get_class_type_1446(PyObject *, PyObject *) {
  // 1-static TypeHandle TemporaryFile::get_class_type(void)
  TypeHandle *return_value = new TypeHandle(TemporaryFile::get_class_type());
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TemporaryFile_get_class_type_1446_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TemporaryFile_get_class_type_1446_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline TemporaryFile::TemporaryFile(Filename const &filename)
 * inline TemporaryFile::TemporaryFile(TemporaryFile const &) = default
 */
static int Dtool_Init_TemporaryFile(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TemporaryFile() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline TemporaryFile::TemporaryFile(TemporaryFile const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TemporaryFile", (char **)keyword_list, &param0)) {
      TemporaryFile const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_TemporaryFile, (void **)&param0_this);
      if (param0_this != NULL) {
        TemporaryFile *return_value = new TemporaryFile(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TemporaryFile, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline TemporaryFile::TemporaryFile(Filename const &filename)
    PyObject *param0;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TemporaryFile", (char **)keyword_list, &param0)) {
      Filename const *param0_this;
      DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_Filename, (void **)&param0_this);
      if (param0_this != NULL) {
        TemporaryFile *return_value = new TemporaryFile(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TemporaryFile, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline TemporaryFile::TemporaryFile(TemporaryFile const &) = default
    PyObject *param0;
    static const char *keyword_list[] = {"param0", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TemporaryFile", (char **)keyword_list, &param0)) {
      CPT(TemporaryFile) param0_this;
      if (Dtool_ConstCoerce_TemporaryFile(param0, param0_this)) {
        TemporaryFile *return_value = new TemporaryFile(*MOVE(param0_this));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TemporaryFile, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline TemporaryFile::TemporaryFile(Filename const &filename)
    PyObject *param0;
    static const char *keyword_list[] = {"filename", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O:TemporaryFile", (char **)keyword_list, &param0)) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != NULL)) {
        TemporaryFile *return_value = new TemporaryFile(*param0_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TemporaryFile, true, false);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TemporaryFile(const TemporaryFile param0)\n"
      "TemporaryFile(const Filename filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_TemporaryFile(PyObject *args, CPT(TemporaryFile) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TemporaryFile, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline TemporaryFile::TemporaryFile(Filename const &filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      TemporaryFile *return_value = new TemporaryFile(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_TemporaryFile(PyObject *args, PT(TemporaryFile) &coerced) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_TemporaryFile, (void**)&coerced.cheat());
  if (coerced != NULL) {
    // The argument is already of matching type, no need to coerce.
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline TemporaryFile::TemporaryFile(Filename const &filename)
    Filename const *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_Filename, (void **)&arg_this);
    if (arg_this != NULL) {
      TemporaryFile *return_value = new TemporaryFile(*arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = MOVE(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_TemporaryFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TemporaryFile) {
    printf("TemporaryFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TemporaryFile *local_this = (TemporaryFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TemporaryFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_FileReference) {
    return (FileReference *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(FileReference *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(FileReference *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(FileReference *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TemporaryFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TemporaryFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_FileReference) {
    FileReference* other_this = (FileReference*)from_this;
    return (TemporaryFile*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TemporaryFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TemporaryFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TemporaryFile*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class IDecompressStream
 */
/**
 * Python function wrapper for:
 * inline IDecompressStream &IDecompressStream::open(istream *source, bool owns_source)
 */
static PyObject *Dtool_IDecompressStream_open_1449(PyObject *self, PyObject *args, PyObject *kwds) {
  IDecompressStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecompressStream, (void **)&local_this, "IDecompressStream.open")) {
    return NULL;
  }
  // 1-inline IDecompressStream &IDecompressStream::open(istream *source, bool owns_source)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"source", "owns_source", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open", (char **)keyword_list, &param1, &param2)) {
    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_istream, 1, "IDecompressStream.open", false, true);
    if (param1_this != NULL) {
      IDecompressStream *return_value = &((*local_this).open(param1_this, (PyObject_IsTrue(param2) != 0)));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecompressStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const IDecompressStream self, istream source, bool owns_source)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_IDecompressStream_open_1449_comment =
  "C++ Interface:\n"
  "open(const IDecompressStream self, istream source, bool owns_source)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IDecompressStream_open_1449_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline IDecompressStream &IDecompressStream::close(void)
 */
static PyObject *Dtool_IDecompressStream_close_1450(PyObject *self, PyObject *) {
  IDecompressStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecompressStream, (void **)&local_this, "IDecompressStream.close")) {
    return NULL;
  }
  // 1-inline IDecompressStream &IDecompressStream::close(void)
  IDecompressStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecompressStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IDecompressStream_close_1450_comment =
  "C++ Interface:\n"
  "close(const IDecompressStream self)\n"
  "\n"
  "/**\n"
  " * Resets the ZStream to empty, but does not actually close the source istream\n"
  " * unless owns_source was true.\n"
  " */";
#else
static const char *Dtool_IDecompressStream_close_1450_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline IDecompressStream::IDecompressStream(void)
 * inline IDecompressStream::IDecompressStream(istream *source, bool owns_source)
 */
static int Dtool_Init_IDecompressStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline IDecompressStream::IDecompressStream(void)
      IDecompressStream *return_value = new IDecompressStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecompressStream, true, false);
    }
    break;
  case 2:
    {
      // 1-inline IDecompressStream::IDecompressStream(istream *source, bool owns_source)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"source", "owns_source", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:IDecompressStream", (char **)keyword_list, &param0, &param1)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IDecompressStream.IDecompressStream", false, true);
        if (param0_this != NULL) {
          IDecompressStream *return_value = new IDecompressStream(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecompressStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IDecompressStream() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IDecompressStream()\n"
      "IDecompressStream(istream source, bool owns_source)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_IDecompressStream(PyObject *args, IDecompressStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IDecompressStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline IDecompressStream::IDecompressStream(istream *source, bool owns_source)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "IDecompressStream", 2, 2, &param0, &param1)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IDecompressStream.IDecompressStream", false, false);
        if (param0_this != NULL) {
          IDecompressStream *return_value = new IDecompressStream(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_IDecompressStream(PyObject *args, IDecompressStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_IDecompressStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline IDecompressStream::IDecompressStream(istream *source, bool owns_source)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "IDecompressStream", 2, 2, &param0, &param1)) {
        istream *param0_this = (istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_istream, 0, "IDecompressStream.IDecompressStream", false, false);
        if (param0_this != NULL) {
          IDecompressStream *return_value = new IDecompressStream(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_IDecompressStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_IDecompressStream) {
    printf("IDecompressStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  IDecompressStream *local_this = (IDecompressStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_IDecompressStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_istream) {
    return (istream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_IDecompressStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_IDecompressStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_istream) {
    istream* other_this = (istream*)from_this;
    return (IDecompressStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class OCompressStream
 */
/**
 * Python function wrapper for:
 * inline OCompressStream &OCompressStream::open(ostream *dest, bool owns_dest, int compression_level = 6)
 */
static PyObject *Dtool_OCompressStream_open_1454(PyObject *self, PyObject *args, PyObject *kwds) {
  OCompressStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OCompressStream, (void **)&local_this, "OCompressStream.open")) {
    return NULL;
  }
  // 1-inline OCompressStream &OCompressStream::open(ostream *dest, bool owns_dest, int compression_level = 6)
  PyObject *param1;
  PyObject *param2;
  int param3 = 6;
  static const char *keyword_list[] = {"dest", "owns_dest", "compression_level", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:open", (char **)keyword_list, &param1, &param2, &param3)) {
    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_ostream, 1, "OCompressStream.open", false, true);
    if (param1_this != NULL) {
      OCompressStream *return_value = &((*local_this).open(param1_this, (PyObject_IsTrue(param2) != 0), (int)param3));
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OCompressStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OCompressStream self, ostream dest, bool owns_dest, int compression_level)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_OCompressStream_open_1454_comment =
  "C++ Interface:\n"
  "open(const OCompressStream self, ostream dest, bool owns_dest, int compression_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OCompressStream_open_1454_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OCompressStream &OCompressStream::close(void)
 */
static PyObject *Dtool_OCompressStream_close_1455(PyObject *self, PyObject *) {
  OCompressStream *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OCompressStream, (void **)&local_this, "OCompressStream.close")) {
    return NULL;
  }
  // 1-inline OCompressStream &OCompressStream::close(void)
  OCompressStream *return_value = &((*local_this).close());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OCompressStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OCompressStream_close_1455_comment =
  "C++ Interface:\n"
  "close(const OCompressStream self)\n"
  "\n"
  "/**\n"
  " * Resets the ZStream to empty, but does not actually close the dest ostream\n"
  " * unless owns_dest was true.\n"
  " */";
#else
static const char *Dtool_OCompressStream_close_1455_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline OCompressStream::OCompressStream(void)
 * inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level = 6)
 */
static int Dtool_Init_OCompressStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OCompressStream::OCompressStream(void)
      OCompressStream *return_value = new OCompressStream();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OCompressStream, true, false);
    }
    break;
  case 2:
  case 3:
    {
      // 1-inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level = 6)
      PyObject *param0;
      PyObject *param1;
      int param2 = 6;
      static const char *keyword_list[] = {"dest", "owns_dest", "compression_level", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:OCompressStream", (char **)keyword_list, &param0, &param1, &param2)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OCompressStream.OCompressStream", false, true);
        if (param0_this != NULL) {
          OCompressStream *return_value = new OCompressStream(param0_this, (PyObject_IsTrue(param1) != 0), (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OCompressStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OCompressStream() takes 0, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OCompressStream()\n"
      "OCompressStream(ostream dest, bool owns_dest, int compression_level)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OCompressStream(PyObject *args, OCompressStream const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OCompressStream, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level = 6)
      PyObject *param0;
      PyObject *param1;
      int param2 = 6;
      if (PyArg_ParseTuple(args, "OO|i:OCompressStream", &param0, &param1, &param2)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OCompressStream.OCompressStream", false, false);
        if (param0_this != NULL) {
          OCompressStream *return_value = new OCompressStream(param0_this, (PyObject_IsTrue(param1) != 0), (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OCompressStream(PyObject *args, OCompressStream *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_OCompressStream, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 3) {
      // 1-inline OCompressStream::OCompressStream(ostream *dest, bool owns_dest, int compression_level = 6)
      PyObject *param0;
      PyObject *param1;
      int param2 = 6;
      if (PyArg_ParseTuple(args, "OO|i:OCompressStream", &param0, &param1, &param2)) {
        ostream *param0_this = (ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ostream, 0, "OCompressStream.OCompressStream", false, false);
        if (param0_this != NULL) {
          OCompressStream *return_value = new OCompressStream(param0_this, (PyObject_IsTrue(param1) != 0), (int)param2);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return false;
          }
          if (_PyErr_OCCURRED()) {
            delete return_value;
            return false;
          } else {
            coerced = return_value;
            manage = true;
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OCompressStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_OCompressStream) {
    printf("OCompressStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  OCompressStream *local_this = (OCompressStream *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_OCompressStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ios) {
    return (ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ios_base) {
    return (ios_base *)(ios *)(ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_ostream) {
    return (ostream *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_OCompressStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_OCompressStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ostream) {
    ostream* other_this = (ostream*)from_this;
    return (OCompressStream*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileList
 */
/**
 * Python function wrapper for:
 * inline std::size_t VirtualFileList::get_num_files(void) const
 */
static PyObject *Dtool_VirtualFileList_get_num_files_1458(PyObject *self, PyObject *) {
  VirtualFileList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline std::size_t VirtualFileList::get_num_files(void) const
  std::size_t return_value = (*(const VirtualFileList*)local_this).get_num_files();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileList_get_num_files_1458_comment =
  "C++ Interface:\n"
  "get_num_files(VirtualFileList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of files in the list.\n"
  " */";
#else
static const char *Dtool_VirtualFileList_get_num_files_1458_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFile *VirtualFileList::get_file(std::size_t n) const
 */
static PyObject *Dtool_VirtualFileList_get_file_1459(PyObject *self, PyObject *arg) {
  VirtualFileList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline VirtualFile *VirtualFileList::get_file(std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:get_file", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    VirtualFile *return_value = (*(const VirtualFileList*)local_this).get_file((std::size_t)param1);
    if (return_value != (VirtualFile *)NULL) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != (VirtualFile *)NULL) {
        unref_delete(return_value);
      }
      return NULL;
    }
    if (return_value == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFile, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(VirtualFileList self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileList_get_file_1459_comment =
  "C++ Interface:\n"
  "get_file(VirtualFileList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth file in the list.\n"
  " */";
#else
static const char *Dtool_VirtualFileList_get_file_1459_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFileList::VirtualFileList(VirtualFileList const &) = default
 */
static int Dtool_Init_VirtualFileList(PyObject *self, PyObject *args, PyObject *kwds) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileList() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg = NULL;
  if (PyTuple_GET_SIZE(args) == 1) {
    arg = PyTuple_GET_ITEM(args, 0);
  } else if (kwds != NULL) {
    arg = PyDict_GetItemString(kwds, "param0");
  }
  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
    return -1;
  }
  // 1-inline VirtualFileList::VirtualFileList(VirtualFileList const &) = default
  VirtualFileList const *arg_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileList, 0, "VirtualFileList.VirtualFileList", true, true);
  if (arg_this != NULL) {
    VirtualFileList *return_value = new VirtualFileList(*arg_this);
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileList, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileList(const VirtualFileList param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_VirtualFileList_get_files(PyObject *self, PyObject *) {
  VirtualFileList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_files();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_VirtualFileList_get_file_1459(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_VirtualFileList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileList) {
    printf("VirtualFileList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileList *local_this = (VirtualFileList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileList*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class VirtualFileSystem
 */
/**
 * Python function wrapper for:
 * bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, std::string const &password = "")
 * bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
 * bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
 */
static PyObject *Dtool_VirtualFileSystem_mount_1470(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.mount")) {
    return NULL;
  }
  {
    // -2 bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, std::string const &password = "")
    PyObject *param1;
    PyObject *param2;
    int param3;
    const char *param4_str = "";
    Py_ssize_t param4_len = 0;
    static const char *keyword_list[] = {"physical_filename", "mount_point", "flags", "password", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi|s#:mount", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
      Filename const *param1_this;
      DTOOL_Call_ExtractThisPointerForType(param1, Dtool_Ptr_Filename, (void **)&param1_this);
      Filename const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_Filename, (void **)&param2_this);
      if (param1_this != NULL && param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).mount(*param1_this, *param2_this, (int)param3, std::string(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"mount", "mount_point", "flags", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      VirtualFileMount *param1_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VirtualFileMount, 1, "VirtualFileSystem.mount", false, false);
      Filename const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_Filename, (void **)&param2_this);
      if (param1_this != NULL && param2_this != NULL) {
        bool return_value = (*local_this).mount(param1_this, *param2_this, (int)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"multifile", "mount_point", "flags", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      Multifile *param1_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Multifile, 1, "VirtualFileSystem.mount", false, false);
      Filename const *param2_this;
      DTOOL_Call_ExtractThisPointerForType(param2, Dtool_Ptr_Filename, (void **)&param2_this);
      if (param1_this != NULL && param2_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).mount(param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, std::string const &password = "")
    PyObject *param1;
    PyObject *param2;
    int param3;
    const char *param4_str = "";
    Py_ssize_t param4_len = 0;
    static const char *keyword_list[] = {"physical_filename", "mount_point", "flags", "password", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi|s#:mount", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if ((param1_this != NULL) && (param2_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).mount(*param1_this, *param2_this, (int)param3, std::string(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"mount", "mount_point", "flags", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      VirtualFileMount *param1_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VirtualFileMount, 1, "VirtualFileSystem.mount", false, false);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if (param1_this != NULL && (param2_this != NULL)) {
        bool return_value = (*local_this).mount(param1_this, *param2_this, (int)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"multifile", "mount_point", "flags", NULL};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      Multifile *param1_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Multifile, 1, "VirtualFileSystem.mount", false, false);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if (param1_this != NULL && (param2_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = (*local_this).mount(param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mount(const VirtualFileSystem self, const Filename physical_filename, const Filename mount_point, int flags, str password)\n"
      "mount(const VirtualFileSystem self, VirtualFileMount mount, const Filename mount_point, int flags)\n"
      "mount(const VirtualFileSystem self, Multifile multifile, const Filename mount_point, int flags)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_mount_1470_comment =
  "C++ Interface:\n"
  "mount(const VirtualFileSystem self, const Filename physical_filename, const Filename mount_point, int flags, str password)\n"
  "mount(const VirtualFileSystem self, VirtualFileMount mount, const Filename mount_point, int flags)\n"
  "mount(const VirtualFileSystem self, Multifile multifile, const Filename mount_point, int flags)\n"
  "\n"
  "/**\n"
  " * Mounts the indicated Multifile at the given mount point.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Mounts the indicated system file or directory at the given mount point.  If\n"
  " * the named file is a directory, mounts the directory.  If the named file is\n"
  " * a Multifile, mounts it as a Multifile.  Returns true on success, false on\n"
  " * failure.\n"
  " *\n"
  " * A given system directory may be mounted to multiple different mount point,\n"
  " * and the same mount point may share multiple system directories.  In the\n"
  " * case of ambiguities (that is, two different files with exactly the same\n"
  " * full pathname), the most-recently mounted system wins.\n"
  " *\n"
  " * The filename specified as the first parameter must refer to a real,\n"
  " * physical filename on disk; it cannot be a virtual file already appearing\n"
  " * within the vfs filespace.  However, it is possible to mount such a file;\n"
  " * see mount_loop() for this.\n"
  " *\n"
  " * Note that a mounted VirtualFileSystem directory is fully case-sensitive,\n"
  " * unlike the native Windows file system, so you must refer to files within\n"
  " * the virtual file system with exactly the right case.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the given VirtualFileMount object to the mount list.  This is a lower-\n"
  " * level function that the other flavors of mount(); it requires you to create\n"
  " * a VirtualFileMount object specifically.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_mount_1470_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, std::string const &password = "")
 */
static PyObject *Dtool_VirtualFileSystem_mount_loop_1471(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.mount_loop")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, std::string const &password = "")
  PyObject *param1;
  PyObject *param2;
  int param3;
  const char *param4_str = "";
  Py_ssize_t param4_len = 0;
  static const char *keyword_list[] = {"virtual_filename", "mount_point", "flags", "password", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi|s#:mount_loop", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.mount_loop", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.mount_loop", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).mount_loop(*param1_this, *param2_this, (int)param3, std::string(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mount_loop(const VirtualFileSystem self, const Filename virtual_filename, const Filename mount_point, int flags, str password)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_mount_loop_1471_comment =
  "C++ Interface:\n"
  "mount_loop(const VirtualFileSystem self, const Filename virtual_filename, const Filename mount_point, int flags, str password)\n"
  "\n"
  "/**\n"
  " * This is similar to mount(), but it receives the name of a Multifile that\n"
  " * already appears within the virtual file system.  It can be used to mount a\n"
  " * Multifile that is itself hosted within a virtually-mounted Multifile.\n"
  " *\n"
  " * This interface can also be used to mount physical files (that appear within\n"
  " * the virtual filespace), but it cannot be used to mount directories.  Use\n"
  " * mount() if you need to mount a directory.\n"
  " *\n"
  " * Note that there is additional overhead, in the form of additional buffer\n"
  " * copies of the data, for recursively mounting a multifile like this.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_mount_loop_1471_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::unmount(Filename const &physical_filename)
 * int VirtualFileSystem::unmount(Multifile *multifile)
 * int VirtualFileSystem::unmount(VirtualFileMount *mount)
 */
static PyObject *Dtool_VirtualFileSystem_unmount_1472(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.unmount")) {
    return NULL;
  }
  {
    // -2 int VirtualFileSystem::unmount(VirtualFileMount *mount)
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 1, "VirtualFileSystem.unmount", false, false);
    if (arg_this != NULL) {
      int return_value = (*local_this).unmount(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int VirtualFileSystem::unmount(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 1, "VirtualFileSystem.unmount", false, false);
    if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      int return_value = (*local_this).unmount(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int VirtualFileSystem::unmount(VirtualFileMount *mount)
  // No coercion possible: int VirtualFileSystem::unmount(Multifile *multifile)
  {
    // -2 int VirtualFileSystem::unmount(Filename const &physical_filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != NULL)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      int return_value = (*local_this).unmount(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unmount(const VirtualFileSystem self, VirtualFileMount mount)\n"
      "unmount(const VirtualFileSystem self, Multifile multifile)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_unmount_1472_comment =
  "C++ Interface:\n"
  "unmount(const VirtualFileSystem self, VirtualFileMount mount)\n"
  "unmount(const VirtualFileSystem self, Multifile multifile)\n"
  "\n"
  "/**\n"
  " * Unmounts all appearances of the indicated Multifile from the file system.\n"
  " * Returns the number of appearances unmounted.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unmounts all appearances of the indicated directory name or multifile name\n"
  " * from the file system.  Returns the number of appearances unmounted.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unmounts the indicated VirtualFileMount object from the file system.\n"
  " * Returns the number of appearances unmounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_unmount_1472_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::unmount_point(Filename const &mount_point)
 */
static PyObject *Dtool_VirtualFileSystem_unmount_point_1473(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.unmount_point")) {
    return NULL;
  }
  // 1-int VirtualFileSystem::unmount_point(Filename const &mount_point)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.unmount_point", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int return_value = (*local_this).unmount_point(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unmount_point(const VirtualFileSystem self, const Filename mount_point)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_unmount_point_1473_comment =
  "C++ Interface:\n"
  "unmount_point(const VirtualFileSystem self, const Filename mount_point)\n"
  "\n"
  "/**\n"
  " * Unmounts all systems attached to the given mount point from the file\n"
  " * system.  Returns the number of appearances unmounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_unmount_point_1473_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::unmount_all(void)
 */
static PyObject *Dtool_VirtualFileSystem_unmount_all_1474(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.unmount_all")) {
    return NULL;
  }
  // 1-int VirtualFileSystem::unmount_all(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int return_value = (*local_this).unmount_all();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_unmount_all_1474_comment =
  "C++ Interface:\n"
  "unmount_all(const VirtualFileSystem self)\n"
  "\n"
  "/**\n"
  " * Unmounts all files from the file system.  Returns the number of systems\n"
  " * unmounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_unmount_all_1474_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::get_num_mounts(void) const
 */
static PyObject *Dtool_VirtualFileSystem_get_num_mounts_1475(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-int VirtualFileSystem::get_num_mounts(void) const
  int return_value = (*(const VirtualFileSystem*)local_this).get_num_mounts();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_num_mounts_1475_comment =
  "C++ Interface:\n"
  "get_num_mounts(VirtualFileSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual mounts in the system.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_num_mounts_1475_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
 */
static PyObject *Dtool_VirtualFileSystem_get_mount_1476(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< VirtualFileMount > return_value = (*(const VirtualFileSystem*)local_this).get_mount((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    VirtualFileMount *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFileMount, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mount(VirtualFileSystem self, int n)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_mount_1476_comment =
  "C++ Interface:\n"
  "get_mount(VirtualFileSystem self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth mount in the system.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_mount_1476_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::chdir(Filename const &new_directory)
 */
static PyObject *Dtool_VirtualFileSystem_chdir_1489(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.chdir")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::chdir(Filename const &new_directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.chdir", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).chdir(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "chdir(const VirtualFileSystem self, const Filename new_directory)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_chdir_1489_comment =
  "C++ Interface:\n"
  "chdir(const VirtualFileSystem self, const Filename new_directory)\n"
  "\n"
  "/**\n"
  " * Changes the current directory.  This is used to resolve relative pathnames\n"
  " * in get_file() and/or find_file().  Returns true if successful, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_chdir_1489_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * Filename VirtualFileSystem::get_cwd(void) const
 */
static PyObject *Dtool_VirtualFileSystem_get_cwd_1490(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-Filename VirtualFileSystem::get_cwd(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  Filename *return_value = new Filename((*(const VirtualFileSystem*)local_this).get_cwd());
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_cwd_1490_comment =
  "C++ Interface:\n"
  "get_cwd(VirtualFileSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the current directory name.  See chdir().\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_cwd_1490_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::make_directory(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_make_directory_1491(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.make_directory")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::make_directory(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.make_directory", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).make_directory(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_directory(const VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_make_directory_1491_comment =
  "C++ Interface:\n"
  "make_directory(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to create a directory within the file system.  Returns true on\n"
  " * success, false on failure (for instance, because the parent directory does\n"
  " * not exist, or is read-only).  If the directory already existed prior to\n"
  " * this call, returns true.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_make_directory_1491_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::make_directory_full(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_make_directory_full_1492(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.make_directory_full")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::make_directory_full(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.make_directory_full", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).make_directory_full(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_directory_full(const VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_make_directory_full_1492_comment =
  "C++ Interface:\n"
  "make_directory_full(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to create a directory within the file system.  Will also create\n"
  " * any intervening directories needed.  Returns true on success, false on\n"
  " * failure.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_make_directory_full_1492_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only = false) const
 */
static PyObject *Dtool_VirtualFileSystem_get_file_1493(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only = false) const
  PyObject *param1;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"filename", "status_only", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.get_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< VirtualFile > return_value = (*(const VirtualFileSystem*)local_this).get_file(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    VirtualFile *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFile, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(VirtualFileSystem self, const Filename filename, bool status_only)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_file_1493_comment =
  "C++ Interface:\n"
  "get_file(VirtualFileSystem self, const Filename filename, bool status_only)\n"
  "\n"
  "/**\n"
  " * Looks up the file by the indicated name in the file system.  Returns a\n"
  " * VirtualFile pointer representing the file if it is found, or NULL if it is\n"
  " * not.\n"
  " *\n"
  " * If status_only is true, the file will be checked for existence and length\n"
  " * and so on, but the returned file's contents cannot be read.  This is an\n"
  " * optimization which is especially important for certain mount types, for\n"
  " * instance HTTP, for which opening a file to determine its status is\n"
  " * substantially less expensive than opening it to read its contents.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_file_1493_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFile > VirtualFileSystem::create_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_create_file_1494(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.create_file")) {
    return NULL;
  }
  // 1-PointerTo< VirtualFile > VirtualFileSystem::create_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.create_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< VirtualFile > return_value = (*local_this).create_file(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  VirtualFile *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFile, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_create_file_1494_comment =
  "C++ Interface:\n"
  "create_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to create a file by the indicated name in the filesystem, if\n"
  " * possible, and returns it.  If a file by this name already exists, returns\n"
  " * the same thing as get_file().  If the filename is located within a read-\n"
  " * only directory, or the directory doesn't exist, returns NULL.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_create_file_1494_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only = false) const
 */
static PyObject *Dtool_VirtualFileSystem_find_file_1495(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only = false) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3 = Py_False;
  static const char *keyword_list[] = {"filename", "searchpath", "status_only", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:find_file", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.find_file", "Filename");
    }
    DSearchPath const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_DSearchPath(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.find_file", "DSearchPath");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< VirtualFile > return_value = (*(const VirtualFileSystem*)local_this).find_file(*param1_this, *param2_this, (PyObject_IsTrue(param3) != 0));
    if (param2_manage) {
      delete param2_this;
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    // Transfer ownership of return_value.
    VirtualFile *return_ptr = return_value.p();
    return_value.cheat() = NULL;
    if (return_ptr == NULL) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFile, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_file(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, bool status_only)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_find_file_1495_comment =
  "C++ Interface:\n"
  "find_file(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, bool status_only)\n"
  "\n"
  "/**\n"
  " * Uses the indicated search path to find the file within the file system.\n"
  " * Returns the first occurrence of the file found, or NULL if the file cannot\n"
  " * be found.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_find_file_1495_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::delete_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_delete_file_1496(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.delete_file")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::delete_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.delete_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).delete_file(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_delete_file_1496_comment =
  "C++ Interface:\n"
  "delete_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to delete the indicated file or directory.  This can remove a\n"
  " * single file or an empty directory.  It will not remove a nonempty\n"
  " * directory.  Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_delete_file_1496_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::rename_file(Filename const &orig_filename, Filename const &new_filename)
 */
static PyObject *Dtool_VirtualFileSystem_rename_file_1497(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.rename_file")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::rename_file(Filename const &orig_filename, Filename const &new_filename)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"orig_filename", "new_filename", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:rename_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.rename_file", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.rename_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).rename_file(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rename_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_rename_file_1497_comment =
  "C++ Interface:\n"
  "rename_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n"
  "\n"
  "/**\n"
  " * Attempts to move or rename the indicated file or directory.  If the\n"
  " * original file is an ordinary file, it will quietly replace any already-\n"
  " * existing file in the new filename (but not a directory).  If the original\n"
  " * file is a directory, the new filename must not already exist.\n"
  " *\n"
  " * If the file is a directory, the new filename must be within the same mount\n"
  " * point.  If the file is an ordinary file, the new filename may be anywhere;\n"
  " * but if it is not within the same mount point then the rename operation is\n"
  " * automatically performed as a two-step copy-and-delete operation.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_rename_file_1497_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::copy_file(Filename const &orig_filename, Filename const &new_filename)
 */
static PyObject *Dtool_VirtualFileSystem_copy_file_1498(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.copy_file")) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::copy_file(Filename const &orig_filename, Filename const &new_filename)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"orig_filename", "new_filename", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.copy_file", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.copy_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*local_this).copy_file(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_copy_file_1498_comment =
  "C++ Interface:\n"
  "copy_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n"
  "\n"
  "/**\n"
  " * Attempts to copy the contents of the indicated file to the indicated file.\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_copy_file_1498_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, std::string const &default_extension = string()) const
 */
static PyObject *Dtool_VirtualFileSystem_resolve_filename_1499(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, std::string const &default_extension = string()) const
  PyObject *param1;
  PyObject *param2;
  const char *param3_str = "";
  Py_ssize_t param3_len = 0;
  static const char *keyword_list[] = {"filename", "searchpath", "default_extension", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|s#:resolve_filename", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.resolve_filename", "Filename");
    }
    DSearchPath const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_DSearchPath(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.resolve_filename", "DSearchPath");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = (*(const VirtualFileSystem*)local_this).resolve_filename(*param1_this, *param2_this, std::string(param3_str, param3_len));
    if (param2_manage) {
      delete param2_this;
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_filename(VirtualFileSystem self, Filename filename, const DSearchPath searchpath, str default_extension)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_resolve_filename_1499_comment =
  "C++ Interface:\n"
  "resolve_filename(VirtualFileSystem self, Filename filename, const DSearchPath searchpath, str default_extension)\n"
  "\n"
  "/**\n"
  " * Searches the given search path for the filename.  If it is found, updates\n"
  " * the filename to the full pathname found and returns true; otherwise,\n"
  " * returns false.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_resolve_filename_1499_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::find_all_files(Filename const &filename, DSearchPath const &searchpath, DSearchPath::Results &results) const
 */
static PyObject *Dtool_VirtualFileSystem_find_all_files_1500(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-int VirtualFileSystem::find_all_files(Filename const &filename, DSearchPath const &searchpath, DSearchPath::Results &results) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "searchpath", "results", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:find_all_files", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.find_all_files", "Filename");
    }
    DSearchPath const *param2_this;
    bool param2_manage = false;
    if (!Dtool_ConstCoerce_DSearchPath(param2, param2_this, param2_manage)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.find_all_files", "DSearchPath");
    }
    DSearchPath::Results *param3_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_DSearchPath_Results, 3, "VirtualFileSystem.find_all_files", false, true);
    if (param3_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      int return_value = (*(const VirtualFileSystem*)local_this).find_all_files(*param1_this, *param2_this, *param3_this);
      if (param2_manage) {
        delete param2_this;
      }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_files(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, Results results)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_find_all_files_1500_comment =
  "C++ Interface:\n"
  "find_all_files(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, Results results)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Fills up the results list with *all* of the matching filenames\n"
  " * found, if any.  Returns the number of matches found.\n"
  " *\n"
  " * It is the responsibility of the the caller to clear the results list first;\n"
  " * otherwise, the newly-found files will be appended to the list.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_find_all_files_1500_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSystem::exists(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_exists_1501(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool VirtualFileSystem::exists(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.exists", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const VirtualFileSystem*)local_this).exists(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "exists(VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_exists_1501_comment =
  "C++ Interface:\n"
  "exists(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns true if the named file exists.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_exists_1501_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSystem::is_directory(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_is_directory_1502(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool VirtualFileSystem::is_directory(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.is_directory", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const VirtualFileSystem*)local_this).is_directory(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_directory(VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_is_directory_1502_comment =
  "C++ Interface:\n"
  "is_directory(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns true if the named file exists and is a\n"
  " * directory.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_is_directory_1502_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSystem::is_regular_file(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_is_regular_file_1503(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool VirtualFileSystem::is_regular_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.is_regular_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const VirtualFileSystem*)local_this).is_regular_file(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_regular_file(VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_is_regular_file_1503_comment =
  "C++ Interface:\n"
  "is_regular_file(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns true if the named file exists and is a\n"
  " * regular file.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_is_regular_file_1503_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< VirtualFileList > VirtualFileSystem::scan_directory(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_scan_directory_1504(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PointerTo< VirtualFileList > VirtualFileSystem::scan_directory(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.scan_directory", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< VirtualFileList > return_value = (*(const VirtualFileSystem*)local_this).scan_directory(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  // Transfer ownership of return_value.
  VirtualFileList *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_VirtualFileList, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scan_directory(VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_scan_directory_1504_comment =
  "C++ Interface:\n"
  "scan_directory(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory (that is, is_directory() returns true),\n"
  " * this returns the list of files within the directory at the current time.\n"
  " * Returns NULL if the file is not a directory or if the directory cannot be\n"
  " * read.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_scan_directory_1504_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void VirtualFileSystem::ls(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_ls_1505(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void VirtualFileSystem::ls(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.ls", "Filename");
  }
  (*(const VirtualFileSystem*)local_this).ls(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_ls_1505_comment =
  "C++ Interface:\n"
  "ls(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; lists the files within the indicated directory.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_ls_1505_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void VirtualFileSystem::ls_all(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_ls_all_1506(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline void VirtualFileSystem::ls_all(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.ls_all", "Filename");
  }
  (*(const VirtualFileSystem*)local_this).ls_all(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls_all(VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_ls_all_1506_comment =
  "C++ Interface:\n"
  "ls_all(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; lists the files within the indicated directory, and\n"
  " * all files below, recursively.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_ls_all_1506_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void VirtualFileSystem::write(ostream &out) const
 */
static PyObject *Dtool_VirtualFileSystem_write_1507(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-void VirtualFileSystem::write(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "VirtualFileSystem.write", false, true);
  if (arg_this != NULL) {
    (*(const VirtualFileSystem*)local_this).write(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VirtualFileSystem self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_write_1507_comment =
  "C++ Interface:\n"
  "write(VirtualFileSystem self, ostream out)\n"
  "\n"
  "/**\n"
  " * Print debugging information.  (e.g.  from Python or gdb prompt).\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_write_1507_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void)
 */
static PyObject *Dtool_VirtualFileSystem_get_global_ptr_1508(PyObject *, PyObject *) {
  // 1-static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void)
  VirtualFileSystem *return_value = VirtualFileSystem::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_global_ptr_1508_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the default global VirtualFileSystem.  You may create your own\n"
  " * personal VirtualFileSystem objects and use them for whatever you like, but\n"
  " * Panda will attempt to load models and stuff from this default object.\n"
  " *\n"
  " * Initially, the global VirtualFileSystem is set up to mount the OS\n"
  " * filesystem to root; i.e.  it is equivalent to the OS filesystem.  This may\n"
  " * be subsequently adjusted by the user.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_global_ptr_1508_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFileSystem::read_file(Filename const &filename, bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFileSystem_read_file_1509(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-PyObject *VirtualFileSystem::read_file(Filename const &filename, bool auto_unwrap) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"filename", "auto_unwrap", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:read_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.read_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PyObject *return_value = invoke_extension((const VirtualFileSystem*)local_this).read_file(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_read_file_1509_comment =
  "C++ Interface:\n"
  "read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns the entire contents of the indicated file as\n"
  " * a string.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Convenience function; fills the string up with the data from the indicated\n"
  " * file, if it exists and can be read.  Returns true on success, false\n"
  " * otherwise.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Convenience function; fills the pvector up with the data from the indicated\n"
  " * file, if it exists and can be read.  Returns true on success, false\n"
  " * otherwise.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_read_file_1509_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * istream *VirtualFileSystem::open_read_file(Filename const &filename, bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFileSystem_open_read_file_1510(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  // 1-istream *VirtualFileSystem::open_read_file(Filename const &filename, bool auto_unwrap) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"filename", "auto_unwrap", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open_read_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.open_read_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    istream *return_value = (*(const VirtualFileSystem*)local_this).open_read_file(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_istream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_read_file_1510_comment =
  "C++ Interface:\n"
  "open_read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns a newly allocated istream if the file exists\n"
  " * and can be read, or NULL otherwise.  Does not return an invalid istream.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_read_file_1510_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileSystem::close_read_file(istream *stream)
 */
static PyObject *Dtool_VirtualFileSystem_close_read_file_1511(PyObject *, PyObject *arg) {
  // 1-static void VirtualFileSystem::close_read_file(istream *stream)
  istream *arg_this = (istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_istream, 0, "VirtualFileSystem.close_read_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    VirtualFileSystem::close_read_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_file(istream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_close_read_file_1511_comment =
  "C++ Interface:\n"
  "close_read_file(istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_file().  This really\n"
  " * just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_close_read_file_1511_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFileSystem::write_file(Filename const &filename, PyObject *data, bool auto_wrap)
 */
static PyObject *Dtool_VirtualFileSystem_write_file_1512(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.write_file")) {
    return NULL;
  }
  // 1-PyObject *VirtualFileSystem::write_file(Filename const &filename, PyObject *data, bool auto_wrap)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "data", "auto_wrap", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:write_file", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.write_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PyObject *return_value = invoke_extension(local_this).write_file(*param1_this, param2, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_file(const VirtualFileSystem self, const Filename filename, object data, bool auto_wrap)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_write_file_1512_comment =
  "C++ Interface:\n"
  "write_file(const VirtualFileSystem self, const Filename filename, object data, bool auto_wrap)\n"
  "\n"
  "/**\n"
  " * Convenience function; writes the entire contents of the indicated file as a\n"
  " * string.\n"
  " *\n"
  " * If auto_wrap is true, an explicitly-named .pz file is automatically\n"
  " * compressed while writing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Convenience function; writes the entire contents of the indicated file as a\n"
  " * block of data.\n"
  " *\n"
  " * If auto_wrap is true, an explicitly-named .pz file is automatically\n"
  " * compressed while writing.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_write_file_1512_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ostream *VirtualFileSystem::open_write_file(Filename const &filename, bool auto_wrap, bool truncate)
 */
static PyObject *Dtool_VirtualFileSystem_open_write_file_1513(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_write_file")) {
    return NULL;
  }
  // 1-ostream *VirtualFileSystem::open_write_file(Filename const &filename, bool auto_wrap, bool truncate)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "auto_wrap", "truncate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:open_write_file", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.open_write_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ostream *return_value = (*local_this).open_write_file(*param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write_file(const VirtualFileSystem self, const Filename filename, bool auto_wrap, bool truncate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_write_file_1513_comment =
  "C++ Interface:\n"
  "open_write_file(const VirtualFileSystem self, const Filename filename, bool auto_wrap, bool truncate)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns a newly allocated ostream if the file exists\n"
  " * and can be written, or NULL otherwise.  Does not return an invalid ostream.\n"
  " *\n"
  " * If auto_wrap is true, an explicitly-named .pz file is automatically\n"
  " * compressed while writing.  If truncate is true, the file is truncated to\n"
  " * zero length before writing.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_write_file_1513_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ostream *VirtualFileSystem::open_append_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_open_append_file_1514(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_append_file")) {
    return NULL;
  }
  // 1-ostream *VirtualFileSystem::open_append_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.open_append_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ostream *return_value = (*local_this).open_append_file(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ostream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_append_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_append_file_1514_comment =
  "C++ Interface:\n"
  "open_append_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Works like open_write_file(), but the file is opened in append mode.  Like\n"
  " * open_write_file, the returned pointer should eventually be passed to\n"
  " * close_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_append_file_1514_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileSystem::close_write_file(ostream *stream)
 */
static PyObject *Dtool_VirtualFileSystem_close_write_file_1515(PyObject *, PyObject *arg) {
  // 1-static void VirtualFileSystem::close_write_file(ostream *stream)
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "VirtualFileSystem.close_write_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    VirtualFileSystem::close_write_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_write_file(ostream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_close_write_file_1515_comment =
  "C++ Interface:\n"
  "close_write_file(ostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_write_file().  This really\n"
  " * just deletes the ostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_close_write_file_1515_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * iostream *VirtualFileSystem::open_read_write_file(Filename const &filename, bool truncate)
 */
static PyObject *Dtool_VirtualFileSystem_open_read_write_file_1516(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_read_write_file")) {
    return NULL;
  }
  // 1-iostream *VirtualFileSystem::open_read_write_file(Filename const &filename, bool truncate)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"filename", "truncate", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open_read_write_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.open_read_write_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    iostream *return_value = (*local_this).open_read_write_file(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write_file(const VirtualFileSystem self, const Filename filename, bool truncate)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_read_write_file_1516_comment =
  "C++ Interface:\n"
  "open_read_write_file(const VirtualFileSystem self, const Filename filename, bool truncate)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns a newly allocated iostream if the file exists\n"
  " * and can be written, or NULL otherwise.  Does not return an invalid\n"
  " * iostream.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_read_write_file_1516_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * iostream *VirtualFileSystem::open_read_append_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_open_read_append_file_1517(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_read_append_file")) {
    return NULL;
  }
  // 1-iostream *VirtualFileSystem::open_read_append_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.open_read_append_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  iostream *return_value = (*local_this).open_read_append_file(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_iostream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_append_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_read_append_file_1517_comment =
  "C++ Interface:\n"
  "open_read_append_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Works like open_read_write_file(), but the file is opened in append mode.\n"
  " * Like open_read_write_file, the returned pointer should eventually be passed\n"
  " * to close_read_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_read_append_file_1517_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileSystem::close_read_write_file(iostream *stream)
 */
static PyObject *Dtool_VirtualFileSystem_close_read_write_file_1518(PyObject *, PyObject *arg) {
  // 1-static void VirtualFileSystem::close_read_write_file(iostream *stream)
  iostream *arg_this = (iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_iostream, 0, "VirtualFileSystem.close_read_write_file", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    VirtualFileSystem::close_read_write_file(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_write_file(iostream stream)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_close_read_write_file_1518_comment =
  "C++ Interface:\n"
  "close_read_write_file(iostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_write_file().  This\n"
  " * really just deletes the iostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_close_read_write_file_1518_comment = NULL;
#endif

/**
 * sequence length function for property VirtualFileSystem::mounts
 */
static Py_ssize_t Dtool_VirtualFileSystem_mounts_Len(PyObject *self) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)(*local_this).get_num_mounts();
}

/**
 * sequence getter for property VirtualFileSystem::mounts
 */
static PyObject *Dtool_VirtualFileSystem_mounts_Getitem(PyObject *self, Py_ssize_t index) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  if (index < 0 || index >= (Py_ssize_t)(*local_this).get_num_mounts()) {
    PyErr_SetString(PyExc_IndexError, "VirtualFileSystem.mounts[] index out of range");
    return NULL;
  }
  // 1-PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
  PointerTo< VirtualFileMount > return_value = (*(const VirtualFileSystem*)local_this).get_mount(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  VirtualFileMount *return_ptr = return_value.p();
  return_value.cheat() = NULL;
  if (return_ptr == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFileMount, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mount(VirtualFileSystem self, index)\n");
  }
}

static PyObject *Dtool_VirtualFileSystem_mounts_Getter(PyObject *self, void *) {
  Py_INCREF(self);
  Dtool_SequenceWrapper *wrap = PyObject_New(Dtool_SequenceWrapper, &Dtool_SequenceWrapper_Type);
  wrap->_base = self;
  wrap->_len_func = &Dtool_VirtualFileSystem_mounts_Len;
  wrap->_getitem_func = &Dtool_VirtualFileSystem_mounts_Getitem;
  wrap->_setitem_func = NULL;
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * VirtualFileSystem::VirtualFileSystem(void)
 * inline VirtualFileSystem::VirtualFileSystem(VirtualFileSystem const &) = default
 */
static int Dtool_Init_VirtualFileSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-VirtualFileSystem::VirtualFileSystem(void)
      VirtualFileSystem *return_value = new VirtualFileSystem();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileSystem, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline VirtualFileSystem::VirtualFileSystem(VirtualFileSystem const &) = default
      VirtualFileSystem const *arg_this = (VirtualFileSystem *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileSystem, 0, "VirtualFileSystem.VirtualFileSystem", true, true);
      if (arg_this != NULL) {
        VirtualFileSystem *return_value = new VirtualFileSystem(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileSystem, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileSystem() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileSystem()\n"
      "VirtualFileSystem(const VirtualFileSystem param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_VirtualFileSystem_get_mounts(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }
  Py_ssize_t count = (Py_ssize_t)(*local_this).get_num_mounts();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_VirtualFileSystem_get_mount_1476(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return NULL;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_VirtualFileSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_VirtualFileSystem) {
    printf("VirtualFileSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  VirtualFileSystem *local_this = (VirtualFileSystem *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_VirtualFileSystem) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_VirtualFileSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_VirtualFileSystem) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerTo< VirtualFileMount >
 */
/**
 * Python function wrapper for:
 * inline VirtualFileMount *PointerTo< VirtualFileMount >::p(void) const
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_p_1485(PyObject *self, PyObject *) {
  PointerTo< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerTo_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline VirtualFileMount *PointerTo< VirtualFileMount >::p(void) const
  VirtualFileMount *return_value = (*(const PointerTo< VirtualFileMount >*)local_this).p();
  if (return_value != (VirtualFileMount *)NULL) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != (VirtualFileMount *)NULL) {
      unref_delete(return_value);
    }
    return NULL;
  }
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFileMount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_p_1485_comment =
  "C++ Interface:\n"
  "p(PointerTo self)\n"
  "\n"
  "// If your base class is a derivative of TypedObject, you might want to use\n"
  "// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,\n"
  "// ptr).  This provides a clean downcast that doesn't require .p() or any\n"
  "// double-casting, and it can be run-time checked for correctness.";
#else
static const char *Dtool_PointerTo_VirtualFileMount_p_1485_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< VirtualFileMount > &PointerTo< VirtualFileMount >::operator =(PointerTo< VirtualFileMount > const &copy)
 * inline PointerTo< VirtualFileMount > &PointerTo< VirtualFileMount >::operator =(VirtualFileMount *ptr)
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_operator_1486(PyObject *self, PyObject *arg) {
  PointerTo< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_VirtualFileMount, (void **)&local_this, "PointerTo_VirtualFileMount.assign")) {
    return NULL;
  }
  {
    // -2 inline PointerTo< VirtualFileMount > &PointerTo< VirtualFileMount >::operator =(VirtualFileMount *ptr)
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 1, "PointerTo.assign", false, false);
    if (arg_this != NULL) {
      (*local_this).operator =(arg_this);
      PointerTo< VirtualFileMount > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_VirtualFileMount, false, false);
    }
  }

  {
    // -2 inline PointerTo< VirtualFileMount > &PointerTo< VirtualFileMount >::operator =(PointerTo< VirtualFileMount > const &copy)
    VirtualFileMount *arg_this;
    DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_VirtualFileMount, (void **)&arg_this);
    if (arg_this != NULL) {
      (*local_this).operator =(arg_this);
      PointerTo< VirtualFileMount > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return NULL;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_VirtualFileMount, false, false);
    }
  }

  // No coercion possible: inline PointerTo< VirtualFileMount > &PointerTo< VirtualFileMount >::operator =(VirtualFileMount *ptr)
  // No coercion possible: inline PointerTo< VirtualFileMount > &PointerTo< VirtualFileMount >::operator =(PointerTo< VirtualFileMount > const &copy)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PointerTo self, VirtualFileMount ptr)\n"
      "assign(const PointerTo self, const VirtualFileMount copy)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_operator_1486_comment =
  "C++ Interface:\n"
  "assign(const PointerTo self, VirtualFileMount ptr)\n"
  "assign(const PointerTo self, const VirtualFileMount copy)\n";
#else
static const char *Dtool_PointerTo_VirtualFileMount_operator_1486_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerTo< VirtualFileMount >::is_null(void) const
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_is_null_1487(PyObject *self, PyObject *) {
  PointerTo< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerTo_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool PointerTo< VirtualFileMount >::is_null(void) const
  bool return_value = (*(const PointerTo< VirtualFileMount >*)local_this).is_null();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_is_null_1487_comment =
  "C++ Interface:\n"
  "is_null(PointerTo self)\n"
  "\n"
  "// These functions normally wouldn't need to be redefined here, but we do so\n"
  "// anyway just to help out interrogate (which doesn't seem to want to\n"
  "// automatically export the PointerToBase class).  When this works again in\n"
  "// interrogate, we can remove these.";
#else
static const char *Dtool_PointerTo_VirtualFileMount_is_null_1487_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void PointerTo< VirtualFileMount >::clear(void)
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_clear_1488(PyObject *self, PyObject *) {
  PointerTo< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_VirtualFileMount, (void **)&local_this, "PointerTo_VirtualFileMount.clear")) {
    return NULL;
  }
  // 1-inline void PointerTo< VirtualFileMount >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_clear_1488_comment =
  "C++ Interface:\n"
  "clear(const PointerTo self)\n";
#else
static const char *Dtool_PointerTo_VirtualFileMount_clear_1488_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< VirtualFileMount >::PointerTo(void) = default
 * inline PointerTo< VirtualFileMount >::PointerTo(PointerTo< VirtualFileMount > const &copy)
 * inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr)
 */
static int Dtool_Init_PointerTo_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerTo< VirtualFileMount >::PointerTo(void) = default
      PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerTo< VirtualFileMount >::PointerTo(PointerTo< VirtualFileMount > const &copy)
        PyObject *param0;
        static const char *keyword_list[] = {"copy", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerTo", (char **)keyword_list, &param0)) {
          VirtualFileMount *param0_this;
          DTOOL_Call_ExtractThisPointerForType(param0, Dtool_Ptr_VirtualFileMount, (void **)&param0_this);
          if (param0_this != NULL) {
            PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr)
        PyObject *param0;
        static const char *keyword_list[] = {"ptr", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:PointerTo", (char **)keyword_list, &param0)) {
          VirtualFileMount *param0_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VirtualFileMount, 0, "PointerTo.PointerTo", false, false);
          if (param0_this != NULL) {
            PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(param0_this);
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline PointerTo< VirtualFileMount >::PointerTo(PointerTo< VirtualFileMount > const &copy)
      // No coercion possible: inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerTo() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerTo()\n"
      "PointerTo(const VirtualFileMount copy)\n"
      "PointerTo(VirtualFileMount ptr)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PointerTo_VirtualFileMount(PyObject *args, PointerTo< VirtualFileMount > const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerTo_VirtualFileMount, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr)
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 0, "PointerTo.PointerTo", false, false);
    if (arg_this != NULL) {
      PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PointerTo_VirtualFileMount(PyObject *args, PointerTo< VirtualFileMount > *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_PointerTo_VirtualFileMount, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr)
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 0, "PointerTo.PointerTo", false, false);
    if (arg_this != NULL) {
      PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PointerTo_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerTo_VirtualFileMount) {
    printf("PointerTo_VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerTo< VirtualFileMount > *local_this = (PointerTo< VirtualFileMount > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerTo_VirtualFileMount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    return (PointerToBase< VirtualFileMount > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< VirtualFileMount > *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerTo_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerTo_VirtualFileMount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    PointerToBase< VirtualFileMount >* other_this = (PointerToBase< VirtualFileMount >*)from_this;
    return (PointerTo< VirtualFileMount >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerTo< VirtualFileMount >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class PointerToBase< VirtualFileMount >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< VirtualFileMount >::clear(void)
 */
static PyObject *Dtool_PointerToBase_VirtualFileMount_clear_1481(PyObject *self, PyObject *) {
  PointerToBase< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_VirtualFileMount, (void **)&local_this, "PointerToBase_VirtualFileMount.clear")) {
    return NULL;
  }
  // 1-inline void PointerToBase< VirtualFileMount >::clear(void)
  (*local_this).clear();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_VirtualFileMount_clear_1481_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_VirtualFileMount_clear_1481_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< VirtualFileMount >::output(ostream &out) const
 */
static PyObject *Dtool_PointerToBase_VirtualFileMount_output_1482(PyObject *self, PyObject *arg) {
  PointerToBase< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }
  // 1-void PointerToBase< VirtualFileMount >::output(ostream &out) const
  ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != NULL) {
    (*(const PointerToBase< VirtualFileMount >*)local_this).output(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_VirtualFileMount_output_1482_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_VirtualFileMount_output_1482_comment = NULL;
#endif

static int Dtool_Init_PointerToBase_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_PointerToBase_VirtualFileMount) {
    printf("PointerToBase_VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  PointerToBase< VirtualFileMount > *local_this = (PointerToBase< VirtualFileMount > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_PointerToBase_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< VirtualFileMount >*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class TrueClock
 */
/**
 * Python function wrapper for:
 * double TrueClock::get_long_time(void)
 */
static PyObject *Dtool_TrueClock_get_long_time_1520(PyObject *self, PyObject *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.get_long_time")) {
    return NULL;
  }
  // 1-double TrueClock::get_long_time(void)
  double return_value = (*local_this).get_long_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_long_time_1520_comment =
  "C++ Interface:\n"
  "get_long_time(const TrueClock self)\n"
  "\n"
  "// get_long_time() returns the most accurate timer we have over a long\n"
  "// interval.  It may not be very precise for measuring short intervals, but\n"
  "// it should not drift substantially over the long haul.\n"
  "\n"
  "// get_long_time() returns the most accurate timer we have over a long\n"
  "// interval.  It may not be very precise for measuring short intervals, but\n"
  "// it should not drift substantially over the long haul.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_get_long_time_1520_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline double TrueClock::get_short_time(void)
 */
static PyObject *Dtool_TrueClock_get_short_time_1522(PyObject *self, PyObject *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.get_short_time")) {
    return NULL;
  }
  // 1-inline double TrueClock::get_short_time(void)
  double return_value = (*local_this).get_short_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_short_time_1522_comment =
  "C++ Interface:\n"
  "get_short_time(const TrueClock self)\n"
  "\n"
  "// get_short_time() returns the most precise timer we have over a short\n"
  "// interval.  It may tend to drift over the long haul, but it should have\n"
  "// lots of digits to measure short intervals very precisely.\n"
  "\n"
  "// get_short_time() returns the most precise timer we have over a short\n"
  "// interval.  It may tend to drift over the long haul, but it should have\n"
  "// lots of digits to measure short intervals very precisely.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_get_short_time_1522_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double TrueClock::get_short_raw_time(void)
 */
static PyObject *Dtool_TrueClock_get_short_raw_time_1524(PyObject *self, PyObject *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.get_short_raw_time")) {
    return NULL;
  }
  // 1-double TrueClock::get_short_raw_time(void)
  double return_value = (*local_this).get_short_raw_time();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_short_raw_time_1524_comment =
  "C++ Interface:\n"
  "get_short_raw_time(const TrueClock self)\n"
  "\n"
  "// get_short_raw_time() is like get_short_time(), but does not apply any\n"
  "// corrections (e.g.  paranoid-clock) to the result returned by the OS.\n"
  "\n"
  "// get_short_raw_time() is like get_short_time(), but does not apply any\n"
  "// corrections (e.g.  paranoid-clock) to the result returned by the OS.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_get_short_raw_time_1524_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int TrueClock::get_error_count(void) const
 */
static PyObject *Dtool_TrueClock_get_error_count_1526(PyObject *self, PyObject *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrueClock, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int TrueClock::get_error_count(void) const
  int return_value = (*(const TrueClock*)local_this).get_error_count();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_error_count_1526_comment =
  "C++ Interface:\n"
  "get_error_count(TrueClock self)\n"
  "\n"
  "/**\n"
  " * Returns the number of clock errors that have been detected.  Each time a\n"
  " * clock error is detected, in which the value returned by either of the above\n"
  " * methods is suspect, the value returned by this method will be incremented.\n"
  " * Applications can monitor this value and react, for instance, by\n"
  " * resynchronizing their clocks each time this value changes.\n"
  " */";
#else
static const char *Dtool_TrueClock_get_error_count_1526_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline TrueClock *TrueClock::get_global_ptr(void)
 */
static PyObject *Dtool_TrueClock_get_global_ptr_1528(PyObject *, PyObject *) {
  // 1-static inline TrueClock *TrueClock::get_global_ptr(void)
  TrueClock *return_value = TrueClock::get_global_ptr();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TrueClock, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_global_ptr_1528_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one TrueClock object in the world.\n"
  " */";
#else
static const char *Dtool_TrueClock_get_global_ptr_1528_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool TrueClock::set_cpu_affinity(uint32_t mask) const
 */
static PyObject *Dtool_TrueClock_set_cpu_affinity_1529(PyObject *self, PyObject *arg) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrueClock, (void **)&local_this)) {
    return NULL;
  }
  // 1-bool TrueClock::set_cpu_affinity(uint32_t mask) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    bool return_value = (*(const TrueClock*)local_this).set_cpu_affinity((uint32_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cpu_affinity(TrueClock self, int mask)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_set_cpu_affinity_1529_comment =
  "C++ Interface:\n"
  "set_cpu_affinity(TrueClock self, int mask)\n";
#else
static const char *Dtool_TrueClock_set_cpu_affinity_1529_comment = NULL;
#endif

static PyObject *Dtool_TrueClock_long_time_Getter(PyObject *self, void *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.long_time")) {
    return NULL;
  }

  // 1-double TrueClock::get_long_time(void)
  double return_value = (*local_this).get_long_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TrueClock_short_time_Getter(PyObject *self, void *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.short_time")) {
    return NULL;
  }

  // 1-inline double TrueClock::get_short_time(void)
  double return_value = (*local_this).get_short_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TrueClock_short_raw_time_Getter(PyObject *self, void *) {
  TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.short_raw_time")) {
    return NULL;
  }

  // 1-double TrueClock::get_short_raw_time(void)
  double return_value = (*local_this).get_short_raw_time();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TrueClock_error_count_Getter(PyObject *self, void *) {
  const TrueClock *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrueClock, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int TrueClock::get_error_count(void) const
  int return_value = (*(const TrueClock*)local_this).get_error_count();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TrueClock(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TrueClock(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_TrueClock) {
    printf("TrueClock ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  TrueClock *local_this = (TrueClock *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_TrueClock) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_TrueClock(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_TrueClock) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class Patchfile
 */
/**
 * Python function wrapper for:
 * bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name)
 */
static PyObject *Dtool_Patchfile_build_1533(PyObject *self, PyObject *args, PyObject *kwds) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.build")) {
    return NULL;
  }
  // 1-bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"file_orig", "file_new", "patch_name", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:build", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.build", "Filename");
    }
    Filename param2_local;
    Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.build", "Filename");
    }
    Filename param3_local;
    Filename *param3_this = Dtool_Coerce_Filename(param3, param3_local);
    if (!(param3_this != NULL)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Patchfile.build", "Filename");
    }
    bool return_value = (*local_this).build(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "build(const Patchfile self, Filename file_orig, Filename file_new, Filename patch_name)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_build_1533_comment =
  "C++ Interface:\n"
  "build(const Patchfile self, Filename file_orig, Filename file_new, Filename patch_name)\n"
  "\n"
  "/**\n"
  " *\n"
  " * This implementation uses the \"greedy differencing algorithm\" described in\n"
  " * the masters thesis \"Differential Compression: A Generalized Solution for\n"
  " * Binary Files\" by Randal C. Burns (p.13). For an original file of size M and\n"
  " * a new file of size N, this algorithm is O(M) in space and O(M*N) (worst-\n"
  " * case) in time.  return false on error\n"
  " */";
#else
static const char *Dtool_Patchfile_build_1533_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Patchfile::read_header(Filename const &patch_file)
 */
static PyObject *Dtool_Patchfile_read_header_1534(PyObject *self, PyObject *arg) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.read_header")) {
    return NULL;
  }
  // 1-int Patchfile::read_header(Filename const &patch_file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Patchfile.read_header", "Filename");
  }
  int return_value = (*local_this).read_header(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_header(const Patchfile self, const Filename patch_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_read_header_1534_comment =
  "C++ Interface:\n"
  "read_header(const Patchfile self, const Filename patch_file)\n"
  "\n"
  "/**\n"
  " * Opens the patch file for reading, and gets the header information from the\n"
  " * file but does not begin to do any real work.  This can be used to query the\n"
  " * data stored in the patch.\n"
  " */";
#else
static const char *Dtool_Patchfile_read_header_1534_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Patchfile::initiate(Filename const &patch_file, Filename const &file)
 * int Patchfile::initiate(Filename const &patch_file, Filename const &orig_file, Filename const &target_file)
 */
static PyObject *Dtool_Patchfile_initiate_1535(PyObject *self, PyObject *args, PyObject *kwds) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.initiate")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-int Patchfile::initiate(Filename const &patch_file, Filename const &file)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"patch_file", "file", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:initiate", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.initiate", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.initiate", "Filename");
        }
        int return_value = (*local_this).initiate(*param1_this, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-int Patchfile::initiate(Filename const &patch_file, Filename const &orig_file, Filename const &target_file)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"patch_file", "orig_file", "target_file", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:initiate", (char **)keyword_list, &param1, &param2, &param3)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.initiate", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.initiate", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Patchfile.initiate", "Filename");
        }
        int return_value = (*local_this).initiate(*param1_this, *param2_this, *param3_this);
        if (Dtool_CheckErrorOccurred()) {
          return NULL;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "initiate() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initiate(const Patchfile self, const Filename patch_file, const Filename file)\n"
      "initiate(const Patchfile self, const Filename patch_file, const Filename orig_file, const Filename target_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_initiate_1535_comment =
  "C++ Interface:\n"
  "initiate(const Patchfile self, const Filename patch_file, const Filename file)\n"
  "initiate(const Patchfile self, const Filename patch_file, const Filename orig_file, const Filename target_file)\n"
  "\n"
  "/**\n"
  " * Set up to apply the patch to the file (original file and patch are\n"
  " * destroyed in the process).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Set up to apply the patch to the file.  In this form, neither the original\n"
  " * file nor the patch file are destroyed.\n"
  " */";
#else
static const char *Dtool_Patchfile_initiate_1535_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * int Patchfile::run(void)
 */
static PyObject *Dtool_Patchfile_run_1536(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.run")) {
    return NULL;
  }
  // 1-int Patchfile::run(void)
  int return_value = (*local_this).run();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_run_1536_comment =
  "C++ Interface:\n"
  "run(const Patchfile self)\n"
  "\n"
  "/**\n"
  " * Perform one buffer's worth of patching Returns EU_ok while patching Returns\n"
  " * EU_success when done If error happens will return one of: EU_error_abort :\n"
  " * Patching has not been initiated EU_error_file_invalid : file is corrupted\n"
  " * EU_error_invalid_checksum : incompatible patch file\n"
  " * EU_error_write_file_rename : could not rename file\n"
  " */";
#else
static const char *Dtool_Patchfile_run_1536_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool Patchfile::apply(Filename &patch_file, Filename &file)
 * bool Patchfile::apply(Filename &patch_file, Filename &orig_file, Filename const &target_file)
 */
static PyObject *Dtool_Patchfile_apply_1537(PyObject *self, PyObject *args, PyObject *kwds) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.apply")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool Patchfile::apply(Filename &patch_file, Filename &file)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"patch_file", "file", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:apply", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.apply", "Filename");
        }
        Filename param2_local;
        Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.apply", "Filename");
        }
        bool return_value = (*local_this).apply(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool Patchfile::apply(Filename &patch_file, Filename &orig_file, Filename const &target_file)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"patch_file", "orig_file", "target_file", NULL};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:apply", (char **)keyword_list, &param1, &param2, &param3)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.apply", "Filename");
        }
        Filename param2_local;
        Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.apply", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
        if (!(param3_this != NULL)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Patchfile.apply", "Filename");
        }
        bool return_value = (*local_this).apply(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "apply() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply(const Patchfile self, Filename patch_file, Filename file)\n"
      "apply(const Patchfile self, Filename patch_file, Filename orig_file, const Filename target_file)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_apply_1537_comment =
  "C++ Interface:\n"
  "apply(const Patchfile self, Filename patch_file, Filename file)\n"
  "apply(const Patchfile self, Filename patch_file, Filename orig_file, const Filename target_file)\n"
  "\n"
  "/**\n"
  " * Patches the entire file in one call returns true on success and false on\n"
  " * error\n"
  " *\n"
  " * This version will delete the patch file and overwrite the original file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Patches the entire file in one call returns true on success and false on\n"
  " * error\n"
  " *\n"
  " * This version will not delete any files.\n"
  " */";
#else
static const char *Dtool_Patchfile_apply_1537_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Patchfile::get_progress(void) const
 */
static PyObject *Dtool_Patchfile_get_progress_1538(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline PN_stdfloat Patchfile::get_progress(void) const
  PN_stdfloat return_value = (*(const Patchfile*)local_this).get_progress();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_progress_1538_comment =
  "C++ Interface:\n"
  "get_progress(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns a value in the range 0..1, representing the amount of progress\n"
  " * through the patchfile, during a session.\n"
  " */";
#else
static const char *Dtool_Patchfile_get_progress_1538_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Patchfile::set_allow_multifile(bool allow_multifile)
 */
static PyObject *Dtool_Patchfile_set_allow_multifile_1542(PyObject *self, PyObject *arg) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.set_allow_multifile")) {
    return NULL;
  }
  // 1-inline void Patchfile::set_allow_multifile(bool allow_multifile)
  (*local_this).set_allow_multifile((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_allow_multifile(const Patchfile self, bool allow_multifile)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_set_allow_multifile_1542_comment =
  "C++ Interface:\n"
  "set_allow_multifile(const Patchfile self, bool allow_multifile)\n"
  "\n"
  "/**\n"
  " * If this flag is set true, the Patchfile will make a special case for\n"
  " * patching Panda Multifiles, if detected, and attempt to patch them on a\n"
  " * subfile-by-subfile basis.  If this flag is false, the Patchfile will always\n"
  " * patch the file on a full-file basis.\n"
  " *\n"
  " * This has effect only when building patches; it is not used for applying\n"
  " * patches.\n"
  " */";
#else
static const char *Dtool_Patchfile_set_allow_multifile_1542_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Patchfile::get_allow_multifile(void)
 */
static PyObject *Dtool_Patchfile_get_allow_multifile_1543(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.get_allow_multifile")) {
    return NULL;
  }
  // 1-inline bool Patchfile::get_allow_multifile(void)
  bool return_value = (*local_this).get_allow_multifile();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_allow_multifile_1543_comment =
  "C++ Interface:\n"
  "get_allow_multifile(const Patchfile self)\n"
  "\n"
  "/**\n"
  " * See set_allow_multifile().\n"
  " */";
#else
static const char *Dtool_Patchfile_get_allow_multifile_1543_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Patchfile::set_footprint_length(int length)
 */
static PyObject *Dtool_Patchfile_set_footprint_length_1545(PyObject *self, PyObject *arg) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.set_footprint_length")) {
    return NULL;
  }
  // 1-inline void Patchfile::set_footprint_length(int length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_footprint_length((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_footprint_length(const Patchfile self, int length)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_set_footprint_length_1545_comment =
  "C++ Interface:\n"
  "set_footprint_length(const Patchfile self, int length)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patchfile_set_footprint_length_1545_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int Patchfile::get_footprint_length(void)
 */
static PyObject *Dtool_Patchfile_get_footprint_length_1546(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.get_footprint_length")) {
    return NULL;
  }
  // 1-inline int Patchfile::get_footprint_length(void)
  int return_value = (*local_this).get_footprint_length();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_footprint_length_1546_comment =
  "C++ Interface:\n"
  "get_footprint_length(const Patchfile self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patchfile_get_footprint_length_1546_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void Patchfile::reset_footprint_length(void)
 */
static PyObject *Dtool_Patchfile_reset_footprint_length_1547(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.reset_footprint_length")) {
    return NULL;
  }
  // 1-inline void Patchfile::reset_footprint_length(void)
  (*local_this).reset_footprint_length();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_reset_footprint_length_1547_comment =
  "C++ Interface:\n"
  "reset_footprint_length(const Patchfile self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patchfile_reset_footprint_length_1547_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool Patchfile::has_source_hash(void) const
 */
static PyObject *Dtool_Patchfile_has_source_hash_1549(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool Patchfile::has_source_hash(void) const
  bool return_value = (*(const Patchfile*)local_this).has_source_hash();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_has_source_hash_1549_comment =
  "C++ Interface:\n"
  "has_source_hash(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the MD5 hash for the source file is known.  (Some early\n"
  " * versions of the patch file did not store this information.)\n"
  " */";
#else
static const char *Dtool_Patchfile_has_source_hash_1549_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HashVal const &Patchfile::get_source_hash(void) const
 */
static PyObject *Dtool_Patchfile_get_source_hash_1550(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HashVal const &Patchfile::get_source_hash(void) const
  HashVal const *return_value = &((*(const Patchfile*)local_this).get_source_hash());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_source_hash_1550_comment =
  "C++ Interface:\n"
  "get_source_hash(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns the MD5 hash for the source file.\n"
  " */";
#else
static const char *Dtool_Patchfile_get_source_hash_1550_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline HashVal const &Patchfile::get_result_hash(void) const
 */
static PyObject *Dtool_Patchfile_get_result_hash_1551(PyObject *self, PyObject *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline HashVal const &Patchfile::get_result_hash(void) const
  HashVal const *return_value = &((*(const Patchfile*)local_this).get_result_hash());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_result_hash_1551_comment =
  "C++ Interface:\n"
  "get_result_hash(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns the MD5 hash for the file after the patch has been applied.\n"
  " */";
#else
static const char *Dtool_Patchfile_get_result_hash_1551_comment = NULL;
#endif

static PyObject *Dtool_Patchfile_progress_Getter(PyObject *self, void *) {
  const Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline PN_stdfloat Patchfile::get_progress(void) const
  PN_stdfloat return_value = (*(const Patchfile*)local_this).get_progress();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Patchfile_allow_multifile_Getter(PyObject *self, void *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.allow_multifile")) {
    return NULL;
  }

  // 1-inline bool Patchfile::get_allow_multifile(void)
  bool return_value = (*local_this).get_allow_multifile();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Patchfile_allow_multifile_Setter(PyObject *self, PyObject *arg, void *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.allow_multifile")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete allow_multifile attribute");
    return -1;
  }
  // 1-inline void Patchfile::set_allow_multifile(bool allow_multifile)
  (*local_this).set_allow_multifile((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_allow_multifile(const Patchfile self, bool allow_multifile)\n");
  }
  return -1;
}

static PyObject *Dtool_Patchfile_footprint_length_Getter(PyObject *self, void *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.footprint_length")) {
    return NULL;
  }

  // 1-inline int Patchfile::get_footprint_length(void)
  int return_value = (*local_this).get_footprint_length();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Patchfile_footprint_length_Setter(PyObject *self, PyObject *arg, void *) {
  Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.footprint_length")) {
    return -1;
  }

  if (arg == (PyObject *)NULL) {
    Dtool_Raise_TypeError("can't delete footprint_length attribute");
    return -1;
  }
  // 1-inline void Patchfile::set_footprint_length(int length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (*local_this).set_footprint_length((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_footprint_length(const Patchfile self, int length)\n");
  }
  return -1;
}

static PyObject *Dtool_Patchfile_source_hash_Getter(PyObject *self, void *) {
  const Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }

  if (!local_this->has_source_hash()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline HashVal const &Patchfile::get_source_hash(void) const
  HashVal const *return_value = &((*(const Patchfile*)local_this).get_source_hash());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

static PyObject *Dtool_Patchfile_result_hash_Getter(PyObject *self, void *) {
  const Patchfile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline HashVal const &Patchfile::get_result_hash(void) const
  HashVal const *return_value = &((*(const Patchfile*)local_this).get_result_hash());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

/**
 * Python function wrapper for:
 * Patchfile::Patchfile(void)
 * Patchfile::Patchfile(PointerTo< Buffer > buffer)
 */
static int Dtool_Init_Patchfile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Patchfile::Patchfile(void)
      Patchfile *return_value = new Patchfile();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patchfile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "buffer");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'buffer' (pos 1) not found");
        return -1;
      }
      // 1-Patchfile::Patchfile(PointerTo< Buffer > buffer)
      Buffer *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Patchfile.Patchfile", false, true);
      if (arg_this != NULL) {
        Patchfile *return_value = new Patchfile(arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patchfile, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Patchfile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Patchfile()\n"
      "Patchfile(Buffer buffer)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Patchfile(PyObject *args, Patchfile const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Patchfile, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Patchfile::Patchfile(PointerTo< Buffer > buffer)
    Buffer *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Patchfile.Patchfile", false, false);
    if (arg_this != NULL) {
      Patchfile *return_value = new Patchfile(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_Patchfile(PyObject *args, Patchfile *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_Patchfile, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Patchfile::Patchfile(PointerTo< Buffer > buffer)
    Buffer *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Patchfile.Patchfile", false, false);
    if (arg_this != NULL) {
      Patchfile *return_value = new Patchfile(arg_this);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_Patchfile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_Patchfile) {
    printf("Patchfile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  Patchfile *local_this = (Patchfile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_Patchfile) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_Patchfile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_Patchfile) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class ProfileTimer
 */
/**
 * Python function wrapper for:
 * void ProfileTimer::init(char const *name, int maxEntries = 4096)
 */
static PyObject *Dtool_ProfileTimer_init_1559(PyObject *self, PyObject *args, PyObject *kwds) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProfileTimer, (void **)&local_this, "ProfileTimer.init")) {
    return NULL;
  }
  // 1-void ProfileTimer::init(char const *name, int maxEntries = 4096)
  char const *param1;
  int param2 = 4096;
  static const char *keyword_list[] = {"name", "maxEntries", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:init", (char **)keyword_list, &param1, &param2)) {
    (*local_this).init((char const *)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "init(const ProfileTimer self, str name, int maxEntries)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_init_1559_comment =
  "C++ Interface:\n"
  "init(const ProfileTimer self, str name, int maxEntries)\n";
#else
static const char *Dtool_ProfileTimer_init_1559_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProfileTimer::on(void)
 */
static PyObject *Dtool_ProfileTimer_on_1560(PyObject *self, PyObject *) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProfileTimer, (void **)&local_this, "ProfileTimer.on")) {
    return NULL;
  }
  // 1-void ProfileTimer::on(void)
  (*local_this).on();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_on_1560_comment =
  "C++ Interface:\n"
  "on(const ProfileTimer self)\n";
#else
static const char *Dtool_ProfileTimer_on_1560_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProfileTimer::mark(char const *tag)
 */
static PyObject *Dtool_ProfileTimer_mark_1561(PyObject *self, PyObject *arg) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProfileTimer, (void **)&local_this, "ProfileTimer.mark")) {
    return NULL;
  }
  // 1-void ProfileTimer::mark(char const *tag)
  char const *param1;
  if (PyArg_Parse(arg, "z:mark", &param1)) {
    (*local_this).mark((char const *)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mark(const ProfileTimer self, str tag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_mark_1561_comment =
  "C++ Interface:\n"
  "mark(const ProfileTimer self, str tag)\n";
#else
static const char *Dtool_ProfileTimer_mark_1561_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProfileTimer::off(void)
 * void ProfileTimer::off(char const *tag)
 */
static PyObject *Dtool_ProfileTimer_off_1562(PyObject *self, PyObject *args) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ProfileTimer, (void **)&local_this, "ProfileTimer.off")) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void ProfileTimer::off(void)
      (*local_this).off();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
        PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void ProfileTimer::off(char const *tag)
      char const *param1;
      if (PyArg_Parse(arg, "z:off", &param1)) {
        (*local_this).off((char const *)param1);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "off() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "off(const ProfileTimer self)\n"
      "off(const ProfileTimer self, str tag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_off_1562_comment =
  "C++ Interface:\n"
  "off(const ProfileTimer self)\n"
  "off(const ProfileTimer self, str tag)\n";
#else
static const char *Dtool_ProfileTimer_off_1562_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * double ProfileTimer::getTotalTime(void) const
 */
static PyObject *Dtool_ProfileTimer_getTotalTime_1563(PyObject *self, PyObject *) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProfileTimer, (void **)&local_this)) {
    return NULL;
  }
  // 1-double ProfileTimer::getTotalTime(void) const
  double return_value = (*(const ProfileTimer*)local_this).getTotalTime();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_getTotalTime_1563_comment =
  "C++ Interface:\n"
  "getTotalTime(ProfileTimer self)\n"
  "\n"
  "// Don't call any of the following during timing: (Because they are slow,\n"
  "// not because anything will break).";
#else
static const char *Dtool_ProfileTimer_getTotalTime_1563_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void ProfileTimer::consolidateAllTo(ostream &out = ::cout)
 */
static PyObject *Dtool_ProfileTimer_consolidateAllTo_1564(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static void ProfileTimer::consolidateAllTo(ostream &out)
      ProfileTimer::consolidateAllTo();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-static void ProfileTimer::consolidateAllTo(ostream &out)
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "ProfileTimer.consolidateAllTo", false, true);
      if (arg_this != NULL) {
        ProfileTimer::consolidateAllTo(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "consolidateAllTo() takes 0 or 1 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "consolidateAllTo()\n"
      "consolidateAllTo(ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_consolidateAllTo_1564_comment =
  "C++ Interface:\n"
  "consolidateAllTo()\n"
  "consolidateAllTo(ostream out)\n";
#else
static const char *Dtool_ProfileTimer_consolidateAllTo_1564_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProfileTimer::consolidateTo(ostream &out = ::cout) const
 */
static PyObject *Dtool_ProfileTimer_consolidateTo_1565(PyObject *self, PyObject *args, PyObject *kwds) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProfileTimer, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void ProfileTimer::consolidateTo(ostream &out) const
      (*(const ProfileTimer*)local_this).consolidateTo();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-void ProfileTimer::consolidateTo(ostream &out) const
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ProfileTimer.consolidateTo", false, true);
      if (arg_this != NULL) {
        (*(const ProfileTimer*)local_this).consolidateTo(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "consolidateTo() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "consolidateTo(ProfileTimer self)\n"
      "consolidateTo(ProfileTimer self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_consolidateTo_1565_comment =
  "C++ Interface:\n"
  "consolidateTo(ProfileTimer self)\n"
  "consolidateTo(ProfileTimer self, ostream out)\n";
#else
static const char *Dtool_ProfileTimer_consolidateTo_1565_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static void ProfileTimer::printAllTo(ostream &out = ::cout)
 */
static PyObject *Dtool_ProfileTimer_printAllTo_1566(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-static void ProfileTimer::printAllTo(ostream &out)
      ProfileTimer::printAllTo();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-static void ProfileTimer::printAllTo(ostream &out)
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 0, "ProfileTimer.printAllTo", false, true);
      if (arg_this != NULL) {
        ProfileTimer::printAllTo(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "printAllTo() takes 0 or 1 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "printAllTo()\n"
      "printAllTo(ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_printAllTo_1566_comment =
  "C++ Interface:\n"
  "printAllTo()\n"
  "printAllTo(ostream out)\n";
#else
static const char *Dtool_ProfileTimer_printAllTo_1566_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void ProfileTimer::printTo(ostream &out = ::cout) const
 */
static PyObject *Dtool_ProfileTimer_printTo_1567(PyObject *self, PyObject *args, PyObject *kwds) {
  ProfileTimer *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ProfileTimer, (void **)&local_this)) {
    return NULL;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void ProfileTimer::printTo(ostream &out) const
      (*(const ProfileTimer*)local_this).printTo();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "out");
      }
      if (arg == (PyObject *)NULL) {
        return Dtool_Raise_TypeError("Required argument 'out' (pos 1) not found");
      }
      // 1-void ProfileTimer::printTo(ostream &out) const
      ostream *arg_this = (ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ostream, 1, "ProfileTimer.printTo", false, true);
      if (arg_this != NULL) {
        (*(const ProfileTimer*)local_this).printTo(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "printTo() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "printTo(ProfileTimer self)\n"
      "printTo(ProfileTimer self, ostream out)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_ProfileTimer_printTo_1567_comment =
  "C++ Interface:\n"
  "printTo(ProfileTimer self)\n"
  "printTo(ProfileTimer self, ostream out)\n";
#else
static const char *Dtool_ProfileTimer_printTo_1567_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * ProfileTimer::ProfileTimer(ProfileTimer const &other)
 * ProfileTimer::ProfileTimer(char const *name = 0, int maxEntries = 4096)
 */
static int Dtool_Init_ProfileTimer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ProfileTimer::ProfileTimer(char const *name, int maxEntries)
      ProfileTimer *return_value = new ProfileTimer();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ProfileTimer, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 ProfileTimer::ProfileTimer(char const *name, int maxEntries = 4096)
        char const *param0;
        int param1 = 4096;
        static const char *keyword_list[] = {"name", "maxEntries", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "z|i:ProfileTimer", (char **)keyword_list, &param0, &param1)) {
          ProfileTimer *return_value = new ProfileTimer((char const *)param0, (int)param1);
          if (return_value == NULL) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ProfileTimer, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: ProfileTimer::ProfileTimer(char const *name, int maxEntries = 4096)
      {
        // -2 ProfileTimer::ProfileTimer(ProfileTimer const &other)
        PyObject *param0;
        static const char *keyword_list[] = {"other", NULL};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O:ProfileTimer", (char **)keyword_list, &param0)) {
          ProfileTimer const *param0_this;
          bool param0_manage = false;
          if (Dtool_ConstCoerce_ProfileTimer(param0, param0_this, param0_manage)) {
            ProfileTimer *return_value = new ProfileTimer(*param0_this);
            if (param0_manage) {
              delete param0_this;
            }
            if (return_value == NULL) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ProfileTimer, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ProfileTimer() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ProfileTimer()\n"
      "ProfileTimer(str name, int maxEntries)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ProfileTimer(PyObject *args, ProfileTimer const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ProfileTimer, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ProfileTimer::ProfileTimer(char const *name, int maxEntries)
    char const *param0;
    if (PyArg_Parse(arg, "z:ProfileTimer", &param0)) {
      ProfileTimer *return_value = new ProfileTimer((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ProfileTimer::ProfileTimer(char const *name, int maxEntries)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:ProfileTimer", &param0, &param1)) {
        ProfileTimer *return_value = new ProfileTimer((char const *)param0, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_ProfileTimer(PyObject *args, ProfileTimer *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_ProfileTimer, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ProfileTimer::ProfileTimer(char const *name, int maxEntries)
    char const *param0;
    if (PyArg_Parse(arg, "z:ProfileTimer", &param0)) {
      ProfileTimer *return_value = new ProfileTimer((char const *)param0);
      if (return_value == NULL) {
        PyErr_NoMemory();
        return false;
      }
      if (_PyErr_OCCURRED()) {
        delete return_value;
        return false;
      } else {
        coerced = return_value;
        manage = true;
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-ProfileTimer::ProfileTimer(char const *name, int maxEntries)
      char const *param0;
      int param1;
      if (PyArg_ParseTuple(args, "zi:ProfileTimer", &param0, &param1)) {
        ProfileTimer *return_value = new ProfileTimer((char const *)param0, (int)param1);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_ProfileTimer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_ProfileTimer) {
    printf("ProfileTimer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  ProfileTimer *local_this = (ProfileTimer *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_ProfileTimer) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_ProfileTimer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_ProfileTimer) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class WeakPointerToVoid
 */
/**
 * Python function wrapper for:
 * inline bool WeakPointerToVoid::was_deleted(void) const
 */
static PyObject *Dtool_WeakPointerToVoid_was_deleted_1569(PyObject *self, PyObject *) {
  WeakPointerToVoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakPointerToVoid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool WeakPointerToVoid::was_deleted(void) const
  bool return_value = (*(const WeakPointerToVoid*)local_this).was_deleted();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakPointerToVoid_was_deleted_1569_comment =
  "C++ Interface:\n"
  "was_deleted(WeakPointerToVoid self)\n"
  "\n"
  "/**\n"
  " * Returns true if the object we are pointing to has been deleted, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_WeakPointerToVoid_was_deleted_1569_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool WeakPointerToVoid::is_valid_pointer(void) const
 */
static PyObject *Dtool_WeakPointerToVoid_is_valid_pointer_1570(PyObject *self, PyObject *) {
  WeakPointerToVoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WeakPointerToVoid, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool WeakPointerToVoid::is_valid_pointer(void) const
  bool return_value = (*(const WeakPointerToVoid*)local_this).is_valid_pointer();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakPointerToVoid_is_valid_pointer_1570_comment =
  "C++ Interface:\n"
  "is_valid_pointer(WeakPointerToVoid self)\n"
  "\n"
  "/**\n"
  " * Returns true if the pointer is not null and the object has not been\n"
  " * deleted.\n"
  " */";
#else
static const char *Dtool_WeakPointerToVoid_is_valid_pointer_1570_comment = NULL;
#endif

static int Dtool_Init_WeakPointerToVoid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_WeakPointerToVoid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_WeakPointerToVoid) {
    printf("WeakPointerToVoid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  WeakPointerToVoid *local_this = (WeakPointerToVoid *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_WeakPointerToVoid) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_WeakPointerToVoid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_WeakPointerToVoid) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (WeakPointerToVoid*)other_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class WindowsRegistry
 */
/**
 * Python function wrapper for:
 * static bool WindowsRegistry::set_string_value(std::string const &key, std::string const &name, std::string const &value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
 */
static PyObject *Dtool_WindowsRegistry_set_string_value_1573(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool WindowsRegistry::set_string_value(std::string const &key, std::string const &name, std::string const &value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  int param3 = WindowsRegistry::rl_machine;
  static const char *keyword_list[] = {"key", "name", "value", "rl", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#|i:set_string_value", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    bool return_value = WindowsRegistry::set_string_value(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (WindowsRegistry::RegLevel)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_string_value(str key, str name, str value, int rl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WindowsRegistry_set_string_value_1573_comment =
  "C++ Interface:\n"
  "set_string_value(str key, str name, str value, int rl)\n"
  "\n"
  "/**\n"
  " * Sets the registry key to the indicated value as a string.  The supplied\n"
  " * string value is automatically converted from whatever encoding is set by\n"
  " * TextEncoder::set_default_encoding() and written as a Unicode string.  The\n"
  " * registry key must already exist prior to calling this function.\n"
  " */";
#else
static const char *Dtool_WindowsRegistry_set_string_value_1573_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static bool WindowsRegistry::set_int_value(std::string const &key, std::string const &name, int value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
 */
static PyObject *Dtool_WindowsRegistry_set_int_value_1574(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static bool WindowsRegistry::set_int_value(std::string const &key, std::string const &name, int value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  int param3 = WindowsRegistry::rl_machine;
  static const char *keyword_list[] = {"key", "name", "value", "rl", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#i|i:set_int_value", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3)) {
    bool return_value = WindowsRegistry::set_int_value(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2, (WindowsRegistry::RegLevel)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_int_value(str key, str name, int value, int rl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WindowsRegistry_set_int_value_1574_comment =
  "C++ Interface:\n"
  "set_int_value(str key, str name, int value, int rl)\n"
  "\n"
  "/**\n"
  " * Sets the registry key to the indicated value as an integer.  The registry\n"
  " * key must already exist prior to calling this function.\n"
  " */";
#else
static const char *Dtool_WindowsRegistry_set_int_value_1574_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static WindowsRegistry::Type WindowsRegistry::get_key_type(std::string const &key, std::string const &name, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
 */
static PyObject *Dtool_WindowsRegistry_get_key_type_1576(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static WindowsRegistry::Type WindowsRegistry::get_key_type(std::string const &key, std::string const &name, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2 = WindowsRegistry::rl_machine;
  static const char *keyword_list[] = {"key", "name", "rl", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|i:get_key_type", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2)) {
    WindowsRegistry::Type return_value = WindowsRegistry::get_key_type(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (WindowsRegistry::RegLevel)param2);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_key_type(str key, str name, int rl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WindowsRegistry_get_key_type_1576_comment =
  "C++ Interface:\n"
  "get_key_type(str key, str name, int rl)\n"
  "\n"
  "/**\n"
  " * Returns the type of the indicated key, or T_none if the key is not known or\n"
  " * is some unsupported type.\n"
  " */";
#else
static const char *Dtool_WindowsRegistry_get_key_type_1576_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static std::string WindowsRegistry::get_string_value(std::string const &key, std::string const &name, std::string const &default_value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
 */
static PyObject *Dtool_WindowsRegistry_get_string_value_1577(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static std::string WindowsRegistry::get_string_value(std::string const &key, std::string const &name, std::string const &default_value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  char *param2_str = NULL;
  Py_ssize_t param2_len;
  int param3 = WindowsRegistry::rl_machine;
  static const char *keyword_list[] = {"key", "name", "default_value", "rl", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#|i:get_string_value", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
    std::string return_value = WindowsRegistry::get_string_value(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (WindowsRegistry::RegLevel)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_string_value(str key, str name, str default_value, int rl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WindowsRegistry_get_string_value_1577_comment =
  "C++ Interface:\n"
  "get_string_value(str key, str name, str default_value, int rl)\n"
  "\n"
  "/**\n"
  " * Returns the value associated with the indicated registry key, assuming it\n"
  " * is a string value.  The string value is automatically encoded using\n"
  " * TextEncoder::get_default_encoding().  If the key is not defined or is not a\n"
  " * string type value, default_value is returned instead.\n"
  " */";
#else
static const char *Dtool_WindowsRegistry_get_string_value_1577_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static int WindowsRegistry::get_int_value(std::string const &key, std::string const &name, int default_value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
 */
static PyObject *Dtool_WindowsRegistry_get_int_value_1578(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int WindowsRegistry::get_int_value(std::string const &key, std::string const &name, int default_value, WindowsRegistry::RegLevel rl = ::WindowsRegistry::rl_machine)
  char *param0_str = NULL;
  Py_ssize_t param0_len;
  char *param1_str = NULL;
  Py_ssize_t param1_len;
  int param2;
  int param3 = WindowsRegistry::rl_machine;
  static const char *keyword_list[] = {"key", "name", "default_value", "rl", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#i|i:get_int_value", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3)) {
    int return_value = WindowsRegistry::get_int_value(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2, (WindowsRegistry::RegLevel)param3);
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_int_value(str key, str name, int default_value, int rl)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_WindowsRegistry_get_int_value_1578_comment =
  "C++ Interface:\n"
  "get_int_value(str key, str name, int default_value, int rl)\n"
  "\n"
  "/**\n"
  " * Returns the value associated with the indicated registry key, assuming it\n"
  " * is an integer value.  If the key is not defined or is not an integer type\n"
  " * value, default_value is returned instead.\n"
  " */";
#else
static const char *Dtool_WindowsRegistry_get_int_value_1578_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline WindowsRegistry::WindowsRegistry(void) = default
 * inline WindowsRegistry::WindowsRegistry(WindowsRegistry const &) = default
 */
static int Dtool_Init_WindowsRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != NULL) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline WindowsRegistry::WindowsRegistry(void) = default
      WindowsRegistry *return_value = new WindowsRegistry();
      if (return_value == NULL) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowsRegistry, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = NULL;
      if (PyTuple_GET_SIZE(args) == 1) {
        arg = PyTuple_GET_ITEM(args, 0);
      } else if (kwds != NULL) {
        arg = PyDict_GetItemString(kwds, "param0");
      }
      if (arg == (PyObject *)NULL) {
        Dtool_Raise_TypeError("Required argument 'param0' (pos 1) not found");
        return -1;
      }
      // 1-inline WindowsRegistry::WindowsRegistry(WindowsRegistry const &) = default
      WindowsRegistry const *arg_this = (WindowsRegistry *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WindowsRegistry, 0, "WindowsRegistry.WindowsRegistry", true, true);
      if (arg_this != NULL) {
        WindowsRegistry *return_value = new WindowsRegistry(*arg_this);
        if (return_value == NULL) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowsRegistry, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "WindowsRegistry() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WindowsRegistry()\n"
      "WindowsRegistry(const WindowsRegistry param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_WindowsRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_WindowsRegistry) {
    printf("WindowsRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  WindowsRegistry *local_this = (WindowsRegistry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_WindowsRegistry) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_WindowsRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_WindowsRegistry) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for ConstPointerToArray_double (ConstPointerToArray_double)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_double[] = {
  {"get_element", &Dtool_ConstPointerToArray_double_get_element_14, METH_O, (const char *)Dtool_ConstPointerToArray_double_get_element_14_comment},
  {"getElement", &Dtool_ConstPointerToArray_double_get_element_14, METH_O, (const char *)Dtool_ConstPointerToArray_double_get_element_14_comment},
  {"get_data", &Dtool_ConstPointerToArray_double_get_data_16, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_data_16_comment},
  {"getData", &Dtool_ConstPointerToArray_double_get_data_16, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_data_16_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_double_get_subdata_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_double_get_subdata_17_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_double_get_subdata_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_double_get_subdata_17_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_double_get_ref_count_18, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_ref_count_18_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_double_get_ref_count_18, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_ref_count_18_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_double_get_node_ref_count_19, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_node_ref_count_19_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_double_get_node_ref_count_19, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_node_ref_count_19_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_double_getbuffer_20_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< double > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_double_releasebuffer_21_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< double > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_double_getitem_15_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_double index out of range");
    return NULL;
  }
  // 1-double const &ConstPointerToArray< double >::__getitem__(unsigned long int n) const
  double return_value = invoke_extension((const ConstPointerToArray< double >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_double_size_13_sq_length(PyObject *self) {
  ConstPointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_double = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_double = {
  &Dtool_ConstPointerToArray_double_size_13_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_double_getitem_15_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_double = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_double = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_double_getbuffer_20_bf_getbuffer,
  &Dtool_ConstPointerToArray_double_releasebuffer_21_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_double = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_double",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_double,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_double,
    &Dtool_SequenceMethods_ConstPointerToArray_double,
    &Dtool_MappingMethods_ConstPointerToArray_double,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_double,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_double,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_double,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_double,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_double,
  Dtool_UpcastInterface_ConstPointerToArray_double,
  Dtool_DowncastInterface_ConstPointerToArray_double,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_double,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_double(NULL);
    Dtool_ConstPointerToArray_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_double);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_double);
  }
}

/**
 * Python method tables for PointerToArrayBase_double (PointerToArrayBase_double)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_double[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_double = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_double = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_double = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_double = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_double = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_double",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_double,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_double,
    &Dtool_SequenceMethods_PointerToArrayBase_double,
    &Dtool_MappingMethods_PointerToArrayBase_double,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_double,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_double,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_double,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_double,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_double,
  Dtool_UpcastInterface_PointerToArrayBase_double,
  Dtool_DowncastInterface_PointerToArrayBase_double,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(NULL);
    Dtool_PointerToArrayBase_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_double);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_double (PointerToBase_ReferenceCountedVector_double)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_double[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_double_clear_9, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_double_clear_9_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_double_output_10, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_double_output_10_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_double
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_double(PyObject *self) {
  PointerToBase< ReferenceCountedVector< double > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_double, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_double = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_double = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_double = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_double = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_double = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_double",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_double,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_double,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_double,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_double,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_double,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_double,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_double,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_double,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_double,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_double,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_double,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_double,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
  }
}

/**
 * Python method tables for PointerToVoid (PointerToVoid)
 */
static PyMethodDef Dtool_Methods_PointerToVoid[] = {
  {"is_null", &Dtool_PointerToVoid_is_null_7, METH_NOARGS, (const char *)Dtool_PointerToVoid_is_null_7_comment},
  {"isNull", &Dtool_PointerToVoid_is_null_7, METH_NOARGS, (const char *)Dtool_PointerToVoid_is_null_7_comment},
  {"get_hash", &Dtool_PointerToVoid_get_hash_8, METH_NOARGS, (const char *)Dtool_PointerToVoid_get_hash_8_comment},
  {"getHash", &Dtool_PointerToVoid_get_hash_8, METH_NOARGS, (const char *)Dtool_PointerToVoid_get_hash_8_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToVoid slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_PointerToVoid_get_hash_8_tp_hash(PyObject *self) {
  PointerToVoid *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToVoid, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

static PyNumberMethods Dtool_NumberMethods_PointerToVoid = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToVoid = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToVoid = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToVoid = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToVoid = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToVoid",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToVoid,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToVoid,
    &Dtool_SequenceMethods_PointerToVoid,
    &Dtool_MappingMethods_PointerToVoid,
    &Dtool_PointerToVoid_get_hash_8_tp_hash,
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToVoid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the non-template part of the base class for PointerTo and\n"
    " * ConstPointerTo.  It is necessary so we can keep a pointer to a non-template\n"
    " * class within the ReferenceCount object, to implement weak reference\n"
    " * pointers--we need to have something to clean up when the ReferenceCount\n"
    " * object destructs.\n"
    " *\n"
    " * This is the base class for PointerToBase<T>.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DTOOL_PyObject_RichCompare,
#else
    0, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToVoid,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToVoid,
    PyType_GenericAlloc,
    Dtool_new_PointerToVoid,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToVoid,
  Dtool_UpcastInterface_PointerToVoid,
  Dtool_DowncastInterface_PointerToVoid,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToVoid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PointerToVoid._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PointerToVoid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToVoid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToVoid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToVoid);
  }
}

/**
 * Python method tables for ConstPointerToArray_float (ConstPointerToArray_float)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_float[] = {
  {"get_element", &Dtool_ConstPointerToArray_float_get_element_32, METH_O, (const char *)Dtool_ConstPointerToArray_float_get_element_32_comment},
  {"getElement", &Dtool_ConstPointerToArray_float_get_element_32, METH_O, (const char *)Dtool_ConstPointerToArray_float_get_element_32_comment},
  {"get_data", &Dtool_ConstPointerToArray_float_get_data_34, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_data_34_comment},
  {"getData", &Dtool_ConstPointerToArray_float_get_data_34, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_data_34_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_float_get_subdata_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_float_get_subdata_35_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_float_get_subdata_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_float_get_subdata_35_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_float_get_ref_count_36, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_ref_count_36_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_float_get_ref_count_36, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_ref_count_36_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_float_get_node_ref_count_37, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_node_ref_count_37_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_float_get_node_ref_count_37, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_node_ref_count_37_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_float_getbuffer_38_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< float > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_float_releasebuffer_39_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< float > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_float_getitem_33_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_float index out of range");
    return NULL;
  }
  // 1-float const &ConstPointerToArray< float >::__getitem__(unsigned long int n) const
  float return_value = invoke_extension((const ConstPointerToArray< float >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_float_size_31_sq_length(PyObject *self) {
  ConstPointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_float = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_float = {
  &Dtool_ConstPointerToArray_float_size_31_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_float_getitem_33_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_float = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_float = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_float_getbuffer_38_bf_getbuffer,
  &Dtool_ConstPointerToArray_float_releasebuffer_39_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_float = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_float",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_float,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_float,
    &Dtool_SequenceMethods_ConstPointerToArray_float,
    &Dtool_MappingMethods_ConstPointerToArray_float,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_float,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_float,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_float,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_float,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_float,
  Dtool_UpcastInterface_ConstPointerToArray_float,
  Dtool_DowncastInterface_ConstPointerToArray_float,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_float,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_float(NULL);
    Dtool_ConstPointerToArray_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_float);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_float);
  }
}

/**
 * Python method tables for PointerToArrayBase_float (PointerToArrayBase_float)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_float[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_float = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_float = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_float = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_float = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_float = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_float",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_float,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_float,
    &Dtool_SequenceMethods_PointerToArrayBase_float,
    &Dtool_MappingMethods_PointerToArrayBase_float,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_float,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_float,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_float,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_float,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_float,
  Dtool_UpcastInterface_PointerToArrayBase_float,
  Dtool_DowncastInterface_PointerToArrayBase_float,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(NULL);
    Dtool_PointerToArrayBase_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_float);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_float (PointerToBase_ReferenceCountedVector_float)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_float[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_float_clear_27, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_float_clear_27_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_float_output_28, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_float_output_28_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_float
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_float(PyObject *self) {
  PointerToBase< ReferenceCountedVector< float > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_float, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_float = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_float = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_float = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_float = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_float = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_float",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_float,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_float,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_float,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_float,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_float,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_float,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_float,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_float,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_float,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_float,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_float,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_float,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
  }
}

/**
 * Python method tables for ConstPointerToArray_int (ConstPointerToArray_int)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_int[] = {
  {"get_element", &Dtool_ConstPointerToArray_int_get_element_50, METH_O, (const char *)Dtool_ConstPointerToArray_int_get_element_50_comment},
  {"getElement", &Dtool_ConstPointerToArray_int_get_element_50, METH_O, (const char *)Dtool_ConstPointerToArray_int_get_element_50_comment},
  {"get_data", &Dtool_ConstPointerToArray_int_get_data_52, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_data_52_comment},
  {"getData", &Dtool_ConstPointerToArray_int_get_data_52, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_data_52_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_int_get_subdata_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_int_get_subdata_53_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_int_get_subdata_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_int_get_subdata_53_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_int_get_ref_count_54, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_ref_count_54_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_int_get_ref_count_54, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_ref_count_54_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_int_get_node_ref_count_55, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_node_ref_count_55_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_int_get_node_ref_count_55, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_node_ref_count_55_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_int_getbuffer_56_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< int > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_int_releasebuffer_57_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< int > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_int_getitem_51_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_int index out of range");
    return NULL;
  }
  // 1-int const &ConstPointerToArray< int >::__getitem__(unsigned long int n) const
  int return_value = invoke_extension((const ConstPointerToArray< int >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_int_size_49_sq_length(PyObject *self) {
  ConstPointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_int = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_int = {
  &Dtool_ConstPointerToArray_int_size_49_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_int_getitem_51_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_int = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_int = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_int_getbuffer_56_bf_getbuffer,
  &Dtool_ConstPointerToArray_int_releasebuffer_57_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_int = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_int",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_int,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_int,
    &Dtool_SequenceMethods_ConstPointerToArray_int,
    &Dtool_MappingMethods_ConstPointerToArray_int,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_int,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_int,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_int,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_int,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_int,
  Dtool_UpcastInterface_ConstPointerToArray_int,
  Dtool_DowncastInterface_ConstPointerToArray_int,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_int,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_int(NULL);
    Dtool_ConstPointerToArray_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_int);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_int);
  }
}

/**
 * Python method tables for PointerToArrayBase_int (PointerToArrayBase_int)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_int[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_int = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_int = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_int = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_int = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_int = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_int",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_int,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_int,
    &Dtool_SequenceMethods_PointerToArrayBase_int,
    &Dtool_MappingMethods_PointerToArrayBase_int,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_int,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_int,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_int,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_int,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_int,
  Dtool_UpcastInterface_PointerToArrayBase_int,
  Dtool_DowncastInterface_PointerToArrayBase_int,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(NULL);
    Dtool_PointerToArrayBase_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_int);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_int (PointerToBase_ReferenceCountedVector_int)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_int[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_int_clear_45, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_int_clear_45_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_int_output_46, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_int_output_46_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_int
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_int(PyObject *self) {
  PointerToBase< ReferenceCountedVector< int > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_int, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_int = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_int = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_int = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_int = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_int = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_int",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_int,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_int,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_int,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_int,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_int,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_int,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_int,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_int,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_int,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_int,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_int,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_int,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
  }
}

/**
 * Python method tables for ConstPointerToArray_unsigned_char (ConstPointerToArray_unsigned_char)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_unsigned_char[] = {
  {"get_element", &Dtool_ConstPointerToArray_unsigned_char_get_element_68, METH_O, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_element_68_comment},
  {"getElement", &Dtool_ConstPointerToArray_unsigned_char_get_element_68, METH_O, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_element_68_comment},
  {"get_data", &Dtool_ConstPointerToArray_unsigned_char_get_data_70, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_data_70_comment},
  {"getData", &Dtool_ConstPointerToArray_unsigned_char_get_data_70, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_data_70_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_unsigned_char_get_subdata_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_subdata_71_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_unsigned_char_get_subdata_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_subdata_71_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_ref_count_72_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_73_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_unsigned_char_getbuffer_74_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< unsigned char > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_unsigned_char_releasebuffer_75_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< unsigned char > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_unsigned_char_getitem_69_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_unsigned_char index out of range");
    return NULL;
  }
  // 1-unsigned char const &ConstPointerToArray< unsigned char >::__getitem__(unsigned long int n) const
  unsigned char return_value = invoke_extension((const ConstPointerToArray< unsigned char >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_unsigned_char_size_67_sq_length(PyObject *self) {
  ConstPointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_unsigned_char = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_unsigned_char = {
  &Dtool_ConstPointerToArray_unsigned_char_size_67_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConstPointerToArray_unsigned_char_getitem_69_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_unsigned_char = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_unsigned_char_getbuffer_74_bf_getbuffer,
  &Dtool_ConstPointerToArray_unsigned_char_releasebuffer_75_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConstPointerToArray_unsigned_char",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_unsigned_char,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConstPointerToArray_unsigned_char,
    &Dtool_SequenceMethods_ConstPointerToArray_unsigned_char,
    &Dtool_MappingMethods_ConstPointerToArray_unsigned_char,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConstPointerToArray_unsigned_char,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConstPointerToArray_unsigned_char,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_unsigned_char,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char,
  Dtool_UpcastInterface_ConstPointerToArray_unsigned_char,
  Dtool_DowncastInterface_ConstPointerToArray_unsigned_char,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_unsigned_char,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(NULL);
    Dtool_ConstPointerToArray_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char);
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_unsigned_char);
  }
}

/**
 * Python method tables for PointerToArrayBase_unsigned_char (PointerToArrayBase_unsigned_char)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_unsigned_char[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_unsigned_char = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_unsigned_char = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_unsigned_char = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArrayBase_unsigned_char",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_unsigned_char,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArrayBase_unsigned_char,
    &Dtool_SequenceMethods_PointerToArrayBase_unsigned_char,
    &Dtool_MappingMethods_PointerToArrayBase_unsigned_char,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArrayBase_unsigned_char,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArrayBase_unsigned_char,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_unsigned_char,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char,
  Dtool_UpcastInterface_PointerToArrayBase_unsigned_char,
  Dtool_DowncastInterface_PointerToArrayBase_unsigned_char,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(NULL);
    Dtool_PointerToArrayBase_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_unsigned_char (PointerToBase_ReferenceCountedVector_unsigned_char)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_unsigned_char[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_63, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_63_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_64, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_64_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_unsigned_char
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self) {
  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_unsigned_char, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_unsigned_char",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_unsigned_char,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_unsigned_char,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_ReferenceCountedVector_unsigned_char,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_unsigned_char,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_unsigned_char,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_unsigned_char,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(NULL);
    Dtool_PointerToBase_ReferenceCountedVector_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
  }
}

/**
 * Python method tables for ConfigDeclaration (ConfigDeclaration)
 */
static PyMethodDef Dtool_Methods_ConfigDeclaration[] = {
  {"get_page", &Dtool_ConfigDeclaration_get_page_83, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_page_83_comment},
  {"getPage", &Dtool_ConfigDeclaration_get_page_83, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_page_83_comment},
  {"get_variable", &Dtool_ConfigDeclaration_get_variable_84, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_variable_84_comment},
  {"getVariable", &Dtool_ConfigDeclaration_get_variable_84, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_variable_84_comment},
  {"get_string_value", &Dtool_ConfigDeclaration_get_string_value_176, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_string_value_176_comment},
  {"getStringValue", &Dtool_ConfigDeclaration_get_string_value_176, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_string_value_176_comment},
  {"set_string_value", &Dtool_ConfigDeclaration_set_string_value_177, METH_O, (const char *)Dtool_ConfigDeclaration_set_string_value_177_comment},
  {"setStringValue", &Dtool_ConfigDeclaration_set_string_value_177, METH_O, (const char *)Dtool_ConfigDeclaration_set_string_value_177_comment},
  {"get_num_words", &Dtool_ConfigDeclaration_get_num_words_178, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_num_words_178_comment},
  {"getNumWords", &Dtool_ConfigDeclaration_get_num_words_178, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_num_words_178_comment},
  {"has_string_word", &Dtool_ConfigDeclaration_has_string_word_179, METH_O, (const char *)Dtool_ConfigDeclaration_has_string_word_179_comment},
  {"hasStringWord", &Dtool_ConfigDeclaration_has_string_word_179, METH_O, (const char *)Dtool_ConfigDeclaration_has_string_word_179_comment},
  {"has_bool_word", &Dtool_ConfigDeclaration_has_bool_word_180, METH_O, (const char *)Dtool_ConfigDeclaration_has_bool_word_180_comment},
  {"hasBoolWord", &Dtool_ConfigDeclaration_has_bool_word_180, METH_O, (const char *)Dtool_ConfigDeclaration_has_bool_word_180_comment},
  {"has_int_word", &Dtool_ConfigDeclaration_has_int_word_181, METH_O, (const char *)Dtool_ConfigDeclaration_has_int_word_181_comment},
  {"hasIntWord", &Dtool_ConfigDeclaration_has_int_word_181, METH_O, (const char *)Dtool_ConfigDeclaration_has_int_word_181_comment},
  {"has_int64_word", &Dtool_ConfigDeclaration_has_int64_word_182, METH_O, (const char *)Dtool_ConfigDeclaration_has_int64_word_182_comment},
  {"hasInt64Word", &Dtool_ConfigDeclaration_has_int64_word_182, METH_O, (const char *)Dtool_ConfigDeclaration_has_int64_word_182_comment},
  {"has_double_word", &Dtool_ConfigDeclaration_has_double_word_183, METH_O, (const char *)Dtool_ConfigDeclaration_has_double_word_183_comment},
  {"hasDoubleWord", &Dtool_ConfigDeclaration_has_double_word_183, METH_O, (const char *)Dtool_ConfigDeclaration_has_double_word_183_comment},
  {"get_string_word", &Dtool_ConfigDeclaration_get_string_word_184, METH_O, (const char *)Dtool_ConfigDeclaration_get_string_word_184_comment},
  {"getStringWord", &Dtool_ConfigDeclaration_get_string_word_184, METH_O, (const char *)Dtool_ConfigDeclaration_get_string_word_184_comment},
  {"get_bool_word", &Dtool_ConfigDeclaration_get_bool_word_185, METH_O, (const char *)Dtool_ConfigDeclaration_get_bool_word_185_comment},
  {"getBoolWord", &Dtool_ConfigDeclaration_get_bool_word_185, METH_O, (const char *)Dtool_ConfigDeclaration_get_bool_word_185_comment},
  {"get_int_word", &Dtool_ConfigDeclaration_get_int_word_186, METH_O, (const char *)Dtool_ConfigDeclaration_get_int_word_186_comment},
  {"getIntWord", &Dtool_ConfigDeclaration_get_int_word_186, METH_O, (const char *)Dtool_ConfigDeclaration_get_int_word_186_comment},
  {"get_int64_word", &Dtool_ConfigDeclaration_get_int64_word_187, METH_O, (const char *)Dtool_ConfigDeclaration_get_int64_word_187_comment},
  {"getInt64Word", &Dtool_ConfigDeclaration_get_int64_word_187, METH_O, (const char *)Dtool_ConfigDeclaration_get_int64_word_187_comment},
  {"get_double_word", &Dtool_ConfigDeclaration_get_double_word_188, METH_O, (const char *)Dtool_ConfigDeclaration_get_double_word_188_comment},
  {"getDoubleWord", &Dtool_ConfigDeclaration_get_double_word_188, METH_O, (const char *)Dtool_ConfigDeclaration_get_double_word_188_comment},
  {"set_string_word", (PyCFunction) &Dtool_ConfigDeclaration_set_string_word_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_string_word_189_comment},
  {"setStringWord", (PyCFunction) &Dtool_ConfigDeclaration_set_string_word_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_string_word_189_comment},
  {"set_bool_word", (PyCFunction) &Dtool_ConfigDeclaration_set_bool_word_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_bool_word_190_comment},
  {"setBoolWord", (PyCFunction) &Dtool_ConfigDeclaration_set_bool_word_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_bool_word_190_comment},
  {"set_int_word", (PyCFunction) &Dtool_ConfigDeclaration_set_int_word_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int_word_191_comment},
  {"setIntWord", (PyCFunction) &Dtool_ConfigDeclaration_set_int_word_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int_word_191_comment},
  {"set_int64_word", (PyCFunction) &Dtool_ConfigDeclaration_set_int64_word_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int64_word_192_comment},
  {"setInt64Word", (PyCFunction) &Dtool_ConfigDeclaration_set_int64_word_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_int64_word_192_comment},
  {"set_double_word", (PyCFunction) &Dtool_ConfigDeclaration_set_double_word_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_double_word_193_comment},
  {"setDoubleWord", (PyCFunction) &Dtool_ConfigDeclaration_set_double_word_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigDeclaration_set_double_word_193_comment},
  {"get_decl_seq", &Dtool_ConfigDeclaration_get_decl_seq_194, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_decl_seq_194_comment},
  {"getDeclSeq", &Dtool_ConfigDeclaration_get_decl_seq_194, METH_NOARGS, (const char *)Dtool_ConfigDeclaration_get_decl_seq_194_comment},
  {"output", &Dtool_ConfigDeclaration_output_195, METH_O, (const char *)Dtool_ConfigDeclaration_output_195_comment},
  {"write", &Dtool_ConfigDeclaration_write_196, METH_O, (const char *)Dtool_ConfigDeclaration_write_196_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigDeclaration
//////////////////
static PyObject *Dtool_Repr_ConfigDeclaration(PyObject *self) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigDeclaration
//////////////////
static PyObject *Dtool_Str_ConfigDeclaration(PyObject *self) {
  ConfigDeclaration *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigDeclaration, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigDeclaration[] = {
  {(char *)"page", &Dtool_ConfigDeclaration_page_Getter, NULL, NULL, NULL},
  {(char *)"variable", &Dtool_ConfigDeclaration_variable_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigDeclaration = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigDeclaration = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigDeclaration = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigDeclaration = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigDeclaration = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigDeclaration",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigDeclaration,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigDeclaration,
    &Dtool_NumberMethods_ConfigDeclaration,
    &Dtool_SequenceMethods_ConfigDeclaration,
    &Dtool_MappingMethods_ConfigDeclaration,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigDeclaration,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigDeclaration,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A single declaration of a config variable, typically defined as one line in\n"
    " * a .prc file, e.g.  \"show-frame-rate-meter 1\".  This is really just a\n"
    " * pairing of a string name (actually, a ConfigVariableCore pointer) to a\n"
    " * string value.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigDeclaration,
    0, // tp_members
    Dtool_Properties_ConfigDeclaration,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigDeclaration,
    PyType_GenericAlloc,
    Dtool_new_ConfigDeclaration,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigDeclaration,
  Dtool_UpcastInterface_ConfigDeclaration,
  Dtool_DowncastInterface_ConfigDeclaration,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigDeclaration(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(NULL);
    Dtool_ConfigDeclaration._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    PyObject *dict = PyDict_New();
    Dtool_ConfigDeclaration._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigDeclaration) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigDeclaration)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigDeclaration);
  }
}

/**
 * Python method tables for ConfigFlags (ConfigFlags)
 */
static PyMethodDef Dtool_Methods_ConfigFlags[] = {
  {"downcast_to_NotifyCategory", &Dtool_ConfigFlags_downcast_to_NotifyCategory_674, METH_NOARGS, (const char *)Dtool_ConfigFlags_downcast_to_NotifyCategory_674_comment},
  {"downcastToNotifyCategory", &Dtool_ConfigFlags_downcast_to_NotifyCategory_674, METH_NOARGS, (const char *)Dtool_ConfigFlags_downcast_to_NotifyCategory_674_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConfigFlags = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigFlags = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigFlags",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigFlags,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigFlags,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is the base class of both ConfigVariable and ConfigVariableCore.\n"
    " * It exists only to provide a convenient name scoping for some enumerated\n"
    " * values common to both classes.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigFlags,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigFlags,
    PyType_GenericAlloc,
    Dtool_new_ConfigFlags,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigFlags,
  Dtool_UpcastInterface_ConfigFlags,
  Dtool_DowncastInterface_ConfigFlags,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigFlags(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConfigFlags._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(33);
    Dtool_ConfigFlags._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ConfigFlags::ValueType;
    PyDict_SetItemString(dict, "VT_undefined", Dtool_WrapValue(ConfigFlags::VT_undefined));
    PyDict_SetItemString(dict, "VTUndefined", Dtool_WrapValue(ConfigFlags::VT_undefined));
    PyDict_SetItemString(dict, "VT_list", Dtool_WrapValue(ConfigFlags::VT_list));
    PyDict_SetItemString(dict, "VTList", Dtool_WrapValue(ConfigFlags::VT_list));
    PyDict_SetItemString(dict, "VT_string", Dtool_WrapValue(ConfigFlags::VT_string));
    PyDict_SetItemString(dict, "VTString", Dtool_WrapValue(ConfigFlags::VT_string));
    PyDict_SetItemString(dict, "VT_filename", Dtool_WrapValue(ConfigFlags::VT_filename));
    PyDict_SetItemString(dict, "VTFilename", Dtool_WrapValue(ConfigFlags::VT_filename));
    PyDict_SetItemString(dict, "VT_bool", Dtool_WrapValue(ConfigFlags::VT_bool));
    PyDict_SetItemString(dict, "VTBool", Dtool_WrapValue(ConfigFlags::VT_bool));
    PyDict_SetItemString(dict, "VT_int", Dtool_WrapValue(ConfigFlags::VT_int));
    PyDict_SetItemString(dict, "VTInt", Dtool_WrapValue(ConfigFlags::VT_int));
    PyDict_SetItemString(dict, "VT_double", Dtool_WrapValue(ConfigFlags::VT_double));
    PyDict_SetItemString(dict, "VTDouble", Dtool_WrapValue(ConfigFlags::VT_double));
    PyDict_SetItemString(dict, "VT_enum", Dtool_WrapValue(ConfigFlags::VT_enum));
    PyDict_SetItemString(dict, "VTEnum", Dtool_WrapValue(ConfigFlags::VT_enum));
    PyDict_SetItemString(dict, "VT_search_path", Dtool_WrapValue(ConfigFlags::VT_search_path));
    PyDict_SetItemString(dict, "VTSearchPath", Dtool_WrapValue(ConfigFlags::VT_search_path));
    PyDict_SetItemString(dict, "VT_int64", Dtool_WrapValue(ConfigFlags::VT_int64));
    PyDict_SetItemString(dict, "VTInt64", Dtool_WrapValue(ConfigFlags::VT_int64));
    PyDict_SetItemString(dict, "VT_color", Dtool_WrapValue(ConfigFlags::VT_color));
    PyDict_SetItemString(dict, "VTColor", Dtool_WrapValue(ConfigFlags::VT_color));
    // enum ConfigFlags::VariableFlags;
    PyDict_SetItemString(dict, "F_trust_level_mask", Dtool_WrapValue(ConfigFlags::F_trust_level_mask));
    PyDict_SetItemString(dict, "FTrustLevelMask", Dtool_WrapValue(ConfigFlags::F_trust_level_mask));
    PyDict_SetItemString(dict, "F_open", Dtool_WrapValue(ConfigFlags::F_open));
    PyDict_SetItemString(dict, "FOpen", Dtool_WrapValue(ConfigFlags::F_open));
    PyDict_SetItemString(dict, "F_closed", Dtool_WrapValue(ConfigFlags::F_closed));
    PyDict_SetItemString(dict, "FClosed", Dtool_WrapValue(ConfigFlags::F_closed));
    PyDict_SetItemString(dict, "F_dynamic", Dtool_WrapValue(ConfigFlags::F_dynamic));
    PyDict_SetItemString(dict, "FDynamic", Dtool_WrapValue(ConfigFlags::F_dynamic));
    PyDict_SetItemString(dict, "F_dconfig", Dtool_WrapValue(ConfigFlags::F_dconfig));
    PyDict_SetItemString(dict, "FDconfig", Dtool_WrapValue(ConfigFlags::F_dconfig));
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigFlags) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigFlags)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigFlags);
  }
}

/**
 * Python method tables for ConfigPage (ConfigPage)
 */
static PyMethodDef Dtool_Methods_ConfigPage[] = {
  {"get_default_page", &Dtool_ConfigPage_get_default_page_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_default_page_88_comment},
  {"getDefaultPage", &Dtool_ConfigPage_get_default_page_88, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_default_page_88_comment},
  {"get_local_page", &Dtool_ConfigPage_get_local_page_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_local_page_89_comment},
  {"getLocalPage", &Dtool_ConfigPage_get_local_page_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPage_get_local_page_89_comment},
  {"get_name", &Dtool_ConfigPage_get_name_90, METH_NOARGS, (const char *)Dtool_ConfigPage_get_name_90_comment},
  {"getName", &Dtool_ConfigPage_get_name_90, METH_NOARGS, (const char *)Dtool_ConfigPage_get_name_90_comment},
  {"is_special", &Dtool_ConfigPage_is_special_95, METH_NOARGS, (const char *)Dtool_ConfigPage_is_special_95_comment},
  {"isSpecial", &Dtool_ConfigPage_is_special_95, METH_NOARGS, (const char *)Dtool_ConfigPage_is_special_95_comment},
  {"is_implicit", &Dtool_ConfigPage_is_implicit_96, METH_NOARGS, (const char *)Dtool_ConfigPage_is_implicit_96_comment},
  {"isImplicit", &Dtool_ConfigPage_is_implicit_96, METH_NOARGS, (const char *)Dtool_ConfigPage_is_implicit_96_comment},
  {"set_sort", &Dtool_ConfigPage_set_sort_100, METH_O, (const char *)Dtool_ConfigPage_set_sort_100_comment},
  {"setSort", &Dtool_ConfigPage_set_sort_100, METH_O, (const char *)Dtool_ConfigPage_set_sort_100_comment},
  {"get_sort", &Dtool_ConfigPage_get_sort_101, METH_NOARGS, (const char *)Dtool_ConfigPage_get_sort_101_comment},
  {"getSort", &Dtool_ConfigPage_get_sort_101, METH_NOARGS, (const char *)Dtool_ConfigPage_get_sort_101_comment},
  {"get_page_seq", &Dtool_ConfigPage_get_page_seq_104, METH_NOARGS, (const char *)Dtool_ConfigPage_get_page_seq_104_comment},
  {"getPageSeq", &Dtool_ConfigPage_get_page_seq_104, METH_NOARGS, (const char *)Dtool_ConfigPage_get_page_seq_104_comment},
  {"get_trust_level", &Dtool_ConfigPage_get_trust_level_105, METH_NOARGS, (const char *)Dtool_ConfigPage_get_trust_level_105_comment},
  {"getTrustLevel", &Dtool_ConfigPage_get_trust_level_105, METH_NOARGS, (const char *)Dtool_ConfigPage_get_trust_level_105_comment},
  {"set_trust_level", &Dtool_ConfigPage_set_trust_level_106, METH_O, (const char *)Dtool_ConfigPage_set_trust_level_106_comment},
  {"setTrustLevel", &Dtool_ConfigPage_set_trust_level_106, METH_O, (const char *)Dtool_ConfigPage_set_trust_level_106_comment},
  {"get_signature", &Dtool_ConfigPage_get_signature_107, METH_NOARGS, (const char *)Dtool_ConfigPage_get_signature_107_comment},
  {"getSignature", &Dtool_ConfigPage_get_signature_107, METH_NOARGS, (const char *)Dtool_ConfigPage_get_signature_107_comment},
  {"clear", &Dtool_ConfigPage_clear_111, METH_NOARGS, (const char *)Dtool_ConfigPage_clear_111_comment},
  {"read_prc", &Dtool_ConfigPage_read_prc_112, METH_O, (const char *)Dtool_ConfigPage_read_prc_112_comment},
  {"readPrc", &Dtool_ConfigPage_read_prc_112, METH_O, (const char *)Dtool_ConfigPage_read_prc_112_comment},
  {"read_encrypted_prc", (PyCFunction) &Dtool_ConfigPage_read_encrypted_prc_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_read_encrypted_prc_113_comment},
  {"readEncryptedPrc", (PyCFunction) &Dtool_ConfigPage_read_encrypted_prc_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_read_encrypted_prc_113_comment},
  {"make_declaration", (PyCFunction) &Dtool_ConfigPage_make_declaration_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_make_declaration_114_comment},
  {"makeDeclaration", (PyCFunction) &Dtool_ConfigPage_make_declaration_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigPage_make_declaration_114_comment},
  {"delete_declaration", &Dtool_ConfigPage_delete_declaration_115, METH_O, (const char *)Dtool_ConfigPage_delete_declaration_115_comment},
  {"deleteDeclaration", &Dtool_ConfigPage_delete_declaration_115, METH_O, (const char *)Dtool_ConfigPage_delete_declaration_115_comment},
  {"get_num_declarations", &Dtool_ConfigPage_get_num_declarations_116, METH_NOARGS, (const char *)Dtool_ConfigPage_get_num_declarations_116_comment},
  {"getNumDeclarations", &Dtool_ConfigPage_get_num_declarations_116, METH_NOARGS, (const char *)Dtool_ConfigPage_get_num_declarations_116_comment},
  {"get_declaration", &Dtool_ConfigPage_get_declaration_117, METH_O, (const char *)Dtool_ConfigPage_get_declaration_117_comment},
  {"getDeclaration", &Dtool_ConfigPage_get_declaration_117, METH_O, (const char *)Dtool_ConfigPage_get_declaration_117_comment},
  {"modify_declaration", &Dtool_ConfigPage_modify_declaration_118, METH_O, (const char *)Dtool_ConfigPage_modify_declaration_118_comment},
  {"modifyDeclaration", &Dtool_ConfigPage_modify_declaration_118, METH_O, (const char *)Dtool_ConfigPage_modify_declaration_118_comment},
  {"get_variable_name", &Dtool_ConfigPage_get_variable_name_119, METH_O, (const char *)Dtool_ConfigPage_get_variable_name_119_comment},
  {"getVariableName", &Dtool_ConfigPage_get_variable_name_119, METH_O, (const char *)Dtool_ConfigPage_get_variable_name_119_comment},
  {"get_string_value", &Dtool_ConfigPage_get_string_value_120, METH_O, (const char *)Dtool_ConfigPage_get_string_value_120_comment},
  {"getStringValue", &Dtool_ConfigPage_get_string_value_120, METH_O, (const char *)Dtool_ConfigPage_get_string_value_120_comment},
  {"is_variable_used", &Dtool_ConfigPage_is_variable_used_121, METH_O, (const char *)Dtool_ConfigPage_is_variable_used_121_comment},
  {"isVariableUsed", &Dtool_ConfigPage_is_variable_used_121, METH_O, (const char *)Dtool_ConfigPage_is_variable_used_121_comment},
  {"output", &Dtool_ConfigPage_output_124, METH_O, (const char *)Dtool_ConfigPage_output_124_comment},
  {"output_brief_signature", &Dtool_ConfigPage_output_brief_signature_125, METH_O, (const char *)Dtool_ConfigPage_output_brief_signature_125_comment},
  {"outputBriefSignature", &Dtool_ConfigPage_output_brief_signature_125, METH_O, (const char *)Dtool_ConfigPage_output_brief_signature_125_comment},
  {"write", &Dtool_ConfigPage_write_126, METH_O, (const char *)Dtool_ConfigPage_write_126_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigPage
//////////////////
static PyObject *Dtool_Repr_ConfigPage(PyObject *self) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigPage
//////////////////
static PyObject *Dtool_Str_ConfigPage(PyObject *self) {
  ConfigPage *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPage, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigPage[] = {
  {(char *)"name", &Dtool_ConfigPage_name_Getter, NULL, NULL, NULL},
  {(char *)"special", &Dtool_ConfigPage_special_Getter, NULL, NULL, NULL},
  {(char *)"implicit", &Dtool_ConfigPage_implicit_Getter, NULL, NULL, NULL},
  {(char *)"sort", &Dtool_ConfigPage_sort_Getter, &Dtool_ConfigPage_sort_Setter, NULL, NULL},
  {(char *)"page_seq", &Dtool_ConfigPage_page_seq_Getter, NULL, NULL, NULL},
  {(char *)"trust_level", &Dtool_ConfigPage_trust_level_Getter, &Dtool_ConfigPage_trust_level_Setter, NULL, NULL},
  {(char *)"signature", &Dtool_ConfigPage_signature_Getter, NULL, NULL, NULL},
  {(char *)"declarations", &Dtool_ConfigPage_declarations_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigPage = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigPage = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigPage",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigPage,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigPage,
    &Dtool_NumberMethods_ConfigPage,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigPage,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A page of ConfigDeclarations that may be loaded or unloaded.  Typically\n"
    " * this represents a single .prc file that is read from disk at runtime, but\n"
    " * it may also represent a list of declarations built up by application code\n"
    " * and explicitly loaded.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigPage,
    0, // tp_members
    Dtool_Properties_ConfigPage,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigPage,
    PyType_GenericAlloc,
    Dtool_new_ConfigPage,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigPage,
  Dtool_UpcastInterface_ConfigPage,
  Dtool_DowncastInterface_ConfigPage,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigPage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConfigPage._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConfigPage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigPage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigPage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigPage);
  }
}

/**
 * Python method tables for ConfigVariableCore (ConfigVariableCore)
 */
static PyMethodDef Dtool_Methods_ConfigVariableCore[] = {
  {"get_name", &Dtool_ConfigVariableCore_get_name_130, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_name_130_comment},
  {"getName", &Dtool_ConfigVariableCore_get_name_130, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_name_130_comment},
  {"is_used", &Dtool_ConfigVariableCore_is_used_131, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_used_131_comment},
  {"isUsed", &Dtool_ConfigVariableCore_is_used_131, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_used_131_comment},
  {"get_value_type", &Dtool_ConfigVariableCore_get_value_type_132, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_value_type_132_comment},
  {"getValueType", &Dtool_ConfigVariableCore_get_value_type_132, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_value_type_132_comment},
  {"get_description", &Dtool_ConfigVariableCore_get_description_133, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_description_133_comment},
  {"getDescription", &Dtool_ConfigVariableCore_get_description_133, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_description_133_comment},
  {"get_flags", &Dtool_ConfigVariableCore_get_flags_134, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_flags_134_comment},
  {"getFlags", &Dtool_ConfigVariableCore_get_flags_134, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_flags_134_comment},
  {"is_closed", &Dtool_ConfigVariableCore_is_closed_135, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_closed_135_comment},
  {"isClosed", &Dtool_ConfigVariableCore_is_closed_135, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_closed_135_comment},
  {"get_trust_level", &Dtool_ConfigVariableCore_get_trust_level_136, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_trust_level_136_comment},
  {"getTrustLevel", &Dtool_ConfigVariableCore_get_trust_level_136, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_trust_level_136_comment},
  {"is_dynamic", &Dtool_ConfigVariableCore_is_dynamic_137, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_dynamic_137_comment},
  {"isDynamic", &Dtool_ConfigVariableCore_is_dynamic_137, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_is_dynamic_137_comment},
  {"get_default_value", &Dtool_ConfigVariableCore_get_default_value_138, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_default_value_138_comment},
  {"getDefaultValue", &Dtool_ConfigVariableCore_get_default_value_138, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_default_value_138_comment},
  {"set_value_type", &Dtool_ConfigVariableCore_set_value_type_139, METH_O, (const char *)Dtool_ConfigVariableCore_set_value_type_139_comment},
  {"setValueType", &Dtool_ConfigVariableCore_set_value_type_139, METH_O, (const char *)Dtool_ConfigVariableCore_set_value_type_139_comment},
  {"set_flags", &Dtool_ConfigVariableCore_set_flags_140, METH_O, (const char *)Dtool_ConfigVariableCore_set_flags_140_comment},
  {"setFlags", &Dtool_ConfigVariableCore_set_flags_140, METH_O, (const char *)Dtool_ConfigVariableCore_set_flags_140_comment},
  {"set_description", &Dtool_ConfigVariableCore_set_description_141, METH_O, (const char *)Dtool_ConfigVariableCore_set_description_141_comment},
  {"setDescription", &Dtool_ConfigVariableCore_set_description_141, METH_O, (const char *)Dtool_ConfigVariableCore_set_description_141_comment},
  {"set_default_value", &Dtool_ConfigVariableCore_set_default_value_142, METH_O, (const char *)Dtool_ConfigVariableCore_set_default_value_142_comment},
  {"setDefaultValue", &Dtool_ConfigVariableCore_set_default_value_142, METH_O, (const char *)Dtool_ConfigVariableCore_set_default_value_142_comment},
  {"set_used", &Dtool_ConfigVariableCore_set_used_143, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_set_used_143_comment},
  {"setUsed", &Dtool_ConfigVariableCore_set_used_143, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_set_used_143_comment},
  {"make_local_value", &Dtool_ConfigVariableCore_make_local_value_144, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_make_local_value_144_comment},
  {"makeLocalValue", &Dtool_ConfigVariableCore_make_local_value_144, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_make_local_value_144_comment},
  {"clear_local_value", &Dtool_ConfigVariableCore_clear_local_value_145, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_clear_local_value_145_comment},
  {"clearLocalValue", &Dtool_ConfigVariableCore_clear_local_value_145, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_clear_local_value_145_comment},
  {"has_local_value", &Dtool_ConfigVariableCore_has_local_value_146, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_local_value_146_comment},
  {"hasLocalValue", &Dtool_ConfigVariableCore_has_local_value_146, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_local_value_146_comment},
  {"has_value", &Dtool_ConfigVariableCore_has_value_147, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_value_147_comment},
  {"hasValue", &Dtool_ConfigVariableCore_has_value_147, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_has_value_147_comment},
  {"get_num_declarations", &Dtool_ConfigVariableCore_get_num_declarations_148, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_declarations_148_comment},
  {"getNumDeclarations", &Dtool_ConfigVariableCore_get_num_declarations_148, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_declarations_148_comment},
  {"get_declaration", &Dtool_ConfigVariableCore_get_declaration_149, METH_O, (const char *)Dtool_ConfigVariableCore_get_declaration_149_comment},
  {"getDeclaration", &Dtool_ConfigVariableCore_get_declaration_149, METH_O, (const char *)Dtool_ConfigVariableCore_get_declaration_149_comment},
  {"get_num_references", &Dtool_ConfigVariableCore_get_num_references_151, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_references_151_comment},
  {"getNumReferences", &Dtool_ConfigVariableCore_get_num_references_151, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_references_151_comment},
  {"get_reference", &Dtool_ConfigVariableCore_get_reference_152, METH_O, (const char *)Dtool_ConfigVariableCore_get_reference_152_comment},
  {"getReference", &Dtool_ConfigVariableCore_get_reference_152, METH_O, (const char *)Dtool_ConfigVariableCore_get_reference_152_comment},
  {"get_num_trusted_references", &Dtool_ConfigVariableCore_get_num_trusted_references_154, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_trusted_references_154_comment},
  {"getNumTrustedReferences", &Dtool_ConfigVariableCore_get_num_trusted_references_154, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_trusted_references_154_comment},
  {"get_trusted_reference", &Dtool_ConfigVariableCore_get_trusted_reference_155, METH_O, (const char *)Dtool_ConfigVariableCore_get_trusted_reference_155_comment},
  {"getTrustedReference", &Dtool_ConfigVariableCore_get_trusted_reference_155, METH_O, (const char *)Dtool_ConfigVariableCore_get_trusted_reference_155_comment},
  {"get_num_unique_references", &Dtool_ConfigVariableCore_get_num_unique_references_157, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_unique_references_157_comment},
  {"getNumUniqueReferences", &Dtool_ConfigVariableCore_get_num_unique_references_157, METH_NOARGS, (const char *)Dtool_ConfigVariableCore_get_num_unique_references_157_comment},
  {"get_unique_reference", &Dtool_ConfigVariableCore_get_unique_reference_158, METH_O, (const char *)Dtool_ConfigVariableCore_get_unique_reference_158_comment},
  {"getUniqueReference", &Dtool_ConfigVariableCore_get_unique_reference_158, METH_O, (const char *)Dtool_ConfigVariableCore_get_unique_reference_158_comment},
  {"output", &Dtool_ConfigVariableCore_output_163, METH_O, (const char *)Dtool_ConfigVariableCore_output_163_comment},
  {"write", &Dtool_ConfigVariableCore_write_164, METH_O, (const char *)Dtool_ConfigVariableCore_write_164_comment},
  {"get_declarations", (PyCFunction) &MakeSeq_ConfigVariableCore_get_declarations, METH_NOARGS, NULL},
  { "getDeclarations", (PyCFunction) &MakeSeq_ConfigVariableCore_get_declarations, METH_NOARGS, NULL},
  {"get_references", (PyCFunction) &MakeSeq_ConfigVariableCore_get_references, METH_NOARGS, NULL},
  { "getReferences", (PyCFunction) &MakeSeq_ConfigVariableCore_get_references, METH_NOARGS, NULL},
  {"get_trusted_references", (PyCFunction) &MakeSeq_ConfigVariableCore_get_trusted_references, METH_NOARGS, NULL},
  { "getTrustedReferences", (PyCFunction) &MakeSeq_ConfigVariableCore_get_trusted_references, METH_NOARGS, NULL},
  {"get_unique_references", (PyCFunction) &MakeSeq_ConfigVariableCore_get_unique_references, METH_NOARGS, NULL},
  { "getUniqueReferences", (PyCFunction) &MakeSeq_ConfigVariableCore_get_unique_references, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigVariableCore
//////////////////
static PyObject *Dtool_Repr_ConfigVariableCore(PyObject *self) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableCore
//////////////////
static PyObject *Dtool_Str_ConfigVariableCore(PyObject *self) {
  ConfigVariableCore *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableCore, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableCore[] = {
  {(char *)"declarations", &Dtool_ConfigVariableCore_declarations_Getter, NULL, NULL, NULL},
  {(char *)"name", &Dtool_ConfigVariableCore_name_Getter, NULL, NULL, NULL},
  {(char *)"used", &Dtool_ConfigVariableCore_used_Getter, NULL, NULL, NULL},
  {(char *)"closed", &Dtool_ConfigVariableCore_closed_Getter, NULL, NULL, NULL},
  {(char *)"trust_level", &Dtool_ConfigVariableCore_trust_level_Getter, NULL, NULL, NULL},
  {(char *)"dynamic", &Dtool_ConfigVariableCore_dynamic_Getter, NULL, NULL, NULL},
  {(char *)"value_type", &Dtool_ConfigVariableCore_value_type_Getter, &Dtool_ConfigVariableCore_value_type_Setter, NULL, NULL},
  {(char *)"description", &Dtool_ConfigVariableCore_description_Getter, &Dtool_ConfigVariableCore_description_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableCore_default_value_Getter, &Dtool_ConfigVariableCore_default_value_Setter, NULL, NULL},
  {(char *)"references", &Dtool_ConfigVariableCore_references_Getter, NULL, NULL, NULL},
  {(char *)"trusted_references", &Dtool_ConfigVariableCore_trusted_references_Getter, NULL, NULL, NULL},
  {(char *)"unique_references", &Dtool_ConfigVariableCore_unique_references_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableCore = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableCore = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableCore = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableCore = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableCore = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableCore",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableCore,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableCore,
    &Dtool_NumberMethods_ConfigVariableCore,
    &Dtool_SequenceMethods_ConfigVariableCore,
    &Dtool_MappingMethods_ConfigVariableCore,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigVariableCore,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableCore,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The internal definition of a ConfigVariable.  This object is shared between\n"
    " * all instances of a ConfigVariable that use the same variable name.\n"
    " *\n"
    " * You cannot create a ConfigVariableCore instance directly; instead, use the\n"
    " * make() method, which may return a shared instance.  Once created, these\n"
    " * objects are never destructed.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableCore,
    0, // tp_members
    Dtool_Properties_ConfigVariableCore,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableCore,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableCore,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableCore,
  Dtool_UpcastInterface_ConfigVariableCore,
  Dtool_DowncastInterface_ConfigVariableCore,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigVariableCore(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(NULL);
    Dtool_ConfigVariableCore._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableCore._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableCore) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableCore)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableCore);
  }
}

/**
 * Python method tables for ConfigPageManager (ConfigPageManager)
 */
static PyMethodDef Dtool_Methods_ConfigPageManager[] = {
  {"loaded_implicit_pages", &Dtool_ConfigPageManager_loaded_implicit_pages_198, METH_NOARGS, (const char *)Dtool_ConfigPageManager_loaded_implicit_pages_198_comment},
  {"loadedImplicitPages", &Dtool_ConfigPageManager_loaded_implicit_pages_198, METH_NOARGS, (const char *)Dtool_ConfigPageManager_loaded_implicit_pages_198_comment},
  {"load_implicit_pages", &Dtool_ConfigPageManager_load_implicit_pages_199, METH_NOARGS, (const char *)Dtool_ConfigPageManager_load_implicit_pages_199_comment},
  {"loadImplicitPages", &Dtool_ConfigPageManager_load_implicit_pages_199, METH_NOARGS, (const char *)Dtool_ConfigPageManager_load_implicit_pages_199_comment},
  {"reload_implicit_pages", &Dtool_ConfigPageManager_reload_implicit_pages_200, METH_NOARGS, (const char *)Dtool_ConfigPageManager_reload_implicit_pages_200_comment},
  {"reloadImplicitPages", &Dtool_ConfigPageManager_reload_implicit_pages_200, METH_NOARGS, (const char *)Dtool_ConfigPageManager_reload_implicit_pages_200_comment},
  {"get_search_path", &Dtool_ConfigPageManager_get_search_path_201, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_search_path_201_comment},
  {"getSearchPath", &Dtool_ConfigPageManager_get_search_path_201, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_search_path_201_comment},
  {"get_num_prc_patterns", &Dtool_ConfigPageManager_get_num_prc_patterns_202, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_patterns_202_comment},
  {"getNumPrcPatterns", &Dtool_ConfigPageManager_get_num_prc_patterns_202, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_patterns_202_comment},
  {"get_prc_pattern", &Dtool_ConfigPageManager_get_prc_pattern_203, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_pattern_203_comment},
  {"getPrcPattern", &Dtool_ConfigPageManager_get_prc_pattern_203, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_pattern_203_comment},
  {"get_num_prc_encrypted_patterns", &Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204_comment},
  {"getNumPrcEncryptedPatterns", &Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_encrypted_patterns_204_comment},
  {"get_prc_encrypted_pattern", &Dtool_ConfigPageManager_get_prc_encrypted_pattern_205, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_encrypted_pattern_205_comment},
  {"getPrcEncryptedPattern", &Dtool_ConfigPageManager_get_prc_encrypted_pattern_205, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_encrypted_pattern_205_comment},
  {"get_num_prc_executable_patterns", &Dtool_ConfigPageManager_get_num_prc_executable_patterns_206, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_executable_patterns_206_comment},
  {"getNumPrcExecutablePatterns", &Dtool_ConfigPageManager_get_num_prc_executable_patterns_206, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_prc_executable_patterns_206_comment},
  {"get_prc_executable_pattern", &Dtool_ConfigPageManager_get_prc_executable_pattern_207, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_executable_pattern_207_comment},
  {"getPrcExecutablePattern", &Dtool_ConfigPageManager_get_prc_executable_pattern_207, METH_O, (const char *)Dtool_ConfigPageManager_get_prc_executable_pattern_207_comment},
  {"make_explicit_page", &Dtool_ConfigPageManager_make_explicit_page_208, METH_O, (const char *)Dtool_ConfigPageManager_make_explicit_page_208_comment},
  {"makeExplicitPage", &Dtool_ConfigPageManager_make_explicit_page_208, METH_O, (const char *)Dtool_ConfigPageManager_make_explicit_page_208_comment},
  {"delete_explicit_page", &Dtool_ConfigPageManager_delete_explicit_page_209, METH_O, (const char *)Dtool_ConfigPageManager_delete_explicit_page_209_comment},
  {"deleteExplicitPage", &Dtool_ConfigPageManager_delete_explicit_page_209, METH_O, (const char *)Dtool_ConfigPageManager_delete_explicit_page_209_comment},
  {"get_num_implicit_pages", &Dtool_ConfigPageManager_get_num_implicit_pages_210, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_implicit_pages_210_comment},
  {"getNumImplicitPages", &Dtool_ConfigPageManager_get_num_implicit_pages_210, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_implicit_pages_210_comment},
  {"get_implicit_page", &Dtool_ConfigPageManager_get_implicit_page_211, METH_O, (const char *)Dtool_ConfigPageManager_get_implicit_page_211_comment},
  {"getImplicitPage", &Dtool_ConfigPageManager_get_implicit_page_211, METH_O, (const char *)Dtool_ConfigPageManager_get_implicit_page_211_comment},
  {"get_num_explicit_pages", &Dtool_ConfigPageManager_get_num_explicit_pages_212, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_explicit_pages_212_comment},
  {"getNumExplicitPages", &Dtool_ConfigPageManager_get_num_explicit_pages_212, METH_NOARGS, (const char *)Dtool_ConfigPageManager_get_num_explicit_pages_212_comment},
  {"get_explicit_page", &Dtool_ConfigPageManager_get_explicit_page_213, METH_O, (const char *)Dtool_ConfigPageManager_get_explicit_page_213_comment},
  {"getExplicitPage", &Dtool_ConfigPageManager_get_explicit_page_213, METH_O, (const char *)Dtool_ConfigPageManager_get_explicit_page_213_comment},
  {"output", &Dtool_ConfigPageManager_output_214, METH_O, (const char *)Dtool_ConfigPageManager_output_214_comment},
  {"write", &Dtool_ConfigPageManager_write_215, METH_O, (const char *)Dtool_ConfigPageManager_write_215_comment},
  {"get_global_ptr", &Dtool_ConfigPageManager_get_global_ptr_216, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPageManager_get_global_ptr_216_comment},
  {"getGlobalPtr", &Dtool_ConfigPageManager_get_global_ptr_216, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigPageManager_get_global_ptr_216_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigPageManager
//////////////////
static PyObject *Dtool_Repr_ConfigPageManager(PyObject *self) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigPageManager
//////////////////
static PyObject *Dtool_Str_ConfigPageManager(PyObject *self) {
  ConfigPageManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigPageManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConfigPageManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigPageManager = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigPageManager = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigPageManager = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigPageManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigPageManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigPageManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigPageManager,
    &Dtool_NumberMethods_ConfigPageManager,
    &Dtool_SequenceMethods_ConfigPageManager,
    &Dtool_MappingMethods_ConfigPageManager,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigPageManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigPageManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A global object that maintains the set of ConfigPages everywhere in the\n"
    " * world, and keeps them in sorted order.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigPageManager,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigPageManager,
    PyType_GenericAlloc,
    Dtool_new_ConfigPageManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigPageManager,
  Dtool_UpcastInterface_ConfigPageManager,
  Dtool_DowncastInterface_ConfigPageManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigPageManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(NULL);
    Dtool_ConfigPageManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    PyObject *dict = PyDict_New();
    Dtool_ConfigPageManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigPageManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigPageManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigPageManager);
  }
}

/**
 * Python method tables for ConfigVariable (ConfigVariable)
 */
static PyMethodDef Dtool_Methods_ConfigVariable[] = {
  {"get_string_value", &Dtool_ConfigVariable_get_string_value_239, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_string_value_239_comment},
  {"getStringValue", &Dtool_ConfigVariable_get_string_value_239, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_string_value_239_comment},
  {"set_string_value", &Dtool_ConfigVariable_set_string_value_240, METH_O, (const char *)Dtool_ConfigVariable_set_string_value_240_comment},
  {"setStringValue", &Dtool_ConfigVariable_set_string_value_240, METH_O, (const char *)Dtool_ConfigVariable_set_string_value_240_comment},
  {"clear_value", &Dtool_ConfigVariable_clear_value_241, METH_NOARGS, (const char *)Dtool_ConfigVariable_clear_value_241_comment},
  {"clearValue", &Dtool_ConfigVariable_clear_value_241, METH_NOARGS, (const char *)Dtool_ConfigVariable_clear_value_241_comment},
  {"get_num_words", &Dtool_ConfigVariable_get_num_words_242, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_num_words_242_comment},
  {"getNumWords", &Dtool_ConfigVariable_get_num_words_242, METH_NOARGS, (const char *)Dtool_ConfigVariable_get_num_words_242_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariable,
    &Dtool_SequenceMethods_ConfigVariable,
    &Dtool_MappingMethods_ConfigVariable,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic, untyped ConfigVariable.  It is also the base class for\n"
    " * the typed ConfigVariables, and contains all of the code common to\n"
    " * ConfigVariables of all types (except ConfigVariableList, which is a bit of\n"
    " * a special case).\n"
    " *\n"
    " * Mostly, this class serves as a thin wrapper around ConfigVariableCore\n"
    " * and/or ConfigDeclaration, more or less duplicating the interface presented\n"
    " * there.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariable,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariable,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariable,
  Dtool_UpcastInterface_ConfigVariable,
  Dtool_DowncastInterface_ConfigVariable,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariable,
  (CoerceFunction)Dtool_Coerce_ConfigVariable,
};

static void Dtool_PyModuleClassInit_ConfigVariable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariableBase(NULL);
    Dtool_ConfigVariable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariableBase);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariable);
  }
}

/**
 * Python method tables for ConfigVariableBase (ConfigVariableBase)
 */
static PyMethodDef Dtool_Methods_ConfigVariableBase[] = {
  {"get_name", &Dtool_ConfigVariableBase_get_name_219, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_name_219_comment},
  {"getName", &Dtool_ConfigVariableBase_get_name_219, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_name_219_comment},
  {"get_value_type", &Dtool_ConfigVariableBase_get_value_type_220, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_value_type_220_comment},
  {"getValueType", &Dtool_ConfigVariableBase_get_value_type_220, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_value_type_220_comment},
  {"get_description", &Dtool_ConfigVariableBase_get_description_221, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_description_221_comment},
  {"getDescription", &Dtool_ConfigVariableBase_get_description_221, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_description_221_comment},
  {"get_flags", &Dtool_ConfigVariableBase_get_flags_222, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_flags_222_comment},
  {"getFlags", &Dtool_ConfigVariableBase_get_flags_222, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_flags_222_comment},
  {"is_closed", &Dtool_ConfigVariableBase_is_closed_223, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_closed_223_comment},
  {"isClosed", &Dtool_ConfigVariableBase_is_closed_223, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_closed_223_comment},
  {"get_trust_level", &Dtool_ConfigVariableBase_get_trust_level_224, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_trust_level_224_comment},
  {"getTrustLevel", &Dtool_ConfigVariableBase_get_trust_level_224, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_get_trust_level_224_comment},
  {"is_dynamic", &Dtool_ConfigVariableBase_is_dynamic_225, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_dynamic_225_comment},
  {"isDynamic", &Dtool_ConfigVariableBase_is_dynamic_225, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_is_dynamic_225_comment},
  {"clear_local_value", &Dtool_ConfigVariableBase_clear_local_value_232, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_clear_local_value_232_comment},
  {"clearLocalValue", &Dtool_ConfigVariableBase_clear_local_value_232, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_clear_local_value_232_comment},
  {"has_local_value", &Dtool_ConfigVariableBase_has_local_value_233, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_local_value_233_comment},
  {"hasLocalValue", &Dtool_ConfigVariableBase_has_local_value_233, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_local_value_233_comment},
  {"has_value", &Dtool_ConfigVariableBase_has_value_234, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_value_234_comment},
  {"hasValue", &Dtool_ConfigVariableBase_has_value_234, METH_NOARGS, (const char *)Dtool_ConfigVariableBase_has_value_234_comment},
  {"output", &Dtool_ConfigVariableBase_output_235, METH_O, (const char *)Dtool_ConfigVariableBase_output_235_comment},
  {"write", &Dtool_ConfigVariableBase_write_236, METH_O, (const char *)Dtool_ConfigVariableBase_write_236_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigVariableBase
//////////////////
static PyObject *Dtool_Repr_ConfigVariableBase(PyObject *self) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableBase
//////////////////
static PyObject *Dtool_Str_ConfigVariableBase(PyObject *self) {
  ConfigVariableBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBase, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableBase[] = {
  {(char *)"name", &Dtool_ConfigVariableBase_name_Getter, NULL, NULL, NULL},
  {(char *)"value_type", &Dtool_ConfigVariableBase_value_type_Getter, NULL, NULL, NULL},
  {(char *)"description", &Dtool_ConfigVariableBase_description_Getter, NULL, NULL, NULL},
  {(char *)"closed", &Dtool_ConfigVariableBase_closed_Getter, NULL, NULL, NULL},
  {(char *)"trust_level", &Dtool_ConfigVariableBase_trust_level_Getter, NULL, NULL, NULL},
  {(char *)"dynamic", &Dtool_ConfigVariableBase_dynamic_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableBase,
    &Dtool_NumberMethods_ConfigVariableBase,
    &Dtool_SequenceMethods_ConfigVariableBase,
    &Dtool_MappingMethods_ConfigVariableBase,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigVariableBase,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is the base class for both ConfigVariableList and ConfigVariable\n"
    " * (and hence for all of the ConfigVariableBool, ConfigVaribleString, etc.\n"
    " * classes).  It collects together the common interface for all generic\n"
    " * ConfigVariables.\n"
    " *\n"
    " * Mostly, this class serves as a thin wrapper around ConfigVariableCore\n"
    " * and/or ConfigDeclaration, more or less duplicating the interface presented\n"
    " * there.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableBase,
    0, // tp_members
    Dtool_Properties_ConfigVariableBase,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableBase,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableBase,
  Dtool_UpcastInterface_ConfigVariableBase,
  Dtool_DowncastInterface_ConfigVariableBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigVariableBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(NULL);
    Dtool_ConfigVariableBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableBase);
  }
}

/**
 * Python method tables for ConfigVariableBool (ConfigVariableBool)
 */
static PyMethodDef Dtool_Methods_ConfigVariableBool[] = {
  {"assign", &Dtool_ConfigVariableBool_operator_245, METH_O, (const char *)Dtool_ConfigVariableBool_operator_245_comment},
  {"set_value", &Dtool_ConfigVariableBool_set_value_249, METH_O, (const char *)Dtool_ConfigVariableBool_set_value_249_comment},
  {"setValue", &Dtool_ConfigVariableBool_set_value_249, METH_O, (const char *)Dtool_ConfigVariableBool_set_value_249_comment},
  {"get_value", &Dtool_ConfigVariableBool_get_value_250, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_value_250_comment},
  {"getValue", &Dtool_ConfigVariableBool_get_value_250, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_value_250_comment},
  {"get_default_value", &Dtool_ConfigVariableBool_get_default_value_251, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_default_value_251_comment},
  {"getDefaultValue", &Dtool_ConfigVariableBool_get_default_value_251, METH_NOARGS, (const char *)Dtool_ConfigVariableBool_get_default_value_251_comment},
  {"get_word", &Dtool_ConfigVariableBool_get_word_254, METH_O, (const char *)Dtool_ConfigVariableBool_get_word_254_comment},
  {"getWord", &Dtool_ConfigVariableBool_get_word_254, METH_O, (const char *)Dtool_ConfigVariableBool_get_word_254_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableBool_set_word_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableBool_set_word_255_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableBool_set_word_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableBool_set_word_255_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableBool slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_ConfigVariableBool_operator_typecast_bool_246_nb_bool(PyObject *self) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableBool slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableBool_operator_248_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableBool index out of range");
    return NULL;
  }
  // 1-inline bool ConfigVariableBool::operator [](std::size_t n) const
  bool return_value = (*(const ConfigVariableBool*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableBool self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableBool slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableBool_size_247_sq_length(PyObject *self) {
  ConfigVariableBool *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableBool, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableBool[] = {
  {(char *)"value", &Dtool_ConfigVariableBool_value_Getter, &Dtool_ConfigVariableBool_value_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableBool_default_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableBool = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_ConfigVariableBool_operator_typecast_bool_246_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableBool = {
  &Dtool_ConfigVariableBool_size_247_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConfigVariableBool_operator_248_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableBool = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableBool = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableBool = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableBool",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableBool,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableBool,
    &Dtool_SequenceMethods_ConfigVariableBool,
    &Dtool_MappingMethods_ConfigVariableBool,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableBool,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a boolean type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableBool,
    0, // tp_members
    Dtool_Properties_ConfigVariableBool,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableBool,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableBool,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableBool,
  Dtool_UpcastInterface_ConfigVariableBool,
  Dtool_DowncastInterface_ConfigVariableBool,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableBool,
  (CoerceFunction)Dtool_Coerce_ConfigVariableBool,
};

static void Dtool_PyModuleClassInit_ConfigVariableBool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(NULL);
    Dtool_ConfigVariableBool._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableBool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableBool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableBool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableBool);
  }
}

/**
 * Python method tables for ConfigVariableDouble (ConfigVariableDouble)
 */
static PyMethodDef Dtool_Methods_ConfigVariableDouble[] = {
  {"assign", &Dtool_ConfigVariableDouble_operator_259, METH_O, (const char *)Dtool_ConfigVariableDouble_operator_259_comment},
  {"set_value", &Dtool_ConfigVariableDouble_set_value_263, METH_O, (const char *)Dtool_ConfigVariableDouble_set_value_263_comment},
  {"setValue", &Dtool_ConfigVariableDouble_set_value_263, METH_O, (const char *)Dtool_ConfigVariableDouble_set_value_263_comment},
  {"get_value", &Dtool_ConfigVariableDouble_get_value_264, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_value_264_comment},
  {"getValue", &Dtool_ConfigVariableDouble_get_value_264, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_value_264_comment},
  {"get_default_value", &Dtool_ConfigVariableDouble_get_default_value_265, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_default_value_265_comment},
  {"getDefaultValue", &Dtool_ConfigVariableDouble_get_default_value_265, METH_NOARGS, (const char *)Dtool_ConfigVariableDouble_get_default_value_265_comment},
  {"get_word", &Dtool_ConfigVariableDouble_get_word_269, METH_O, (const char *)Dtool_ConfigVariableDouble_get_word_269_comment},
  {"getWord", &Dtool_ConfigVariableDouble_get_word_269, METH_O, (const char *)Dtool_ConfigVariableDouble_get_word_269_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableDouble_set_word_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableDouble_set_word_270_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableDouble_set_word_270, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableDouble_set_word_270_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableDouble slot nb_float -> operator typecast double
//////////////////
static PyObject *Dtool_ConfigVariableDouble_operator_typecast_double_260_nb_float(PyObject *self) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline double ConfigVariableDouble::operator typecast double(void) const
  double return_value = (double)*(const ConfigVariableDouble*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast_double(ConfigVariableDouble self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableDouble slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableDouble_operator_262_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableDouble index out of range");
    return NULL;
  }
  // 1-inline double ConfigVariableDouble::operator [](std::size_t n) const
  double return_value = (*(const ConfigVariableDouble*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableDouble self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableDouble slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableDouble_size_261_sq_length(PyObject *self) {
  ConfigVariableDouble *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableDouble, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableDouble[] = {
  {(char *)"value", &Dtool_ConfigVariableDouble_value_Getter, &Dtool_ConfigVariableDouble_value_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableDouble_default_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableDouble = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  &Dtool_ConfigVariableDouble_operator_typecast_double_260_nb_float,
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableDouble = {
  &Dtool_ConfigVariableDouble_size_261_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConfigVariableDouble_operator_262_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableDouble = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableDouble = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableDouble = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableDouble",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableDouble,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableDouble,
    &Dtool_SequenceMethods_ConfigVariableDouble,
    &Dtool_MappingMethods_ConfigVariableDouble,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableDouble,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a floating-\n"
    " * point type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableDouble,
    0, // tp_members
    Dtool_Properties_ConfigVariableDouble,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableDouble,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableDouble,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableDouble,
  Dtool_UpcastInterface_ConfigVariableDouble,
  Dtool_DowncastInterface_ConfigVariableDouble,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableDouble,
  (CoerceFunction)Dtool_Coerce_ConfigVariableDouble,
};

static void Dtool_PyModuleClassInit_ConfigVariableDouble(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(NULL);
    Dtool_ConfigVariableDouble._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableDouble._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableDouble) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableDouble)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableDouble);
  }
}

/**
 * Python method tables for ConfigVariableFilename (ConfigVariableFilename)
 */
static PyMethodDef Dtool_Methods_ConfigVariableFilename[] = {
  {"assign", &Dtool_ConfigVariableFilename_operator_274, METH_O, (const char *)Dtool_ConfigVariableFilename_operator_274_comment},
  {"c_str", &Dtool_ConfigVariableFilename_c_str_276, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_c_str_276_comment},
  {"cStr", &Dtool_ConfigVariableFilename_c_str_276, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_c_str_276_comment},
  {"empty", &Dtool_ConfigVariableFilename_empty_277, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_empty_277_comment},
  {"length", &Dtool_ConfigVariableFilename_length_278, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_length_278_comment},
  {"get_fullpath", &Dtool_ConfigVariableFilename_get_fullpath_280, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_280_comment},
  {"getFullpath", &Dtool_ConfigVariableFilename_get_fullpath_280, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_280_comment},
  {"get_dirname", &Dtool_ConfigVariableFilename_get_dirname_281, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_dirname_281_comment},
  {"getDirname", &Dtool_ConfigVariableFilename_get_dirname_281, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_dirname_281_comment},
  {"get_basename", &Dtool_ConfigVariableFilename_get_basename_282, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_282_comment},
  {"getBasename", &Dtool_ConfigVariableFilename_get_basename_282, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_282_comment},
  {"get_fullpath_wo_extension", &Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283_comment},
  {"getFullpathWoExtension", &Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_fullpath_wo_extension_283_comment},
  {"get_basename_wo_extension", &Dtool_ConfigVariableFilename_get_basename_wo_extension_284, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_wo_extension_284_comment},
  {"getBasenameWoExtension", &Dtool_ConfigVariableFilename_get_basename_wo_extension_284, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_basename_wo_extension_284_comment},
  {"get_extension", &Dtool_ConfigVariableFilename_get_extension_285, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_extension_285_comment},
  {"getExtension", &Dtool_ConfigVariableFilename_get_extension_285, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_extension_285_comment},
  {"set_value", &Dtool_ConfigVariableFilename_set_value_289, METH_O, (const char *)Dtool_ConfigVariableFilename_set_value_289_comment},
  {"setValue", &Dtool_ConfigVariableFilename_set_value_289, METH_O, (const char *)Dtool_ConfigVariableFilename_set_value_289_comment},
  {"get_value", &Dtool_ConfigVariableFilename_get_value_290, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_value_290_comment},
  {"getValue", &Dtool_ConfigVariableFilename_get_value_290, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_value_290_comment},
  {"get_default_value", &Dtool_ConfigVariableFilename_get_default_value_291, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_default_value_291_comment},
  {"getDefaultValue", &Dtool_ConfigVariableFilename_get_default_value_291, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_get_default_value_291_comment},
  {"get_word", &Dtool_ConfigVariableFilename_get_word_397, METH_O, (const char *)Dtool_ConfigVariableFilename_get_word_397_comment},
  {"getWord", &Dtool_ConfigVariableFilename_get_word_397, METH_O, (const char *)Dtool_ConfigVariableFilename_get_word_397_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableFilename_set_word_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableFilename_set_word_398_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableFilename_set_word_398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableFilename_set_word_398_comment},
  {"operator_typecast", &Dtool_ConfigVariableFilename_operator_typecast_275, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_operator_typecast_275_comment},
  {"operatorTypecast", &Dtool_ConfigVariableFilename_operator_typecast_275, METH_NOARGS, (const char *)Dtool_ConfigVariableFilename_operator_typecast_275_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableFilename slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableFilename_operator_279_mp_subscript(PyObject *self, PyObject *arg) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char ConfigVariableFilename::operator [](std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:__getitem__", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    char return_value = (*(const ConfigVariableFilename*)local_this).operator []((std::size_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableFilename self, int n)\n");
  }
  return NULL;
}

//////////////////
//  A rich comparison function
//     ConfigVariableFilename
//////////////////
static PyObject *Dtool_RichCompare_ConfigVariableFilename(PyObject *self, PyObject *arg, int op) {
  ConfigVariableFilename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableFilename, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ConfigVariableFilename::operator ==(Filename const &other) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ConfigVariableFilename*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ConfigVariableFilename::operator !=(Filename const &other) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ConfigVariableFilename*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ConfigVariableFilename::operator <(Filename const &other) const
      Filename arg_local;
      Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const ConfigVariableFilename*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ConfigVariableFilename[] = {
  {(char *)"value", &Dtool_ConfigVariableFilename_value_Getter, &Dtool_ConfigVariableFilename_value_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableFilename_default_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableFilename = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableFilename = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableFilename = {
  0, // mp_length
  &Dtool_ConfigVariableFilename_operator_279_mp_subscript,
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableFilename = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableFilename = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableFilename",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableFilename,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableFilename,
    &Dtool_SequenceMethods_ConfigVariableFilename,
    &Dtool_MappingMethods_ConfigVariableFilename,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableFilename,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a Filename\n"
    " * type.  It is almost the same thing as ConfigVariableString, except it\n"
    " * handles an implicit Filename::expand_from() operation so that the user may\n"
    " * put OS-specific filenames, or filenames based on environment variables, in\n"
    " * the prc file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_ConfigVariableFilename,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableFilename,
    0, // tp_members
    Dtool_Properties_ConfigVariableFilename,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableFilename,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableFilename,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableFilename,
  Dtool_UpcastInterface_ConfigVariableFilename,
  Dtool_DowncastInterface_ConfigVariableFilename,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableFilename,
  (CoerceFunction)Dtool_Coerce_ConfigVariableFilename,
};

static void Dtool_PyModuleClassInit_ConfigVariableFilename(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(NULL);
    Dtool_ConfigVariableFilename._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableFilename._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableFilename) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableFilename)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableFilename);
  }
}

/**
 * Python method tables for Filename (Filename)
 */
static PyMethodDef Dtool_Methods_Filename[] = {
  {"__reduce__", &Dtool_Filename_reduce_297, METH_NOARGS, (const char *)Dtool_Filename_reduce_297_comment},
  {"text_filename", &Dtool_Filename_text_filename_298, METH_O | METH_STATIC, (const char *)Dtool_Filename_text_filename_298_comment},
  {"textFilename", &Dtool_Filename_text_filename_298, METH_O | METH_STATIC, (const char *)Dtool_Filename_text_filename_298_comment},
  {"binary_filename", &Dtool_Filename_binary_filename_299, METH_O | METH_STATIC, (const char *)Dtool_Filename_binary_filename_299_comment},
  {"binaryFilename", &Dtool_Filename_binary_filename_299, METH_O | METH_STATIC, (const char *)Dtool_Filename_binary_filename_299_comment},
  {"dso_filename", &Dtool_Filename_dso_filename_300, METH_O | METH_STATIC, (const char *)Dtool_Filename_dso_filename_300_comment},
  {"dsoFilename", &Dtool_Filename_dso_filename_300, METH_O | METH_STATIC, (const char *)Dtool_Filename_dso_filename_300_comment},
  {"executable_filename", &Dtool_Filename_executable_filename_301, METH_O | METH_STATIC, (const char *)Dtool_Filename_executable_filename_301_comment},
  {"executableFilename", &Dtool_Filename_executable_filename_301, METH_O | METH_STATIC, (const char *)Dtool_Filename_executable_filename_301_comment},
  {"pattern_filename", &Dtool_Filename_pattern_filename_302, METH_O | METH_STATIC, (const char *)Dtool_Filename_pattern_filename_302_comment},
  {"patternFilename", &Dtool_Filename_pattern_filename_302, METH_O | METH_STATIC, (const char *)Dtool_Filename_pattern_filename_302_comment},
  {"from_os_specific", (PyCFunction) &Dtool_Filename_from_os_specific_303, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_303_comment},
  {"fromOsSpecific", (PyCFunction) &Dtool_Filename_from_os_specific_303, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_303_comment},
  {"from_os_specific_w", (PyCFunction) &Dtool_Filename_from_os_specific_w_304, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_w_304_comment},
  {"fromOsSpecificW", (PyCFunction) &Dtool_Filename_from_os_specific_w_304, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_from_os_specific_w_304_comment},
  {"expand_from", (PyCFunction) &Dtool_Filename_expand_from_305, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_expand_from_305_comment},
  {"expandFrom", (PyCFunction) &Dtool_Filename_expand_from_305, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_expand_from_305_comment},
  {"temporary", (PyCFunction) &Dtool_Filename_temporary_306, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_Filename_temporary_306_comment},
  {"get_home_directory", &Dtool_Filename_get_home_directory_307, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_home_directory_307_comment},
  {"getHomeDirectory", &Dtool_Filename_get_home_directory_307, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_home_directory_307_comment},
  {"get_temp_directory", &Dtool_Filename_get_temp_directory_308, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_temp_directory_308_comment},
  {"getTempDirectory", &Dtool_Filename_get_temp_directory_308, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_temp_directory_308_comment},
  {"get_user_appdata_directory", &Dtool_Filename_get_user_appdata_directory_309, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_user_appdata_directory_309_comment},
  {"getUserAppdataDirectory", &Dtool_Filename_get_user_appdata_directory_309, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_user_appdata_directory_309_comment},
  {"get_common_appdata_directory", &Dtool_Filename_get_common_appdata_directory_310, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_common_appdata_directory_310_comment},
  {"getCommonAppdataDirectory", &Dtool_Filename_get_common_appdata_directory_310, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_common_appdata_directory_310_comment},
  {"assign", &Dtool_Filename_operator_311, METH_O, (const char *)Dtool_Filename_operator_311_comment},
  {"c_str", &Dtool_Filename_c_str_313, METH_NOARGS, (const char *)Dtool_Filename_c_str_313_comment},
  {"cStr", &Dtool_Filename_c_str_313, METH_NOARGS, (const char *)Dtool_Filename_c_str_313_comment},
  {"empty", &Dtool_Filename_empty_314, METH_NOARGS, (const char *)Dtool_Filename_empty_314_comment},
  {"length", &Dtool_Filename_length_315, METH_NOARGS, (const char *)Dtool_Filename_length_315_comment},
  {"substr", (PyCFunction) &Dtool_Filename_substr_318, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_substr_318_comment},
  {"get_fullpath", &Dtool_Filename_get_fullpath_322, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_322_comment},
  {"getFullpath", &Dtool_Filename_get_fullpath_322, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_322_comment},
  {"get_fullpath_w", &Dtool_Filename_get_fullpath_w_323, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_w_323_comment},
  {"getFullpathW", &Dtool_Filename_get_fullpath_w_323, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_w_323_comment},
  {"get_dirname", &Dtool_Filename_get_dirname_324, METH_NOARGS, (const char *)Dtool_Filename_get_dirname_324_comment},
  {"getDirname", &Dtool_Filename_get_dirname_324, METH_NOARGS, (const char *)Dtool_Filename_get_dirname_324_comment},
  {"get_basename", &Dtool_Filename_get_basename_325, METH_NOARGS, (const char *)Dtool_Filename_get_basename_325_comment},
  {"getBasename", &Dtool_Filename_get_basename_325, METH_NOARGS, (const char *)Dtool_Filename_get_basename_325_comment},
  {"get_fullpath_wo_extension", &Dtool_Filename_get_fullpath_wo_extension_326, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_wo_extension_326_comment},
  {"getFullpathWoExtension", &Dtool_Filename_get_fullpath_wo_extension_326, METH_NOARGS, (const char *)Dtool_Filename_get_fullpath_wo_extension_326_comment},
  {"get_basename_wo_extension", &Dtool_Filename_get_basename_wo_extension_327, METH_NOARGS, (const char *)Dtool_Filename_get_basename_wo_extension_327_comment},
  {"getBasenameWoExtension", &Dtool_Filename_get_basename_wo_extension_327, METH_NOARGS, (const char *)Dtool_Filename_get_basename_wo_extension_327_comment},
  {"get_extension", &Dtool_Filename_get_extension_328, METH_NOARGS, (const char *)Dtool_Filename_get_extension_328_comment},
  {"getExtension", &Dtool_Filename_get_extension_328, METH_NOARGS, (const char *)Dtool_Filename_get_extension_328_comment},
  {"set_fullpath", &Dtool_Filename_set_fullpath_329, METH_O, (const char *)Dtool_Filename_set_fullpath_329_comment},
  {"setFullpath", &Dtool_Filename_set_fullpath_329, METH_O, (const char *)Dtool_Filename_set_fullpath_329_comment},
  {"set_dirname", &Dtool_Filename_set_dirname_330, METH_O, (const char *)Dtool_Filename_set_dirname_330_comment},
  {"setDirname", &Dtool_Filename_set_dirname_330, METH_O, (const char *)Dtool_Filename_set_dirname_330_comment},
  {"set_basename", &Dtool_Filename_set_basename_331, METH_O, (const char *)Dtool_Filename_set_basename_331_comment},
  {"setBasename", &Dtool_Filename_set_basename_331, METH_O, (const char *)Dtool_Filename_set_basename_331_comment},
  {"set_fullpath_wo_extension", &Dtool_Filename_set_fullpath_wo_extension_332, METH_O, (const char *)Dtool_Filename_set_fullpath_wo_extension_332_comment},
  {"setFullpathWoExtension", &Dtool_Filename_set_fullpath_wo_extension_332, METH_O, (const char *)Dtool_Filename_set_fullpath_wo_extension_332_comment},
  {"set_basename_wo_extension", &Dtool_Filename_set_basename_wo_extension_333, METH_O, (const char *)Dtool_Filename_set_basename_wo_extension_333_comment},
  {"setBasenameWoExtension", &Dtool_Filename_set_basename_wo_extension_333, METH_O, (const char *)Dtool_Filename_set_basename_wo_extension_333_comment},
  {"set_extension", &Dtool_Filename_set_extension_334, METH_O, (const char *)Dtool_Filename_set_extension_334_comment},
  {"setExtension", &Dtool_Filename_set_extension_334, METH_O, (const char *)Dtool_Filename_set_extension_334_comment},
  {"set_binary", &Dtool_Filename_set_binary_335, METH_NOARGS, (const char *)Dtool_Filename_set_binary_335_comment},
  {"setBinary", &Dtool_Filename_set_binary_335, METH_NOARGS, (const char *)Dtool_Filename_set_binary_335_comment},
  {"set_text", &Dtool_Filename_set_text_336, METH_NOARGS, (const char *)Dtool_Filename_set_text_336_comment},
  {"setText", &Dtool_Filename_set_text_336, METH_NOARGS, (const char *)Dtool_Filename_set_text_336_comment},
  {"is_binary", &Dtool_Filename_is_binary_337, METH_NOARGS, (const char *)Dtool_Filename_is_binary_337_comment},
  {"isBinary", &Dtool_Filename_is_binary_337, METH_NOARGS, (const char *)Dtool_Filename_is_binary_337_comment},
  {"is_text", &Dtool_Filename_is_text_338, METH_NOARGS, (const char *)Dtool_Filename_is_text_338_comment},
  {"isText", &Dtool_Filename_is_text_338, METH_NOARGS, (const char *)Dtool_Filename_is_text_338_comment},
  {"is_binary_or_text", &Dtool_Filename_is_binary_or_text_339, METH_NOARGS, (const char *)Dtool_Filename_is_binary_or_text_339_comment},
  {"isBinaryOrText", &Dtool_Filename_is_binary_or_text_339, METH_NOARGS, (const char *)Dtool_Filename_is_binary_or_text_339_comment},
  {"set_type", &Dtool_Filename_set_type_340, METH_O, (const char *)Dtool_Filename_set_type_340_comment},
  {"setType", &Dtool_Filename_set_type_340, METH_O, (const char *)Dtool_Filename_set_type_340_comment},
  {"get_type", &Dtool_Filename_get_type_341, METH_NOARGS, (const char *)Dtool_Filename_get_type_341_comment},
  {"getType", &Dtool_Filename_get_type_341, METH_NOARGS, (const char *)Dtool_Filename_get_type_341_comment},
  {"set_pattern", &Dtool_Filename_set_pattern_342, METH_O, (const char *)Dtool_Filename_set_pattern_342_comment},
  {"setPattern", &Dtool_Filename_set_pattern_342, METH_O, (const char *)Dtool_Filename_set_pattern_342_comment},
  {"get_pattern", &Dtool_Filename_get_pattern_343, METH_NOARGS, (const char *)Dtool_Filename_get_pattern_343_comment},
  {"getPattern", &Dtool_Filename_get_pattern_343, METH_NOARGS, (const char *)Dtool_Filename_get_pattern_343_comment},
  {"has_hash", &Dtool_Filename_has_hash_344, METH_NOARGS, (const char *)Dtool_Filename_has_hash_344_comment},
  {"hasHash", &Dtool_Filename_has_hash_344, METH_NOARGS, (const char *)Dtool_Filename_has_hash_344_comment},
  {"get_filename_index", &Dtool_Filename_get_filename_index_345, METH_O, (const char *)Dtool_Filename_get_filename_index_345_comment},
  {"getFilenameIndex", &Dtool_Filename_get_filename_index_345, METH_O, (const char *)Dtool_Filename_get_filename_index_345_comment},
  {"get_hash_to_end", &Dtool_Filename_get_hash_to_end_346, METH_NOARGS, (const char *)Dtool_Filename_get_hash_to_end_346_comment},
  {"getHashToEnd", &Dtool_Filename_get_hash_to_end_346, METH_NOARGS, (const char *)Dtool_Filename_get_hash_to_end_346_comment},
  {"set_hash_to_end", &Dtool_Filename_set_hash_to_end_347, METH_O, (const char *)Dtool_Filename_set_hash_to_end_347_comment},
  {"setHashToEnd", &Dtool_Filename_set_hash_to_end_347, METH_O, (const char *)Dtool_Filename_set_hash_to_end_347_comment},
  {"standardize", &Dtool_Filename_standardize_349, METH_NOARGS, (const char *)Dtool_Filename_standardize_349_comment},
  {"is_local", &Dtool_Filename_is_local_350, METH_NOARGS, (const char *)Dtool_Filename_is_local_350_comment},
  {"isLocal", &Dtool_Filename_is_local_350, METH_NOARGS, (const char *)Dtool_Filename_is_local_350_comment},
  {"is_fully_qualified", &Dtool_Filename_is_fully_qualified_351, METH_NOARGS, (const char *)Dtool_Filename_is_fully_qualified_351_comment},
  {"isFullyQualified", &Dtool_Filename_is_fully_qualified_351, METH_NOARGS, (const char *)Dtool_Filename_is_fully_qualified_351_comment},
  {"make_absolute", &Dtool_Filename_make_absolute_352, METH_VARARGS, (const char *)Dtool_Filename_make_absolute_352_comment},
  {"makeAbsolute", &Dtool_Filename_make_absolute_352, METH_VARARGS, (const char *)Dtool_Filename_make_absolute_352_comment},
  {"make_canonical", &Dtool_Filename_make_canonical_353, METH_NOARGS, (const char *)Dtool_Filename_make_canonical_353_comment},
  {"makeCanonical", &Dtool_Filename_make_canonical_353, METH_NOARGS, (const char *)Dtool_Filename_make_canonical_353_comment},
  {"make_true_case", &Dtool_Filename_make_true_case_354, METH_NOARGS, (const char *)Dtool_Filename_make_true_case_354_comment},
  {"makeTrueCase", &Dtool_Filename_make_true_case_354, METH_NOARGS, (const char *)Dtool_Filename_make_true_case_354_comment},
  {"to_os_specific", &Dtool_Filename_to_os_specific_355, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_355_comment},
  {"toOsSpecific", &Dtool_Filename_to_os_specific_355, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_355_comment},
  {"to_os_specific_w", &Dtool_Filename_to_os_specific_w_356, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_w_356_comment},
  {"toOsSpecificW", &Dtool_Filename_to_os_specific_w_356, METH_NOARGS, (const char *)Dtool_Filename_to_os_specific_w_356_comment},
  {"to_os_generic", &Dtool_Filename_to_os_generic_357, METH_NOARGS, (const char *)Dtool_Filename_to_os_generic_357_comment},
  {"toOsGeneric", &Dtool_Filename_to_os_generic_357, METH_NOARGS, (const char *)Dtool_Filename_to_os_generic_357_comment},
  {"to_os_short_name", &Dtool_Filename_to_os_short_name_358, METH_NOARGS, (const char *)Dtool_Filename_to_os_short_name_358_comment},
  {"toOsShortName", &Dtool_Filename_to_os_short_name_358, METH_NOARGS, (const char *)Dtool_Filename_to_os_short_name_358_comment},
  {"to_os_long_name", &Dtool_Filename_to_os_long_name_359, METH_NOARGS, (const char *)Dtool_Filename_to_os_long_name_359_comment},
  {"toOsLongName", &Dtool_Filename_to_os_long_name_359, METH_NOARGS, (const char *)Dtool_Filename_to_os_long_name_359_comment},
  {"exists", &Dtool_Filename_exists_360, METH_NOARGS, (const char *)Dtool_Filename_exists_360_comment},
  {"is_regular_file", &Dtool_Filename_is_regular_file_361, METH_NOARGS, (const char *)Dtool_Filename_is_regular_file_361_comment},
  {"isRegularFile", &Dtool_Filename_is_regular_file_361, METH_NOARGS, (const char *)Dtool_Filename_is_regular_file_361_comment},
  {"is_writable", &Dtool_Filename_is_writable_362, METH_NOARGS, (const char *)Dtool_Filename_is_writable_362_comment},
  {"isWritable", &Dtool_Filename_is_writable_362, METH_NOARGS, (const char *)Dtool_Filename_is_writable_362_comment},
  {"is_directory", &Dtool_Filename_is_directory_363, METH_NOARGS, (const char *)Dtool_Filename_is_directory_363_comment},
  {"isDirectory", &Dtool_Filename_is_directory_363, METH_NOARGS, (const char *)Dtool_Filename_is_directory_363_comment},
  {"is_executable", &Dtool_Filename_is_executable_364, METH_NOARGS, (const char *)Dtool_Filename_is_executable_364_comment},
  {"isExecutable", &Dtool_Filename_is_executable_364, METH_NOARGS, (const char *)Dtool_Filename_is_executable_364_comment},
  {"compare_timestamps", (PyCFunction) &Dtool_Filename_compare_timestamps_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_compare_timestamps_365_comment},
  {"compareTimestamps", (PyCFunction) &Dtool_Filename_compare_timestamps_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_compare_timestamps_365_comment},
  {"get_timestamp", &Dtool_Filename_get_timestamp_366, METH_NOARGS, (const char *)Dtool_Filename_get_timestamp_366_comment},
  {"getTimestamp", &Dtool_Filename_get_timestamp_366, METH_NOARGS, (const char *)Dtool_Filename_get_timestamp_366_comment},
  {"get_access_timestamp", &Dtool_Filename_get_access_timestamp_367, METH_NOARGS, (const char *)Dtool_Filename_get_access_timestamp_367_comment},
  {"getAccessTimestamp", &Dtool_Filename_get_access_timestamp_367, METH_NOARGS, (const char *)Dtool_Filename_get_access_timestamp_367_comment},
  {"get_file_size", &Dtool_Filename_get_file_size_368, METH_NOARGS, (const char *)Dtool_Filename_get_file_size_368_comment},
  {"getFileSize", &Dtool_Filename_get_file_size_368, METH_NOARGS, (const char *)Dtool_Filename_get_file_size_368_comment},
  {"resolve_filename", (PyCFunction) &Dtool_Filename_resolve_filename_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_resolve_filename_369_comment},
  {"resolveFilename", (PyCFunction) &Dtool_Filename_resolve_filename_369, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_resolve_filename_369_comment},
  {"make_relative_to", (PyCFunction) &Dtool_Filename_make_relative_to_370, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_make_relative_to_370_comment},
  {"makeRelativeTo", (PyCFunction) &Dtool_Filename_make_relative_to_370, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_make_relative_to_370_comment},
  {"find_on_searchpath", &Dtool_Filename_find_on_searchpath_371, METH_O, (const char *)Dtool_Filename_find_on_searchpath_371_comment},
  {"findOnSearchpath", &Dtool_Filename_find_on_searchpath_371, METH_O, (const char *)Dtool_Filename_find_on_searchpath_371_comment},
  {"scan_directory", &Dtool_Filename_scan_directory_372, METH_VARARGS, (const char *)Dtool_Filename_scan_directory_372_comment},
  {"scanDirectory", &Dtool_Filename_scan_directory_372, METH_VARARGS, (const char *)Dtool_Filename_scan_directory_372_comment},
  {"open_read", &Dtool_Filename_open_read_373, METH_O, (const char *)Dtool_Filename_open_read_373_comment},
  {"openRead", &Dtool_Filename_open_read_373, METH_O, (const char *)Dtool_Filename_open_read_373_comment},
  {"open_write", (PyCFunction) &Dtool_Filename_open_write_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_write_374_comment},
  {"openWrite", (PyCFunction) &Dtool_Filename_open_write_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_write_374_comment},
  {"open_append", &Dtool_Filename_open_append_375, METH_O, (const char *)Dtool_Filename_open_append_375_comment},
  {"openAppend", &Dtool_Filename_open_append_375, METH_O, (const char *)Dtool_Filename_open_append_375_comment},
  {"open_read_write", (PyCFunction) &Dtool_Filename_open_read_write_376, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_read_write_376_comment},
  {"openReadWrite", (PyCFunction) &Dtool_Filename_open_read_write_376, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Filename_open_read_write_376_comment},
  {"open_read_append", &Dtool_Filename_open_read_append_377, METH_O, (const char *)Dtool_Filename_open_read_append_377_comment},
  {"openReadAppend", &Dtool_Filename_open_read_append_377, METH_O, (const char *)Dtool_Filename_open_read_append_377_comment},
  {"chdir", &Dtool_Filename_chdir_378, METH_NOARGS, (const char *)Dtool_Filename_chdir_378_comment},
  {"touch", &Dtool_Filename_touch_379, METH_NOARGS, (const char *)Dtool_Filename_touch_379_comment},
  {"unlink", &Dtool_Filename_unlink_380, METH_NOARGS, (const char *)Dtool_Filename_unlink_380_comment},
  {"rename_to", &Dtool_Filename_rename_to_381, METH_O, (const char *)Dtool_Filename_rename_to_381_comment},
  {"renameTo", &Dtool_Filename_rename_to_381, METH_O, (const char *)Dtool_Filename_rename_to_381_comment},
  {"copy_to", &Dtool_Filename_copy_to_382, METH_O, (const char *)Dtool_Filename_copy_to_382_comment},
  {"copyTo", &Dtool_Filename_copy_to_382, METH_O, (const char *)Dtool_Filename_copy_to_382_comment},
  {"make_dir", &Dtool_Filename_make_dir_383, METH_NOARGS, (const char *)Dtool_Filename_make_dir_383_comment},
  {"makeDir", &Dtool_Filename_make_dir_383, METH_NOARGS, (const char *)Dtool_Filename_make_dir_383_comment},
  {"mkdir", &Dtool_Filename_mkdir_384, METH_NOARGS, (const char *)Dtool_Filename_mkdir_384_comment},
  {"rmdir", &Dtool_Filename_rmdir_385, METH_NOARGS, (const char *)Dtool_Filename_rmdir_385_comment},
  {"compare_to", &Dtool_Filename_compare_to_389, METH_O, (const char *)Dtool_Filename_compare_to_389_comment},
  {"compareTo", &Dtool_Filename_compare_to_389, METH_O, (const char *)Dtool_Filename_compare_to_389_comment},
  {"get_hash", &Dtool_Filename_get_hash_391, METH_NOARGS, (const char *)Dtool_Filename_get_hash_391_comment},
  {"getHash", &Dtool_Filename_get_hash_391, METH_NOARGS, (const char *)Dtool_Filename_get_hash_391_comment},
  {"output", &Dtool_Filename_output_392, METH_O, (const char *)Dtool_Filename_output_392_comment},
  {"set_filesystem_encoding", &Dtool_Filename_set_filesystem_encoding_393, METH_O | METH_STATIC, (const char *)Dtool_Filename_set_filesystem_encoding_393_comment},
  {"setFilesystemEncoding", &Dtool_Filename_set_filesystem_encoding_393, METH_O | METH_STATIC, (const char *)Dtool_Filename_set_filesystem_encoding_393_comment},
  {"get_filesystem_encoding", &Dtool_Filename_get_filesystem_encoding_394, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_filesystem_encoding_394_comment},
  {"getFilesystemEncoding", &Dtool_Filename_get_filesystem_encoding_394, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_filesystem_encoding_394_comment},
  {"get_class_type", &Dtool_Filename_get_class_type_395, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_class_type_395_comment},
  {"getClassType", &Dtool_Filename_get_class_type_395, METH_NOARGS | METH_STATIC, (const char *)Dtool_Filename_get_class_type_395_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_Filename_operator_316_mp_subscript(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char Filename::operator [](std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:__getitem__", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    char return_value = (*(const Filename*)local_this).operator []((std::size_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Filename self, int n)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_add -> operator +
//////////////////
static PyObject *Dtool_Filename_operator_320_nb_add(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_Filename, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline Filename Filename::operator +(std::string const &other) const
  char *param1_str = NULL;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
    param1_str = NULL;
  }
#endif
  if (param1_str != NULL) {
    Filename *return_value = new Filename((*(const Filename*)local_this).operator +(std::string(param1_str, param1_len)));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_bool -> __nonzero__
//////////////////
static int Dtool_Filename_nonzero_390_nb_bool(PyObject *self) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return -1;
  }

  return (int) (*local_this).__nonzero__();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_divide -> operator /
//////////////////
static PyObject *Dtool_Filename_operator_321_nb_divide(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_Filename, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline Filename Filename::operator /(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Filename.__div__", "Filename");
  }
  Filename *return_value = new Filename((*(const Filename*)local_this).operator /(*arg_this));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_Filename_operator_319_nb_inplace_add(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_Filename, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void Filename::operator +=(std::string const &other)
    char *param1_str = NULL;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
      param1_str = NULL;
    }
#endif
    if (param1_str != NULL) {
      (*local_this).operator +=(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call Filename.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_compare -> compare_to
//////////////////
static int Dtool_Filename_compare_to_389_tp_compare(PyObject *self, PyObject *arg) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int Filename::compare_to(Filename const &other) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "Filename.compare_to", "Filename");
    return -1;
  }
  int return_value = (*(const Filename*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(Filename self, const Filename other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_Filename_get_hash_391_tp_hash(PyObject *self) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_repr -> __repr__
//////////////////
static PyObject *Dtool_Filename_repr_317_tp_repr(PyObject *self) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }

  // 1-PyObject *Filename::__repr__(void) const
  PyObject *return_value = invoke_extension((const Filename*)local_this).__repr__();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__repr__(Filename self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// Filename slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_Filename_operator_typecast_312_tp_str(PyObject *self) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &Filename::operator typecast(void) const
  std::string const &return_value = (std::string const &)*(const Filename*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(Filename self)\n");
  }
  return NULL;
}

//////////////////
//  A rich comparison function
//     Filename
//////////////////
static PyObject *Dtool_RichCompare_Filename(PyObject *self, PyObject *arg, int op) {
  Filename *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Filename, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Filename::operator ==(std::string const &other) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const Filename*)local_this).operator ==(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Filename::operator !=(std::string const &other) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const Filename*)local_this).operator !=(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Filename::operator <(std::string const &other) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const Filename*)local_this).operator <(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_Filename_compare_to_389_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_Filename = {
  &Dtool_Filename_operator_320_nb_add,
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  &Dtool_Filename_operator_321_nb_divide,
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_Filename_nonzero_390_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_Filename_operator_319_nb_inplace_add,
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PyMappingMethods Dtool_MappingMethods_Filename = {
  0, // mp_length
  &Dtool_Filename_operator_316_mp_subscript,
  0, // mp_ass_subscript
};

struct Dtool_PyTypedObject Dtool_Filename = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Filename",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Filename,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_Filename_compare_to_389_tp_compare,
#endif
    &Dtool_Filename_repr_317_tp_repr,
    &Dtool_NumberMethods_Filename,
    0, // tp_as_sequence
    &Dtool_MappingMethods_Filename,
    &Dtool_Filename_get_hash_391_tp_hash,
    0, // tp_call
    &Dtool_Filename_operator_typecast_312_tp_str,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The name of a file, such as a texture file or an Egg file.  Stores the full\n"
    " * pathname, and includes functions for extracting out the directory prefix\n"
    " * part and the file extension and stuff.\n"
    " *\n"
    " * A Filename is also aware of the mapping between the Unix-like filename\n"
    " * convention we use internally, and the local OS's specific filename\n"
    " * convention, and it knows how to perform basic OS-specific I/O, like testing\n"
    " * for file existence and searching a searchpath, as well as the best way to\n"
    " * open an fstream for reading or writing.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_Filename,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Filename,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Filename,
    PyType_GenericAlloc,
    Dtool_new_Filename,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Filename,
  Dtool_UpcastInterface_Filename,
  Dtool_DowncastInterface_Filename,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_Filename,
};

static void Dtool_PyModuleClassInit_Filename(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Filename._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_Filename._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum Filename::Type;
    PyDict_SetItemString(dict, "T_general", Dtool_WrapValue(Filename::T_general));
    PyDict_SetItemString(dict, "TGeneral", Dtool_WrapValue(Filename::T_general));
    PyDict_SetItemString(dict, "T_dso", Dtool_WrapValue(Filename::T_dso));
    PyDict_SetItemString(dict, "TDso", Dtool_WrapValue(Filename::T_dso));
    PyDict_SetItemString(dict, "T_executable", Dtool_WrapValue(Filename::T_executable));
    PyDict_SetItemString(dict, "TExecutable", Dtool_WrapValue(Filename::T_executable));
    if (PyType_Ready((PyTypeObject *)&Dtool_Filename) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Filename)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Filename);
  }
}

/**
 * Python method tables for ConfigVariableInt (ConfigVariableInt)
 */
static PyMethodDef Dtool_Methods_ConfigVariableInt[] = {
  {"assign", &Dtool_ConfigVariableInt_operator_402, METH_O, (const char *)Dtool_ConfigVariableInt_operator_402_comment},
  {"set_value", &Dtool_ConfigVariableInt_set_value_406, METH_O, (const char *)Dtool_ConfigVariableInt_set_value_406_comment},
  {"setValue", &Dtool_ConfigVariableInt_set_value_406, METH_O, (const char *)Dtool_ConfigVariableInt_set_value_406_comment},
  {"get_value", &Dtool_ConfigVariableInt_get_value_407, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_value_407_comment},
  {"getValue", &Dtool_ConfigVariableInt_get_value_407, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_value_407_comment},
  {"get_default_value", &Dtool_ConfigVariableInt_get_default_value_408, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_default_value_408_comment},
  {"getDefaultValue", &Dtool_ConfigVariableInt_get_default_value_408, METH_NOARGS, (const char *)Dtool_ConfigVariableInt_get_default_value_408_comment},
  {"get_word", &Dtool_ConfigVariableInt_get_word_411, METH_O, (const char *)Dtool_ConfigVariableInt_get_word_411_comment},
  {"getWord", &Dtool_ConfigVariableInt_get_word_411, METH_O, (const char *)Dtool_ConfigVariableInt_get_word_411_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableInt_set_word_412, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt_set_word_412_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableInt_set_word_412, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt_set_word_412_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt slot nb_int -> operator typecast int
//////////////////
static PyObject *Dtool_ConfigVariableInt_operator_typecast_int_403_nb_int(PyObject *self) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int ConfigVariableInt::operator typecast int(void) const
  int return_value = (int)*(const ConfigVariableInt*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast_int(ConfigVariableInt self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableInt_operator_405_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableInt index out of range");
    return NULL;
  }
  // 1-inline int ConfigVariableInt::operator [](std::size_t n) const
  int return_value = (*(const ConfigVariableInt*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableInt self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableInt_size_404_sq_length(PyObject *self) {
  ConfigVariableInt *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableInt[] = {
  {(char *)"value", &Dtool_ConfigVariableInt_value_Getter, &Dtool_ConfigVariableInt_value_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableInt_default_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableInt = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  &Dtool_ConfigVariableInt_operator_typecast_int_403_nb_int,
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableInt = {
  &Dtool_ConfigVariableInt_size_404_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConfigVariableInt_operator_405_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableInt = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableInt = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableInt = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableInt",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableInt,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableInt,
    &Dtool_SequenceMethods_ConfigVariableInt,
    &Dtool_MappingMethods_ConfigVariableInt,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableInt,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as an integer\n"
    " * type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableInt,
    0, // tp_members
    Dtool_Properties_ConfigVariableInt,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableInt,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableInt,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableInt,
  Dtool_UpcastInterface_ConfigVariableInt,
  Dtool_DowncastInterface_ConfigVariableInt,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableInt,
  (CoerceFunction)Dtool_Coerce_ConfigVariableInt,
};

static void Dtool_PyModuleClassInit_ConfigVariableInt(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(NULL);
    Dtool_ConfigVariableInt._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableInt._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableInt) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableInt)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableInt);
  }
}

/**
 * Python method tables for ConfigVariableInt64 (ConfigVariableInt64)
 */
static PyMethodDef Dtool_Methods_ConfigVariableInt64[] = {
  {"assign", &Dtool_ConfigVariableInt64_operator_416, METH_O, (const char *)Dtool_ConfigVariableInt64_operator_416_comment},
  {"set_value", &Dtool_ConfigVariableInt64_set_value_420, METH_O, (const char *)Dtool_ConfigVariableInt64_set_value_420_comment},
  {"setValue", &Dtool_ConfigVariableInt64_set_value_420, METH_O, (const char *)Dtool_ConfigVariableInt64_set_value_420_comment},
  {"get_value", &Dtool_ConfigVariableInt64_get_value_421, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_value_421_comment},
  {"getValue", &Dtool_ConfigVariableInt64_get_value_421, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_value_421_comment},
  {"get_default_value", &Dtool_ConfigVariableInt64_get_default_value_422, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_default_value_422_comment},
  {"getDefaultValue", &Dtool_ConfigVariableInt64_get_default_value_422, METH_NOARGS, (const char *)Dtool_ConfigVariableInt64_get_default_value_422_comment},
  {"get_word", &Dtool_ConfigVariableInt64_get_word_427, METH_O, (const char *)Dtool_ConfigVariableInt64_get_word_427_comment},
  {"getWord", &Dtool_ConfigVariableInt64_get_word_427, METH_O, (const char *)Dtool_ConfigVariableInt64_get_word_427_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableInt64_set_word_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt64_set_word_428_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableInt64_set_word_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableInt64_set_word_428_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt64 slot nb_int -> operator typecast int64_t
//////////////////
static PyObject *Dtool_ConfigVariableInt64_operator_typecast_int64_t_417_nb_int(PyObject *self) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline int64_t ConfigVariableInt64::operator typecast int64_t(void) const
  int64_t return_value = (int64_t)*(const ConfigVariableInt64*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast_int64_t(ConfigVariableInt64 self)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt64 slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableInt64_operator_419_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableInt64 index out of range");
    return NULL;
  }
  // 1-inline int64_t ConfigVariableInt64::operator [](std::size_t n) const
  int64_t return_value = (*(const ConfigVariableInt64*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableInt64 self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableInt64 slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableInt64_size_418_sq_length(PyObject *self) {
  ConfigVariableInt64 *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableInt64, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyGetSetDef Dtool_Properties_ConfigVariableInt64[] = {
  {(char *)"value", &Dtool_ConfigVariableInt64_value_Getter, &Dtool_ConfigVariableInt64_value_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableInt64_default_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableInt64 = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  &Dtool_ConfigVariableInt64_operator_typecast_int64_t_417_nb_int,
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableInt64 = {
  &Dtool_ConfigVariableInt64_size_418_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConfigVariableInt64_operator_419_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableInt64 = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableInt64 = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableInt64 = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableInt64",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableInt64,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableInt64,
    &Dtool_SequenceMethods_ConfigVariableInt64,
    &Dtool_MappingMethods_ConfigVariableInt64,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableInt64,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a 64-bit\n"
    " * integer type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableInt64,
    0, // tp_members
    Dtool_Properties_ConfigVariableInt64,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableInt64,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableInt64,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableInt64,
  Dtool_UpcastInterface_ConfigVariableInt64,
  Dtool_DowncastInterface_ConfigVariableInt64,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableInt64,
  (CoerceFunction)Dtool_Coerce_ConfigVariableInt64,
};

static void Dtool_PyModuleClassInit_ConfigVariableInt64(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(NULL);
    Dtool_ConfigVariableInt64._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableInt64._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableInt64) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableInt64)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableInt64);
  }
}

/**
 * Python method tables for ConfigVariableList (ConfigVariableList)
 */
static PyMethodDef Dtool_Methods_ConfigVariableList[] = {
  {"get_num_values", &Dtool_ConfigVariableList_get_num_values_433, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_values_433_comment},
  {"getNumValues", &Dtool_ConfigVariableList_get_num_values_433, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_values_433_comment},
  {"get_string_value", &Dtool_ConfigVariableList_get_string_value_434, METH_O, (const char *)Dtool_ConfigVariableList_get_string_value_434_comment},
  {"getStringValue", &Dtool_ConfigVariableList_get_string_value_434, METH_O, (const char *)Dtool_ConfigVariableList_get_string_value_434_comment},
  {"get_num_unique_values", &Dtool_ConfigVariableList_get_num_unique_values_435, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_unique_values_435_comment},
  {"getNumUniqueValues", &Dtool_ConfigVariableList_get_num_unique_values_435, METH_NOARGS, (const char *)Dtool_ConfigVariableList_get_num_unique_values_435_comment},
  {"get_unique_value", &Dtool_ConfigVariableList_get_unique_value_436, METH_O, (const char *)Dtool_ConfigVariableList_get_unique_value_436_comment},
  {"getUniqueValue", &Dtool_ConfigVariableList_get_unique_value_436, METH_O, (const char *)Dtool_ConfigVariableList_get_unique_value_436_comment},
  {"output", &Dtool_ConfigVariableList_output_439, METH_O, (const char *)Dtool_ConfigVariableList_output_439_comment},
  {"write", &Dtool_ConfigVariableList_write_440, METH_O, (const char *)Dtool_ConfigVariableList_write_440_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableList slot sq_item -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableList_operator_438_sq_item(PyObject *self, Py_ssize_t index) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConfigVariableList index out of range");
    return NULL;
  }
  // 1-inline std::string ConfigVariableList::operator [](std::size_t n) const
  std::string return_value = (*(const ConfigVariableList*)local_this).operator [](index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableList self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableList slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConfigVariableList_size_437_sq_length(PyObject *self) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     ConfigVariableList
//////////////////
static PyObject *Dtool_Repr_ConfigVariableList(PyObject *self) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableList
//////////////////
static PyObject *Dtool_Str_ConfigVariableList(PyObject *self) {
  ConfigVariableList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableList, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConfigVariableList = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableList = {
  &Dtool_ConfigVariableList_size_437_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_ConfigVariableList_operator_438_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableList = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableList = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableList = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableList",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableList,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableList,
    &Dtool_NumberMethods_ConfigVariableList,
    &Dtool_SequenceMethods_ConfigVariableList,
    &Dtool_MappingMethods_ConfigVariableList,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigVariableList,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is similar to ConfigVariable, but it reports its value as a list\n"
    " * of strings.  In this special case, all of the declarations of the variable\n"
    " * are returned as the elements of this list, in order.\n"
    " *\n"
    " * Note that this is different from a normal ConfigVariableString, which just\n"
    " * returns its topmost value, which can optionally be treated as a number of\n"
    " * discrete words by dividing it at the spaces.\n"
    " *\n"
    " * A ConfigVariableList cannot be modified locally.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableList,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableList,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableList,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableList,
  Dtool_UpcastInterface_ConfigVariableList,
  Dtool_DowncastInterface_ConfigVariableList,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableList,
  (CoerceFunction)Dtool_Coerce_ConfigVariableList,
};

static void Dtool_PyModuleClassInit_ConfigVariableList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariableBase(NULL);
    Dtool_ConfigVariableList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariableBase);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableList);
  }
}

/**
 * Python method tables for ConfigVariableManager (ConfigVariableManager)
 */
static PyMethodDef Dtool_Methods_ConfigVariableManager[] = {
  {"make_variable", &Dtool_ConfigVariableManager_make_variable_442, METH_O, (const char *)Dtool_ConfigVariableManager_make_variable_442_comment},
  {"makeVariable", &Dtool_ConfigVariableManager_make_variable_442, METH_O, (const char *)Dtool_ConfigVariableManager_make_variable_442_comment},
  {"make_variable_template", (PyCFunction) &Dtool_ConfigVariableManager_make_variable_template_443, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableManager_make_variable_template_443_comment},
  {"makeVariableTemplate", (PyCFunction) &Dtool_ConfigVariableManager_make_variable_template_443, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableManager_make_variable_template_443_comment},
  {"get_num_variables", &Dtool_ConfigVariableManager_get_num_variables_444, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_get_num_variables_444_comment},
  {"getNumVariables", &Dtool_ConfigVariableManager_get_num_variables_444, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_get_num_variables_444_comment},
  {"get_variable", &Dtool_ConfigVariableManager_get_variable_445, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_445_comment},
  {"getVariable", &Dtool_ConfigVariableManager_get_variable_445, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_445_comment},
  {"get_variable_name", &Dtool_ConfigVariableManager_get_variable_name_447, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_name_447_comment},
  {"getVariableName", &Dtool_ConfigVariableManager_get_variable_name_447, METH_O, (const char *)Dtool_ConfigVariableManager_get_variable_name_447_comment},
  {"is_variable_used", &Dtool_ConfigVariableManager_is_variable_used_448, METH_O, (const char *)Dtool_ConfigVariableManager_is_variable_used_448_comment},
  {"isVariableUsed", &Dtool_ConfigVariableManager_is_variable_used_448, METH_O, (const char *)Dtool_ConfigVariableManager_is_variable_used_448_comment},
  {"output", &Dtool_ConfigVariableManager_output_450, METH_O, (const char *)Dtool_ConfigVariableManager_output_450_comment},
  {"write", &Dtool_ConfigVariableManager_write_451, METH_O, (const char *)Dtool_ConfigVariableManager_write_451_comment},
  {"write_prc_variables", &Dtool_ConfigVariableManager_write_prc_variables_452, METH_O, (const char *)Dtool_ConfigVariableManager_write_prc_variables_452_comment},
  {"writePrcVariables", &Dtool_ConfigVariableManager_write_prc_variables_452, METH_O, (const char *)Dtool_ConfigVariableManager_write_prc_variables_452_comment},
  {"list_unused_variables", &Dtool_ConfigVariableManager_list_unused_variables_453, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_unused_variables_453_comment},
  {"listUnusedVariables", &Dtool_ConfigVariableManager_list_unused_variables_453, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_unused_variables_453_comment},
  {"list_variables", &Dtool_ConfigVariableManager_list_variables_454, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_variables_454_comment},
  {"listVariables", &Dtool_ConfigVariableManager_list_variables_454, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_variables_454_comment},
  {"list_dynamic_variables", &Dtool_ConfigVariableManager_list_dynamic_variables_455, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_dynamic_variables_455_comment},
  {"listDynamicVariables", &Dtool_ConfigVariableManager_list_dynamic_variables_455, METH_NOARGS, (const char *)Dtool_ConfigVariableManager_list_dynamic_variables_455_comment},
  {"get_global_ptr", &Dtool_ConfigVariableManager_get_global_ptr_456, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigVariableManager_get_global_ptr_456_comment},
  {"getGlobalPtr", &Dtool_ConfigVariableManager_get_global_ptr_456, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConfigVariableManager_get_global_ptr_456_comment},
  {"get_variables", (PyCFunction) &MakeSeq_ConfigVariableManager_get_variables, METH_NOARGS, NULL},
  { "getVariables", (PyCFunction) &MakeSeq_ConfigVariableManager_get_variables, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigVariableManager
//////////////////
static PyObject *Dtool_Repr_ConfigVariableManager(PyObject *self) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableManager
//////////////////
static PyObject *Dtool_Str_ConfigVariableManager(PyObject *self) {
  ConfigVariableManager *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableManager, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableManager[] = {
  {(char *)"variables", &Dtool_ConfigVariableManager_variables_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableManager = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableManager = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableManager",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableManager,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableManager,
    &Dtool_NumberMethods_ConfigVariableManager,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigVariableManager,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A global object that maintains the set of ConfigVariables (actually,\n"
    " * ConfigVariableCores) everywhere in the world, and keeps them in sorted\n"
    " * order.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableManager,
    0, // tp_members
    Dtool_Properties_ConfigVariableManager,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableManager,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableManager,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableManager,
  Dtool_UpcastInterface_ConfigVariableManager,
  Dtool_DowncastInterface_ConfigVariableManager,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ConfigVariableManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConfigVariableManager._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableManager);
  }
}

/**
 * Python method tables for ConfigVariableSearchPath (ConfigVariableSearchPath)
 */
static PyMethodDef Dtool_Methods_ConfigVariableSearchPath[] = {
  {"get_value", &Dtool_ConfigVariableSearchPath_get_value_461, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_value_461_comment},
  {"getValue", &Dtool_ConfigVariableSearchPath_get_value_461, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_value_461_comment},
  {"get_default_value", &Dtool_ConfigVariableSearchPath_get_default_value_462, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_default_value_462_comment},
  {"getDefaultValue", &Dtool_ConfigVariableSearchPath_get_default_value_462, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_default_value_462_comment},
  {"clear_local_value", &Dtool_ConfigVariableSearchPath_clear_local_value_497, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_clear_local_value_497_comment},
  {"clearLocalValue", &Dtool_ConfigVariableSearchPath_clear_local_value_497, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_clear_local_value_497_comment},
  {"clear", &Dtool_ConfigVariableSearchPath_clear_498, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_clear_498_comment},
  {"append_directory", &Dtool_ConfigVariableSearchPath_append_directory_499, METH_O, (const char *)Dtool_ConfigVariableSearchPath_append_directory_499_comment},
  {"appendDirectory", &Dtool_ConfigVariableSearchPath_append_directory_499, METH_O, (const char *)Dtool_ConfigVariableSearchPath_append_directory_499_comment},
  {"prepend_directory", &Dtool_ConfigVariableSearchPath_prepend_directory_500, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_directory_500_comment},
  {"prependDirectory", &Dtool_ConfigVariableSearchPath_prepend_directory_500, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_directory_500_comment},
  {"append_path", (PyCFunction) &Dtool_ConfigVariableSearchPath_append_path_501, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_append_path_501_comment},
  {"appendPath", (PyCFunction) &Dtool_ConfigVariableSearchPath_append_path_501, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_append_path_501_comment},
  {"prepend_path", &Dtool_ConfigVariableSearchPath_prepend_path_502, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_path_502_comment},
  {"prependPath", &Dtool_ConfigVariableSearchPath_prepend_path_502, METH_O, (const char *)Dtool_ConfigVariableSearchPath_prepend_path_502_comment},
  {"is_empty", &Dtool_ConfigVariableSearchPath_is_empty_503, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_is_empty_503_comment},
  {"isEmpty", &Dtool_ConfigVariableSearchPath_is_empty_503, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_is_empty_503_comment},
  {"get_num_directories", &Dtool_ConfigVariableSearchPath_get_num_directories_504, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_num_directories_504_comment},
  {"getNumDirectories", &Dtool_ConfigVariableSearchPath_get_num_directories_504, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_get_num_directories_504_comment},
  {"get_directory", &Dtool_ConfigVariableSearchPath_get_directory_505, METH_O, (const char *)Dtool_ConfigVariableSearchPath_get_directory_505_comment},
  {"getDirectory", &Dtool_ConfigVariableSearchPath_get_directory_505, METH_O, (const char *)Dtool_ConfigVariableSearchPath_get_directory_505_comment},
  {"find_file", &Dtool_ConfigVariableSearchPath_find_file_508, METH_O, (const char *)Dtool_ConfigVariableSearchPath_find_file_508_comment},
  {"findFile", &Dtool_ConfigVariableSearchPath_find_file_508, METH_O, (const char *)Dtool_ConfigVariableSearchPath_find_file_508_comment},
  {"find_all_files", (PyCFunction) &Dtool_ConfigVariableSearchPath_find_all_files_509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_find_all_files_509_comment},
  {"findAllFiles", (PyCFunction) &Dtool_ConfigVariableSearchPath_find_all_files_509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableSearchPath_find_all_files_509_comment},
  {"output", &Dtool_ConfigVariableSearchPath_output_510, METH_O, (const char *)Dtool_ConfigVariableSearchPath_output_510_comment},
  {"write", &Dtool_ConfigVariableSearchPath_write_511, METH_O, (const char *)Dtool_ConfigVariableSearchPath_write_511_comment},
  {"operator_typecast", &Dtool_ConfigVariableSearchPath_operator_typecast_460, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_operator_typecast_460_comment},
  {"operatorTypecast", &Dtool_ConfigVariableSearchPath_operator_typecast_460, METH_NOARGS, (const char *)Dtool_ConfigVariableSearchPath_operator_typecast_460_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_directories", (PyCFunction) &MakeSeq_ConfigVariableSearchPath_get_directories, METH_NOARGS, NULL},
  { "getDirectories", (PyCFunction) &MakeSeq_ConfigVariableSearchPath_get_directories, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     ConfigVariableSearchPath
//////////////////
static PyObject *Dtool_Repr_ConfigVariableSearchPath(PyObject *self) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ConfigVariableSearchPath
//////////////////
static PyObject *Dtool_Str_ConfigVariableSearchPath(PyObject *self) {
  ConfigVariableSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableSearchPath, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_ConfigVariableSearchPath[] = {
  {(char *)"value", &Dtool_ConfigVariableSearchPath_value_Getter, NULL, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableSearchPath_default_value_Getter, NULL, NULL, NULL},
  {(char *)"directories", &Dtool_ConfigVariableSearchPath_directories_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableSearchPath = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableSearchPath = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableSearchPath = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableSearchPath = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableSearchPath = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableSearchPath",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableSearchPath,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_ConfigVariableSearchPath,
    &Dtool_NumberMethods_ConfigVariableSearchPath,
    &Dtool_SequenceMethods_ConfigVariableSearchPath,
    &Dtool_MappingMethods_ConfigVariableSearchPath,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_ConfigVariableSearchPath,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableSearchPath,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is similar to a ConfigVariableList, but it returns its list as a\n"
    " * DSearchPath, as a list of directories.\n"
    " *\n"
    " * You may locally append directories to the end of the search path with the\n"
    " * methods here, or prepend them to the beginning.  Use these methods to make\n"
    " * adjustments to the path; do not attempt to directly modify the const\n"
    " * DSearchPath object returned by get_value().\n"
    " *\n"
    " * Unlike other ConfigVariable types, local changes (made by calling\n"
    " * append_directory() and prepend_directory()) are specific to this particular\n"
    " * instance of the ConfigVariableSearchPath.  A separate instance of the same\n"
    " * variable, created by using the same name to the constructor, will not\n"
    " * reflect the local changes.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableSearchPath,
    0, // tp_members
    Dtool_Properties_ConfigVariableSearchPath,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableSearchPath,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableSearchPath,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableSearchPath,
  Dtool_UpcastInterface_ConfigVariableSearchPath,
  Dtool_DowncastInterface_ConfigVariableSearchPath,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableSearchPath,
  (CoerceFunction)Dtool_Coerce_ConfigVariableSearchPath,
};

static void Dtool_PyModuleClassInit_ConfigVariableSearchPath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariableBase(NULL);
    Dtool_ConfigVariableSearchPath._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariableBase);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableSearchPath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableSearchPath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableSearchPath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableSearchPath);
  }
}

/**
 * Python method tables for DSearchPath_Results (Results)
 */
static PyMethodDef Dtool_Methods_DSearchPath_Results[] = {
  {"assign", &Dtool_DSearchPath_Results_operator_468, METH_O, (const char *)Dtool_DSearchPath_Results_operator_468_comment},
  {"clear", &Dtool_DSearchPath_Results_clear_470, METH_NOARGS, (const char *)Dtool_DSearchPath_Results_clear_470_comment},
  {"get_num_files", &Dtool_DSearchPath_Results_get_num_files_471, METH_NOARGS, (const char *)Dtool_DSearchPath_Results_get_num_files_471_comment},
  {"getNumFiles", &Dtool_DSearchPath_Results_get_num_files_471, METH_NOARGS, (const char *)Dtool_DSearchPath_Results_get_num_files_471_comment},
  {"get_file", &Dtool_DSearchPath_Results_get_file_472, METH_O, (const char *)Dtool_DSearchPath_Results_get_file_472_comment},
  {"getFile", &Dtool_DSearchPath_Results_get_file_472, METH_O, (const char *)Dtool_DSearchPath_Results_get_file_472_comment},
  {"output", &Dtool_DSearchPath_Results_output_475, METH_O, (const char *)Dtool_DSearchPath_Results_output_475_comment},
  {"write", (PyCFunction) &Dtool_DSearchPath_Results_write_476, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_Results_write_476_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DSearchPath_Results slot sq_item -> operator []
//////////////////
static PyObject *Dtool_DSearchPath_Results_operator_473_sq_item(PyObject *self, Py_ssize_t index) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "DSearchPath_Results index out of range");
    return NULL;
  }
  // 1-inline Filename DSearchPath::Results::operator [](std::size_t n) const
  Filename *return_value = new Filename((*(const DSearchPath::Results*)local_this).operator [](index));
  if (return_value == NULL) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(Results self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DSearchPath_Results slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_DSearchPath_Results_size_474_sq_length(PyObject *self) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     DSearchPath_Results
//////////////////
static PyObject *Dtool_Repr_DSearchPath_Results(PyObject *self) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DSearchPath_Results
//////////////////
static PyObject *Dtool_Str_DSearchPath_Results(PyObject *self) {
  DSearchPath::Results *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath_Results, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DSearchPath_Results = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DSearchPath_Results = {
  &Dtool_DSearchPath_Results_size_474_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_DSearchPath_Results_operator_473_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

struct Dtool_PyTypedObject Dtool_DSearchPath_Results = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Results",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DSearchPath_Results,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DSearchPath_Results,
    &Dtool_NumberMethods_DSearchPath_Results,
    &Dtool_SequenceMethods_DSearchPath_Results,
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DSearchPath_Results,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DSearchPath_Results,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DSearchPath_Results,
    PyType_GenericAlloc,
    Dtool_new_DSearchPath_Results,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DSearchPath_Results,
  Dtool_UpcastInterface_DSearchPath_Results,
  Dtool_DowncastInterface_DSearchPath_Results,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DSearchPath_Results(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DSearchPath_Results._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DSearchPath_Results._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DSearchPath_Results) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DSearchPath_Results)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DSearchPath_Results);
  }
}

/**
 * Python method tables for DSearchPath (DSearchPath)
 */
static PyMethodDef Dtool_Methods_DSearchPath[] = {
  {"assign", &Dtool_DSearchPath_operator_478, METH_O, (const char *)Dtool_DSearchPath_operator_478_comment},
  {"clear", &Dtool_DSearchPath_clear_480, METH_NOARGS, (const char *)Dtool_DSearchPath_clear_480_comment},
  {"append_directory", &Dtool_DSearchPath_append_directory_481, METH_O, (const char *)Dtool_DSearchPath_append_directory_481_comment},
  {"appendDirectory", &Dtool_DSearchPath_append_directory_481, METH_O, (const char *)Dtool_DSearchPath_append_directory_481_comment},
  {"prepend_directory", &Dtool_DSearchPath_prepend_directory_482, METH_O, (const char *)Dtool_DSearchPath_prepend_directory_482_comment},
  {"prependDirectory", &Dtool_DSearchPath_prepend_directory_482, METH_O, (const char *)Dtool_DSearchPath_prepend_directory_482_comment},
  {"append_path", (PyCFunction) &Dtool_DSearchPath_append_path_483, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_append_path_483_comment},
  {"appendPath", (PyCFunction) &Dtool_DSearchPath_append_path_483, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_append_path_483_comment},
  {"prepend_path", &Dtool_DSearchPath_prepend_path_484, METH_O, (const char *)Dtool_DSearchPath_prepend_path_484_comment},
  {"prependPath", &Dtool_DSearchPath_prepend_path_484, METH_O, (const char *)Dtool_DSearchPath_prepend_path_484_comment},
  {"is_empty", &Dtool_DSearchPath_is_empty_485, METH_NOARGS, (const char *)Dtool_DSearchPath_is_empty_485_comment},
  {"isEmpty", &Dtool_DSearchPath_is_empty_485, METH_NOARGS, (const char *)Dtool_DSearchPath_is_empty_485_comment},
  {"get_num_directories", &Dtool_DSearchPath_get_num_directories_486, METH_NOARGS, (const char *)Dtool_DSearchPath_get_num_directories_486_comment},
  {"getNumDirectories", &Dtool_DSearchPath_get_num_directories_486, METH_NOARGS, (const char *)Dtool_DSearchPath_get_num_directories_486_comment},
  {"get_directory", &Dtool_DSearchPath_get_directory_487, METH_O, (const char *)Dtool_DSearchPath_get_directory_487_comment},
  {"getDirectory", &Dtool_DSearchPath_get_directory_487, METH_O, (const char *)Dtool_DSearchPath_get_directory_487_comment},
  {"find_file", &Dtool_DSearchPath_find_file_491, METH_O, (const char *)Dtool_DSearchPath_find_file_491_comment},
  {"findFile", &Dtool_DSearchPath_find_file_491, METH_O, (const char *)Dtool_DSearchPath_find_file_491_comment},
  {"find_all_files", (PyCFunction) &Dtool_DSearchPath_find_all_files_492, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_find_all_files_492_comment},
  {"findAllFiles", (PyCFunction) &Dtool_DSearchPath_find_all_files_492, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_find_all_files_492_comment},
  {"search_path", (PyCFunction) &Dtool_DSearchPath_search_path_493, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DSearchPath_search_path_493_comment},
  {"searchPath", (PyCFunction) &Dtool_DSearchPath_search_path_493, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DSearchPath_search_path_493_comment},
  {"output", (PyCFunction) &Dtool_DSearchPath_output_494, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_output_494_comment},
  {"write", (PyCFunction) &Dtool_DSearchPath_write_495, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DSearchPath_write_495_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_directories", (PyCFunction) &MakeSeq_DSearchPath_get_directories, METH_NOARGS, NULL},
  { "getDirectories", (PyCFunction) &MakeSeq_DSearchPath_get_directories, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DSearchPath
//////////////////
static PyObject *Dtool_Repr_DSearchPath(PyObject *self) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DSearchPath
//////////////////
static PyObject *Dtool_Str_DSearchPath(PyObject *self) {
  DSearchPath *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DSearchPath, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_DSearchPath[] = {
  {(char *)"directories", &Dtool_DSearchPath_directories_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_DSearchPath = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DSearchPath = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DSearchPath",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DSearchPath,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DSearchPath,
    &Dtool_NumberMethods_DSearchPath,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DSearchPath,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class stores a list of directories that can be searched, in order, to\n"
    " * locate a particular file.  It is normally constructed by passing it a\n"
    " * traditional searchpath-style string, e.g.  a list of directory names\n"
    " * delimited by spaces or colons, but it can also be built up explicitly.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DSearchPath,
    0, // tp_members
    Dtool_Properties_DSearchPath,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DSearchPath,
    PyType_GenericAlloc,
    Dtool_new_DSearchPath,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DSearchPath,
  Dtool_UpcastInterface_DSearchPath,
  Dtool_DowncastInterface_DSearchPath,
  (CoerceFunction)Dtool_ConstCoerce_DSearchPath,
  (CoerceFunction)Dtool_Coerce_DSearchPath,
};

static void Dtool_PyModuleClassInit_DSearchPath(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DSearchPath._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DSearchPath._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   DSearchPath_Results;
    Dtool_PyModuleClassInit_DSearchPath_Results(NULL);
    PyDict_SetItemString(dict, "Results", (PyObject *)&Dtool_DSearchPath_Results);
    if (PyType_Ready((PyTypeObject *)&Dtool_DSearchPath) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DSearchPath)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DSearchPath);
  }
}

/**
 * Python method tables for ConfigVariableString (ConfigVariableString)
 */
static PyMethodDef Dtool_Methods_ConfigVariableString[] = {
  {"assign", &Dtool_ConfigVariableString_operator_514, METH_O, (const char *)Dtool_ConfigVariableString_operator_514_comment},
  {"c_str", &Dtool_ConfigVariableString_c_str_516, METH_NOARGS, (const char *)Dtool_ConfigVariableString_c_str_516_comment},
  {"cStr", &Dtool_ConfigVariableString_c_str_516, METH_NOARGS, (const char *)Dtool_ConfigVariableString_c_str_516_comment},
  {"empty", &Dtool_ConfigVariableString_empty_517, METH_NOARGS, (const char *)Dtool_ConfigVariableString_empty_517_comment},
  {"length", &Dtool_ConfigVariableString_length_518, METH_NOARGS, (const char *)Dtool_ConfigVariableString_length_518_comment},
  {"set_value", &Dtool_ConfigVariableString_set_value_523, METH_O, (const char *)Dtool_ConfigVariableString_set_value_523_comment},
  {"setValue", &Dtool_ConfigVariableString_set_value_523, METH_O, (const char *)Dtool_ConfigVariableString_set_value_523_comment},
  {"get_value", &Dtool_ConfigVariableString_get_value_524, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_value_524_comment},
  {"getValue", &Dtool_ConfigVariableString_get_value_524, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_value_524_comment},
  {"get_default_value", &Dtool_ConfigVariableString_get_default_value_525, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_default_value_525_comment},
  {"getDefaultValue", &Dtool_ConfigVariableString_get_default_value_525, METH_NOARGS, (const char *)Dtool_ConfigVariableString_get_default_value_525_comment},
  {"get_word", &Dtool_ConfigVariableString_get_word_528, METH_O, (const char *)Dtool_ConfigVariableString_get_word_528_comment},
  {"getWord", &Dtool_ConfigVariableString_get_word_528, METH_O, (const char *)Dtool_ConfigVariableString_get_word_528_comment},
  {"set_word", (PyCFunction) &Dtool_ConfigVariableString_set_word_529, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableString_set_word_529_comment},
  {"setWord", (PyCFunction) &Dtool_ConfigVariableString_set_word_529, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConfigVariableString_set_word_529_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableString slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_ConfigVariableString_operator_519_mp_subscript(PyObject *self, PyObject *arg) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline char ConfigVariableString::operator [](std::size_t n) const
  Py_ssize_t param1;
  if (PyArg_Parse(arg, "n:__getitem__", &param1)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    char return_value = (*(const ConfigVariableString*)local_this).operator []((std::size_t)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConfigVariableString self, int n)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConfigVariableString slot tp_str -> operator typecast
//////////////////
static PyObject *Dtool_ConfigVariableString_operator_typecast_515_tp_str(PyObject *self) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }

  // 1-inline std::string const &ConfigVariableString::operator typecast(void) const
  std::string const &return_value = (std::string const &)*(const ConfigVariableString*)local_this;
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "operator_typecast(ConfigVariableString self)\n");
  }
  return NULL;
}

//////////////////
//  A rich comparison function
//     ConfigVariableString
//////////////////
static PyObject *Dtool_RichCompare_ConfigVariableString(PyObject *self, PyObject *arg, int op) {
  ConfigVariableString *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConfigVariableString, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ConfigVariableString::operator ==(std::string const &other) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const ConfigVariableString*)local_this).operator ==(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ConfigVariableString::operator !=(std::string const &other) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const ConfigVariableString*)local_this).operator !=(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ConfigVariableString::operator <(std::string const &other) const
      char *param1_str = NULL;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, &param1_str, &param1_len) == -1) {
        param1_str = NULL;
      }
#endif
      if (param1_str != NULL) {
        bool return_value = (*(const ConfigVariableString*)local_this).operator <(std::string(param1_str, param1_len));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      PyErr_Clear();
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ConfigVariableString[] = {
  {(char *)"value", &Dtool_ConfigVariableString_value_Getter, &Dtool_ConfigVariableString_value_Setter, NULL, NULL},
  {(char *)"default_value", &Dtool_ConfigVariableString_default_value_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ConfigVariableString = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConfigVariableString = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ConfigVariableString = {
  0, // mp_length
  &Dtool_ConfigVariableString_operator_519_mp_subscript,
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ConfigVariableString = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ConfigVariableString = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ConfigVariableString",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ConfigVariableString,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ConfigVariableString,
    &Dtool_SequenceMethods_ConfigVariableString,
    &Dtool_MappingMethods_ConfigVariableString,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_ConfigVariableString_operator_typecast_515_tp_str,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ConfigVariableString,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a convenience class to specialize ConfigVariable as a string type.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_ConfigVariableString,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ConfigVariableString,
    0, // tp_members
    Dtool_Properties_ConfigVariableString,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ConfigVariableString,
    PyType_GenericAlloc,
    Dtool_new_ConfigVariableString,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConfigVariableString,
  Dtool_UpcastInterface_ConfigVariableString,
  Dtool_DowncastInterface_ConfigVariableString,
  (CoerceFunction)Dtool_ConstCoerce_ConfigVariableString,
  (CoerceFunction)Dtool_Coerce_ConfigVariableString,
};

static void Dtool_PyModuleClassInit_ConfigVariableString(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigVariable(NULL);
    Dtool_ConfigVariableString._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigVariable);
    PyObject *dict = PyDict_New();
    Dtool_ConfigVariableString._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConfigVariableString) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConfigVariableString)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConfigVariableString);
  }
}

/**
 * Python method tables for DConfig (DConfig)
 */
static PyMethodDef Dtool_Methods_DConfig[] = {
  {"GetBool", (PyCFunction) &Dtool_DConfig_GetBool_532, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DConfig_GetBool_532_comment},
  {"GetInt", (PyCFunction) &Dtool_DConfig_GetInt_533, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DConfig_GetInt_533_comment},
  {"GetFloat", (PyCFunction) &Dtool_DConfig_GetFloat_534, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DConfig_GetFloat_534_comment},
  {"GetDouble", (PyCFunction) &Dtool_DConfig_GetDouble_535, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DConfig_GetDouble_535_comment},
  {"GetString", (PyCFunction) &Dtool_DConfig_GetString_536, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DConfig_GetString_536_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DConfig = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DConfig = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DConfig",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DConfig,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DConfig,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class emulates the old dconfig-style interface to our Panda config\n"
    " * system.  It exists only to provide backward-compatible support, and it is\n"
    " * used primarily by Python code.  For modern code, use the new\n"
    " * ConfigVariable* interface instead of this deprecated interface.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DConfig,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DConfig,
    PyType_GenericAlloc,
    Dtool_new_DConfig,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DConfig,
  Dtool_UpcastInterface_DConfig,
  Dtool_DowncastInterface_DConfig,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DConfig(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DConfig._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DConfig._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DConfig) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DConfig)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DConfig);
  }
}

/**
 * Python method tables for ExecutionEnvironment (ExecutionEnvironment)
 */
static PyMethodDef Dtool_Methods_ExecutionEnvironment[] = {
  {"has_environment_variable", &Dtool_ExecutionEnvironment_has_environment_variable_540, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_has_environment_variable_540_comment},
  {"hasEnvironmentVariable", &Dtool_ExecutionEnvironment_has_environment_variable_540, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_has_environment_variable_540_comment},
  {"get_environment_variable", &Dtool_ExecutionEnvironment_get_environment_variable_541, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_environment_variable_541_comment},
  {"getEnvironmentVariable", &Dtool_ExecutionEnvironment_get_environment_variable_541, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_environment_variable_541_comment},
  {"set_environment_variable", (PyCFunction) &Dtool_ExecutionEnvironment_set_environment_variable_542, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_environment_variable_542_comment},
  {"setEnvironmentVariable", (PyCFunction) &Dtool_ExecutionEnvironment_set_environment_variable_542, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_environment_variable_542_comment},
  {"shadow_environment_variable", (PyCFunction) &Dtool_ExecutionEnvironment_shadow_environment_variable_543, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_shadow_environment_variable_543_comment},
  {"shadowEnvironmentVariable", (PyCFunction) &Dtool_ExecutionEnvironment_shadow_environment_variable_543, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_shadow_environment_variable_543_comment},
  {"clear_shadow", &Dtool_ExecutionEnvironment_clear_shadow_544, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_clear_shadow_544_comment},
  {"clearShadow", &Dtool_ExecutionEnvironment_clear_shadow_544, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_clear_shadow_544_comment},
  {"expand_string", &Dtool_ExecutionEnvironment_expand_string_545, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_expand_string_545_comment},
  {"expandString", &Dtool_ExecutionEnvironment_expand_string_545, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_expand_string_545_comment},
  {"get_num_args", &Dtool_ExecutionEnvironment_get_num_args_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_num_args_546_comment},
  {"getNumArgs", &Dtool_ExecutionEnvironment_get_num_args_546, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_num_args_546_comment},
  {"get_arg", &Dtool_ExecutionEnvironment_get_arg_547, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_arg_547_comment},
  {"getArg", &Dtool_ExecutionEnvironment_get_arg_547, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_arg_547_comment},
  {"get_binary_name", &Dtool_ExecutionEnvironment_get_binary_name_548, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_binary_name_548_comment},
  {"getBinaryName", &Dtool_ExecutionEnvironment_get_binary_name_548, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_binary_name_548_comment},
  {"get_dtool_name", &Dtool_ExecutionEnvironment_get_dtool_name_549, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_dtool_name_549_comment},
  {"getDtoolName", &Dtool_ExecutionEnvironment_get_dtool_name_549, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_dtool_name_549_comment},
  {"set_binary_name", &Dtool_ExecutionEnvironment_set_binary_name_550, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_binary_name_550_comment},
  {"setBinaryName", &Dtool_ExecutionEnvironment_set_binary_name_550, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_binary_name_550_comment},
  {"set_dtool_name", &Dtool_ExecutionEnvironment_set_dtool_name_551, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_dtool_name_551_comment},
  {"setDtoolName", &Dtool_ExecutionEnvironment_set_dtool_name_551, METH_O | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_set_dtool_name_551_comment},
  {"get_cwd", &Dtool_ExecutionEnvironment_get_cwd_552, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_cwd_552_comment},
  {"getCwd", &Dtool_ExecutionEnvironment_get_cwd_552, METH_NOARGS | METH_STATIC, (const char *)Dtool_ExecutionEnvironment_get_cwd_552_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ExecutionEnvironment = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ExecutionEnvironment = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ExecutionEnvironment",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ExecutionEnvironment,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ExecutionEnvironment,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Encapsulates access to the environment variables and command-line arguments\n"
    " * at the time of execution.  This is encapsulated to support accessing these\n"
    " * things during static init time, which seems to be risky at best.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ExecutionEnvironment,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ExecutionEnvironment,
    PyType_GenericAlloc,
    Dtool_new_ExecutionEnvironment,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ExecutionEnvironment,
  Dtool_UpcastInterface_ExecutionEnvironment,
  Dtool_DowncastInterface_ExecutionEnvironment,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ExecutionEnvironment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ExecutionEnvironment._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ExecutionEnvironment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ExecutionEnvironment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ExecutionEnvironment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ExecutionEnvironment);
  }
}

/**
 * Python method tables for FileStream (FileStream)
 */
static PyMethodDef Dtool_Methods_FileStream[] = {
  {"open", (PyCFunction) &Dtool_FileStream_open_589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FileStream_open_589_comment},
  {"close", &Dtool_FileStream_close_590, METH_NOARGS, (const char *)Dtool_FileStream_close_590_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FileStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FileStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FileStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FileStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FileStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FileStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FileStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FileStream,
    &Dtool_SequenceMethods_FileStream,
    &Dtool_MappingMethods_FileStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FileStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a C++ stream object suitable for reading from and/or writing to\n"
    " * files on disk.  This is similar to fstream, but it provides low-level\n"
    " * support for Panda's simple-threading implementation (using this interface\n"
    " * will block only the current thread, rather than the entire process, on I/O\n"
    " * waits).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FileStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FileStream,
    PyType_GenericAlloc,
    Dtool_new_FileStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FileStream,
  Dtool_UpcastInterface_FileStream,
  Dtool_DowncastInterface_FileStream,
  (CoerceFunction)Dtool_ConstCoerce_FileStream,
  (CoerceFunction)Dtool_Coerce_FileStream,
};

static void Dtool_PyModuleClassInit_FileStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_iostream(NULL);
    Dtool_FileStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_iostream);
    PyObject *dict = PyDict_New();
    Dtool_FileStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FileStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FileStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FileStream);
  }
}

/**
 * Python method tables for iostream (iostream)
 */
static PyMethodDef Dtool_Methods_iostream[] = {
  {"flush", &Dtool_iostream_flush_585, METH_NOARGS, (const char *)Dtool_iostream_flush_585_comment},
  {"upcast_to_istream", &Dtool_iostream_upcast_to_istream_574, METH_NOARGS, (const char *)Dtool_iostream_upcast_to_istream_574_comment},
  {"upcastToIstream", &Dtool_iostream_upcast_to_istream_574, METH_NOARGS, (const char *)Dtool_iostream_upcast_to_istream_574_comment},
  {"upcast_to_ostream", &Dtool_iostream_upcast_to_ostream_583, METH_NOARGS, (const char *)Dtool_iostream_upcast_to_ostream_583_comment},
  {"upcastToOstream", &Dtool_iostream_upcast_to_ostream_583, METH_NOARGS, (const char *)Dtool_iostream_upcast_to_ostream_583_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_iostream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_iostream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_iostream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_iostream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_iostream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.iostream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_iostream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_iostream,
    &Dtool_SequenceMethods_iostream,
    &Dtool_MappingMethods_iostream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_iostream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_iostream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_iostream,
    PyType_GenericAlloc,
    Dtool_new_iostream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_iostream,
  Dtool_UpcastInterface_iostream,
  Dtool_DowncastInterface_iostream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_iostream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_istream(NULL);
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_iostream._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_istream, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_iostream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_iostream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(iostream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_iostream);
  }
}

/**
 * Python method tables for istream (istream)
 */
static PyMethodDef Dtool_Methods_istream[] = {
  {"get", &Dtool_istream_get_570, METH_NOARGS, (const char *)Dtool_istream_get_570_comment},
  {"tellg", &Dtool_istream_tellg_571, METH_NOARGS, (const char *)Dtool_istream_tellg_571_comment},
  {"seekg", (PyCFunction) &Dtool_istream_seekg_572, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_istream_seekg_572_comment},
  {"upcast_to_ios", &Dtool_istream_upcast_to_ios_569, METH_NOARGS, (const char *)Dtool_istream_upcast_to_ios_569_comment},
  {"upcastToIos", &Dtool_istream_upcast_to_ios_569, METH_NOARGS, (const char *)Dtool_istream_upcast_to_ios_569_comment},
  {"downcast_to_iostream", &Dtool_istream_downcast_to_iostream_575, METH_NOARGS, (const char *)Dtool_istream_downcast_to_iostream_575_comment},
  {"downcastToIostream", &Dtool_istream_downcast_to_iostream_575, METH_NOARGS, (const char *)Dtool_istream_downcast_to_iostream_575_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_istream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_istream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_istream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_istream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_istream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.istream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_istream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_istream,
    &Dtool_SequenceMethods_istream,
    &Dtool_MappingMethods_istream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_istream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_istream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_istream,
    PyType_GenericAlloc,
    Dtool_new_istream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_istream,
  Dtool_UpcastInterface_istream,
  Dtool_DowncastInterface_istream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_istream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ios(NULL);
    Dtool_istream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ios);
    PyObject *dict = PyDict_New();
    Dtool_istream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_istream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(istream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_istream);
  }
}

/**
 * Python method tables for ios (ios)
 */
static PyMethodDef Dtool_Methods_ios[] = {
  {"good", &Dtool_ios_good_563, METH_NOARGS, (const char *)Dtool_ios_good_563_comment},
  {"eof", &Dtool_ios_eof_564, METH_NOARGS, (const char *)Dtool_ios_eof_564_comment},
  {"fail", &Dtool_ios_fail_565, METH_NOARGS, (const char *)Dtool_ios_fail_565_comment},
  {"bad", &Dtool_ios_bad_566, METH_NOARGS, (const char *)Dtool_ios_bad_566_comment},
  {"clear", &Dtool_ios_clear_567, METH_NOARGS, (const char *)Dtool_ios_clear_567_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ios = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ios = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ios = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ios = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ios = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ios",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ios,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ios,
    &Dtool_SequenceMethods_ios,
    &Dtool_MappingMethods_ios,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ios,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ios,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ios,
    PyType_GenericAlloc,
    Dtool_new_ios,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ios,
  Dtool_UpcastInterface_ios,
  Dtool_DowncastInterface_ios,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ios(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ios_base(NULL);
    Dtool_ios._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ios_base);
    PyObject *dict = PyDict_New();
    Dtool_ios._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ios) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ios)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ios);
  }
}

/**
 * Python method tables for ios_base (ios_base)
 */
static PyMethodDef Dtool_Methods_ios_base[] = {
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ios_base = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ios_base = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ios_base",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ios_base,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ios_base,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// We need to expose one method in each class to force it to publish.\n"
    "// But we'd like to expose some of these methods anyway, so no\n"
    "// problem.",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ios_base,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ios_base,
    PyType_GenericAlloc,
    Dtool_new_ios_base,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ios_base,
  Dtool_UpcastInterface_ios_base,
  Dtool_DowncastInterface_ios_base,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ios_base(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ios_base._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_ios_base._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ios_base::seekdir;
    PyDict_SetItemString(dict, "beg", Dtool_WrapValue(ios_base::beg));
    PyDict_SetItemString(dict, "Beg", Dtool_WrapValue(ios_base::beg));
    PyDict_SetItemString(dict, "cur", Dtool_WrapValue(ios_base::cur));
    PyDict_SetItemString(dict, "Cur", Dtool_WrapValue(ios_base::cur));
    PyDict_SetItemString(dict, "end", Dtool_WrapValue(ios_base::end));
    PyDict_SetItemString(dict, "End", Dtool_WrapValue(ios_base::end));
    // enum ios_base::openmode;
    if (PyType_Ready((PyTypeObject *)&Dtool_ios_base) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ios_base)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ios_base);
  }
}

/**
 * Python method tables for ostream (ostream)
 */
static PyMethodDef Dtool_Methods_ostream[] = {
  {"put", &Dtool_ostream_put_578, METH_O, (const char *)Dtool_ostream_put_578_comment},
  {"flush", &Dtool_ostream_flush_579, METH_NOARGS, (const char *)Dtool_ostream_flush_579_comment},
  {"tellp", &Dtool_ostream_tellp_580, METH_NOARGS, (const char *)Dtool_ostream_tellp_580_comment},
  {"seekp", (PyCFunction) &Dtool_ostream_seekp_581, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ostream_seekp_581_comment},
  {"upcast_to_ios", &Dtool_ostream_upcast_to_ios_577, METH_NOARGS, (const char *)Dtool_ostream_upcast_to_ios_577_comment},
  {"upcastToIos", &Dtool_ostream_upcast_to_ios_577, METH_NOARGS, (const char *)Dtool_ostream_upcast_to_ios_577_comment},
  {"downcast_to_iostream", &Dtool_ostream_downcast_to_iostream_584, METH_NOARGS, (const char *)Dtool_ostream_downcast_to_iostream_584_comment},
  {"downcastToIostream", &Dtool_ostream_downcast_to_iostream_584, METH_NOARGS, (const char *)Dtool_ostream_downcast_to_iostream_584_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ostream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ostream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ostream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ostream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ostream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ostream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ostream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ostream,
    &Dtool_SequenceMethods_ostream,
    &Dtool_MappingMethods_ostream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ostream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ostream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ostream,
    PyType_GenericAlloc,
    Dtool_new_ostream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ostream,
  Dtool_UpcastInterface_ostream,
  Dtool_DowncastInterface_ostream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ostream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ios(NULL);
    Dtool_ostream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ios);
    PyObject *dict = PyDict_New();
    Dtool_ostream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ostream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ostream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ostream);
  }
}

/**
 * Python method tables for GlobPattern (GlobPattern)
 */
static PyMethodDef Dtool_Methods_GlobPattern[] = {
  {"assign", &Dtool_GlobPattern_operator_593, METH_O, (const char *)Dtool_GlobPattern_operator_593_comment},
  {"set_pattern", &Dtool_GlobPattern_set_pattern_597, METH_O, (const char *)Dtool_GlobPattern_set_pattern_597_comment},
  {"setPattern", &Dtool_GlobPattern_set_pattern_597, METH_O, (const char *)Dtool_GlobPattern_set_pattern_597_comment},
  {"get_pattern", &Dtool_GlobPattern_get_pattern_598, METH_NOARGS, (const char *)Dtool_GlobPattern_get_pattern_598_comment},
  {"getPattern", &Dtool_GlobPattern_get_pattern_598, METH_NOARGS, (const char *)Dtool_GlobPattern_get_pattern_598_comment},
  {"set_case_sensitive", &Dtool_GlobPattern_set_case_sensitive_600, METH_O, (const char *)Dtool_GlobPattern_set_case_sensitive_600_comment},
  {"setCaseSensitive", &Dtool_GlobPattern_set_case_sensitive_600, METH_O, (const char *)Dtool_GlobPattern_set_case_sensitive_600_comment},
  {"get_case_sensitive", &Dtool_GlobPattern_get_case_sensitive_601, METH_NOARGS, (const char *)Dtool_GlobPattern_get_case_sensitive_601_comment},
  {"getCaseSensitive", &Dtool_GlobPattern_get_case_sensitive_601, METH_NOARGS, (const char *)Dtool_GlobPattern_get_case_sensitive_601_comment},
  {"set_nomatch_chars", &Dtool_GlobPattern_set_nomatch_chars_603, METH_O, (const char *)Dtool_GlobPattern_set_nomatch_chars_603_comment},
  {"setNomatchChars", &Dtool_GlobPattern_set_nomatch_chars_603, METH_O, (const char *)Dtool_GlobPattern_set_nomatch_chars_603_comment},
  {"get_nomatch_chars", &Dtool_GlobPattern_get_nomatch_chars_604, METH_NOARGS, (const char *)Dtool_GlobPattern_get_nomatch_chars_604_comment},
  {"getNomatchChars", &Dtool_GlobPattern_get_nomatch_chars_604, METH_NOARGS, (const char *)Dtool_GlobPattern_get_nomatch_chars_604_comment},
  {"matches", &Dtool_GlobPattern_matches_606, METH_O, (const char *)Dtool_GlobPattern_matches_606_comment},
  {"output", &Dtool_GlobPattern_output_607, METH_O, (const char *)Dtool_GlobPattern_output_607_comment},
  {"has_glob_characters", &Dtool_GlobPattern_has_glob_characters_608, METH_NOARGS, (const char *)Dtool_GlobPattern_has_glob_characters_608_comment},
  {"hasGlobCharacters", &Dtool_GlobPattern_has_glob_characters_608, METH_NOARGS, (const char *)Dtool_GlobPattern_has_glob_characters_608_comment},
  {"get_const_prefix", &Dtool_GlobPattern_get_const_prefix_609, METH_NOARGS, (const char *)Dtool_GlobPattern_get_const_prefix_609_comment},
  {"getConstPrefix", &Dtool_GlobPattern_get_const_prefix_609, METH_NOARGS, (const char *)Dtool_GlobPattern_get_const_prefix_609_comment},
  {"match_files", (PyCFunction) &Dtool_GlobPattern_match_files_610, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GlobPattern_match_files_610_comment},
  {"matchFiles", (PyCFunction) &Dtool_GlobPattern_match_files_610, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GlobPattern_match_files_610_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     GlobPattern
//////////////////
static PyObject *Dtool_Repr_GlobPattern(PyObject *self) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     GlobPattern
//////////////////
static PyObject *Dtool_RichCompare_GlobPattern(PyObject *self, PyObject *arg, int op) {
  GlobPattern *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GlobPattern, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool GlobPattern::operator ==(GlobPattern const &other) const
      GlobPattern const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
        bool return_value = (*(const GlobPattern*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool GlobPattern::operator !=(GlobPattern const &other) const
      GlobPattern const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
        bool return_value = (*(const GlobPattern*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool GlobPattern::operator <(GlobPattern const &other) const
      GlobPattern const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_GlobPattern(arg, arg_this, arg_manage)) {
        bool return_value = (*(const GlobPattern*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_GlobPattern[] = {
  {(char *)"pattern", &Dtool_GlobPattern_pattern_Getter, &Dtool_GlobPattern_pattern_Setter, NULL, NULL},
  {(char *)"case_sensitive", &Dtool_GlobPattern_case_sensitive_Getter, &Dtool_GlobPattern_case_sensitive_Setter, NULL, NULL},
  {(char *)"nomatch_chars", &Dtool_GlobPattern_nomatch_chars_Getter, &Dtool_GlobPattern_nomatch_chars_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_GlobPattern = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_GlobPattern = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.GlobPattern",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_GlobPattern,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_GlobPattern,
    &Dtool_NumberMethods_GlobPattern,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_GlobPattern,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to test for string matches against standard Unix-\n"
    " * shell filename globbing conventions.  It serves as a portable standin for\n"
    " * the Posix fnmatch() call.\n"
    " *\n"
    " * A GlobPattern is given a pattern string, which can contain operators like\n"
    " * *, ?, and [].  Then it can be tested against any number of candidate\n"
    " * strings; for each candidate, it will indicate whether the string matches\n"
    " * the pattern or not.  It can be used, for example, to scan a directory for\n"
    " * all files matching a particular pattern.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_GlobPattern,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_GlobPattern,
    0, // tp_members
    Dtool_Properties_GlobPattern,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_GlobPattern,
    PyType_GenericAlloc,
    Dtool_new_GlobPattern,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GlobPattern,
  Dtool_UpcastInterface_GlobPattern,
  Dtool_DowncastInterface_GlobPattern,
  (CoerceFunction)Dtool_ConstCoerce_GlobPattern,
  (CoerceFunction)Dtool_Coerce_GlobPattern,
};

static void Dtool_PyModuleClassInit_GlobPattern(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GlobPattern._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_GlobPattern._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GlobPattern) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GlobPattern)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GlobPattern);
  }
}

/**
 * Python method tables for IDecryptStream (IDecryptStream)
 */
static PyMethodDef Dtool_Methods_IDecryptStream[] = {
  {"open", (PyCFunction) &Dtool_IDecryptStream_open_614, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IDecryptStream_open_614_comment},
  {"close", &Dtool_IDecryptStream_close_615, METH_NOARGS, (const char *)Dtool_IDecryptStream_close_615_comment},
  {"get_algorithm", &Dtool_IDecryptStream_get_algorithm_616, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_algorithm_616_comment},
  {"getAlgorithm", &Dtool_IDecryptStream_get_algorithm_616, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_algorithm_616_comment},
  {"get_key_length", &Dtool_IDecryptStream_get_key_length_617, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_key_length_617_comment},
  {"getKeyLength", &Dtool_IDecryptStream_get_key_length_617, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_key_length_617_comment},
  {"get_iteration_count", &Dtool_IDecryptStream_get_iteration_count_618, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_iteration_count_618_comment},
  {"getIterationCount", &Dtool_IDecryptStream_get_iteration_count_618, METH_NOARGS, (const char *)Dtool_IDecryptStream_get_iteration_count_618_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_IDecryptStream[] = {
  {(char *)"algorithm", &Dtool_IDecryptStream_algorithm_Getter, NULL, NULL, NULL},
  {(char *)"key_length", &Dtool_IDecryptStream_key_length_Getter, NULL, NULL, NULL},
  {(char *)"iteration_count", &Dtool_IDecryptStream_iteration_count_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_IDecryptStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IDecryptStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_IDecryptStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_IDecryptStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_IDecryptStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.IDecryptStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_IDecryptStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_IDecryptStream,
    &Dtool_SequenceMethods_IDecryptStream,
    &Dtool_MappingMethods_IDecryptStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_IDecryptStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses OpenSSL to decrypt the input from another\n"
    " * source stream on-the-fly.\n"
    " *\n"
    " * Attach an IDecryptStream to an existing istream that provides encrypted\n"
    " * data, as generated by an OEncryptStream, and read the corresponding\n"
    " * unencrypted data from the IDecryptStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_IDecryptStream,
    0, // tp_members
    Dtool_Properties_IDecryptStream,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_IDecryptStream,
    PyType_GenericAlloc,
    Dtool_new_IDecryptStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IDecryptStream,
  Dtool_UpcastInterface_IDecryptStream,
  Dtool_DowncastInterface_IDecryptStream,
  (CoerceFunction)Dtool_ConstCoerce_IDecryptStream,
  (CoerceFunction)Dtool_Coerce_IDecryptStream,
};

static void Dtool_PyModuleClassInit_IDecryptStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_istream(NULL);
    Dtool_IDecryptStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_istream);
    PyObject *dict = PyDict_New();
    Dtool_IDecryptStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IDecryptStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IDecryptStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IDecryptStream);
  }
}

/**
 * Python method tables for IFileStream (IFileStream)
 */
static PyMethodDef Dtool_Methods_IFileStream[] = {
  {"open", (PyCFunction) &Dtool_IFileStream_open_626, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IFileStream_open_626_comment},
  {"close", &Dtool_IFileStream_close_627, METH_NOARGS, (const char *)Dtool_IFileStream_close_627_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_IFileStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IFileStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_IFileStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_IFileStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_IFileStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.IFileStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_IFileStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_IFileStream,
    &Dtool_SequenceMethods_IFileStream,
    &Dtool_MappingMethods_IFileStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_IFileStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a C++ stream object suitable for reading from files on disk.\n"
    " * This is similar to ifstream, but it provides low-level support for Panda's\n"
    " * simple-threading implementation (using this interface will block only the\n"
    " * current thread, rather than the entire process, on I/O waits).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_IFileStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_IFileStream,
    PyType_GenericAlloc,
    Dtool_new_IFileStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IFileStream,
  Dtool_UpcastInterface_IFileStream,
  Dtool_DowncastInterface_IFileStream,
  (CoerceFunction)Dtool_ConstCoerce_IFileStream,
  (CoerceFunction)Dtool_Coerce_IFileStream,
};

static void Dtool_PyModuleClassInit_IFileStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_istream(NULL);
    Dtool_IFileStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_istream);
    PyObject *dict = PyDict_New();
    Dtool_IFileStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IFileStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IFileStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IFileStream);
  }
}

/**
 * Python method tables for IStreamWrapper (IStreamWrapper)
 */
static PyMethodDef Dtool_Methods_IStreamWrapper[] = {
  {"get_istream", &Dtool_IStreamWrapper_get_istream_637, METH_NOARGS, (const char *)Dtool_IStreamWrapper_get_istream_637_comment},
  {"getIstream", &Dtool_IStreamWrapper_get_istream_637, METH_NOARGS, (const char *)Dtool_IStreamWrapper_get_istream_637_comment},
  {"upcast_to_StreamWrapperBase", &Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634, METH_NOARGS, (const char *)Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634_comment},
  {"upcastToStreamWrapperBase", &Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634, METH_NOARGS, (const char *)Dtool_IStreamWrapper_upcast_to_StreamWrapperBase_634_comment},
  {"downcast_to_StreamWrapper", &Dtool_IStreamWrapper_downcast_to_StreamWrapper_873, METH_NOARGS, (const char *)Dtool_IStreamWrapper_downcast_to_StreamWrapper_873_comment},
  {"downcastToStreamWrapper", &Dtool_IStreamWrapper_downcast_to_StreamWrapper_873, METH_NOARGS, (const char *)Dtool_IStreamWrapper_downcast_to_StreamWrapper_873_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_IStreamWrapper[] = {
  {(char *)"istream", &Dtool_IStreamWrapper_istream_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_IStreamWrapper = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IStreamWrapper = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_IStreamWrapper = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_IStreamWrapper = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_IStreamWrapper = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.IStreamWrapper",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_IStreamWrapper,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_IStreamWrapper,
    &Dtool_SequenceMethods_IStreamWrapper,
    &Dtool_MappingMethods_IStreamWrapper,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_IStreamWrapper,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a locking wrapper around an arbitrary istream pointer.\n"
    " * A thread may use this class to perform an atomic seek/read/gcount\n"
    " * operation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_IStreamWrapper,
    0, // tp_members
    Dtool_Properties_IStreamWrapper,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_IStreamWrapper,
    PyType_GenericAlloc,
    Dtool_new_IStreamWrapper,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IStreamWrapper,
  Dtool_UpcastInterface_IStreamWrapper,
  Dtool_DowncastInterface_IStreamWrapper,
  (CoerceFunction)Dtool_ConstCoerce_IStreamWrapper,
  (CoerceFunction)Dtool_Coerce_IStreamWrapper,
};

static void Dtool_PyModuleClassInit_IStreamWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_StreamWrapperBase(NULL);
    Dtool_IStreamWrapper._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_StreamWrapperBase);
    PyObject *dict = PyDict_New();
    Dtool_IStreamWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IStreamWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IStreamWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IStreamWrapper);
  }
}

/**
 * Python method tables for StreamWrapperBase (StreamWrapperBase)
 */
static PyMethodDef Dtool_Methods_StreamWrapperBase[] = {
  {"acquire", &Dtool_StreamWrapperBase_acquire_630, METH_NOARGS, (const char *)Dtool_StreamWrapperBase_acquire_630_comment},
  {"release", &Dtool_StreamWrapperBase_release_631, METH_NOARGS, (const char *)Dtool_StreamWrapperBase_release_631_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_StreamWrapperBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_StreamWrapperBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StreamWrapperBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamWrapperBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StreamWrapperBase,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for both IStreamWrapper and OStreamWrapper, this provides\n"
    " * the common locking interface.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StreamWrapperBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StreamWrapperBase,
    PyType_GenericAlloc,
    Dtool_new_StreamWrapperBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamWrapperBase,
  Dtool_UpcastInterface_StreamWrapperBase,
  Dtool_DowncastInterface_StreamWrapperBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_StreamWrapperBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StreamWrapperBase._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_StreamWrapperBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamWrapperBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamWrapperBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamWrapperBase);
  }
}

/**
 * Python method tables for LineStream (LineStream)
 */
static PyMethodDef Dtool_Methods_LineStream[] = {
  {"is_text_available", &Dtool_LineStream_is_text_available_642, METH_NOARGS, (const char *)Dtool_LineStream_is_text_available_642_comment},
  {"isTextAvailable", &Dtool_LineStream_is_text_available_642, METH_NOARGS, (const char *)Dtool_LineStream_is_text_available_642_comment},
  {"get_line", &Dtool_LineStream_get_line_643, METH_NOARGS, (const char *)Dtool_LineStream_get_line_643_comment},
  {"getLine", &Dtool_LineStream_get_line_643, METH_NOARGS, (const char *)Dtool_LineStream_get_line_643_comment},
  {"has_newline", &Dtool_LineStream_has_newline_644, METH_NOARGS, (const char *)Dtool_LineStream_has_newline_644_comment},
  {"hasNewline", &Dtool_LineStream_has_newline_644, METH_NOARGS, (const char *)Dtool_LineStream_has_newline_644_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_LineStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LineStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_LineStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_LineStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_LineStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.LineStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LineStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_LineStream,
    &Dtool_SequenceMethods_LineStream,
    &Dtool_MappingMethods_LineStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_LineStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special ostream that writes to a memory buffer, like ostrstream.\n"
    " * However, its contents can be continuously extracted as a sequence of lines\n"
    " * of text.\n"
    " *\n"
    " * Unlike ostrstream, which can only be extracted from once (and then the\n"
    " * buffer freezes and it can no longer be written to), the LineStream is not\n"
    " * otherwise affected when a line of text is extracted.  More text can still\n"
    " * be written to it and continuously extracted.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_LineStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_LineStream,
    PyType_GenericAlloc,
    Dtool_new_LineStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LineStream,
  Dtool_UpcastInterface_LineStream,
  Dtool_DowncastInterface_LineStream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_LineStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_LineStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_LineStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LineStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LineStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LineStream);
  }
}

/**
 * Python method tables for NeverFreeMemory (NeverFreeMemory)
 */
static PyMethodDef Dtool_Methods_NeverFreeMemory[] = {
  {"get_total_alloc", &Dtool_NeverFreeMemory_get_total_alloc_647, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_alloc_647_comment},
  {"getTotalAlloc", &Dtool_NeverFreeMemory_get_total_alloc_647, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_alloc_647_comment},
  {"get_total_used", &Dtool_NeverFreeMemory_get_total_used_648, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_used_648_comment},
  {"getTotalUsed", &Dtool_NeverFreeMemory_get_total_used_648, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_used_648_comment},
  {"get_total_unused", &Dtool_NeverFreeMemory_get_total_unused_649, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_unused_649_comment},
  {"getTotalUnused", &Dtool_NeverFreeMemory_get_total_unused_649, METH_NOARGS | METH_STATIC, (const char *)Dtool_NeverFreeMemory_get_total_unused_649_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NeverFreeMemory = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_NeverFreeMemory = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NeverFreeMemory",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NeverFreeMemory,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NeverFreeMemory,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to allocate bytes of memory from a pool that is never\n"
    " * intended to be freed.  It is particularly useful to support DeletedChain,\n"
    " * which allocates memory in just such a fashion.\n"
    " *\n"
    " * When it is known that memory will not be freed, it is preferable to use\n"
    " * this instead of the standard malloc() (or global_operator_new()) call,\n"
    " * since this will help reduce fragmentation problems in the dynamic heap.\n"
    " * Also, memory allocated from here will exhibit less wasted space.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NeverFreeMemory,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NeverFreeMemory,
    PyType_GenericAlloc,
    Dtool_new_NeverFreeMemory,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NeverFreeMemory,
  Dtool_UpcastInterface_NeverFreeMemory,
  Dtool_DowncastInterface_NeverFreeMemory,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NeverFreeMemory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NeverFreeMemory._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_NeverFreeMemory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NeverFreeMemory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NeverFreeMemory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NeverFreeMemory);
  }
}

/**
 * Python method tables for Notify (Notify)
 */
static PyMethodDef Dtool_Methods_Notify[] = {
  {"set_ostream_ptr", (PyCFunction) &Dtool_Notify_set_ostream_ptr_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_set_ostream_ptr_655_comment},
  {"setOstreamPtr", (PyCFunction) &Dtool_Notify_set_ostream_ptr_655, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_set_ostream_ptr_655_comment},
  {"get_ostream_ptr", &Dtool_Notify_get_ostream_ptr_656, METH_NOARGS, (const char *)Dtool_Notify_get_ostream_ptr_656_comment},
  {"getOstreamPtr", &Dtool_Notify_get_ostream_ptr_656, METH_NOARGS, (const char *)Dtool_Notify_get_ostream_ptr_656_comment},
  {"clear_assert_handler", &Dtool_Notify_clear_assert_handler_658, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_handler_658_comment},
  {"clearAssertHandler", &Dtool_Notify_clear_assert_handler_658, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_handler_658_comment},
  {"has_assert_handler", &Dtool_Notify_has_assert_handler_659, METH_NOARGS, (const char *)Dtool_Notify_has_assert_handler_659_comment},
  {"hasAssertHandler", &Dtool_Notify_has_assert_handler_659, METH_NOARGS, (const char *)Dtool_Notify_has_assert_handler_659_comment},
  {"has_assert_failed", &Dtool_Notify_has_assert_failed_661, METH_NOARGS, (const char *)Dtool_Notify_has_assert_failed_661_comment},
  {"hasAssertFailed", &Dtool_Notify_has_assert_failed_661, METH_NOARGS, (const char *)Dtool_Notify_has_assert_failed_661_comment},
  {"get_assert_error_message", &Dtool_Notify_get_assert_error_message_662, METH_NOARGS, (const char *)Dtool_Notify_get_assert_error_message_662_comment},
  {"getAssertErrorMessage", &Dtool_Notify_get_assert_error_message_662, METH_NOARGS, (const char *)Dtool_Notify_get_assert_error_message_662_comment},
  {"clear_assert_failed", &Dtool_Notify_clear_assert_failed_663, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_failed_663_comment},
  {"clearAssertFailed", &Dtool_Notify_clear_assert_failed_663, METH_NOARGS, (const char *)Dtool_Notify_clear_assert_failed_663_comment},
  {"get_top_category", &Dtool_Notify_get_top_category_664, METH_NOARGS, (const char *)Dtool_Notify_get_top_category_664_comment},
  {"getTopCategory", &Dtool_Notify_get_top_category_664, METH_NOARGS, (const char *)Dtool_Notify_get_top_category_664_comment},
  {"get_category", (PyCFunction) &Dtool_Notify_get_category_665, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_get_category_665_comment},
  {"getCategory", (PyCFunction) &Dtool_Notify_get_category_665, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Notify_get_category_665_comment},
  {"out", &Dtool_Notify_out_666, METH_NOARGS | METH_STATIC, (const char *)Dtool_Notify_out_666_comment},
  {"null", &Dtool_Notify_null_667, METH_NOARGS | METH_STATIC, (const char *)Dtool_Notify_null_667_comment},
  {"write_string", &Dtool_Notify_write_string_668, METH_O | METH_STATIC, (const char *)Dtool_Notify_write_string_668_comment},
  {"writeString", &Dtool_Notify_write_string_668, METH_O | METH_STATIC, (const char *)Dtool_Notify_write_string_668_comment},
  {"ptr", &Dtool_Notify_ptr_669, METH_NOARGS | METH_STATIC, (const char *)Dtool_Notify_ptr_669_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Notify = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Notify = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Notify",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Notify,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Notify,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An object that handles general error reporting to the user.  It contains a\n"
    " * pointer to an ostream, initially cerr, which can be reset at will to point\n"
    " * to different output devices, according to the needs of the application.\n"
    " * All output generated within Panda should vector through the Notify ostream.\n"
    " *\n"
    " * This also includes a collection of Categories and Severities, which may be\n"
    " * independently enabled or disabled, so that error messages may be squelched\n"
    " * or respected according to the wishes of the user.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Notify,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Notify,
    PyType_GenericAlloc,
    Dtool_new_Notify,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Notify,
  Dtool_UpcastInterface_Notify,
  Dtool_DowncastInterface_Notify,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Notify(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Notify._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Notify._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Notify) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Notify)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Notify);
  }
}

/**
 * Python method tables for NotifyCategory (NotifyCategory)
 */
static PyMethodDef Dtool_Methods_NotifyCategory[] = {
  {"get_fullname", &Dtool_NotifyCategory_get_fullname_675, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_fullname_675_comment},
  {"getFullname", &Dtool_NotifyCategory_get_fullname_675, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_fullname_675_comment},
  {"get_basename", &Dtool_NotifyCategory_get_basename_676, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_basename_676_comment},
  {"getBasename", &Dtool_NotifyCategory_get_basename_676, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_basename_676_comment},
  {"get_severity", &Dtool_NotifyCategory_get_severity_677, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_severity_677_comment},
  {"getSeverity", &Dtool_NotifyCategory_get_severity_677, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_severity_677_comment},
  {"set_severity", &Dtool_NotifyCategory_set_severity_678, METH_O, (const char *)Dtool_NotifyCategory_set_severity_678_comment},
  {"setSeverity", &Dtool_NotifyCategory_set_severity_678, METH_O, (const char *)Dtool_NotifyCategory_set_severity_678_comment},
  {"is_on", &Dtool_NotifyCategory_is_on_683, METH_O, (const char *)Dtool_NotifyCategory_is_on_683_comment},
  {"isOn", &Dtool_NotifyCategory_is_on_683, METH_O, (const char *)Dtool_NotifyCategory_is_on_683_comment},
  {"is_spam", &Dtool_NotifyCategory_is_spam_684, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_spam_684_comment},
  {"isSpam", &Dtool_NotifyCategory_is_spam_684, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_spam_684_comment},
  {"is_debug", &Dtool_NotifyCategory_is_debug_685, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_debug_685_comment},
  {"isDebug", &Dtool_NotifyCategory_is_debug_685, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_debug_685_comment},
  {"is_info", &Dtool_NotifyCategory_is_info_686, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_info_686_comment},
  {"isInfo", &Dtool_NotifyCategory_is_info_686, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_info_686_comment},
  {"is_warning", &Dtool_NotifyCategory_is_warning_687, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_warning_687_comment},
  {"isWarning", &Dtool_NotifyCategory_is_warning_687, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_warning_687_comment},
  {"is_error", &Dtool_NotifyCategory_is_error_688, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_error_688_comment},
  {"isError", &Dtool_NotifyCategory_is_error_688, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_error_688_comment},
  {"is_fatal", &Dtool_NotifyCategory_is_fatal_689, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_fatal_689_comment},
  {"isFatal", &Dtool_NotifyCategory_is_fatal_689, METH_NOARGS, (const char *)Dtool_NotifyCategory_is_fatal_689_comment},
  {"out", (PyCFunction) &Dtool_NotifyCategory_out_690, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_out_690_comment},
  {"spam", (PyCFunction) &Dtool_NotifyCategory_spam_691, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_spam_691_comment},
  {"debug", (PyCFunction) &Dtool_NotifyCategory_debug_692, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_debug_692_comment},
  {"info", (PyCFunction) &Dtool_NotifyCategory_info_693, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_info_693_comment},
  {"warning", (PyCFunction) &Dtool_NotifyCategory_warning_694, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_warning_694_comment},
  {"error", (PyCFunction) &Dtool_NotifyCategory_error_695, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_error_695_comment},
  {"fatal", (PyCFunction) &Dtool_NotifyCategory_fatal_696, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NotifyCategory_fatal_696_comment},
  {"get_num_children", &Dtool_NotifyCategory_get_num_children_697, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_num_children_697_comment},
  {"getNumChildren", &Dtool_NotifyCategory_get_num_children_697, METH_NOARGS, (const char *)Dtool_NotifyCategory_get_num_children_697_comment},
  {"get_child", &Dtool_NotifyCategory_get_child_698, METH_O, (const char *)Dtool_NotifyCategory_get_child_698_comment},
  {"getChild", &Dtool_NotifyCategory_get_child_698, METH_O, (const char *)Dtool_NotifyCategory_get_child_698_comment},
  {"set_server_delta", &Dtool_NotifyCategory_set_server_delta_702, METH_O | METH_STATIC, (const char *)Dtool_NotifyCategory_set_server_delta_702_comment},
  {"setServerDelta", &Dtool_NotifyCategory_set_server_delta_702, METH_O | METH_STATIC, (const char *)Dtool_NotifyCategory_set_server_delta_702_comment},
  {"upcast_to_ConfigFlags", &Dtool_NotifyCategory_upcast_to_ConfigFlags_673, METH_NOARGS, (const char *)Dtool_NotifyCategory_upcast_to_ConfigFlags_673_comment},
  {"upcastToConfigFlags", &Dtool_NotifyCategory_upcast_to_ConfigFlags_673, METH_NOARGS, (const char *)Dtool_NotifyCategory_upcast_to_ConfigFlags_673_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_children", (PyCFunction) &MakeSeq_NotifyCategory_get_children, METH_NOARGS, NULL},
  { "getChildren", (PyCFunction) &MakeSeq_NotifyCategory_get_children, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_NotifyCategory[] = {
  {(char *)"fullname", &Dtool_NotifyCategory_fullname_Getter, NULL, NULL, NULL},
  {(char *)"basename", &Dtool_NotifyCategory_basename_Getter, NULL, NULL, NULL},
  {(char *)"severity", &Dtool_NotifyCategory_severity_Getter, &Dtool_NotifyCategory_severity_Setter, NULL, NULL},
  {(char *)"children", &Dtool_NotifyCategory_children_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_NotifyCategory = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NotifyCategory = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NotifyCategory = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NotifyCategory = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NotifyCategory = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NotifyCategory",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NotifyCategory,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NotifyCategory,
    &Dtool_SequenceMethods_NotifyCategory,
    &Dtool_MappingMethods_NotifyCategory,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NotifyCategory,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A particular category of error messages.  Typically there will be one of\n"
    " * these per package, so that we can turn on or off error messages at least at\n"
    " * a package level; further nested categories can be created within a package\n"
    " * if a finer grain of control is required.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NotifyCategory,
    0, // tp_members
    Dtool_Properties_NotifyCategory,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NotifyCategory,
    PyType_GenericAlloc,
    Dtool_new_NotifyCategory,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NotifyCategory,
  Dtool_UpcastInterface_NotifyCategory,
  Dtool_DowncastInterface_NotifyCategory,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NotifyCategory(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConfigFlags(NULL);
    Dtool_NotifyCategory._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConfigFlags);
    PyObject *dict = PyDict_New();
    Dtool_NotifyCategory._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NotifyCategory) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NotifyCategory)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NotifyCategory);
  }
}

/**
 * Python method tables for OEncryptStream (OEncryptStream)
 */
static PyMethodDef Dtool_Methods_OEncryptStream[] = {
  {"open", (PyCFunction) &Dtool_OEncryptStream_open_707, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OEncryptStream_open_707_comment},
  {"close", &Dtool_OEncryptStream_close_708, METH_NOARGS, (const char *)Dtool_OEncryptStream_close_708_comment},
  {"set_algorithm", &Dtool_OEncryptStream_set_algorithm_709, METH_O, (const char *)Dtool_OEncryptStream_set_algorithm_709_comment},
  {"setAlgorithm", &Dtool_OEncryptStream_set_algorithm_709, METH_O, (const char *)Dtool_OEncryptStream_set_algorithm_709_comment},
  {"set_key_length", &Dtool_OEncryptStream_set_key_length_710, METH_O, (const char *)Dtool_OEncryptStream_set_key_length_710_comment},
  {"setKeyLength", &Dtool_OEncryptStream_set_key_length_710, METH_O, (const char *)Dtool_OEncryptStream_set_key_length_710_comment},
  {"set_iteration_count", &Dtool_OEncryptStream_set_iteration_count_711, METH_O, (const char *)Dtool_OEncryptStream_set_iteration_count_711_comment},
  {"setIterationCount", &Dtool_OEncryptStream_set_iteration_count_711, METH_O, (const char *)Dtool_OEncryptStream_set_iteration_count_711_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_OEncryptStream[] = {
  {(char *)"algorithm", &Dtool_OEncryptStream_algorithm_Getter, &Dtool_OEncryptStream_algorithm_Setter, NULL, NULL},
  {(char *)"key_length", &Dtool_OEncryptStream_key_length_Getter, &Dtool_OEncryptStream_key_length_Setter, NULL, NULL},
  {(char *)"iteration_count", &Dtool_OEncryptStream_iteration_count_Getter, &Dtool_OEncryptStream_iteration_count_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_OEncryptStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OEncryptStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OEncryptStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OEncryptStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OEncryptStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OEncryptStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OEncryptStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OEncryptStream,
    &Dtool_SequenceMethods_OEncryptStream,
    &Dtool_MappingMethods_OEncryptStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OEncryptStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses OpenSSL to encrypt data to another\n"
    " * destination stream on-the-fly.\n"
    " *\n"
    " * Attach an OEncryptStream to an existing ostream that will accept encrypted\n"
    " * data, and write your unencrypted source data to the OEncryptStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OEncryptStream,
    0, // tp_members
    Dtool_Properties_OEncryptStream,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OEncryptStream,
    PyType_GenericAlloc,
    Dtool_new_OEncryptStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OEncryptStream,
  Dtool_UpcastInterface_OEncryptStream,
  Dtool_DowncastInterface_OEncryptStream,
  (CoerceFunction)Dtool_ConstCoerce_OEncryptStream,
  (CoerceFunction)Dtool_Coerce_OEncryptStream,
};

static void Dtool_PyModuleClassInit_OEncryptStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_OEncryptStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_OEncryptStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OEncryptStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OEncryptStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OEncryptStream);
  }
}

/**
 * Python method tables for OFileStream (OFileStream)
 */
static PyMethodDef Dtool_Methods_OFileStream[] = {
  {"open", (PyCFunction) &Dtool_OFileStream_open_722, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OFileStream_open_722_comment},
  {"close", &Dtool_OFileStream_close_723, METH_NOARGS, (const char *)Dtool_OFileStream_close_723_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OFileStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OFileStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OFileStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OFileStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OFileStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OFileStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OFileStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OFileStream,
    &Dtool_SequenceMethods_OFileStream,
    &Dtool_MappingMethods_OFileStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OFileStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Implements a C++ stream object suitable for writing to files on disk.  This\n"
    " * is similar to ofstream, but it provides low-level support for Panda's\n"
    " * simple-threading implementation (using this interface will block only the\n"
    " * current thread, rather than the entire process, on I/O waits).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OFileStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OFileStream,
    PyType_GenericAlloc,
    Dtool_new_OFileStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OFileStream,
  Dtool_UpcastInterface_OFileStream,
  Dtool_DowncastInterface_OFileStream,
  (CoerceFunction)Dtool_ConstCoerce_OFileStream,
  (CoerceFunction)Dtool_Coerce_OFileStream,
};

static void Dtool_PyModuleClassInit_OFileStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_OFileStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_OFileStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OFileStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OFileStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OFileStream);
  }
}

/**
 * Python method tables for OStreamWrapper (OStreamWrapper)
 */
static PyMethodDef Dtool_Methods_OStreamWrapper[] = {
  {"get_ostream", &Dtool_OStreamWrapper_get_ostream_728, METH_NOARGS, (const char *)Dtool_OStreamWrapper_get_ostream_728_comment},
  {"getOstream", &Dtool_OStreamWrapper_get_ostream_728, METH_NOARGS, (const char *)Dtool_OStreamWrapper_get_ostream_728_comment},
  {"upcast_to_StreamWrapperBase", &Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725, METH_NOARGS, (const char *)Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725_comment},
  {"upcastToStreamWrapperBase", &Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725, METH_NOARGS, (const char *)Dtool_OStreamWrapper_upcast_to_StreamWrapperBase_725_comment},
  {"downcast_to_StreamWrapper", &Dtool_OStreamWrapper_downcast_to_StreamWrapper_875, METH_NOARGS, (const char *)Dtool_OStreamWrapper_downcast_to_StreamWrapper_875_comment},
  {"downcastToStreamWrapper", &Dtool_OStreamWrapper_downcast_to_StreamWrapper_875, METH_NOARGS, (const char *)Dtool_OStreamWrapper_downcast_to_StreamWrapper_875_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_OStreamWrapper[] = {
  {(char *)"ostream", &Dtool_OStreamWrapper_ostream_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_OStreamWrapper = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OStreamWrapper = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OStreamWrapper = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OStreamWrapper = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OStreamWrapper = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OStreamWrapper",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OStreamWrapper,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OStreamWrapper,
    &Dtool_SequenceMethods_OStreamWrapper,
    &Dtool_MappingMethods_OStreamWrapper,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OStreamWrapper,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a locking wrapper around an arbitrary ostream pointer.\n"
    " * A thread may use this class to perform an atomic seek/write operation.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OStreamWrapper,
    0, // tp_members
    Dtool_Properties_OStreamWrapper,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OStreamWrapper,
    PyType_GenericAlloc,
    Dtool_new_OStreamWrapper,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OStreamWrapper,
  Dtool_UpcastInterface_OStreamWrapper,
  Dtool_DowncastInterface_OStreamWrapper,
  (CoerceFunction)Dtool_ConstCoerce_OStreamWrapper,
  (CoerceFunction)Dtool_Coerce_OStreamWrapper,
};

static void Dtool_PyModuleClassInit_OStreamWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_StreamWrapperBase(NULL);
    Dtool_OStreamWrapper._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_StreamWrapperBase);
    PyObject *dict = PyDict_New();
    Dtool_OStreamWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OStreamWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OStreamWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OStreamWrapper);
  }
}

/**
 * Python method tables for PointerToArray_double (PointerToArray_double)
 */
static PyMethodDef Dtool_Methods_PointerToArray_double[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_double_empty_array_734, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_double_empty_array_734_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_double_empty_array_734, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_double_empty_array_734_comment},
  {"push_back", &Dtool_PointerToArray_double_push_back_736, METH_O, (const char *)Dtool_PointerToArray_double_push_back_736_comment},
  {"pushBack", &Dtool_PointerToArray_double_push_back_736, METH_O, (const char *)Dtool_PointerToArray_double_push_back_736_comment},
  {"pop_back", &Dtool_PointerToArray_double_pop_back_737, METH_NOARGS, (const char *)Dtool_PointerToArray_double_pop_back_737_comment},
  {"popBack", &Dtool_PointerToArray_double_pop_back_737, METH_NOARGS, (const char *)Dtool_PointerToArray_double_pop_back_737_comment},
  {"get_element", &Dtool_PointerToArray_double_get_element_738, METH_O, (const char *)Dtool_PointerToArray_double_get_element_738_comment},
  {"getElement", &Dtool_PointerToArray_double_get_element_738, METH_O, (const char *)Dtool_PointerToArray_double_get_element_738_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_double_set_element_739, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_element_739_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_double_set_element_739, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_element_739_comment},
  {"get_data", &Dtool_PointerToArray_double_get_data_742, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_data_742_comment},
  {"getData", &Dtool_PointerToArray_double_get_data_742, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_data_742_comment},
  {"set_data", &Dtool_PointerToArray_double_set_data_743, METH_O, (const char *)Dtool_PointerToArray_double_set_data_743_comment},
  {"setData", &Dtool_PointerToArray_double_set_data_743, METH_O, (const char *)Dtool_PointerToArray_double_set_data_743_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_double_get_subdata_744, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_get_subdata_744_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_double_get_subdata_744, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_get_subdata_744_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_double_set_subdata_745, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_subdata_745_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_double_set_subdata_745, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_subdata_745_comment},
  {"get_ref_count", &Dtool_PointerToArray_double_get_ref_count_746, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_ref_count_746_comment},
  {"getRefCount", &Dtool_PointerToArray_double_get_ref_count_746, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_ref_count_746_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_double_get_node_ref_count_747, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_node_ref_count_747_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_double_get_node_ref_count_747, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_node_ref_count_747_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_double_getbuffer_748_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_double.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_double_releasebuffer_749_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< double > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_double_setitem_741_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_double index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< double >::__setitem__(unsigned long int n, double const &value)
      if (PyNumber_Check(arg)) {
        invoke_extension(local_this).__setitem__(index, PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, double value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_double_getitem_740_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_double index out of range");
    return NULL;
  }
  // 1-double const &PointerToArray< double >::__getitem__(unsigned long int n) const
  double return_value = invoke_extension((const PointerToArray< double >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_double_size_735_sq_length(PyObject *self) {
  PointerToArray< double > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_double = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_double = {
  &Dtool_PointerToArray_double_size_735_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_double_getitem_740_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_double_setitem_741_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_double = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_double = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_double_getbuffer_748_bf_getbuffer,
  &Dtool_PointerToArray_double_releasebuffer_749_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_double = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_double",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_double,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_double,
    &Dtool_SequenceMethods_PointerToArray_double,
    &Dtool_MappingMethods_PointerToArray_double,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_double,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_double,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_double,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_double,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_double,
  Dtool_UpcastInterface_PointerToArray_double,
  Dtool_DowncastInterface_PointerToArray_double,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_double,
};

static void Dtool_PyModuleClassInit_PointerToArray_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_double(NULL);
    Dtool_PointerToArray_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_double);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_double);
  }
}

/**
 * Python method tables for PointerToArray_float (PointerToArray_float)
 */
static PyMethodDef Dtool_Methods_PointerToArray_float[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_float_empty_array_754, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_float_empty_array_754_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_float_empty_array_754, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_float_empty_array_754_comment},
  {"push_back", &Dtool_PointerToArray_float_push_back_756, METH_O, (const char *)Dtool_PointerToArray_float_push_back_756_comment},
  {"pushBack", &Dtool_PointerToArray_float_push_back_756, METH_O, (const char *)Dtool_PointerToArray_float_push_back_756_comment},
  {"pop_back", &Dtool_PointerToArray_float_pop_back_757, METH_NOARGS, (const char *)Dtool_PointerToArray_float_pop_back_757_comment},
  {"popBack", &Dtool_PointerToArray_float_pop_back_757, METH_NOARGS, (const char *)Dtool_PointerToArray_float_pop_back_757_comment},
  {"get_element", &Dtool_PointerToArray_float_get_element_758, METH_O, (const char *)Dtool_PointerToArray_float_get_element_758_comment},
  {"getElement", &Dtool_PointerToArray_float_get_element_758, METH_O, (const char *)Dtool_PointerToArray_float_get_element_758_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_float_set_element_759, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_element_759_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_float_set_element_759, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_element_759_comment},
  {"get_data", &Dtool_PointerToArray_float_get_data_762, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_data_762_comment},
  {"getData", &Dtool_PointerToArray_float_get_data_762, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_data_762_comment},
  {"set_data", &Dtool_PointerToArray_float_set_data_763, METH_O, (const char *)Dtool_PointerToArray_float_set_data_763_comment},
  {"setData", &Dtool_PointerToArray_float_set_data_763, METH_O, (const char *)Dtool_PointerToArray_float_set_data_763_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_float_get_subdata_764, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_get_subdata_764_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_float_get_subdata_764, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_get_subdata_764_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_float_set_subdata_765, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_subdata_765_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_float_set_subdata_765, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_subdata_765_comment},
  {"get_ref_count", &Dtool_PointerToArray_float_get_ref_count_766, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_ref_count_766_comment},
  {"getRefCount", &Dtool_PointerToArray_float_get_ref_count_766, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_ref_count_766_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_float_get_node_ref_count_767, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_node_ref_count_767_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_float_get_node_ref_count_767, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_node_ref_count_767_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_float_getbuffer_768_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_float.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_float_releasebuffer_769_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< float > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_float_setitem_761_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_float index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< float >::__setitem__(unsigned long int n, float const &value)
      if (PyNumber_Check(arg)) {
        invoke_extension(local_this).__setitem__(index, (float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, float value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_float_getitem_760_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_float index out of range");
    return NULL;
  }
  // 1-float const &PointerToArray< float >::__getitem__(unsigned long int n) const
  float return_value = invoke_extension((const PointerToArray< float >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_float_size_755_sq_length(PyObject *self) {
  PointerToArray< float > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_float = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_float = {
  &Dtool_PointerToArray_float_size_755_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_float_getitem_760_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_float_setitem_761_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_float = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_float = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_float_getbuffer_768_bf_getbuffer,
  &Dtool_PointerToArray_float_releasebuffer_769_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_float = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_float",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_float,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_float,
    &Dtool_SequenceMethods_PointerToArray_float,
    &Dtool_MappingMethods_PointerToArray_float,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_float,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_float,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_float,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_float,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_float,
  Dtool_UpcastInterface_PointerToArray_float,
  Dtool_DowncastInterface_PointerToArray_float,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_float,
};

static void Dtool_PyModuleClassInit_PointerToArray_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_float(NULL);
    Dtool_PointerToArray_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_float);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_float);
  }
}

/**
 * Python method tables for PointerToArray_int (PointerToArray_int)
 */
static PyMethodDef Dtool_Methods_PointerToArray_int[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_int_empty_array_774, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_int_empty_array_774_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_int_empty_array_774, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_int_empty_array_774_comment},
  {"push_back", &Dtool_PointerToArray_int_push_back_776, METH_O, (const char *)Dtool_PointerToArray_int_push_back_776_comment},
  {"pushBack", &Dtool_PointerToArray_int_push_back_776, METH_O, (const char *)Dtool_PointerToArray_int_push_back_776_comment},
  {"pop_back", &Dtool_PointerToArray_int_pop_back_777, METH_NOARGS, (const char *)Dtool_PointerToArray_int_pop_back_777_comment},
  {"popBack", &Dtool_PointerToArray_int_pop_back_777, METH_NOARGS, (const char *)Dtool_PointerToArray_int_pop_back_777_comment},
  {"get_element", &Dtool_PointerToArray_int_get_element_778, METH_O, (const char *)Dtool_PointerToArray_int_get_element_778_comment},
  {"getElement", &Dtool_PointerToArray_int_get_element_778, METH_O, (const char *)Dtool_PointerToArray_int_get_element_778_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_int_set_element_779, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_element_779_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_int_set_element_779, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_element_779_comment},
  {"get_data", &Dtool_PointerToArray_int_get_data_782, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_data_782_comment},
  {"getData", &Dtool_PointerToArray_int_get_data_782, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_data_782_comment},
  {"set_data", &Dtool_PointerToArray_int_set_data_783, METH_O, (const char *)Dtool_PointerToArray_int_set_data_783_comment},
  {"setData", &Dtool_PointerToArray_int_set_data_783, METH_O, (const char *)Dtool_PointerToArray_int_set_data_783_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_int_get_subdata_784, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_get_subdata_784_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_int_get_subdata_784, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_get_subdata_784_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_int_set_subdata_785, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_subdata_785_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_int_set_subdata_785, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_subdata_785_comment},
  {"get_ref_count", &Dtool_PointerToArray_int_get_ref_count_786, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_ref_count_786_comment},
  {"getRefCount", &Dtool_PointerToArray_int_get_ref_count_786, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_ref_count_786_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_int_get_node_ref_count_787, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_node_ref_count_787_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_int_get_node_ref_count_787, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_node_ref_count_787_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_int_getbuffer_788_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_int.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_int_releasebuffer_789_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< int > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_int_setitem_781_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_int index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< int >::__setitem__(unsigned long int n, int const &value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return -1;
        }
#endif
        invoke_extension(local_this).__setitem__(index, (int)arg_val);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, int value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_int_getitem_780_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_int index out of range");
    return NULL;
  }
  // 1-int const &PointerToArray< int >::__getitem__(unsigned long int n) const
  int return_value = invoke_extension((const PointerToArray< int >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_int_size_775_sq_length(PyObject *self) {
  PointerToArray< int > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_int = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_int = {
  &Dtool_PointerToArray_int_size_775_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_int_getitem_780_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_int_setitem_781_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_int = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_int = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_int_getbuffer_788_bf_getbuffer,
  &Dtool_PointerToArray_int_releasebuffer_789_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_int = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_int",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_int,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_int,
    &Dtool_SequenceMethods_PointerToArray_int,
    &Dtool_MappingMethods_PointerToArray_int,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_int,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_int,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_int,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_int,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_int,
  Dtool_UpcastInterface_PointerToArray_int,
  Dtool_DowncastInterface_PointerToArray_int,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_int,
};

static void Dtool_PyModuleClassInit_PointerToArray_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_int(NULL);
    Dtool_PointerToArray_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_int);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_int);
  }
}

/**
 * Python method tables for PointerToArray_unsigned_char (PointerToArray_unsigned_char)
 */
static PyMethodDef Dtool_Methods_PointerToArray_unsigned_char[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_unsigned_char_empty_array_794, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_unsigned_char_empty_array_794_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_unsigned_char_empty_array_794, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_unsigned_char_empty_array_794_comment},
  {"push_back", &Dtool_PointerToArray_unsigned_char_push_back_796, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_push_back_796_comment},
  {"pushBack", &Dtool_PointerToArray_unsigned_char_push_back_796, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_push_back_796_comment},
  {"pop_back", &Dtool_PointerToArray_unsigned_char_pop_back_797, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_pop_back_797_comment},
  {"popBack", &Dtool_PointerToArray_unsigned_char_pop_back_797, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_pop_back_797_comment},
  {"get_element", &Dtool_PointerToArray_unsigned_char_get_element_798, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_get_element_798_comment},
  {"getElement", &Dtool_PointerToArray_unsigned_char_get_element_798, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_get_element_798_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_element_799, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_element_799_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_element_799, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_element_799_comment},
  {"get_data", &Dtool_PointerToArray_unsigned_char_get_data_802, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_data_802_comment},
  {"getData", &Dtool_PointerToArray_unsigned_char_get_data_802, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_data_802_comment},
  {"set_data", &Dtool_PointerToArray_unsigned_char_set_data_803, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_set_data_803_comment},
  {"setData", &Dtool_PointerToArray_unsigned_char_set_data_803, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_set_data_803_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_get_subdata_804, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_get_subdata_804_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_get_subdata_804, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_get_subdata_804_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_subdata_805, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_subdata_805_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_subdata_805, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_subdata_805_comment},
  {"get_ref_count", &Dtool_PointerToArray_unsigned_char_get_ref_count_806, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_ref_count_806_comment},
  {"getRefCount", &Dtool_PointerToArray_unsigned_char_get_ref_count_806, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_ref_count_806_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_unsigned_char_get_node_ref_count_807, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_node_ref_count_807_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_unsigned_char_get_node_ref_count_807, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_node_ref_count_807_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_unsigned_char_getbuffer_808_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  if (!((Dtool_PyInstDef *)self)->_is_const) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_unsigned_char.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_unsigned_char_releasebuffer_809_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< unsigned char > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_unsigned_char_setitem_801_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_unsigned_char index out of range");
    return -1;
  }
  if (arg != (PyObject *)NULL) { // __setitem__
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PointerToArray< unsigned char >::__setitem__(unsigned long int n, unsigned char const &value)
      if (PyLongOrInt_Check(arg)) {
        long param2 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param2 < 0 || param2 > UCHAR_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned byte",
                       param2);
          return -1;
        }
#endif
        invoke_extension(local_this).__setitem__(index, (unsigned char)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, int value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_unsigned_char_getitem_800_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_unsigned_char index out of range");
    return NULL;
  }
  // 1-unsigned char const &PointerToArray< unsigned char >::__getitem__(unsigned long int n) const
  unsigned char return_value = invoke_extension((const PointerToArray< unsigned char >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_unsigned_char_size_795_sq_length(PyObject *self) {
  PointerToArray< unsigned char > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_unsigned_char = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_unsigned_char = {
  &Dtool_PointerToArray_unsigned_char_size_795_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_PointerToArray_unsigned_char_getitem_800_sq_item,
  0, // sq_slice
  &Dtool_PointerToArray_unsigned_char_setitem_801_sq_ass_item,
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_unsigned_char = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_unsigned_char_getbuffer_808_bf_getbuffer,
  &Dtool_PointerToArray_unsigned_char_releasebuffer_809_bf_releasebuffer,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToArray_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToArray_unsigned_char",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_unsigned_char,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerToArray_unsigned_char,
    &Dtool_SequenceMethods_PointerToArray_unsigned_char,
    &Dtool_MappingMethods_PointerToArray_unsigned_char,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToArray_unsigned_char,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToArray_unsigned_char,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_unsigned_char,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_unsigned_char,
  Dtool_UpcastInterface_PointerToArray_unsigned_char,
  Dtool_DowncastInterface_PointerToArray_unsigned_char,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_PointerToArray_unsigned_char,
};

static void Dtool_PyModuleClassInit_PointerToArray_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(NULL);
    Dtool_PointerToArray_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char);
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_unsigned_char);
  }
}

/**
 * Python method tables for PandaSystem (PandaSystem)
 */
static PyMethodDef Dtool_Methods_PandaSystem[] = {
  {"get_version_string", &Dtool_PandaSystem_get_version_string_812, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_version_string_812_comment},
  {"getVersionString", &Dtool_PandaSystem_get_version_string_812, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_version_string_812_comment},
  {"get_package_version_string", &Dtool_PandaSystem_get_package_version_string_813, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_version_string_813_comment},
  {"getPackageVersionString", &Dtool_PandaSystem_get_package_version_string_813, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_version_string_813_comment},
  {"get_package_host_url", &Dtool_PandaSystem_get_package_host_url_814, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_host_url_814_comment},
  {"getPackageHostUrl", &Dtool_PandaSystem_get_package_host_url_814, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_package_host_url_814_comment},
  {"get_p3d_coreapi_version_string", &Dtool_PandaSystem_get_p3d_coreapi_version_string_815, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_p3d_coreapi_version_string_815_comment},
  {"getP3dCoreapiVersionString", &Dtool_PandaSystem_get_p3d_coreapi_version_string_815, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_p3d_coreapi_version_string_815_comment},
  {"get_major_version", &Dtool_PandaSystem_get_major_version_816, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_major_version_816_comment},
  {"getMajorVersion", &Dtool_PandaSystem_get_major_version_816, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_major_version_816_comment},
  {"get_minor_version", &Dtool_PandaSystem_get_minor_version_817, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_minor_version_817_comment},
  {"getMinorVersion", &Dtool_PandaSystem_get_minor_version_817, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_minor_version_817_comment},
  {"get_sequence_version", &Dtool_PandaSystem_get_sequence_version_818, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_sequence_version_818_comment},
  {"getSequenceVersion", &Dtool_PandaSystem_get_sequence_version_818, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_sequence_version_818_comment},
  {"is_official_version", &Dtool_PandaSystem_is_official_version_819, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_is_official_version_819_comment},
  {"isOfficialVersion", &Dtool_PandaSystem_is_official_version_819, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_is_official_version_819_comment},
  {"get_distributor", &Dtool_PandaSystem_get_distributor_820, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_distributor_820_comment},
  {"getDistributor", &Dtool_PandaSystem_get_distributor_820, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_distributor_820_comment},
  {"get_compiler", &Dtool_PandaSystem_get_compiler_821, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_compiler_821_comment},
  {"getCompiler", &Dtool_PandaSystem_get_compiler_821, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_compiler_821_comment},
  {"get_build_date", &Dtool_PandaSystem_get_build_date_822, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_build_date_822_comment},
  {"getBuildDate", &Dtool_PandaSystem_get_build_date_822, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_build_date_822_comment},
  {"get_git_commit", &Dtool_PandaSystem_get_git_commit_823, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_git_commit_823_comment},
  {"getGitCommit", &Dtool_PandaSystem_get_git_commit_823, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_git_commit_823_comment},
  {"get_platform", &Dtool_PandaSystem_get_platform_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_platform_824_comment},
  {"getPlatform", &Dtool_PandaSystem_get_platform_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_platform_824_comment},
  {"has_system", &Dtool_PandaSystem_has_system_825, METH_O, (const char *)Dtool_PandaSystem_has_system_825_comment},
  {"hasSystem", &Dtool_PandaSystem_has_system_825, METH_O, (const char *)Dtool_PandaSystem_has_system_825_comment},
  {"get_num_systems", &Dtool_PandaSystem_get_num_systems_826, METH_NOARGS, (const char *)Dtool_PandaSystem_get_num_systems_826_comment},
  {"getNumSystems", &Dtool_PandaSystem_get_num_systems_826, METH_NOARGS, (const char *)Dtool_PandaSystem_get_num_systems_826_comment},
  {"get_system", &Dtool_PandaSystem_get_system_827, METH_O, (const char *)Dtool_PandaSystem_get_system_827_comment},
  {"getSystem", &Dtool_PandaSystem_get_system_827, METH_O, (const char *)Dtool_PandaSystem_get_system_827_comment},
  {"get_system_tag", (PyCFunction) &Dtool_PandaSystem_get_system_tag_830, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_get_system_tag_830_comment},
  {"getSystemTag", (PyCFunction) &Dtool_PandaSystem_get_system_tag_830, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_get_system_tag_830_comment},
  {"add_system", &Dtool_PandaSystem_add_system_831, METH_O, (const char *)Dtool_PandaSystem_add_system_831_comment},
  {"addSystem", &Dtool_PandaSystem_add_system_831, METH_O, (const char *)Dtool_PandaSystem_add_system_831_comment},
  {"set_system_tag", (PyCFunction) &Dtool_PandaSystem_set_system_tag_832, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_set_system_tag_832_comment},
  {"setSystemTag", (PyCFunction) &Dtool_PandaSystem_set_system_tag_832, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PandaSystem_set_system_tag_832_comment},
  {"heap_trim", &Dtool_PandaSystem_heap_trim_833, METH_O, (const char *)Dtool_PandaSystem_heap_trim_833_comment},
  {"heapTrim", &Dtool_PandaSystem_heap_trim_833, METH_O, (const char *)Dtool_PandaSystem_heap_trim_833_comment},
  {"output", &Dtool_PandaSystem_output_834, METH_O, (const char *)Dtool_PandaSystem_output_834_comment},
  {"write", &Dtool_PandaSystem_write_835, METH_O, (const char *)Dtool_PandaSystem_write_835_comment},
  {"get_global_ptr", &Dtool_PandaSystem_get_global_ptr_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_global_ptr_836_comment},
  {"getGlobalPtr", &Dtool_PandaSystem_get_global_ptr_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_global_ptr_836_comment},
  {"get_class_type", &Dtool_PandaSystem_get_class_type_837, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_class_type_837_comment},
  {"getClassType", &Dtool_PandaSystem_get_class_type_837, METH_NOARGS | METH_STATIC, (const char *)Dtool_PandaSystem_get_class_type_837_comment},
  {"get_systems", (PyCFunction) &MakeSeq_PandaSystem_get_systems, METH_NOARGS, NULL},
  { "getSystems", (PyCFunction) &MakeSeq_PandaSystem_get_systems, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PandaSystem
//////////////////
static PyObject *Dtool_Repr_PandaSystem(PyObject *self) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PandaSystem
//////////////////
static PyObject *Dtool_Str_PandaSystem(PyObject *self) {
  PandaSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PandaSystem, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PandaSystem[] = {
  {(char *)"systems", &Dtool_PandaSystem_systems_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_PandaSystem = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_PandaSystem = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PandaSystem",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PandaSystem,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PandaSystem,
    &Dtool_NumberMethods_PandaSystem,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_PandaSystem,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used as a namespace to group several global properties of\n"
    " * Panda.  Application developers can use this class to query the runtime\n"
    " * version or capabilities of the current Panda environment.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PandaSystem,
    0, // tp_members
    Dtool_Properties_PandaSystem,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PandaSystem,
    PyType_GenericAlloc,
    Dtool_new_PandaSystem,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PandaSystem,
  Dtool_UpcastInterface_PandaSystem,
  Dtool_DowncastInterface_PandaSystem,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PandaSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PandaSystem._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_PandaSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PandaSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PandaSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PandaSystem);
  }
}

/**
 * Python method tables for StreamReader (StreamReader)
 */
static PyMethodDef Dtool_Methods_StreamReader[] = {
  {"assign", &Dtool_StreamReader_operator_840, METH_O, (const char *)Dtool_StreamReader_operator_840_comment},
  {"get_istream", &Dtool_StreamReader_get_istream_842, METH_NOARGS, (const char *)Dtool_StreamReader_get_istream_842_comment},
  {"getIstream", &Dtool_StreamReader_get_istream_842, METH_NOARGS, (const char *)Dtool_StreamReader_get_istream_842_comment},
  {"get_bool", &Dtool_StreamReader_get_bool_844, METH_NOARGS, (const char *)Dtool_StreamReader_get_bool_844_comment},
  {"getBool", &Dtool_StreamReader_get_bool_844, METH_NOARGS, (const char *)Dtool_StreamReader_get_bool_844_comment},
  {"get_int8", &Dtool_StreamReader_get_int8_845, METH_NOARGS, (const char *)Dtool_StreamReader_get_int8_845_comment},
  {"getInt8", &Dtool_StreamReader_get_int8_845, METH_NOARGS, (const char *)Dtool_StreamReader_get_int8_845_comment},
  {"get_uint8", &Dtool_StreamReader_get_uint8_846, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint8_846_comment},
  {"getUint8", &Dtool_StreamReader_get_uint8_846, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint8_846_comment},
  {"get_int16", &Dtool_StreamReader_get_int16_847, METH_NOARGS, (const char *)Dtool_StreamReader_get_int16_847_comment},
  {"getInt16", &Dtool_StreamReader_get_int16_847, METH_NOARGS, (const char *)Dtool_StreamReader_get_int16_847_comment},
  {"get_int32", &Dtool_StreamReader_get_int32_848, METH_NOARGS, (const char *)Dtool_StreamReader_get_int32_848_comment},
  {"getInt32", &Dtool_StreamReader_get_int32_848, METH_NOARGS, (const char *)Dtool_StreamReader_get_int32_848_comment},
  {"get_int64", &Dtool_StreamReader_get_int64_849, METH_NOARGS, (const char *)Dtool_StreamReader_get_int64_849_comment},
  {"getInt64", &Dtool_StreamReader_get_int64_849, METH_NOARGS, (const char *)Dtool_StreamReader_get_int64_849_comment},
  {"get_uint16", &Dtool_StreamReader_get_uint16_850, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint16_850_comment},
  {"getUint16", &Dtool_StreamReader_get_uint16_850, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint16_850_comment},
  {"get_uint32", &Dtool_StreamReader_get_uint32_851, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint32_851_comment},
  {"getUint32", &Dtool_StreamReader_get_uint32_851, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint32_851_comment},
  {"get_uint64", &Dtool_StreamReader_get_uint64_852, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint64_852_comment},
  {"getUint64", &Dtool_StreamReader_get_uint64_852, METH_NOARGS, (const char *)Dtool_StreamReader_get_uint64_852_comment},
  {"get_float32", &Dtool_StreamReader_get_float32_853, METH_NOARGS, (const char *)Dtool_StreamReader_get_float32_853_comment},
  {"getFloat32", &Dtool_StreamReader_get_float32_853, METH_NOARGS, (const char *)Dtool_StreamReader_get_float32_853_comment},
  {"get_float64", &Dtool_StreamReader_get_float64_854, METH_NOARGS, (const char *)Dtool_StreamReader_get_float64_854_comment},
  {"getFloat64", &Dtool_StreamReader_get_float64_854, METH_NOARGS, (const char *)Dtool_StreamReader_get_float64_854_comment},
  {"get_be_int16", &Dtool_StreamReader_get_be_int16_855, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int16_855_comment},
  {"getBeInt16", &Dtool_StreamReader_get_be_int16_855, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int16_855_comment},
  {"get_be_int32", &Dtool_StreamReader_get_be_int32_856, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int32_856_comment},
  {"getBeInt32", &Dtool_StreamReader_get_be_int32_856, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int32_856_comment},
  {"get_be_int64", &Dtool_StreamReader_get_be_int64_857, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int64_857_comment},
  {"getBeInt64", &Dtool_StreamReader_get_be_int64_857, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_int64_857_comment},
  {"get_be_uint16", &Dtool_StreamReader_get_be_uint16_858, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint16_858_comment},
  {"getBeUint16", &Dtool_StreamReader_get_be_uint16_858, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint16_858_comment},
  {"get_be_uint32", &Dtool_StreamReader_get_be_uint32_859, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint32_859_comment},
  {"getBeUint32", &Dtool_StreamReader_get_be_uint32_859, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint32_859_comment},
  {"get_be_uint64", &Dtool_StreamReader_get_be_uint64_860, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint64_860_comment},
  {"getBeUint64", &Dtool_StreamReader_get_be_uint64_860, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_uint64_860_comment},
  {"get_be_float32", &Dtool_StreamReader_get_be_float32_861, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float32_861_comment},
  {"getBeFloat32", &Dtool_StreamReader_get_be_float32_861, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float32_861_comment},
  {"get_be_float64", &Dtool_StreamReader_get_be_float64_862, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float64_862_comment},
  {"getBeFloat64", &Dtool_StreamReader_get_be_float64_862, METH_NOARGS, (const char *)Dtool_StreamReader_get_be_float64_862_comment},
  {"get_string", &Dtool_StreamReader_get_string_863, METH_NOARGS, (const char *)Dtool_StreamReader_get_string_863_comment},
  {"getString", &Dtool_StreamReader_get_string_863, METH_NOARGS, (const char *)Dtool_StreamReader_get_string_863_comment},
  {"get_string32", &Dtool_StreamReader_get_string32_864, METH_NOARGS, (const char *)Dtool_StreamReader_get_string32_864_comment},
  {"getString32", &Dtool_StreamReader_get_string32_864, METH_NOARGS, (const char *)Dtool_StreamReader_get_string32_864_comment},
  {"get_z_string", &Dtool_StreamReader_get_z_string_865, METH_NOARGS, (const char *)Dtool_StreamReader_get_z_string_865_comment},
  {"getZString", &Dtool_StreamReader_get_z_string_865, METH_NOARGS, (const char *)Dtool_StreamReader_get_z_string_865_comment},
  {"get_fixed_string", &Dtool_StreamReader_get_fixed_string_866, METH_O, (const char *)Dtool_StreamReader_get_fixed_string_866_comment},
  {"getFixedString", &Dtool_StreamReader_get_fixed_string_866, METH_O, (const char *)Dtool_StreamReader_get_fixed_string_866_comment},
  {"skip_bytes", &Dtool_StreamReader_skip_bytes_867, METH_O, (const char *)Dtool_StreamReader_skip_bytes_867_comment},
  {"skipBytes", &Dtool_StreamReader_skip_bytes_867, METH_O, (const char *)Dtool_StreamReader_skip_bytes_867_comment},
  {"extract_bytes", &Dtool_StreamReader_extract_bytes_868, METH_O, (const char *)Dtool_StreamReader_extract_bytes_868_comment},
  {"extractBytes", &Dtool_StreamReader_extract_bytes_868, METH_O, (const char *)Dtool_StreamReader_extract_bytes_868_comment},
  {"readline", &Dtool_StreamReader_readline_869, METH_NOARGS, (const char *)Dtool_StreamReader_readline_869_comment},
  {"readlines", &Dtool_StreamReader_readlines_870, METH_NOARGS, (const char *)Dtool_StreamReader_readlines_870_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_StreamReader[] = {
  {(char *)"istream", &Dtool_StreamReader_istream_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_StreamReader = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_StreamReader = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StreamReader",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamReader,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StreamReader,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to read sequential binary data directly from an istream.  Its\n"
    " * interface is similar to DatagramIterator by design; see also StreamWriter.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StreamReader,
    0, // tp_members
    Dtool_Properties_StreamReader,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StreamReader,
    PyType_GenericAlloc,
    Dtool_new_StreamReader,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamReader,
  Dtool_UpcastInterface_StreamReader,
  Dtool_DowncastInterface_StreamReader,
  (CoerceFunction)Dtool_ConstCoerce_StreamReader,
  (CoerceFunction)Dtool_Coerce_StreamReader,
};

static void Dtool_PyModuleClassInit_StreamReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StreamReader._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_StreamReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamReader);
  }
}

/**
 * Python method tables for StreamWrapper (StreamWrapper)
 */
static PyMethodDef Dtool_Methods_StreamWrapper[] = {
  {"get_iostream", &Dtool_StreamWrapper_get_iostream_878, METH_NOARGS, (const char *)Dtool_StreamWrapper_get_iostream_878_comment},
  {"getIostream", &Dtool_StreamWrapper_get_iostream_878, METH_NOARGS, (const char *)Dtool_StreamWrapper_get_iostream_878_comment},
  {"upcast_to_IStreamWrapper", &Dtool_StreamWrapper_upcast_to_IStreamWrapper_872, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_IStreamWrapper_872_comment},
  {"upcastToIStreamWrapper", &Dtool_StreamWrapper_upcast_to_IStreamWrapper_872, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_IStreamWrapper_872_comment},
  {"upcast_to_OStreamWrapper", &Dtool_StreamWrapper_upcast_to_OStreamWrapper_874, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_OStreamWrapper_874_comment},
  {"upcastToOStreamWrapper", &Dtool_StreamWrapper_upcast_to_OStreamWrapper_874, METH_NOARGS, (const char *)Dtool_StreamWrapper_upcast_to_OStreamWrapper_874_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_StreamWrapper[] = {
  {(char *)"iostream", &Dtool_StreamWrapper_iostream_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_StreamWrapper = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StreamWrapper = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_StreamWrapper = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_StreamWrapper = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_StreamWrapper = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StreamWrapper",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamWrapper,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StreamWrapper,
    &Dtool_SequenceMethods_StreamWrapper,
    &Dtool_MappingMethods_StreamWrapper,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_StreamWrapper,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a locking wrapper around a combination ostream/istream\n"
    " * pointer.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StreamWrapper,
    0, // tp_members
    Dtool_Properties_StreamWrapper,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StreamWrapper,
    PyType_GenericAlloc,
    Dtool_new_StreamWrapper,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamWrapper,
  Dtool_UpcastInterface_StreamWrapper,
  Dtool_DowncastInterface_StreamWrapper,
  (CoerceFunction)Dtool_ConstCoerce_StreamWrapper,
  (CoerceFunction)Dtool_Coerce_StreamWrapper,
};

static void Dtool_PyModuleClassInit_StreamWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_IStreamWrapper(NULL);
    Dtool_PyModuleClassInit_OStreamWrapper(NULL);
    Dtool_StreamWrapper._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_IStreamWrapper, (PyTypeObject *)&Dtool_OStreamWrapper);
    PyObject *dict = PyDict_New();
    Dtool_StreamWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamWrapper);
  }
}

/**
 * Python method tables for StreamWriter (StreamWriter)
 */
static PyMethodDef Dtool_Methods_StreamWriter[] = {
  {"assign", &Dtool_StreamWriter_operator_883, METH_O, (const char *)Dtool_StreamWriter_operator_883_comment},
  {"get_ostream", &Dtool_StreamWriter_get_ostream_885, METH_NOARGS, (const char *)Dtool_StreamWriter_get_ostream_885_comment},
  {"getOstream", &Dtool_StreamWriter_get_ostream_885, METH_NOARGS, (const char *)Dtool_StreamWriter_get_ostream_885_comment},
  {"add_bool", &Dtool_StreamWriter_add_bool_887, METH_O, (const char *)Dtool_StreamWriter_add_bool_887_comment},
  {"addBool", &Dtool_StreamWriter_add_bool_887, METH_O, (const char *)Dtool_StreamWriter_add_bool_887_comment},
  {"add_int8", &Dtool_StreamWriter_add_int8_888, METH_O, (const char *)Dtool_StreamWriter_add_int8_888_comment},
  {"addInt8", &Dtool_StreamWriter_add_int8_888, METH_O, (const char *)Dtool_StreamWriter_add_int8_888_comment},
  {"add_uint8", &Dtool_StreamWriter_add_uint8_889, METH_O, (const char *)Dtool_StreamWriter_add_uint8_889_comment},
  {"addUint8", &Dtool_StreamWriter_add_uint8_889, METH_O, (const char *)Dtool_StreamWriter_add_uint8_889_comment},
  {"add_int16", &Dtool_StreamWriter_add_int16_890, METH_O, (const char *)Dtool_StreamWriter_add_int16_890_comment},
  {"addInt16", &Dtool_StreamWriter_add_int16_890, METH_O, (const char *)Dtool_StreamWriter_add_int16_890_comment},
  {"add_int32", &Dtool_StreamWriter_add_int32_891, METH_O, (const char *)Dtool_StreamWriter_add_int32_891_comment},
  {"addInt32", &Dtool_StreamWriter_add_int32_891, METH_O, (const char *)Dtool_StreamWriter_add_int32_891_comment},
  {"add_int64", &Dtool_StreamWriter_add_int64_892, METH_O, (const char *)Dtool_StreamWriter_add_int64_892_comment},
  {"addInt64", &Dtool_StreamWriter_add_int64_892, METH_O, (const char *)Dtool_StreamWriter_add_int64_892_comment},
  {"add_uint16", &Dtool_StreamWriter_add_uint16_893, METH_O, (const char *)Dtool_StreamWriter_add_uint16_893_comment},
  {"addUint16", &Dtool_StreamWriter_add_uint16_893, METH_O, (const char *)Dtool_StreamWriter_add_uint16_893_comment},
  {"add_uint32", &Dtool_StreamWriter_add_uint32_894, METH_O, (const char *)Dtool_StreamWriter_add_uint32_894_comment},
  {"addUint32", &Dtool_StreamWriter_add_uint32_894, METH_O, (const char *)Dtool_StreamWriter_add_uint32_894_comment},
  {"add_uint64", &Dtool_StreamWriter_add_uint64_895, METH_O, (const char *)Dtool_StreamWriter_add_uint64_895_comment},
  {"addUint64", &Dtool_StreamWriter_add_uint64_895, METH_O, (const char *)Dtool_StreamWriter_add_uint64_895_comment},
  {"add_float32", &Dtool_StreamWriter_add_float32_896, METH_O, (const char *)Dtool_StreamWriter_add_float32_896_comment},
  {"addFloat32", &Dtool_StreamWriter_add_float32_896, METH_O, (const char *)Dtool_StreamWriter_add_float32_896_comment},
  {"add_float64", &Dtool_StreamWriter_add_float64_897, METH_O, (const char *)Dtool_StreamWriter_add_float64_897_comment},
  {"addFloat64", &Dtool_StreamWriter_add_float64_897, METH_O, (const char *)Dtool_StreamWriter_add_float64_897_comment},
  {"add_be_int16", &Dtool_StreamWriter_add_be_int16_898, METH_O, (const char *)Dtool_StreamWriter_add_be_int16_898_comment},
  {"addBeInt16", &Dtool_StreamWriter_add_be_int16_898, METH_O, (const char *)Dtool_StreamWriter_add_be_int16_898_comment},
  {"add_be_int32", &Dtool_StreamWriter_add_be_int32_899, METH_O, (const char *)Dtool_StreamWriter_add_be_int32_899_comment},
  {"addBeInt32", &Dtool_StreamWriter_add_be_int32_899, METH_O, (const char *)Dtool_StreamWriter_add_be_int32_899_comment},
  {"add_be_int64", &Dtool_StreamWriter_add_be_int64_900, METH_O, (const char *)Dtool_StreamWriter_add_be_int64_900_comment},
  {"addBeInt64", &Dtool_StreamWriter_add_be_int64_900, METH_O, (const char *)Dtool_StreamWriter_add_be_int64_900_comment},
  {"add_be_uint16", &Dtool_StreamWriter_add_be_uint16_901, METH_O, (const char *)Dtool_StreamWriter_add_be_uint16_901_comment},
  {"addBeUint16", &Dtool_StreamWriter_add_be_uint16_901, METH_O, (const char *)Dtool_StreamWriter_add_be_uint16_901_comment},
  {"add_be_uint32", &Dtool_StreamWriter_add_be_uint32_902, METH_O, (const char *)Dtool_StreamWriter_add_be_uint32_902_comment},
  {"addBeUint32", &Dtool_StreamWriter_add_be_uint32_902, METH_O, (const char *)Dtool_StreamWriter_add_be_uint32_902_comment},
  {"add_be_uint64", &Dtool_StreamWriter_add_be_uint64_903, METH_O, (const char *)Dtool_StreamWriter_add_be_uint64_903_comment},
  {"addBeUint64", &Dtool_StreamWriter_add_be_uint64_903, METH_O, (const char *)Dtool_StreamWriter_add_be_uint64_903_comment},
  {"add_be_float32", &Dtool_StreamWriter_add_be_float32_904, METH_O, (const char *)Dtool_StreamWriter_add_be_float32_904_comment},
  {"addBeFloat32", &Dtool_StreamWriter_add_be_float32_904, METH_O, (const char *)Dtool_StreamWriter_add_be_float32_904_comment},
  {"add_be_float64", &Dtool_StreamWriter_add_be_float64_905, METH_O, (const char *)Dtool_StreamWriter_add_be_float64_905_comment},
  {"addBeFloat64", &Dtool_StreamWriter_add_be_float64_905, METH_O, (const char *)Dtool_StreamWriter_add_be_float64_905_comment},
  {"add_string", &Dtool_StreamWriter_add_string_906, METH_O, (const char *)Dtool_StreamWriter_add_string_906_comment},
  {"addString", &Dtool_StreamWriter_add_string_906, METH_O, (const char *)Dtool_StreamWriter_add_string_906_comment},
  {"add_string32", &Dtool_StreamWriter_add_string32_907, METH_O, (const char *)Dtool_StreamWriter_add_string32_907_comment},
  {"addString32", &Dtool_StreamWriter_add_string32_907, METH_O, (const char *)Dtool_StreamWriter_add_string32_907_comment},
  {"add_z_string", &Dtool_StreamWriter_add_z_string_908, METH_O, (const char *)Dtool_StreamWriter_add_z_string_908_comment},
  {"addZString", &Dtool_StreamWriter_add_z_string_908, METH_O, (const char *)Dtool_StreamWriter_add_z_string_908_comment},
  {"add_fixed_string", (PyCFunction) &Dtool_StreamWriter_add_fixed_string_909, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StreamWriter_add_fixed_string_909_comment},
  {"addFixedString", (PyCFunction) &Dtool_StreamWriter_add_fixed_string_909, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_StreamWriter_add_fixed_string_909_comment},
  {"pad_bytes", &Dtool_StreamWriter_pad_bytes_910, METH_O, (const char *)Dtool_StreamWriter_pad_bytes_910_comment},
  {"padBytes", &Dtool_StreamWriter_pad_bytes_910, METH_O, (const char *)Dtool_StreamWriter_pad_bytes_910_comment},
  {"append_data", &Dtool_StreamWriter_append_data_911, METH_O, (const char *)Dtool_StreamWriter_append_data_911_comment},
  {"appendData", &Dtool_StreamWriter_append_data_911, METH_O, (const char *)Dtool_StreamWriter_append_data_911_comment},
  {"flush", &Dtool_StreamWriter_flush_912, METH_NOARGS, (const char *)Dtool_StreamWriter_flush_912_comment},
  {"write", &Dtool_StreamWriter_write_913, METH_O, (const char *)Dtool_StreamWriter_write_913_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_StreamWriter[] = {
  {(char *)"ostream", &Dtool_StreamWriter_ostream_Getter, NULL, NULL, NULL},
  {(char *)"softspace", &Dtool_StreamWriter_softspace_Getter, &Dtool_StreamWriter_softspace_Setter, (char *)
    "// Python 2 needs this for printing to work correctly.",
    NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_StreamWriter = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_StreamWriter = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.StreamWriter",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_StreamWriter,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_StreamWriter,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A StreamWriter object is used to write sequential binary data directly to\n"
    " * an ostream.  Its interface is very similar to Datagram by design; it's\n"
    " * primarily intended as a convenience to eliminate the overhead of writing\n"
    " * bytes to a Datagram and then writing the Datagram to a stream.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_StreamWriter,
    0, // tp_members
    Dtool_Properties_StreamWriter,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_StreamWriter,
    PyType_GenericAlloc,
    Dtool_new_StreamWriter,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StreamWriter,
  Dtool_UpcastInterface_StreamWriter,
  Dtool_DowncastInterface_StreamWriter,
  (CoerceFunction)Dtool_ConstCoerce_StreamWriter,
  (CoerceFunction)Dtool_Coerce_StreamWriter,
};

static void Dtool_PyModuleClassInit_StreamWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_StreamWriter._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_StreamWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StreamWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StreamWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StreamWriter);
  }
}

/**
 * Python method tables for TextEncoder (TextEncoder)
 */
static PyMethodDef Dtool_Methods_TextEncoder[] = {
  {"set_encoding", &Dtool_TextEncoder_set_encoding_920, METH_O, (const char *)Dtool_TextEncoder_set_encoding_920_comment},
  {"setEncoding", &Dtool_TextEncoder_set_encoding_920, METH_O, (const char *)Dtool_TextEncoder_set_encoding_920_comment},
  {"get_encoding", &Dtool_TextEncoder_get_encoding_921, METH_NOARGS, (const char *)Dtool_TextEncoder_get_encoding_921_comment},
  {"getEncoding", &Dtool_TextEncoder_get_encoding_921, METH_NOARGS, (const char *)Dtool_TextEncoder_get_encoding_921_comment},
  {"set_default_encoding", &Dtool_TextEncoder_set_default_encoding_922, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_set_default_encoding_922_comment},
  {"setDefaultEncoding", &Dtool_TextEncoder_set_default_encoding_922, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_set_default_encoding_922_comment},
  {"get_default_encoding", &Dtool_TextEncoder_get_default_encoding_923, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextEncoder_get_default_encoding_923_comment},
  {"getDefaultEncoding", &Dtool_TextEncoder_get_default_encoding_923, METH_NOARGS | METH_STATIC, (const char *)Dtool_TextEncoder_get_default_encoding_923_comment},
  {"set_text", (PyCFunction) &Dtool_TextEncoder_set_text_924, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_text_924_comment},
  {"setText", (PyCFunction) &Dtool_TextEncoder_set_text_924, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_text_924_comment},
  {"clear_text", &Dtool_TextEncoder_clear_text_925, METH_NOARGS, (const char *)Dtool_TextEncoder_clear_text_925_comment},
  {"clearText", &Dtool_TextEncoder_clear_text_925, METH_NOARGS, (const char *)Dtool_TextEncoder_clear_text_925_comment},
  {"has_text", &Dtool_TextEncoder_has_text_926, METH_NOARGS, (const char *)Dtool_TextEncoder_has_text_926_comment},
  {"hasText", &Dtool_TextEncoder_has_text_926, METH_NOARGS, (const char *)Dtool_TextEncoder_has_text_926_comment},
  {"make_upper", &Dtool_TextEncoder_make_upper_927, METH_NOARGS, (const char *)Dtool_TextEncoder_make_upper_927_comment},
  {"makeUpper", &Dtool_TextEncoder_make_upper_927, METH_NOARGS, (const char *)Dtool_TextEncoder_make_upper_927_comment},
  {"make_lower", &Dtool_TextEncoder_make_lower_928, METH_NOARGS, (const char *)Dtool_TextEncoder_make_lower_928_comment},
  {"makeLower", &Dtool_TextEncoder_make_lower_928, METH_NOARGS, (const char *)Dtool_TextEncoder_make_lower_928_comment},
  {"get_text", &Dtool_TextEncoder_get_text_929, METH_VARARGS, (const char *)Dtool_TextEncoder_get_text_929_comment},
  {"getText", &Dtool_TextEncoder_get_text_929, METH_VARARGS, (const char *)Dtool_TextEncoder_get_text_929_comment},
  {"append_text", &Dtool_TextEncoder_append_text_930, METH_O, (const char *)Dtool_TextEncoder_append_text_930_comment},
  {"appendText", &Dtool_TextEncoder_append_text_930, METH_O, (const char *)Dtool_TextEncoder_append_text_930_comment},
  {"append_unicode_char", &Dtool_TextEncoder_append_unicode_char_931, METH_O, (const char *)Dtool_TextEncoder_append_unicode_char_931_comment},
  {"appendUnicodeChar", &Dtool_TextEncoder_append_unicode_char_931, METH_O, (const char *)Dtool_TextEncoder_append_unicode_char_931_comment},
  {"get_num_chars", &Dtool_TextEncoder_get_num_chars_932, METH_NOARGS, (const char *)Dtool_TextEncoder_get_num_chars_932_comment},
  {"getNumChars", &Dtool_TextEncoder_get_num_chars_932, METH_NOARGS, (const char *)Dtool_TextEncoder_get_num_chars_932_comment},
  {"get_unicode_char", &Dtool_TextEncoder_get_unicode_char_933, METH_O, (const char *)Dtool_TextEncoder_get_unicode_char_933_comment},
  {"getUnicodeChar", &Dtool_TextEncoder_get_unicode_char_933, METH_O, (const char *)Dtool_TextEncoder_get_unicode_char_933_comment},
  {"set_unicode_char", (PyCFunction) &Dtool_TextEncoder_set_unicode_char_934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_unicode_char_934_comment},
  {"setUnicodeChar", (PyCFunction) &Dtool_TextEncoder_set_unicode_char_934, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_set_unicode_char_934_comment},
  {"get_encoded_char", (PyCFunction) &Dtool_TextEncoder_get_encoded_char_935, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_get_encoded_char_935_comment},
  {"getEncodedChar", (PyCFunction) &Dtool_TextEncoder_get_encoded_char_935, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_get_encoded_char_935_comment},
  {"get_text_as_ascii", &Dtool_TextEncoder_get_text_as_ascii_936, METH_NOARGS, (const char *)Dtool_TextEncoder_get_text_as_ascii_936_comment},
  {"getTextAsAscii", &Dtool_TextEncoder_get_text_as_ascii_936, METH_NOARGS, (const char *)Dtool_TextEncoder_get_text_as_ascii_936_comment},
  {"reencode_text", (PyCFunction) &Dtool_TextEncoder_reencode_text_937, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_reencode_text_937_comment},
  {"reencodeText", (PyCFunction) &Dtool_TextEncoder_reencode_text_937, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_reencode_text_937_comment},
  {"unicode_isalpha", &Dtool_TextEncoder_unicode_isalpha_938, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isalpha_938_comment},
  {"unicodeIsalpha", &Dtool_TextEncoder_unicode_isalpha_938, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isalpha_938_comment},
  {"unicode_isdigit", &Dtool_TextEncoder_unicode_isdigit_939, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isdigit_939_comment},
  {"unicodeIsdigit", &Dtool_TextEncoder_unicode_isdigit_939, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isdigit_939_comment},
  {"unicode_ispunct", &Dtool_TextEncoder_unicode_ispunct_940, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_ispunct_940_comment},
  {"unicodeIspunct", &Dtool_TextEncoder_unicode_ispunct_940, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_ispunct_940_comment},
  {"unicode_islower", &Dtool_TextEncoder_unicode_islower_941, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_islower_941_comment},
  {"unicodeIslower", &Dtool_TextEncoder_unicode_islower_941, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_islower_941_comment},
  {"unicode_isupper", &Dtool_TextEncoder_unicode_isupper_942, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isupper_942_comment},
  {"unicodeIsupper", &Dtool_TextEncoder_unicode_isupper_942, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isupper_942_comment},
  {"unicode_isspace", &Dtool_TextEncoder_unicode_isspace_943, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isspace_943_comment},
  {"unicodeIsspace", &Dtool_TextEncoder_unicode_isspace_943, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_isspace_943_comment},
  {"unicode_toupper", &Dtool_TextEncoder_unicode_toupper_944, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_toupper_944_comment},
  {"unicodeToupper", &Dtool_TextEncoder_unicode_toupper_944, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_toupper_944_comment},
  {"unicode_tolower", &Dtool_TextEncoder_unicode_tolower_945, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_tolower_945_comment},
  {"unicodeTolower", &Dtool_TextEncoder_unicode_tolower_945, METH_O | METH_STATIC, (const char *)Dtool_TextEncoder_unicode_tolower_945_comment},
  {"upper", (PyCFunction) &Dtool_TextEncoder_upper_946, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_upper_946_comment},
  {"lower", (PyCFunction) &Dtool_TextEncoder_lower_947, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_lower_947_comment},
  {"set_wtext", &Dtool_TextEncoder_set_wtext_948, METH_O, (const char *)Dtool_TextEncoder_set_wtext_948_comment},
  {"setWtext", &Dtool_TextEncoder_set_wtext_948, METH_O, (const char *)Dtool_TextEncoder_set_wtext_948_comment},
  {"get_wtext", &Dtool_TextEncoder_get_wtext_949, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_949_comment},
  {"getWtext", &Dtool_TextEncoder_get_wtext_949, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_949_comment},
  {"append_wtext", &Dtool_TextEncoder_append_wtext_950, METH_O, (const char *)Dtool_TextEncoder_append_wtext_950_comment},
  {"appendWtext", &Dtool_TextEncoder_append_wtext_950, METH_O, (const char *)Dtool_TextEncoder_append_wtext_950_comment},
  {"get_wtext_as_ascii", &Dtool_TextEncoder_get_wtext_as_ascii_951, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_as_ascii_951_comment},
  {"getWtextAsAscii", &Dtool_TextEncoder_get_wtext_as_ascii_951, METH_NOARGS, (const char *)Dtool_TextEncoder_get_wtext_as_ascii_951_comment},
  {"is_wtext", &Dtool_TextEncoder_is_wtext_952, METH_NOARGS, (const char *)Dtool_TextEncoder_is_wtext_952_comment},
  {"isWtext", &Dtool_TextEncoder_is_wtext_952, METH_NOARGS, (const char *)Dtool_TextEncoder_is_wtext_952_comment},
  {"encode_wchar", (PyCFunction) &Dtool_TextEncoder_encode_wchar_953, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_encode_wchar_953_comment},
  {"encodeWchar", (PyCFunction) &Dtool_TextEncoder_encode_wchar_953, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TextEncoder_encode_wchar_953_comment},
  {"encode_wtext", (PyCFunction) &Dtool_TextEncoder_encode_wtext_954, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_encode_wtext_954_comment},
  {"encodeWtext", (PyCFunction) &Dtool_TextEncoder_encode_wtext_954, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_encode_wtext_954_comment},
  {"decode_text", (PyCFunction) &Dtool_TextEncoder_decode_text_955, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_decode_text_955_comment},
  {"decodeText", (PyCFunction) &Dtool_TextEncoder_decode_text_955, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TextEncoder_decode_text_955_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TextEncoder = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TextEncoder = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TextEncoder",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TextEncoder,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TextEncoder,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to convert text between multiple representations,\n"
    " * e.g.  utf-8 to Unicode.  You may use it as a static class object, passing\n"
    " * the encoding each time, or you may create an instance and use that object,\n"
    " * which will record the current encoding and retain the current string.\n"
    " *\n"
    " * This class is also a base class of TextNode, which inherits this\n"
    " * functionality.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TextEncoder,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TextEncoder,
    PyType_GenericAlloc,
    Dtool_new_TextEncoder,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TextEncoder,
  Dtool_UpcastInterface_TextEncoder,
  Dtool_DowncastInterface_TextEncoder,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TextEncoder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TextEncoder._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_TextEncoder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TextEncoder::Encoding;
    PyDict_SetItemString(dict, "E_iso8859", Dtool_WrapValue(TextEncoder::E_iso8859));
    PyDict_SetItemString(dict, "EIso8859", Dtool_WrapValue(TextEncoder::E_iso8859));
    PyDict_SetItemString(dict, "E_utf8", Dtool_WrapValue(TextEncoder::E_utf8));
    PyDict_SetItemString(dict, "EUtf8", Dtool_WrapValue(TextEncoder::E_utf8));
    PyDict_SetItemString(dict, "E_unicode", Dtool_WrapValue(TextEncoder::E_unicode));
    PyDict_SetItemString(dict, "EUnicode", Dtool_WrapValue(TextEncoder::E_unicode));
    if (PyType_Ready((PyTypeObject *)&Dtool_TextEncoder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TextEncoder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TextEncoder);
  }
}

/**
 * Python method tables for TypeHandle (TypeHandle)
 */
static PyMethodDef Dtool_Methods_TypeHandle[] = {
  {"make", &Dtool_TypeHandle_make_959, METH_O | METH_STATIC, (const char *)Dtool_TypeHandle_make_959_comment},
  {"compare_to", &Dtool_TypeHandle_compare_to_966, METH_O, (const char *)Dtool_TypeHandle_compare_to_966_comment},
  {"compareTo", &Dtool_TypeHandle_compare_to_966, METH_O, (const char *)Dtool_TypeHandle_compare_to_966_comment},
  {"get_hash", &Dtool_TypeHandle_get_hash_967, METH_NOARGS, (const char *)Dtool_TypeHandle_get_hash_967_comment},
  {"getHash", &Dtool_TypeHandle_get_hash_967, METH_NOARGS, (const char *)Dtool_TypeHandle_get_hash_967_comment},
  {"get_name", (PyCFunction) &Dtool_TypeHandle_get_name_968, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_name_968_comment},
  {"getName", (PyCFunction) &Dtool_TypeHandle_get_name_968, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_name_968_comment},
  {"is_derived_from", (PyCFunction) &Dtool_TypeHandle_is_derived_from_969, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_is_derived_from_969_comment},
  {"isDerivedFrom", (PyCFunction) &Dtool_TypeHandle_is_derived_from_969, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_is_derived_from_969_comment},
  {"get_num_parent_classes", (PyCFunction) &Dtool_TypeHandle_get_num_parent_classes_970, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_parent_classes_970_comment},
  {"getNumParentClasses", (PyCFunction) &Dtool_TypeHandle_get_num_parent_classes_970, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_parent_classes_970_comment},
  {"get_parent_class", &Dtool_TypeHandle_get_parent_class_971, METH_O, (const char *)Dtool_TypeHandle_get_parent_class_971_comment},
  {"getParentClass", &Dtool_TypeHandle_get_parent_class_971, METH_O, (const char *)Dtool_TypeHandle_get_parent_class_971_comment},
  {"get_num_child_classes", (PyCFunction) &Dtool_TypeHandle_get_num_child_classes_972, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_child_classes_972_comment},
  {"getNumChildClasses", (PyCFunction) &Dtool_TypeHandle_get_num_child_classes_972, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_num_child_classes_972_comment},
  {"get_child_class", &Dtool_TypeHandle_get_child_class_973, METH_O, (const char *)Dtool_TypeHandle_get_child_class_973_comment},
  {"getChildClass", &Dtool_TypeHandle_get_child_class_973, METH_O, (const char *)Dtool_TypeHandle_get_child_class_973_comment},
  {"get_parent_towards", (PyCFunction) &Dtool_TypeHandle_get_parent_towards_974, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_parent_towards_974_comment},
  {"getParentTowards", (PyCFunction) &Dtool_TypeHandle_get_parent_towards_974, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_get_parent_towards_974_comment},
  {"get_memory_usage", &Dtool_TypeHandle_get_memory_usage_976, METH_O, (const char *)Dtool_TypeHandle_get_memory_usage_976_comment},
  {"getMemoryUsage", &Dtool_TypeHandle_get_memory_usage_976, METH_O, (const char *)Dtool_TypeHandle_get_memory_usage_976_comment},
  {"inc_memory_usage", (PyCFunction) &Dtool_TypeHandle_inc_memory_usage_977, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_inc_memory_usage_977_comment},
  {"incMemoryUsage", (PyCFunction) &Dtool_TypeHandle_inc_memory_usage_977, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_inc_memory_usage_977_comment},
  {"dec_memory_usage", (PyCFunction) &Dtool_TypeHandle_dec_memory_usage_978, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_dec_memory_usage_978_comment},
  {"decMemoryUsage", (PyCFunction) &Dtool_TypeHandle_dec_memory_usage_978, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeHandle_dec_memory_usage_978_comment},
  {"get_index", &Dtool_TypeHandle_get_index_979, METH_NOARGS, (const char *)Dtool_TypeHandle_get_index_979_comment},
  {"getIndex", &Dtool_TypeHandle_get_index_979, METH_NOARGS, (const char *)Dtool_TypeHandle_get_index_979_comment},
  {"output", &Dtool_TypeHandle_output_980, METH_O, (const char *)Dtool_TypeHandle_output_980_comment},
  {"none", &Dtool_TypeHandle_none_981, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeHandle_none_981_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TypeHandle slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_TypeHandle_operator_typecast_bool_982_nb_bool(PyObject *self) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TypeHandle slot tp_compare -> compare_to
//////////////////
static int Dtool_TypeHandle_compare_to_966_tp_compare(PyObject *self, PyObject *arg) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int TypeHandle::compare_to(TypeHandle const &other) const
  TypeHandle arg_local;
  TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
  if (!(arg_this != NULL)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TypeHandle.compare_to", "TypeHandle");
    return -1;
  }
  int return_value = (*(const TypeHandle*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(TypeHandle self, const TypeHandle other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// TypeHandle slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_TypeHandle_get_hash_967_tp_hash(PyObject *self) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) (*local_this).get_hash();
}

//////////////////
//  A __repr__ function
//     TypeHandle
//////////////////
static PyObject *Dtool_Repr_TypeHandle(PyObject *self) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     TypeHandle
//////////////////
static PyObject *Dtool_RichCompare_TypeHandle(PyObject *self, PyObject *arg, int op) {
  TypeHandle *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeHandle, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool TypeHandle::operator ==(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const TypeHandle*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool TypeHandle::operator !=(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const TypeHandle*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool TypeHandle::operator <(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const TypeHandle*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LE:
    {
      // 1-inline bool TypeHandle::operator <=(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const TypeHandle*)local_this).operator <=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool TypeHandle::operator >(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const TypeHandle*)local_this).operator >(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GE:
    {
      // 1-inline bool TypeHandle::operator >=(TypeHandle const &other) const
      TypeHandle arg_local;
      TypeHandle const *arg_this = Dtool_Coerce_TypeHandle(arg, arg_local);
      if ((arg_this != NULL)) {
        bool return_value = (*(const TypeHandle*)local_this).operator >=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_TypeHandle_compare_to_966_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_TypeHandle[] = {
  {(char *)"index", &Dtool_TypeHandle_index_Getter, NULL, NULL, NULL},
  {(char *)"name", &Dtool_TypeHandle_name_Getter, NULL, NULL, NULL},
  {(char *)"parent_classes", &Dtool_TypeHandle_parent_classes_Getter, NULL, NULL, NULL},
  {(char *)"child_classes", &Dtool_TypeHandle_child_classes_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TypeHandle = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  &Dtool_TypeHandle_operator_typecast_bool_982_nb_bool,
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TypeHandle = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TypeHandle",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TypeHandle,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_TypeHandle_compare_to_966_tp_compare,
#endif
    &Dtool_Repr_TypeHandle,
    &Dtool_NumberMethods_TypeHandle,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &Dtool_TypeHandle_get_hash_967_tp_hash,
    0, // tp_call
    &Dtool_Repr_TypeHandle,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * TypeHandle is the identifier used to differentiate C++ class types.  Any\n"
    " * C++ classes that inherit from some base class, and must be differentiated\n"
    " * at run time, should store a static TypeHandle object that can be queried\n"
    " * through a static member function named get_class_type().  Most of the time,\n"
    " * it is also desirable to inherit from TypedObject, which provides some\n"
    " * virtual functions to return the TypeHandle for a particular instance.\n"
    " *\n"
    " * At its essence, a TypeHandle is simply a unique identifier that is assigned\n"
    " * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so\n"
    " * that ancestry of a particular type may be queried, and the type name may be\n"
    " * retrieved for run-time display.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_TypeHandle,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TypeHandle,
    0, // tp_members
    Dtool_Properties_TypeHandle,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TypeHandle,
    PyType_GenericAlloc,
    Dtool_new_TypeHandle,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypeHandle,
  Dtool_UpcastInterface_TypeHandle,
  Dtool_DowncastInterface_TypeHandle,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_TypeHandle,
};

static void Dtool_PyModuleClassInit_TypeHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypeHandle._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_TypeHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TypeHandle::MemoryClass;
    PyDict_SetItemString(dict, "MC_singleton", Dtool_WrapValue(TypeHandle::MC_singleton));
    PyDict_SetItemString(dict, "MCSingleton", Dtool_WrapValue(TypeHandle::MC_singleton));
    PyDict_SetItemString(dict, "MC_array", Dtool_WrapValue(TypeHandle::MC_array));
    PyDict_SetItemString(dict, "MCArray", Dtool_WrapValue(TypeHandle::MC_array));
    PyDict_SetItemString(dict, "MC_deleted_chain_active", Dtool_WrapValue(TypeHandle::MC_deleted_chain_active));
    PyDict_SetItemString(dict, "MCDeletedChainActive", Dtool_WrapValue(TypeHandle::MC_deleted_chain_active));
    PyDict_SetItemString(dict, "MC_deleted_chain_inactive", Dtool_WrapValue(TypeHandle::MC_deleted_chain_inactive));
    PyDict_SetItemString(dict, "MCDeletedChainInactive", Dtool_WrapValue(TypeHandle::MC_deleted_chain_inactive));
    PyDict_SetItemString(dict, "MC_limit", Dtool_WrapValue(TypeHandle::MC_limit));
    PyDict_SetItemString(dict, "MCLimit", Dtool_WrapValue(TypeHandle::MC_limit));
    if (PyType_Ready((PyTypeObject *)&Dtool_TypeHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypeHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypeHandle);
  }
}

/**
 * Python method tables for TypeRegistry (TypeRegistry)
 */
static PyMethodDef Dtool_Methods_TypeRegistry[] = {
  {"register_dynamic_type", &Dtool_TypeRegistry_register_dynamic_type_990, METH_O, (const char *)Dtool_TypeRegistry_register_dynamic_type_990_comment},
  {"registerDynamicType", &Dtool_TypeRegistry_register_dynamic_type_990, METH_O, (const char *)Dtool_TypeRegistry_register_dynamic_type_990_comment},
  {"record_derivation", (PyCFunction) &Dtool_TypeRegistry_record_derivation_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_derivation_991_comment},
  {"recordDerivation", (PyCFunction) &Dtool_TypeRegistry_record_derivation_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_derivation_991_comment},
  {"record_alternate_name", (PyCFunction) &Dtool_TypeRegistry_record_alternate_name_992, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_alternate_name_992_comment},
  {"recordAlternateName", (PyCFunction) &Dtool_TypeRegistry_record_alternate_name_992, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_record_alternate_name_992_comment},
  {"find_type", &Dtool_TypeRegistry_find_type_993, METH_O, (const char *)Dtool_TypeRegistry_find_type_993_comment},
  {"findType", &Dtool_TypeRegistry_find_type_993, METH_O, (const char *)Dtool_TypeRegistry_find_type_993_comment},
  {"find_type_by_id", &Dtool_TypeRegistry_find_type_by_id_994, METH_O, (const char *)Dtool_TypeRegistry_find_type_by_id_994_comment},
  {"findTypeById", &Dtool_TypeRegistry_find_type_by_id_994, METH_O, (const char *)Dtool_TypeRegistry_find_type_by_id_994_comment},
  {"get_name", (PyCFunction) &Dtool_TypeRegistry_get_name_995, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_name_995_comment},
  {"getName", (PyCFunction) &Dtool_TypeRegistry_get_name_995, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_name_995_comment},
  {"is_derived_from", (PyCFunction) &Dtool_TypeRegistry_is_derived_from_996, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_is_derived_from_996_comment},
  {"isDerivedFrom", (PyCFunction) &Dtool_TypeRegistry_is_derived_from_996, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_is_derived_from_996_comment},
  {"get_num_typehandles", &Dtool_TypeRegistry_get_num_typehandles_997, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_typehandles_997_comment},
  {"getNumTypehandles", &Dtool_TypeRegistry_get_num_typehandles_997, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_typehandles_997_comment},
  {"get_typehandle", &Dtool_TypeRegistry_get_typehandle_998, METH_O, (const char *)Dtool_TypeRegistry_get_typehandle_998_comment},
  {"getTypehandle", &Dtool_TypeRegistry_get_typehandle_998, METH_O, (const char *)Dtool_TypeRegistry_get_typehandle_998_comment},
  {"get_num_root_classes", &Dtool_TypeRegistry_get_num_root_classes_1000, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_root_classes_1000_comment},
  {"getNumRootClasses", &Dtool_TypeRegistry_get_num_root_classes_1000, METH_NOARGS, (const char *)Dtool_TypeRegistry_get_num_root_classes_1000_comment},
  {"get_root_class", &Dtool_TypeRegistry_get_root_class_1001, METH_O, (const char *)Dtool_TypeRegistry_get_root_class_1001_comment},
  {"getRootClass", &Dtool_TypeRegistry_get_root_class_1001, METH_O, (const char *)Dtool_TypeRegistry_get_root_class_1001_comment},
  {"get_num_parent_classes", (PyCFunction) &Dtool_TypeRegistry_get_num_parent_classes_1003, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_parent_classes_1003_comment},
  {"getNumParentClasses", (PyCFunction) &Dtool_TypeRegistry_get_num_parent_classes_1003, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_parent_classes_1003_comment},
  {"get_parent_class", (PyCFunction) &Dtool_TypeRegistry_get_parent_class_1004, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_class_1004_comment},
  {"getParentClass", (PyCFunction) &Dtool_TypeRegistry_get_parent_class_1004, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_class_1004_comment},
  {"get_num_child_classes", (PyCFunction) &Dtool_TypeRegistry_get_num_child_classes_1005, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_child_classes_1005_comment},
  {"getNumChildClasses", (PyCFunction) &Dtool_TypeRegistry_get_num_child_classes_1005, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_num_child_classes_1005_comment},
  {"get_child_class", (PyCFunction) &Dtool_TypeRegistry_get_child_class_1006, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_child_class_1006_comment},
  {"getChildClass", (PyCFunction) &Dtool_TypeRegistry_get_child_class_1006, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_child_class_1006_comment},
  {"get_parent_towards", (PyCFunction) &Dtool_TypeRegistry_get_parent_towards_1007, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_towards_1007_comment},
  {"getParentTowards", (PyCFunction) &Dtool_TypeRegistry_get_parent_towards_1007, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypeRegistry_get_parent_towards_1007_comment},
  {"reregister_types", &Dtool_TypeRegistry_reregister_types_1008, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeRegistry_reregister_types_1008_comment},
  {"reregisterTypes", &Dtool_TypeRegistry_reregister_types_1008, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeRegistry_reregister_types_1008_comment},
  {"write", &Dtool_TypeRegistry_write_1009, METH_O, (const char *)Dtool_TypeRegistry_write_1009_comment},
  {"ptr", &Dtool_TypeRegistry_ptr_1010, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypeRegistry_ptr_1010_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_typehandles", (PyCFunction) &MakeSeq_TypeRegistry_get_typehandles, METH_NOARGS, NULL},
  { "getTypehandles", (PyCFunction) &MakeSeq_TypeRegistry_get_typehandles, METH_NOARGS, NULL},
  {"get_root_classes", (PyCFunction) &MakeSeq_TypeRegistry_get_root_classes, METH_NOARGS, NULL},
  { "getRootClasses", (PyCFunction) &MakeSeq_TypeRegistry_get_root_classes, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     TypeRegistry
//////////////////
static PyObject *Dtool_Str_TypeRegistry(PyObject *self) {
  TypeRegistry *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TypeRegistry, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_TypeRegistry[] = {
  {(char *)"typehandles", &Dtool_TypeRegistry_typehandles_Getter, NULL, NULL, NULL},
  {(char *)"root_classes", &Dtool_TypeRegistry_root_classes_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TypeRegistry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypeRegistry = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TypeRegistry = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TypeRegistry = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TypeRegistry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TypeRegistry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TypeRegistry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TypeRegistry,
    &Dtool_SequenceMethods_TypeRegistry,
    &Dtool_MappingMethods_TypeRegistry,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_TypeRegistry,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TypeRegistry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The TypeRegistry class maintains all the assigned TypeHandles in a given\n"
    " * system.  There should be only one TypeRegistry class during the lifetime of\n"
    " * the application.  It will be created on the local heap initially, and it\n"
    " * should be migrated to shared memory as soon as shared memory becomes\n"
    " * available.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TypeRegistry,
    0, // tp_members
    Dtool_Properties_TypeRegistry,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TypeRegistry,
    PyType_GenericAlloc,
    Dtool_new_TypeRegistry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypeRegistry,
  Dtool_UpcastInterface_TypeRegistry,
  Dtool_DowncastInterface_TypeRegistry,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TypeRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypeRegistry._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TypeRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypeRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypeRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypeRegistry);
  }
}

/**
 * Python method tables for TypedObject (TypedObject)
 */
static PyMethodDef Dtool_Methods_TypedObject[] = {
  {"get_type", &Dtool_TypedObject_get_type_1019, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_1019_comment},
  {"getType", &Dtool_TypedObject_get_type_1019, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_1019_comment},
  {"get_type_index", &Dtool_TypedObject_get_type_index_1021, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_index_1021_comment},
  {"getTypeIndex", &Dtool_TypedObject_get_type_index_1021, METH_NOARGS, (const char *)Dtool_TypedObject_get_type_index_1021_comment},
  {"is_of_type", &Dtool_TypedObject_is_of_type_1022, METH_O, (const char *)Dtool_TypedObject_is_of_type_1022_comment},
  {"isOfType", &Dtool_TypedObject_is_of_type_1022, METH_O, (const char *)Dtool_TypedObject_is_of_type_1022_comment},
  {"is_exact_type", &Dtool_TypedObject_is_exact_type_1023, METH_O, (const char *)Dtool_TypedObject_is_exact_type_1023_comment},
  {"isExactType", &Dtool_TypedObject_is_exact_type_1023, METH_O, (const char *)Dtool_TypedObject_is_exact_type_1023_comment},
  {"get_class_type", &Dtool_TypedObject_get_class_type_1024, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedObject_get_class_type_1024_comment},
  {"getClassType", &Dtool_TypedObject_get_class_type_1024, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedObject_get_class_type_1024_comment},
  {"downcast_to_TypedReferenceCount", &Dtool_TypedObject_downcast_to_TypedReferenceCount_1209, METH_NOARGS, (const char *)Dtool_TypedObject_downcast_to_TypedReferenceCount_1209_comment},
  {"downcastToTypedReferenceCount", &Dtool_TypedObject_downcast_to_TypedReferenceCount_1209, METH_NOARGS, (const char *)Dtool_TypedObject_downcast_to_TypedReferenceCount_1209_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_TypedObject[] = {
  {(char *)"type", &Dtool_TypedObject_type_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TypedObject = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedObject = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TypedObject = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TypedObject = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TypedObject = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TypedObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedObject,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TypedObject,
    &Dtool_SequenceMethods_TypedObject,
    &Dtool_MappingMethods_TypedObject,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TypedObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract class that all classes which use TypeHandle, and also\n"
    " * provide virtual functions to support polymorphism, should inherit from.\n"
    " * Each derived class should define get_type(), which should return the\n"
    " * specific type of the derived class.  Inheriting from this automatically\n"
    " * provides support for is_of_type() and is_exact_type().\n"
    " *\n"
    " * All classes that inherit directly or indirectly from TypedObject should\n"
    " * redefine get_type() and force_init_type(), as shown below.  Some classes\n"
    " * that do not inherit from TypedObject may still declare TypeHandles for\n"
    " * themselves by defining methods called get_class_type() and init_type().\n"
    " * Classes such as these may serve as base classes, but the dynamic type\n"
    " * identification system will be limited.  Classes that do not inherit from\n"
    " * TypedObject need not define the virtual functions get_type() and\n"
    " * force_init_type() (or any other virtual functions).\n"
    " *\n"
    " * There is a specific layout for defining the overrides from this class.\n"
    " * Keeping the definitions formatted just like these examples will allow\n"
    " * someone in the future to use a sed (or similar) script to make global\n"
    " * changes, if necessary.  Avoid rearranging the braces or the order of the\n"
    " * functions unless you're ready to change them in every file all at once.\n"
    " *\n"
    " * What follows are some examples that can be used in new classes that you\n"
    " * create.\n"
    " *\n"
    " * @par In the class definition (.h file): @code public: static TypeHandle\n"
    " * get_class_type() { return _type_handle; } static void init_type() {\n"
    " * <<<BaseClassOne>>>::init_type(); <<<BaseClassTwo>>>::init_type();\n"
    " * <<<BaseClassN>>>::init_type(); register_type(_type_handle,\n"
    " * \"<<<ThisClassStringName>>>\", <<<BaseClassOne>>>::get_class_type(),\n"
    " * <<<BaseClassTwo>>>::get_class_type(), <<<BaseClassN>>>::get_class_type());\n"
    " * } virtual TypeHandle get_type() const { return get_class_type(); } virtual\n"
    " * TypeHandle force_init_type() {init_type(); return get_class_type();}\n"
    " *\n"
    " * private: static TypeHandle _type_handle; @endcode\n"
    " *\n"
    " * @par In the class .cxx file: @code TypeHandle\n"
    " * <<<ThisClassStringName>>>::_type_handle; @endcode\n"
    " *\n"
    " * @par In the class config_<<<PackageName>>>.cxx file: @code\n"
    " * ConfigureFn(config_<<<PackageName>>>) { <<<ClassOne>>>::init_type();\n"
    " * <<<ClassTwo>>>::init_type(); <<<ClassN>>>::init_type(); } @endcode\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TypedObject,
    0, // tp_members
    Dtool_Properties_TypedObject,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TypedObject,
    PyType_GenericAlloc,
    Dtool_new_TypedObject,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedObject,
  Dtool_UpcastInterface_TypedObject,
  Dtool_DowncastInterface_TypedObject,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TypedObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TypedObject._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TypedObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedObject);
  }
}

/**
 * Python method tables for fstream (fstream)
 */
static PyMethodDef Dtool_Methods_fstream[] = {
  {"close", &Dtool_fstream_close_1027, METH_NOARGS, (const char *)Dtool_fstream_close_1027_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_fstream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_fstream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_fstream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_fstream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_fstream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.fstream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_fstream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_fstream,
    &Dtool_SequenceMethods_fstream,
    &Dtool_MappingMethods_fstream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_fstream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_fstream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_fstream,
    PyType_GenericAlloc,
    Dtool_new_fstream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_fstream,
  Dtool_UpcastInterface_fstream,
  Dtool_DowncastInterface_fstream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_fstream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_iostream(NULL);
    Dtool_fstream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_iostream);
    PyObject *dict = PyDict_New();
    Dtool_fstream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_fstream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(fstream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_fstream);
  }
}

/**
 * Python method tables for ifstream (ifstream)
 */
static PyMethodDef Dtool_Methods_ifstream[] = {
  {"close", &Dtool_ifstream_close_1031, METH_NOARGS, (const char *)Dtool_ifstream_close_1031_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ifstream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ifstream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ifstream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ifstream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ifstream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ifstream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ifstream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ifstream,
    &Dtool_SequenceMethods_ifstream,
    &Dtool_MappingMethods_ifstream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ifstream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ifstream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ifstream,
    PyType_GenericAlloc,
    Dtool_new_ifstream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ifstream,
  Dtool_UpcastInterface_ifstream,
  Dtool_DowncastInterface_ifstream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ifstream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_istream(NULL);
    Dtool_ifstream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_istream);
    PyObject *dict = PyDict_New();
    Dtool_ifstream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ifstream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ifstream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ifstream);
  }
}

/**
 * Python method tables for ofstream (ofstream)
 */
static PyMethodDef Dtool_Methods_ofstream[] = {
  {"close", &Dtool_ofstream_close_1035, METH_NOARGS, (const char *)Dtool_ofstream_close_1035_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ofstream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ofstream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ofstream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ofstream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ofstream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ofstream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ofstream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ofstream,
    &Dtool_SequenceMethods_ofstream,
    &Dtool_MappingMethods_ofstream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ofstream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ofstream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ofstream,
    PyType_GenericAlloc,
    Dtool_new_ofstream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ofstream,
  Dtool_UpcastInterface_ofstream,
  Dtool_DowncastInterface_ofstream,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ofstream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_ofstream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_ofstream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ofstream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ofstream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ofstream);
  }
}

/**
 * Python method tables for MemoryUsage (MemoryUsage)
 */
static PyMethodDef Dtool_Methods_MemoryUsage[] = {
  {"is_tracking", &Dtool_MemoryUsage_is_tracking_1039, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_tracking_1039_comment},
  {"isTracking", &Dtool_MemoryUsage_is_tracking_1039, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_tracking_1039_comment},
  {"is_counting", &Dtool_MemoryUsage_is_counting_1040, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_counting_1040_comment},
  {"isCounting", &Dtool_MemoryUsage_is_counting_1040, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_counting_1040_comment},
  {"get_current_cpp_size", &Dtool_MemoryUsage_get_current_cpp_size_1041, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_current_cpp_size_1041_comment},
  {"getCurrentCppSize", &Dtool_MemoryUsage_get_current_cpp_size_1041, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_current_cpp_size_1041_comment},
  {"get_total_cpp_size", &Dtool_MemoryUsage_get_total_cpp_size_1042, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_cpp_size_1042_comment},
  {"getTotalCppSize", &Dtool_MemoryUsage_get_total_cpp_size_1042, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_cpp_size_1042_comment},
  {"get_panda_heap_single_size", &Dtool_MemoryUsage_get_panda_heap_single_size_1043, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_single_size_1043_comment},
  {"getPandaHeapSingleSize", &Dtool_MemoryUsage_get_panda_heap_single_size_1043, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_single_size_1043_comment},
  {"get_panda_heap_array_size", &Dtool_MemoryUsage_get_panda_heap_array_size_1044, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_array_size_1044_comment},
  {"getPandaHeapArraySize", &Dtool_MemoryUsage_get_panda_heap_array_size_1044, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_array_size_1044_comment},
  {"get_panda_heap_overhead", &Dtool_MemoryUsage_get_panda_heap_overhead_1045, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_overhead_1045_comment},
  {"getPandaHeapOverhead", &Dtool_MemoryUsage_get_panda_heap_overhead_1045, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_overhead_1045_comment},
  {"get_panda_mmap_size", &Dtool_MemoryUsage_get_panda_mmap_size_1046, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_mmap_size_1046_comment},
  {"getPandaMmapSize", &Dtool_MemoryUsage_get_panda_mmap_size_1046, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_mmap_size_1046_comment},
  {"get_external_size", &Dtool_MemoryUsage_get_external_size_1047, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_external_size_1047_comment},
  {"getExternalSize", &Dtool_MemoryUsage_get_external_size_1047, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_external_size_1047_comment},
  {"get_total_size", &Dtool_MemoryUsage_get_total_size_1048, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_size_1048_comment},
  {"getTotalSize", &Dtool_MemoryUsage_get_total_size_1048, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_size_1048_comment},
  {"get_num_pointers", &Dtool_MemoryUsage_get_num_pointers_1049, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_num_pointers_1049_comment},
  {"getNumPointers", &Dtool_MemoryUsage_get_num_pointers_1049, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_num_pointers_1049_comment},
  {"get_pointers", &Dtool_MemoryUsage_get_pointers_1050, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_1050_comment},
  {"getPointers", &Dtool_MemoryUsage_get_pointers_1050, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_1050_comment},
  {"get_pointers_of_type", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_type_1051, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_type_1051_comment},
  {"getPointersOfType", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_type_1051, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_type_1051_comment},
  {"get_pointers_of_age", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_age_1052, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_age_1052_comment},
  {"getPointersOfAge", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_age_1052, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_age_1052_comment},
  {"get_pointers_with_zero_count", &Dtool_MemoryUsage_get_pointers_with_zero_count_1053, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_with_zero_count_1053_comment},
  {"getPointersWithZeroCount", &Dtool_MemoryUsage_get_pointers_with_zero_count_1053, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_with_zero_count_1053_comment},
  {"freeze", &Dtool_MemoryUsage_freeze_1054, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_freeze_1054_comment},
  {"show_current_types", &Dtool_MemoryUsage_show_current_types_1055, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_types_1055_comment},
  {"showCurrentTypes", &Dtool_MemoryUsage_show_current_types_1055, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_types_1055_comment},
  {"show_trend_types", &Dtool_MemoryUsage_show_trend_types_1056, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_types_1056_comment},
  {"showTrendTypes", &Dtool_MemoryUsage_show_trend_types_1056, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_types_1056_comment},
  {"show_current_ages", &Dtool_MemoryUsage_show_current_ages_1057, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_ages_1057_comment},
  {"showCurrentAges", &Dtool_MemoryUsage_show_current_ages_1057, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_ages_1057_comment},
  {"show_trend_ages", &Dtool_MemoryUsage_show_trend_ages_1058, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_ages_1058_comment},
  {"showTrendAges", &Dtool_MemoryUsage_show_trend_ages_1058, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_ages_1058_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_MemoryUsage = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MemoryUsage = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_MemoryUsage = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_MemoryUsage = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_MemoryUsage = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MemoryUsage",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MemoryUsage,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_MemoryUsage,
    &Dtool_SequenceMethods_MemoryUsage,
    &Dtool_MappingMethods_MemoryUsage,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_MemoryUsage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used strictly for debugging purposes, specifically for\n"
    " * tracking memory leaks of reference-counted objects: it keeps a record of\n"
    " * every such object currently allocated.\n"
    " *\n"
    " * When compiled with NDEBUG set, this entire class does nothing and compiles\n"
    " * to nothing.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MemoryUsage,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MemoryUsage,
    PyType_GenericAlloc,
    Dtool_new_MemoryUsage,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MemoryUsage,
  Dtool_UpcastInterface_MemoryUsage,
  Dtool_DowncastInterface_MemoryUsage,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MemoryUsage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MemoryUsage._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MemoryUsage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MemoryUsage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MemoryUsage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MemoryUsage);
  }
}

/**
 * Python method tables for ReferenceCount (ReferenceCount)
 */
static PyMethodDef Dtool_Methods_ReferenceCount[] = {
  {"get_ref_count", &Dtool_ReferenceCount_get_ref_count_1065, METH_NOARGS, (const char *)Dtool_ReferenceCount_get_ref_count_1065_comment},
  {"getRefCount", &Dtool_ReferenceCount_get_ref_count_1065, METH_NOARGS, (const char *)Dtool_ReferenceCount_get_ref_count_1065_comment},
  {"ref", &Dtool_ReferenceCount_ref_1066, METH_NOARGS, (const char *)Dtool_ReferenceCount_ref_1066_comment},
  {"unref", &Dtool_ReferenceCount_unref_1067, METH_NOARGS, (const char *)Dtool_ReferenceCount_unref_1067_comment},
  {"test_ref_count_integrity", &Dtool_ReferenceCount_test_ref_count_integrity_1069, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_integrity_1069_comment},
  {"testRefCountIntegrity", &Dtool_ReferenceCount_test_ref_count_integrity_1069, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_integrity_1069_comment},
  {"test_ref_count_nonzero", &Dtool_ReferenceCount_test_ref_count_nonzero_1070, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_nonzero_1070_comment},
  {"testRefCountNonzero", &Dtool_ReferenceCount_test_ref_count_nonzero_1070, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_nonzero_1070_comment},
  {"get_class_type", &Dtool_ReferenceCount_get_class_type_1071, METH_NOARGS | METH_STATIC, (const char *)Dtool_ReferenceCount_get_class_type_1071_comment},
  {"getClassType", &Dtool_ReferenceCount_get_class_type_1071, METH_NOARGS | METH_STATIC, (const char *)Dtool_ReferenceCount_get_class_type_1071_comment},
  {"downcast_to_TypedReferenceCount", &Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211, METH_NOARGS, (const char *)Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211_comment},
  {"downcastToTypedReferenceCount", &Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211, METH_NOARGS, (const char *)Dtool_ReferenceCount_downcast_to_TypedReferenceCount_1211_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_ReferenceCount[] = {
  {(char *)"ref_count", &Dtool_ReferenceCount_ref_count_Getter, NULL, (char *)
    "// The current reference count.",
    NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_ReferenceCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ReferenceCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ReferenceCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ReferenceCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ReferenceCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ReferenceCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ReferenceCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ReferenceCount,
    &Dtool_SequenceMethods_ReferenceCount,
    &Dtool_MappingMethods_ReferenceCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for all things that want to be reference-counted.\n"
    " * ReferenceCount works in conjunction with PointerTo to automatically delete\n"
    " * objects when the last pointer to them goes away.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ReferenceCount,
    0, // tp_members
    Dtool_Properties_ReferenceCount,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_ReferenceCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ReferenceCount,
  Dtool_UpcastInterface_ReferenceCount,
  Dtool_DowncastInterface_ReferenceCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_ReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ReferenceCount);
  }
}

/**
 * Python method tables for Buffer (Buffer)
 */
static PyMethodDef Dtool_Methods_Buffer[] = {
  {"get_length", &Dtool_Buffer_get_length_1073, METH_NOARGS, (const char *)Dtool_Buffer_get_length_1073_comment},
  {"getLength", &Dtool_Buffer_get_length_1073, METH_NOARGS, (const char *)Dtool_Buffer_get_length_1073_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Buffer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Buffer = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Buffer = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Buffer = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Buffer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Buffer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Buffer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Buffer,
    &Dtool_SequenceMethods_Buffer,
    &Dtool_MappingMethods_Buffer,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Buffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Buffer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Buffer,
    PyType_GenericAlloc,
    Dtool_new_Buffer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Buffer,
  Dtool_UpcastInterface_Buffer,
  Dtool_DowncastInterface_Buffer,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Buffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(NULL);
    Dtool_Buffer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_Buffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Buffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Buffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Buffer);
  }
}

/**
 * Python method tables for PStatCollectorForwardBase (PStatCollectorForwardBase)
 */
static PyMethodDef Dtool_Methods_PStatCollectorForwardBase[] = {
  {"add_level", &Dtool_PStatCollectorForwardBase_add_level_1083, METH_O, (const char *)Dtool_PStatCollectorForwardBase_add_level_1083_comment},
  {"addLevel", &Dtool_PStatCollectorForwardBase_add_level_1083, METH_O, (const char *)Dtool_PStatCollectorForwardBase_add_level_1083_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PStatCollectorForwardBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PStatCollectorForwardBase = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PStatCollectorForwardBase = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PStatCollectorForwardBase = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PStatCollectorForwardBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PStatCollectorForwardBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PStatCollectorForwardBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PStatCollectorForwardBase,
    &Dtool_SequenceMethods_PStatCollectorForwardBase,
    &Dtool_MappingMethods_PStatCollectorForwardBase,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PStatCollectorForwardBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class serves as a cheap forward reference to a PStatCollector, which\n"
    " * is defined in the pstatclient module (and is not directly accessible here\n"
    " * in the express module).\n"
    " *\n"
    " * This is subclassed as PStatCollectorForward, which defines the actual\n"
    " * functionality.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PStatCollectorForwardBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PStatCollectorForwardBase,
    PyType_GenericAlloc,
    Dtool_new_PStatCollectorForwardBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PStatCollectorForwardBase,
  Dtool_UpcastInterface_PStatCollectorForwardBase,
  Dtool_DowncastInterface_PStatCollectorForwardBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PStatCollectorForwardBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(NULL);
    Dtool_PStatCollectorForwardBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_PStatCollectorForwardBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PStatCollectorForwardBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PStatCollectorForwardBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PStatCollectorForwardBase);
  }
}

/**
 * Python method tables for NodeReferenceCount (NodeReferenceCount)
 */
static PyMethodDef Dtool_Methods_NodeReferenceCount[] = {
  {"get_node_ref_count", &Dtool_NodeReferenceCount_get_node_ref_count_1085, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_get_node_ref_count_1085_comment},
  {"getNodeRefCount", &Dtool_NodeReferenceCount_get_node_ref_count_1085, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_get_node_ref_count_1085_comment},
  {"node_ref", &Dtool_NodeReferenceCount_node_ref_1086, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_ref_1086_comment},
  {"nodeRef", &Dtool_NodeReferenceCount_node_ref_1086, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_ref_1086_comment},
  {"node_unref", &Dtool_NodeReferenceCount_node_unref_1087, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_unref_1087_comment},
  {"nodeUnref", &Dtool_NodeReferenceCount_node_unref_1087, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_unref_1087_comment},
  {"test_ref_count_integrity", &Dtool_NodeReferenceCount_test_ref_count_integrity_1088, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_test_ref_count_integrity_1088_comment},
  {"testRefCountIntegrity", &Dtool_NodeReferenceCount_test_ref_count_integrity_1088, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_test_ref_count_integrity_1088_comment},
  {"get_class_type", &Dtool_NodeReferenceCount_get_class_type_1089, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeReferenceCount_get_class_type_1089_comment},
  {"getClassType", &Dtool_NodeReferenceCount_get_class_type_1089, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeReferenceCount_get_class_type_1089_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_NodeReferenceCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeReferenceCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_NodeReferenceCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_NodeReferenceCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_NodeReferenceCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.NodeReferenceCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeReferenceCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_NodeReferenceCount,
    &Dtool_SequenceMethods_NodeReferenceCount,
    &Dtool_MappingMethods_NodeReferenceCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_NodeReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class specializes ReferenceCount to add an additional counter, called\n"
    " * node_ref_count, for the purposes of counting the number of times the object\n"
    " * is referenced by a \"node\", whatever that may mean in context.\n"
    " *\n"
    " * The new methods node_ref() and node_unref() automatically increment and\n"
    " * decrement the primary reference count as well.  There also exists a\n"
    " * NodePointerTo<> class to maintain the node_ref counters automatically.\n"
    " *\n"
    " * See also CachedTypedWritableReferenceCount, which is similar in principle,\n"
    " * as well as NodeCachedReferenceCount, which combines both of these.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_NodeReferenceCount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_NodeReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_NodeReferenceCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeReferenceCount,
  Dtool_UpcastInterface_NodeReferenceCount,
  Dtool_DowncastInterface_NodeReferenceCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_NodeReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(NULL);
    Dtool_NodeReferenceCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_NodeReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeReferenceCount);
  }
}

/**
 * Python method tables for Datagram (Datagram)
 */
static PyMethodDef Dtool_Methods_Datagram[] = {
  {"assign", &Dtool_Datagram_operator_1092, METH_O, (const char *)Dtool_Datagram_operator_1092_comment},
  {"clear", &Dtool_Datagram_clear_1093, METH_NOARGS, (const char *)Dtool_Datagram_clear_1093_comment},
  {"dump_hex", (PyCFunction) &Dtool_Datagram_dump_hex_1094, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_dump_hex_1094_comment},
  {"dumpHex", (PyCFunction) &Dtool_Datagram_dump_hex_1094, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_dump_hex_1094_comment},
  {"add_bool", &Dtool_Datagram_add_bool_1095, METH_O, (const char *)Dtool_Datagram_add_bool_1095_comment},
  {"addBool", &Dtool_Datagram_add_bool_1095, METH_O, (const char *)Dtool_Datagram_add_bool_1095_comment},
  {"add_int8", &Dtool_Datagram_add_int8_1096, METH_O, (const char *)Dtool_Datagram_add_int8_1096_comment},
  {"addInt8", &Dtool_Datagram_add_int8_1096, METH_O, (const char *)Dtool_Datagram_add_int8_1096_comment},
  {"add_uint8", &Dtool_Datagram_add_uint8_1097, METH_O, (const char *)Dtool_Datagram_add_uint8_1097_comment},
  {"addUint8", &Dtool_Datagram_add_uint8_1097, METH_O, (const char *)Dtool_Datagram_add_uint8_1097_comment},
  {"add_int16", &Dtool_Datagram_add_int16_1098, METH_O, (const char *)Dtool_Datagram_add_int16_1098_comment},
  {"addInt16", &Dtool_Datagram_add_int16_1098, METH_O, (const char *)Dtool_Datagram_add_int16_1098_comment},
  {"add_int32", &Dtool_Datagram_add_int32_1099, METH_O, (const char *)Dtool_Datagram_add_int32_1099_comment},
  {"addInt32", &Dtool_Datagram_add_int32_1099, METH_O, (const char *)Dtool_Datagram_add_int32_1099_comment},
  {"add_int64", &Dtool_Datagram_add_int64_1100, METH_O, (const char *)Dtool_Datagram_add_int64_1100_comment},
  {"addInt64", &Dtool_Datagram_add_int64_1100, METH_O, (const char *)Dtool_Datagram_add_int64_1100_comment},
  {"add_uint16", &Dtool_Datagram_add_uint16_1101, METH_O, (const char *)Dtool_Datagram_add_uint16_1101_comment},
  {"addUint16", &Dtool_Datagram_add_uint16_1101, METH_O, (const char *)Dtool_Datagram_add_uint16_1101_comment},
  {"add_uint32", &Dtool_Datagram_add_uint32_1102, METH_O, (const char *)Dtool_Datagram_add_uint32_1102_comment},
  {"addUint32", &Dtool_Datagram_add_uint32_1102, METH_O, (const char *)Dtool_Datagram_add_uint32_1102_comment},
  {"add_uint64", &Dtool_Datagram_add_uint64_1103, METH_O, (const char *)Dtool_Datagram_add_uint64_1103_comment},
  {"addUint64", &Dtool_Datagram_add_uint64_1103, METH_O, (const char *)Dtool_Datagram_add_uint64_1103_comment},
  {"add_float32", &Dtool_Datagram_add_float32_1104, METH_O, (const char *)Dtool_Datagram_add_float32_1104_comment},
  {"addFloat32", &Dtool_Datagram_add_float32_1104, METH_O, (const char *)Dtool_Datagram_add_float32_1104_comment},
  {"add_float64", &Dtool_Datagram_add_float64_1105, METH_O, (const char *)Dtool_Datagram_add_float64_1105_comment},
  {"addFloat64", &Dtool_Datagram_add_float64_1105, METH_O, (const char *)Dtool_Datagram_add_float64_1105_comment},
  {"add_stdfloat", &Dtool_Datagram_add_stdfloat_1106, METH_O, (const char *)Dtool_Datagram_add_stdfloat_1106_comment},
  {"addStdfloat", &Dtool_Datagram_add_stdfloat_1106, METH_O, (const char *)Dtool_Datagram_add_stdfloat_1106_comment},
  {"add_be_int16", &Dtool_Datagram_add_be_int16_1107, METH_O, (const char *)Dtool_Datagram_add_be_int16_1107_comment},
  {"addBeInt16", &Dtool_Datagram_add_be_int16_1107, METH_O, (const char *)Dtool_Datagram_add_be_int16_1107_comment},
  {"add_be_int32", &Dtool_Datagram_add_be_int32_1108, METH_O, (const char *)Dtool_Datagram_add_be_int32_1108_comment},
  {"addBeInt32", &Dtool_Datagram_add_be_int32_1108, METH_O, (const char *)Dtool_Datagram_add_be_int32_1108_comment},
  {"add_be_int64", &Dtool_Datagram_add_be_int64_1109, METH_O, (const char *)Dtool_Datagram_add_be_int64_1109_comment},
  {"addBeInt64", &Dtool_Datagram_add_be_int64_1109, METH_O, (const char *)Dtool_Datagram_add_be_int64_1109_comment},
  {"add_be_uint16", &Dtool_Datagram_add_be_uint16_1110, METH_O, (const char *)Dtool_Datagram_add_be_uint16_1110_comment},
  {"addBeUint16", &Dtool_Datagram_add_be_uint16_1110, METH_O, (const char *)Dtool_Datagram_add_be_uint16_1110_comment},
  {"add_be_uint32", &Dtool_Datagram_add_be_uint32_1111, METH_O, (const char *)Dtool_Datagram_add_be_uint32_1111_comment},
  {"addBeUint32", &Dtool_Datagram_add_be_uint32_1111, METH_O, (const char *)Dtool_Datagram_add_be_uint32_1111_comment},
  {"add_be_uint64", &Dtool_Datagram_add_be_uint64_1112, METH_O, (const char *)Dtool_Datagram_add_be_uint64_1112_comment},
  {"addBeUint64", &Dtool_Datagram_add_be_uint64_1112, METH_O, (const char *)Dtool_Datagram_add_be_uint64_1112_comment},
  {"add_be_float32", &Dtool_Datagram_add_be_float32_1113, METH_O, (const char *)Dtool_Datagram_add_be_float32_1113_comment},
  {"addBeFloat32", &Dtool_Datagram_add_be_float32_1113, METH_O, (const char *)Dtool_Datagram_add_be_float32_1113_comment},
  {"add_be_float64", &Dtool_Datagram_add_be_float64_1114, METH_O, (const char *)Dtool_Datagram_add_be_float64_1114_comment},
  {"addBeFloat64", &Dtool_Datagram_add_be_float64_1114, METH_O, (const char *)Dtool_Datagram_add_be_float64_1114_comment},
  {"add_string", &Dtool_Datagram_add_string_1115, METH_O, (const char *)Dtool_Datagram_add_string_1115_comment},
  {"addString", &Dtool_Datagram_add_string_1115, METH_O, (const char *)Dtool_Datagram_add_string_1115_comment},
  {"add_string32", &Dtool_Datagram_add_string32_1116, METH_O, (const char *)Dtool_Datagram_add_string32_1116_comment},
  {"addString32", &Dtool_Datagram_add_string32_1116, METH_O, (const char *)Dtool_Datagram_add_string32_1116_comment},
  {"add_z_string", &Dtool_Datagram_add_z_string_1117, METH_O, (const char *)Dtool_Datagram_add_z_string_1117_comment},
  {"addZString", &Dtool_Datagram_add_z_string_1117, METH_O, (const char *)Dtool_Datagram_add_z_string_1117_comment},
  {"add_fixed_string", (PyCFunction) &Dtool_Datagram_add_fixed_string_1118, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_add_fixed_string_1118_comment},
  {"addFixedString", (PyCFunction) &Dtool_Datagram_add_fixed_string_1118, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_add_fixed_string_1118_comment},
  {"add_wstring", &Dtool_Datagram_add_wstring_1119, METH_O, (const char *)Dtool_Datagram_add_wstring_1119_comment},
  {"addWstring", &Dtool_Datagram_add_wstring_1119, METH_O, (const char *)Dtool_Datagram_add_wstring_1119_comment},
  {"pad_bytes", &Dtool_Datagram_pad_bytes_1120, METH_O, (const char *)Dtool_Datagram_pad_bytes_1120_comment},
  {"padBytes", &Dtool_Datagram_pad_bytes_1120, METH_O, (const char *)Dtool_Datagram_pad_bytes_1120_comment},
  {"append_data", &Dtool_Datagram_append_data_1121, METH_O, (const char *)Dtool_Datagram_append_data_1121_comment},
  {"appendData", &Dtool_Datagram_append_data_1121, METH_O, (const char *)Dtool_Datagram_append_data_1121_comment},
  {"get_message", &Dtool_Datagram_get_message_1123, METH_NOARGS, (const char *)Dtool_Datagram_get_message_1123_comment},
  {"getMessage", &Dtool_Datagram_get_message_1123, METH_NOARGS, (const char *)Dtool_Datagram_get_message_1123_comment},
  {"get_length", &Dtool_Datagram_get_length_1125, METH_NOARGS, (const char *)Dtool_Datagram_get_length_1125_comment},
  {"getLength", &Dtool_Datagram_get_length_1125, METH_NOARGS, (const char *)Dtool_Datagram_get_length_1125_comment},
  {"set_array", &Dtool_Datagram_set_array_1126, METH_O, (const char *)Dtool_Datagram_set_array_1126_comment},
  {"setArray", &Dtool_Datagram_set_array_1126, METH_O, (const char *)Dtool_Datagram_set_array_1126_comment},
  {"copy_array", &Dtool_Datagram_copy_array_1127, METH_O, (const char *)Dtool_Datagram_copy_array_1127_comment},
  {"copyArray", &Dtool_Datagram_copy_array_1127, METH_O, (const char *)Dtool_Datagram_copy_array_1127_comment},
  {"get_array", &Dtool_Datagram_get_array_1128, METH_NOARGS, (const char *)Dtool_Datagram_get_array_1128_comment},
  {"getArray", &Dtool_Datagram_get_array_1128, METH_NOARGS, (const char *)Dtool_Datagram_get_array_1128_comment},
  {"modify_array", &Dtool_Datagram_modify_array_1129, METH_NOARGS, (const char *)Dtool_Datagram_modify_array_1129_comment},
  {"modifyArray", &Dtool_Datagram_modify_array_1129, METH_NOARGS, (const char *)Dtool_Datagram_modify_array_1129_comment},
  {"set_stdfloat_double", &Dtool_Datagram_set_stdfloat_double_1130, METH_O, (const char *)Dtool_Datagram_set_stdfloat_double_1130_comment},
  {"setStdfloatDouble", &Dtool_Datagram_set_stdfloat_double_1130, METH_O, (const char *)Dtool_Datagram_set_stdfloat_double_1130_comment},
  {"get_stdfloat_double", &Dtool_Datagram_get_stdfloat_double_1131, METH_NOARGS, (const char *)Dtool_Datagram_get_stdfloat_double_1131_comment},
  {"getStdfloatDouble", &Dtool_Datagram_get_stdfloat_double_1131, METH_NOARGS, (const char *)Dtool_Datagram_get_stdfloat_double_1131_comment},
  {"output", &Dtool_Datagram_output_1135, METH_O, (const char *)Dtool_Datagram_output_1135_comment},
  {"write", (PyCFunction) &Dtool_Datagram_write_1136, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_write_1136_comment},
  {"get_class_type", &Dtool_Datagram_get_class_type_1137, METH_NOARGS | METH_STATIC, (const char *)Dtool_Datagram_get_class_type_1137_comment},
  {"getClassType", &Dtool_Datagram_get_class_type_1137, METH_NOARGS | METH_STATIC, (const char *)Dtool_Datagram_get_class_type_1137_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Datagram
//////////////////
static PyObject *Dtool_Repr_Datagram(PyObject *self) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Datagram
//////////////////
static PyObject *Dtool_Str_Datagram(PyObject *self) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     Datagram
//////////////////
static PyObject *Dtool_RichCompare_Datagram(PyObject *self, PyObject *arg, int op) {
  Datagram *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Datagram::operator ==(Datagram const &other) const
      Datagram const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
        bool return_value = (*(const Datagram*)local_this).operator ==(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Datagram::operator !=(Datagram const &other) const
      Datagram const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
        bool return_value = (*(const Datagram*)local_this).operator !=(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Datagram::operator <(Datagram const &other) const
      Datagram const *arg_this;
      bool arg_manage = false;
      if (Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
        bool return_value = (*(const Datagram*)local_this).operator <(*arg_this);
        if (arg_manage) {
          delete arg_this;
        }
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_Datagram = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Datagram = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Datagram = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Datagram = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Datagram = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Datagram",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Datagram,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &DTOOL_PyObject_ComparePointers,
#endif
    &Dtool_Repr_Datagram,
    &Dtool_NumberMethods_Datagram,
    &Dtool_SequenceMethods_Datagram,
    &Dtool_MappingMethods_Datagram,
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Str_Datagram,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Datagram,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An ordered list of data elements, formatted in memory for transmission over\n"
    " * a socket or writing to a data file.\n"
    " *\n"
    " * Data elements should be added one at a time, in order, to the Datagram.\n"
    " * The nature and contents of the data elements are totally up to the user.\n"
    " * When a Datagram has been transmitted and received, its data elements may be\n"
    " * extracted using a DatagramIterator; it is up to the caller to know the\n"
    " * correct type of each data element in order.\n"
    " *\n"
    " * A Datagram is itself headerless; it is simply a collection of data\n"
    " * elements.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_Datagram,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Datagram,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Datagram,
    PyType_GenericAlloc,
    Dtool_new_Datagram,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Datagram,
  Dtool_UpcastInterface_Datagram,
  Dtool_DowncastInterface_Datagram,
  (CoerceFunction)Dtool_ConstCoerce_Datagram,
  (CoerceFunction)Dtool_Coerce_Datagram,
};

static void Dtool_PyModuleClassInit_Datagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedObject(NULL);
    Dtool_Datagram._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedObject);
    PyObject *dict = PyDict_New();
    Dtool_Datagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Datagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Datagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Datagram);
  }
}

/**
 * Python method tables for DatagramGenerator (DatagramGenerator)
 */
static PyMethodDef Dtool_Methods_DatagramGenerator[] = {
  {"get_datagram", &Dtool_DatagramGenerator_get_datagram_1140, METH_O, (const char *)Dtool_DatagramGenerator_get_datagram_1140_comment},
  {"getDatagram", &Dtool_DatagramGenerator_get_datagram_1140, METH_O, (const char *)Dtool_DatagramGenerator_get_datagram_1140_comment},
  {"save_datagram", &Dtool_DatagramGenerator_save_datagram_1141, METH_O, (const char *)Dtool_DatagramGenerator_save_datagram_1141_comment},
  {"saveDatagram", &Dtool_DatagramGenerator_save_datagram_1141, METH_O, (const char *)Dtool_DatagramGenerator_save_datagram_1141_comment},
  {"is_eof", &Dtool_DatagramGenerator_is_eof_1142, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_eof_1142_comment},
  {"isEof", &Dtool_DatagramGenerator_is_eof_1142, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_eof_1142_comment},
  {"is_error", &Dtool_DatagramGenerator_is_error_1143, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_error_1143_comment},
  {"isError", &Dtool_DatagramGenerator_is_error_1143, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_error_1143_comment},
  {"get_filename", &Dtool_DatagramGenerator_get_filename_1144, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_filename_1144_comment},
  {"getFilename", &Dtool_DatagramGenerator_get_filename_1144, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_filename_1144_comment},
  {"get_timestamp", &Dtool_DatagramGenerator_get_timestamp_1145, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_timestamp_1145_comment},
  {"getTimestamp", &Dtool_DatagramGenerator_get_timestamp_1145, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_timestamp_1145_comment},
  {"get_file", &Dtool_DatagramGenerator_get_file_1146, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_1146_comment},
  {"getFile", &Dtool_DatagramGenerator_get_file_1146, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_1146_comment},
  {"get_vfile", &Dtool_DatagramGenerator_get_vfile_1147, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_vfile_1147_comment},
  {"getVfile", &Dtool_DatagramGenerator_get_vfile_1147, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_vfile_1147_comment},
  {"get_file_pos", &Dtool_DatagramGenerator_get_file_pos_1148, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_pos_1148_comment},
  {"getFilePos", &Dtool_DatagramGenerator_get_file_pos_1148, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_pos_1148_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DatagramGenerator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramGenerator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DatagramGenerator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramGenerator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DatagramGenerator,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines the abstract interace to any source of datagrams,\n"
    " * whether it be from a file or from the net.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DatagramGenerator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DatagramGenerator,
    PyType_GenericAlloc,
    Dtool_new_DatagramGenerator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramGenerator,
  Dtool_UpcastInterface_DatagramGenerator,
  Dtool_DowncastInterface_DatagramGenerator,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DatagramGenerator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DatagramGenerator._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DatagramGenerator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramGenerator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramGenerator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramGenerator);
  }
}

/**
 * Python method tables for DatagramIterator (DatagramIterator)
 */
static PyMethodDef Dtool_Methods_DatagramIterator[] = {
  {"assign", &Dtool_DatagramIterator_operator_1151, METH_O, (const char *)Dtool_DatagramIterator_operator_1151_comment},
  {"get_bool", &Dtool_DatagramIterator_get_bool_1153, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_bool_1153_comment},
  {"getBool", &Dtool_DatagramIterator_get_bool_1153, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_bool_1153_comment},
  {"get_int8", &Dtool_DatagramIterator_get_int8_1154, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int8_1154_comment},
  {"getInt8", &Dtool_DatagramIterator_get_int8_1154, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int8_1154_comment},
  {"get_uint8", &Dtool_DatagramIterator_get_uint8_1155, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint8_1155_comment},
  {"getUint8", &Dtool_DatagramIterator_get_uint8_1155, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint8_1155_comment},
  {"get_int16", &Dtool_DatagramIterator_get_int16_1156, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int16_1156_comment},
  {"getInt16", &Dtool_DatagramIterator_get_int16_1156, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int16_1156_comment},
  {"get_int32", &Dtool_DatagramIterator_get_int32_1157, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int32_1157_comment},
  {"getInt32", &Dtool_DatagramIterator_get_int32_1157, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int32_1157_comment},
  {"get_int64", &Dtool_DatagramIterator_get_int64_1158, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int64_1158_comment},
  {"getInt64", &Dtool_DatagramIterator_get_int64_1158, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int64_1158_comment},
  {"get_uint16", &Dtool_DatagramIterator_get_uint16_1159, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint16_1159_comment},
  {"getUint16", &Dtool_DatagramIterator_get_uint16_1159, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint16_1159_comment},
  {"get_uint32", &Dtool_DatagramIterator_get_uint32_1160, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint32_1160_comment},
  {"getUint32", &Dtool_DatagramIterator_get_uint32_1160, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint32_1160_comment},
  {"get_uint64", &Dtool_DatagramIterator_get_uint64_1161, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint64_1161_comment},
  {"getUint64", &Dtool_DatagramIterator_get_uint64_1161, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint64_1161_comment},
  {"get_float32", &Dtool_DatagramIterator_get_float32_1162, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float32_1162_comment},
  {"getFloat32", &Dtool_DatagramIterator_get_float32_1162, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float32_1162_comment},
  {"get_float64", &Dtool_DatagramIterator_get_float64_1163, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float64_1163_comment},
  {"getFloat64", &Dtool_DatagramIterator_get_float64_1163, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float64_1163_comment},
  {"get_stdfloat", &Dtool_DatagramIterator_get_stdfloat_1164, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_stdfloat_1164_comment},
  {"getStdfloat", &Dtool_DatagramIterator_get_stdfloat_1164, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_stdfloat_1164_comment},
  {"get_be_int16", &Dtool_DatagramIterator_get_be_int16_1165, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int16_1165_comment},
  {"getBeInt16", &Dtool_DatagramIterator_get_be_int16_1165, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int16_1165_comment},
  {"get_be_int32", &Dtool_DatagramIterator_get_be_int32_1166, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int32_1166_comment},
  {"getBeInt32", &Dtool_DatagramIterator_get_be_int32_1166, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int32_1166_comment},
  {"get_be_int64", &Dtool_DatagramIterator_get_be_int64_1167, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int64_1167_comment},
  {"getBeInt64", &Dtool_DatagramIterator_get_be_int64_1167, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int64_1167_comment},
  {"get_be_uint16", &Dtool_DatagramIterator_get_be_uint16_1168, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint16_1168_comment},
  {"getBeUint16", &Dtool_DatagramIterator_get_be_uint16_1168, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint16_1168_comment},
  {"get_be_uint32", &Dtool_DatagramIterator_get_be_uint32_1169, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint32_1169_comment},
  {"getBeUint32", &Dtool_DatagramIterator_get_be_uint32_1169, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint32_1169_comment},
  {"get_be_uint64", &Dtool_DatagramIterator_get_be_uint64_1170, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint64_1170_comment},
  {"getBeUint64", &Dtool_DatagramIterator_get_be_uint64_1170, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint64_1170_comment},
  {"get_be_float32", &Dtool_DatagramIterator_get_be_float32_1171, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float32_1171_comment},
  {"getBeFloat32", &Dtool_DatagramIterator_get_be_float32_1171, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float32_1171_comment},
  {"get_be_float64", &Dtool_DatagramIterator_get_be_float64_1172, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float64_1172_comment},
  {"getBeFloat64", &Dtool_DatagramIterator_get_be_float64_1172, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float64_1172_comment},
  {"get_string", &Dtool_DatagramIterator_get_string_1173, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string_1173_comment},
  {"getString", &Dtool_DatagramIterator_get_string_1173, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string_1173_comment},
  {"get_string32", &Dtool_DatagramIterator_get_string32_1174, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string32_1174_comment},
  {"getString32", &Dtool_DatagramIterator_get_string32_1174, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string32_1174_comment},
  {"get_z_string", &Dtool_DatagramIterator_get_z_string_1175, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_z_string_1175_comment},
  {"getZString", &Dtool_DatagramIterator_get_z_string_1175, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_z_string_1175_comment},
  {"get_fixed_string", &Dtool_DatagramIterator_get_fixed_string_1176, METH_O, (const char *)Dtool_DatagramIterator_get_fixed_string_1176_comment},
  {"getFixedString", &Dtool_DatagramIterator_get_fixed_string_1176, METH_O, (const char *)Dtool_DatagramIterator_get_fixed_string_1176_comment},
  {"get_wstring", &Dtool_DatagramIterator_get_wstring_1177, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_wstring_1177_comment},
  {"getWstring", &Dtool_DatagramIterator_get_wstring_1177, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_wstring_1177_comment},
  {"skip_bytes", &Dtool_DatagramIterator_skip_bytes_1178, METH_O, (const char *)Dtool_DatagramIterator_skip_bytes_1178_comment},
  {"skipBytes", &Dtool_DatagramIterator_skip_bytes_1178, METH_O, (const char *)Dtool_DatagramIterator_skip_bytes_1178_comment},
  {"extract_bytes", &Dtool_DatagramIterator_extract_bytes_1179, METH_O, (const char *)Dtool_DatagramIterator_extract_bytes_1179_comment},
  {"extractBytes", &Dtool_DatagramIterator_extract_bytes_1179, METH_O, (const char *)Dtool_DatagramIterator_extract_bytes_1179_comment},
  {"get_remaining_bytes", &Dtool_DatagramIterator_get_remaining_bytes_1180, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_bytes_1180_comment},
  {"getRemainingBytes", &Dtool_DatagramIterator_get_remaining_bytes_1180, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_bytes_1180_comment},
  {"get_remaining_size", &Dtool_DatagramIterator_get_remaining_size_1181, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_size_1181_comment},
  {"getRemainingSize", &Dtool_DatagramIterator_get_remaining_size_1181, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_size_1181_comment},
  {"get_datagram", &Dtool_DatagramIterator_get_datagram_1182, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_datagram_1182_comment},
  {"getDatagram", &Dtool_DatagramIterator_get_datagram_1182, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_datagram_1182_comment},
  {"get_current_index", &Dtool_DatagramIterator_get_current_index_1183, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_current_index_1183_comment},
  {"getCurrentIndex", &Dtool_DatagramIterator_get_current_index_1183, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_current_index_1183_comment},
  {"output", &Dtool_DatagramIterator_output_1184, METH_O, (const char *)Dtool_DatagramIterator_output_1184_comment},
  {"write", (PyCFunction) &Dtool_DatagramIterator_write_1185, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramIterator_write_1185_comment},
  {"get_class_type", &Dtool_DatagramIterator_get_class_type_1186, METH_NOARGS | METH_STATIC, (const char *)Dtool_DatagramIterator_get_class_type_1186_comment},
  {"getClassType", &Dtool_DatagramIterator_get_class_type_1186, METH_NOARGS | METH_STATIC, (const char *)Dtool_DatagramIterator_get_class_type_1186_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     DatagramIterator
//////////////////
static PyObject *Dtool_Repr_DatagramIterator(PyObject *self) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DatagramIterator
//////////////////
static PyObject *Dtool_Str_DatagramIterator(PyObject *self) {
  DatagramIterator *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DatagramIterator = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramIterator = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DatagramIterator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramIterator,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_DatagramIterator,
    &Dtool_NumberMethods_DatagramIterator,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_DatagramIterator,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to retrieve the individual data elements previously stored in a\n"
    " * Datagram.  Elements may be retrieved one at a time; it is up to the caller\n"
    " * to know the correct type and order of each element.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DatagramIterator,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DatagramIterator,
    PyType_GenericAlloc,
    Dtool_new_DatagramIterator,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramIterator,
  Dtool_UpcastInterface_DatagramIterator,
  Dtool_DowncastInterface_DatagramIterator,
  (CoerceFunction)0,
  (CoerceFunction)Dtool_Coerce_DatagramIterator,
};

static void Dtool_PyModuleClassInit_DatagramIterator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DatagramIterator._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DatagramIterator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramIterator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramIterator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramIterator);
  }
}

/**
 * Python method tables for DatagramSink (DatagramSink)
 */
static PyMethodDef Dtool_Methods_DatagramSink[] = {
  {"put_datagram", &Dtool_DatagramSink_put_datagram_1189, METH_O, (const char *)Dtool_DatagramSink_put_datagram_1189_comment},
  {"putDatagram", &Dtool_DatagramSink_put_datagram_1189, METH_O, (const char *)Dtool_DatagramSink_put_datagram_1189_comment},
  {"copy_datagram", (PyCFunction) &Dtool_DatagramSink_copy_datagram_1190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramSink_copy_datagram_1190_comment},
  {"copyDatagram", (PyCFunction) &Dtool_DatagramSink_copy_datagram_1190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramSink_copy_datagram_1190_comment},
  {"is_error", &Dtool_DatagramSink_is_error_1191, METH_NOARGS, (const char *)Dtool_DatagramSink_is_error_1191_comment},
  {"isError", &Dtool_DatagramSink_is_error_1191, METH_NOARGS, (const char *)Dtool_DatagramSink_is_error_1191_comment},
  {"flush", &Dtool_DatagramSink_flush_1192, METH_NOARGS, (const char *)Dtool_DatagramSink_flush_1192_comment},
  {"get_filename", &Dtool_DatagramSink_get_filename_1193, METH_NOARGS, (const char *)Dtool_DatagramSink_get_filename_1193_comment},
  {"getFilename", &Dtool_DatagramSink_get_filename_1193, METH_NOARGS, (const char *)Dtool_DatagramSink_get_filename_1193_comment},
  {"get_file", &Dtool_DatagramSink_get_file_1194, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_1194_comment},
  {"getFile", &Dtool_DatagramSink_get_file_1194, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_1194_comment},
  {"get_file_pos", &Dtool_DatagramSink_get_file_pos_1195, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_pos_1195_comment},
  {"getFilePos", &Dtool_DatagramSink_get_file_pos_1195, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_pos_1195_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_DatagramSink = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramSink = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.DatagramSink",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramSink,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_DatagramSink,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines the abstract interface to sending datagrams to any\n"
    " * target, whether it be into a file or across the net\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_DatagramSink,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_DatagramSink,
    PyType_GenericAlloc,
    Dtool_new_DatagramSink,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramSink,
  Dtool_UpcastInterface_DatagramSink,
  Dtool_DowncastInterface_DatagramSink,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_DatagramSink(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DatagramSink._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_DatagramSink._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramSink) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramSink)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramSink);
  }
}

/**
 * Python method tables for TypedReferenceCount (TypedReferenceCount)
 */
static PyMethodDef Dtool_Methods_TypedReferenceCount[] = {
  {"get_class_type", &Dtool_TypedReferenceCount_get_class_type_1212, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedReferenceCount_get_class_type_1212_comment},
  {"getClassType", &Dtool_TypedReferenceCount_get_class_type_1212, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedReferenceCount_get_class_type_1212_comment},
  {"upcast_to_TypedObject", &Dtool_TypedReferenceCount_upcast_to_TypedObject_1208, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_TypedObject_1208_comment},
  {"upcastToTypedObject", &Dtool_TypedReferenceCount_upcast_to_TypedObject_1208, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_TypedObject_1208_comment},
  {"upcast_to_ReferenceCount", &Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210_comment},
  {"upcastToReferenceCount", &Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_ReferenceCount_1210_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TypedReferenceCount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedReferenceCount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TypedReferenceCount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TypedReferenceCount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TypedReferenceCount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TypedReferenceCount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedReferenceCount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TypedReferenceCount,
    &Dtool_SequenceMethods_TypedReferenceCount,
    &Dtool_MappingMethods_TypedReferenceCount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TypedReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for things which need to inherit from both TypedObject and\n"
    " * from ReferenceCount.  It's convenient to define this intermediate base\n"
    " * class instead of multiply inheriting from the two classes each time they\n"
    " * are needed, so that we can sensibly pass around pointers to things which\n"
    " * are both TypedObjects and ReferenceCounters.\n"
    " *\n"
    " * See also TypedObject for detailed instructions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TypedReferenceCount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TypedReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_TypedReferenceCount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedReferenceCount,
  Dtool_UpcastInterface_TypedReferenceCount,
  Dtool_DowncastInterface_TypedReferenceCount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TypedReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedObject(NULL);
    Dtool_PyModuleClassInit_ReferenceCount(NULL);
    Dtool_TypedReferenceCount._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_TypedObject, (PyTypeObject *)&Dtool_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_TypedReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedReferenceCount);
  }
}

/**
 * Python method tables for FileReference (FileReference)
 */
static PyMethodDef Dtool_Methods_FileReference[] = {
  {"get_filename", &Dtool_FileReference_get_filename_1216, METH_NOARGS, (const char *)Dtool_FileReference_get_filename_1216_comment},
  {"getFilename", &Dtool_FileReference_get_filename_1216, METH_NOARGS, (const char *)Dtool_FileReference_get_filename_1216_comment},
  {"get_class_type", &Dtool_FileReference_get_class_type_1217, METH_NOARGS | METH_STATIC, (const char *)Dtool_FileReference_get_class_type_1217_comment},
  {"getClassType", &Dtool_FileReference_get_class_type_1217, METH_NOARGS | METH_STATIC, (const char *)Dtool_FileReference_get_class_type_1217_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_FileReference = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FileReference = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_FileReference = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_FileReference = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_FileReference = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.FileReference",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_FileReference,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_FileReference,
    &Dtool_SequenceMethods_FileReference,
    &Dtool_MappingMethods_FileReference,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_FileReference,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Keeps a reference-counted pointer to a file on disk.  As long as the\n"
    " * FileReference is held, someone presumably has a use for this file.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_FileReference,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_FileReference,
    PyType_GenericAlloc,
    Dtool_new_FileReference,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FileReference,
  Dtool_UpcastInterface_FileReference,
  Dtool_DowncastInterface_FileReference,
  (CoerceFunction)Dtool_ConstCoerce_FileReference,
  (CoerceFunction)Dtool_Coerce_FileReference,
};

static void Dtool_PyModuleClassInit_FileReference(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedReferenceCount(NULL);
    Dtool_FileReference._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_FileReference._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FileReference) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FileReference)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FileReference);
  }
}

/**
 * Python method tables for Ramfile (Ramfile)
 */
static PyMethodDef Dtool_Methods_Ramfile[] = {
  {"seek", &Dtool_Ramfile_seek_1221, METH_O, (const char *)Dtool_Ramfile_seek_1221_comment},
  {"tell", &Dtool_Ramfile_tell_1222, METH_NOARGS, (const char *)Dtool_Ramfile_tell_1222_comment},
  {"read", &Dtool_Ramfile_read_1223, METH_O, (const char *)Dtool_Ramfile_read_1223_comment},
  {"readline", &Dtool_Ramfile_readline_1224, METH_NOARGS, (const char *)Dtool_Ramfile_readline_1224_comment},
  {"readlines", &Dtool_Ramfile_readlines_1225, METH_NOARGS, (const char *)Dtool_Ramfile_readlines_1225_comment},
  {"get_data", &Dtool_Ramfile_get_data_1226, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_1226_comment},
  {"getData", &Dtool_Ramfile_get_data_1226, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_1226_comment},
  {"get_data_size", &Dtool_Ramfile_get_data_size_1227, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_size_1227_comment},
  {"getDataSize", &Dtool_Ramfile_get_data_size_1227, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_size_1227_comment},
  {"clear", &Dtool_Ramfile_clear_1228, METH_NOARGS, (const char *)Dtool_Ramfile_clear_1228_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_Ramfile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Ramfile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Ramfile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Ramfile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Ramfile,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An in-memory buffer specifically designed for downloading files to memory.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Ramfile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Ramfile,
    PyType_GenericAlloc,
    Dtool_new_Ramfile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Ramfile,
  Dtool_UpcastInterface_Ramfile,
  Dtool_DowncastInterface_Ramfile,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Ramfile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Ramfile._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Ramfile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Ramfile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Ramfile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Ramfile);
  }
}

/**
 * Python method tables for HashVal (HashVal)
 */
static PyMethodDef Dtool_Methods_HashVal[] = {
  {"assign", &Dtool_HashVal_operator_1232, METH_O, (const char *)Dtool_HashVal_operator_1232_comment},
  {"compare_to", &Dtool_HashVal_compare_to_1236, METH_O, (const char *)Dtool_HashVal_compare_to_1236_comment},
  {"compareTo", &Dtool_HashVal_compare_to_1236, METH_O, (const char *)Dtool_HashVal_compare_to_1236_comment},
  {"merge_with", &Dtool_HashVal_merge_with_1237, METH_O, (const char *)Dtool_HashVal_merge_with_1237_comment},
  {"mergeWith", &Dtool_HashVal_merge_with_1237, METH_O, (const char *)Dtool_HashVal_merge_with_1237_comment},
  {"output_dec", &Dtool_HashVal_output_dec_1238, METH_O, (const char *)Dtool_HashVal_output_dec_1238_comment},
  {"outputDec", &Dtool_HashVal_output_dec_1238, METH_O, (const char *)Dtool_HashVal_output_dec_1238_comment},
  {"input_dec", &Dtool_HashVal_input_dec_1239, METH_O, (const char *)Dtool_HashVal_input_dec_1239_comment},
  {"inputDec", &Dtool_HashVal_input_dec_1239, METH_O, (const char *)Dtool_HashVal_input_dec_1239_comment},
  {"output_hex", &Dtool_HashVal_output_hex_1240, METH_O, (const char *)Dtool_HashVal_output_hex_1240_comment},
  {"outputHex", &Dtool_HashVal_output_hex_1240, METH_O, (const char *)Dtool_HashVal_output_hex_1240_comment},
  {"input_hex", &Dtool_HashVal_input_hex_1241, METH_O, (const char *)Dtool_HashVal_input_hex_1241_comment},
  {"inputHex", &Dtool_HashVal_input_hex_1241, METH_O, (const char *)Dtool_HashVal_input_hex_1241_comment},
  {"output_binary", &Dtool_HashVal_output_binary_1242, METH_O, (const char *)Dtool_HashVal_output_binary_1242_comment},
  {"outputBinary", &Dtool_HashVal_output_binary_1242, METH_O, (const char *)Dtool_HashVal_output_binary_1242_comment},
  {"input_binary", &Dtool_HashVal_input_binary_1243, METH_O, (const char *)Dtool_HashVal_input_binary_1243_comment},
  {"inputBinary", &Dtool_HashVal_input_binary_1243, METH_O, (const char *)Dtool_HashVal_input_binary_1243_comment},
  {"output", &Dtool_HashVal_output_1244, METH_O, (const char *)Dtool_HashVal_output_1244_comment},
  {"as_dec", &Dtool_HashVal_as_dec_1245, METH_NOARGS, (const char *)Dtool_HashVal_as_dec_1245_comment},
  {"asDec", &Dtool_HashVal_as_dec_1245, METH_NOARGS, (const char *)Dtool_HashVal_as_dec_1245_comment},
  {"set_from_dec", &Dtool_HashVal_set_from_dec_1246, METH_O, (const char *)Dtool_HashVal_set_from_dec_1246_comment},
  {"setFromDec", &Dtool_HashVal_set_from_dec_1246, METH_O, (const char *)Dtool_HashVal_set_from_dec_1246_comment},
  {"as_hex", &Dtool_HashVal_as_hex_1247, METH_NOARGS, (const char *)Dtool_HashVal_as_hex_1247_comment},
  {"asHex", &Dtool_HashVal_as_hex_1247, METH_NOARGS, (const char *)Dtool_HashVal_as_hex_1247_comment},
  {"set_from_hex", &Dtool_HashVal_set_from_hex_1248, METH_O, (const char *)Dtool_HashVal_set_from_hex_1248_comment},
  {"setFromHex", &Dtool_HashVal_set_from_hex_1248, METH_O, (const char *)Dtool_HashVal_set_from_hex_1248_comment},
  {"as_bin", &Dtool_HashVal_as_bin_1249, METH_NOARGS, (const char *)Dtool_HashVal_as_bin_1249_comment},
  {"asBin", &Dtool_HashVal_as_bin_1249, METH_NOARGS, (const char *)Dtool_HashVal_as_bin_1249_comment},
  {"set_from_bin", &Dtool_HashVal_set_from_bin_1250, METH_O, (const char *)Dtool_HashVal_set_from_bin_1250_comment},
  {"setFromBin", &Dtool_HashVal_set_from_bin_1250, METH_O, (const char *)Dtool_HashVal_set_from_bin_1250_comment},
  {"write_datagram", &Dtool_HashVal_write_datagram_1251, METH_O, (const char *)Dtool_HashVal_write_datagram_1251_comment},
  {"writeDatagram", &Dtool_HashVal_write_datagram_1251, METH_O, (const char *)Dtool_HashVal_write_datagram_1251_comment},
  {"read_datagram", &Dtool_HashVal_read_datagram_1252, METH_O, (const char *)Dtool_HashVal_read_datagram_1252_comment},
  {"readDatagram", &Dtool_HashVal_read_datagram_1252, METH_O, (const char *)Dtool_HashVal_read_datagram_1252_comment},
  {"write_stream", &Dtool_HashVal_write_stream_1253, METH_O, (const char *)Dtool_HashVal_write_stream_1253_comment},
  {"writeStream", &Dtool_HashVal_write_stream_1253, METH_O, (const char *)Dtool_HashVal_write_stream_1253_comment},
  {"read_stream", &Dtool_HashVal_read_stream_1254, METH_O, (const char *)Dtool_HashVal_read_stream_1254_comment},
  {"readStream", &Dtool_HashVal_read_stream_1254, METH_O, (const char *)Dtool_HashVal_read_stream_1254_comment},
  {"hash_file", &Dtool_HashVal_hash_file_1255, METH_O, (const char *)Dtool_HashVal_hash_file_1255_comment},
  {"hashFile", &Dtool_HashVal_hash_file_1255, METH_O, (const char *)Dtool_HashVal_hash_file_1255_comment},
  {"hash_stream", &Dtool_HashVal_hash_stream_1256, METH_O, (const char *)Dtool_HashVal_hash_stream_1256_comment},
  {"hashStream", &Dtool_HashVal_hash_stream_1256, METH_O, (const char *)Dtool_HashVal_hash_stream_1256_comment},
  {"hash_ramfile", &Dtool_HashVal_hash_ramfile_1257, METH_O, (const char *)Dtool_HashVal_hash_ramfile_1257_comment},
  {"hashRamfile", &Dtool_HashVal_hash_ramfile_1257, METH_O, (const char *)Dtool_HashVal_hash_ramfile_1257_comment},
  {"hash_string", &Dtool_HashVal_hash_string_1258, METH_O, (const char *)Dtool_HashVal_hash_string_1258_comment},
  {"hashString", &Dtool_HashVal_hash_string_1258, METH_O, (const char *)Dtool_HashVal_hash_string_1258_comment},
  {"hash_bytes", &Dtool_HashVal_hash_bytes_1259, METH_O, (const char *)Dtool_HashVal_hash_bytes_1259_comment},
  {"hashBytes", &Dtool_HashVal_hash_bytes_1259, METH_O, (const char *)Dtool_HashVal_hash_bytes_1259_comment},
  {"hash_buffer", (PyCFunction) &Dtool_HashVal_hash_buffer_1260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HashVal_hash_buffer_1260_comment},
  {"hashBuffer", (PyCFunction) &Dtool_HashVal_hash_buffer_1260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HashVal_hash_buffer_1260_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HashVal slot tp_compare -> compare_to
//////////////////
static int Dtool_HashVal_compare_to_1236_tp_compare(PyObject *self, PyObject *arg) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int HashVal::compare_to(HashVal const &other) const
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.compare_to", true, true);
  if (arg_this != NULL) {
    int return_value = (*(const HashVal*)local_this).compare_to(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(HashVal self, const HashVal other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     HashVal
//////////////////
static PyObject *Dtool_Repr_HashVal(PyObject *self) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     HashVal
//////////////////
static PyObject *Dtool_RichCompare_HashVal(PyObject *self, PyObject *arg, int op) {
  HashVal *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return NULL;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool HashVal::operator ==(HashVal const &other) const
      HashVal const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_HashVal, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const HashVal*)local_this).operator ==(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool HashVal::operator !=(HashVal const &other) const
      HashVal const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_HashVal, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const HashVal*)local_this).operator !=(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool HashVal::operator <(HashVal const &other) const
      HashVal const *arg_this;
      DTOOL_Call_ExtractThisPointerForType(arg, Dtool_Ptr_HashVal, (void **)&arg_this);
      if (arg_this != NULL) {
        bool return_value = (*(const HashVal*)local_this).operator <(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (notify->has_assert_failed()) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

#if PY_MAJOR_VERSION >= 3
  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_HashVal_compare_to_1236_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return (PyObject *)NULL;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
#endif

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_HashVal = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_HashVal = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.HashVal",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_HashVal,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    &Dtool_HashVal_compare_to_1236_tp_compare,
#endif
    &Dtool_Repr_HashVal,
    &Dtool_NumberMethods_HashVal,
    0, // tp_as_sequence
    0, // tp_as_mapping
    &DTOOL_PyObject_HashPointer,
    0, // tp_call
    &Dtool_Repr_HashVal,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores a 128-bit value that represents the hashed contents (typically MD5)\n"
    " * of a file or buffer.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    &Dtool_RichCompare_HashVal,
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_HashVal,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_HashVal,
    PyType_GenericAlloc,
    Dtool_new_HashVal,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HashVal,
  Dtool_UpcastInterface_HashVal,
  Dtool_DowncastInterface_HashVal,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_HashVal(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_HashVal._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_HashVal._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HashVal) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HashVal)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HashVal);
  }
}

/**
 * Python method tables for MemoryUsagePointers (MemoryUsagePointers)
 */
static PyMethodDef Dtool_Methods_MemoryUsagePointers[] = {
  {"get_num_pointers", &Dtool_MemoryUsagePointers_get_num_pointers_1265, METH_NOARGS, (const char *)Dtool_MemoryUsagePointers_get_num_pointers_1265_comment},
  {"getNumPointers", &Dtool_MemoryUsagePointers_get_num_pointers_1265, METH_NOARGS, (const char *)Dtool_MemoryUsagePointers_get_num_pointers_1265_comment},
  {"get_pointer", &Dtool_MemoryUsagePointers_get_pointer_1266, METH_O, (const char *)Dtool_MemoryUsagePointers_get_pointer_1266_comment},
  {"getPointer", &Dtool_MemoryUsagePointers_get_pointer_1266, METH_O, (const char *)Dtool_MemoryUsagePointers_get_pointer_1266_comment},
  {"get_typed_pointer", &Dtool_MemoryUsagePointers_get_typed_pointer_1268, METH_O, (const char *)Dtool_MemoryUsagePointers_get_typed_pointer_1268_comment},
  {"getTypedPointer", &Dtool_MemoryUsagePointers_get_typed_pointer_1268, METH_O, (const char *)Dtool_MemoryUsagePointers_get_typed_pointer_1268_comment},
  {"get_type", &Dtool_MemoryUsagePointers_get_type_1270, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_1270_comment},
  {"getType", &Dtool_MemoryUsagePointers_get_type_1270, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_1270_comment},
  {"get_type_name", &Dtool_MemoryUsagePointers_get_type_name_1271, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_name_1271_comment},
  {"getTypeName", &Dtool_MemoryUsagePointers_get_type_name_1271, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_name_1271_comment},
  {"get_age", &Dtool_MemoryUsagePointers_get_age_1272, METH_O, (const char *)Dtool_MemoryUsagePointers_get_age_1272_comment},
  {"getAge", &Dtool_MemoryUsagePointers_get_age_1272, METH_O, (const char *)Dtool_MemoryUsagePointers_get_age_1272_comment},
  {"get_python_pointer", &Dtool_MemoryUsagePointers_get_python_pointer_1273, METH_O, (const char *)Dtool_MemoryUsagePointers_get_python_pointer_1273_comment},
  {"getPythonPointer", &Dtool_MemoryUsagePointers_get_python_pointer_1273, METH_O, (const char *)Dtool_MemoryUsagePointers_get_python_pointer_1273_comment},
  {"clear", &Dtool_MemoryUsagePointers_clear_1274, METH_NOARGS, (const char *)Dtool_MemoryUsagePointers_clear_1274_comment},
  {"output", &Dtool_MemoryUsagePointers_output_1275, METH_O, (const char *)Dtool_MemoryUsagePointers_output_1275_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_pointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_pointers, METH_NOARGS, NULL},
  { "getPointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_pointers, METH_NOARGS, NULL},
  {"get_typed_pointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_typed_pointers, METH_NOARGS, NULL},
  { "getTypedPointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_typed_pointers, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     MemoryUsagePointers
//////////////////
static PyObject *Dtool_Repr_MemoryUsagePointers(PyObject *self) {
  MemoryUsagePointers *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MemoryUsagePointers = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_MemoryUsagePointers = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.MemoryUsagePointers",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_MemoryUsagePointers,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_MemoryUsagePointers,
    &Dtool_NumberMethods_MemoryUsagePointers,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_MemoryUsagePointers,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a list of pointers returned by a MemoryUsage object in response to\n"
    " * some query.\n"
    " *\n"
    " * Warning: once pointers are stored in a MemoryUsagePointers object, they are\n"
    " * reference-counted, and will not be freed until the MemoryUsagePointers\n"
    " * object is freed (or clear() is called on the object).  However, they may\n"
    " * not even be freed then; pointers may leak once they have been added to this\n"
    " * structure.  This is because we don't store enough information in this\n"
    " * structure to correctly free the pointers that have been added.  Since this\n"
    " * is intended primarily as a debugging tool, this is not a major issue.\n"
    " *\n"
    " * This class is just a user interface to talk about pointers stored in a\n"
    " * MemoryUsage object.  It doesn't even exist when compiled with NDEBUG.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_MemoryUsagePointers,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_MemoryUsagePointers,
    PyType_GenericAlloc,
    Dtool_new_MemoryUsagePointers,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MemoryUsagePointers,
  Dtool_UpcastInterface_MemoryUsagePointers,
  Dtool_DowncastInterface_MemoryUsagePointers,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_MemoryUsagePointers(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MemoryUsagePointers._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_MemoryUsagePointers._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MemoryUsagePointers) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MemoryUsagePointers)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MemoryUsagePointers);
  }
}

/**
 * Python method tables for ISubStream (ISubStream)
 */
static PyMethodDef Dtool_Methods_ISubStream[] = {
  {"open", (PyCFunction) &Dtool_ISubStream_open_1278, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ISubStream_open_1278_comment},
  {"close", &Dtool_ISubStream_close_1279, METH_NOARGS, (const char *)Dtool_ISubStream_close_1279_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ISubStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ISubStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_ISubStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_ISubStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_ISubStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ISubStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ISubStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ISubStream,
    &Dtool_SequenceMethods_ISubStream,
    &Dtool_MappingMethods_ISubStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_ISubStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An istream object that presents a subwindow into another istream.  The\n"
    " * first character read from this stream will be the \"start\" character from\n"
    " * the source istream; just before the file pointer reaches the \"end\"\n"
    " * character, eof is returned.\n"
    " *\n"
    " * The source stream must be one that we can randomly seek within.  The\n"
    " * resulting ISubStream will also support arbitrary seeks.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ISubStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ISubStream,
    PyType_GenericAlloc,
    Dtool_new_ISubStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ISubStream,
  Dtool_UpcastInterface_ISubStream,
  Dtool_DowncastInterface_ISubStream,
  (CoerceFunction)Dtool_ConstCoerce_ISubStream,
  (CoerceFunction)Dtool_Coerce_ISubStream,
};

static void Dtool_PyModuleClassInit_ISubStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_istream(NULL);
    Dtool_ISubStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_istream);
    PyObject *dict = PyDict_New();
    Dtool_ISubStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ISubStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ISubStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ISubStream);
  }
}

/**
 * Python method tables for OSubStream (OSubStream)
 */
static PyMethodDef Dtool_Methods_OSubStream[] = {
  {"open", (PyCFunction) &Dtool_OSubStream_open_1283, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OSubStream_open_1283_comment},
  {"close", &Dtool_OSubStream_close_1284, METH_NOARGS, (const char *)Dtool_OSubStream_close_1284_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OSubStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OSubStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OSubStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OSubStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OSubStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OSubStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OSubStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OSubStream,
    &Dtool_SequenceMethods_OSubStream,
    &Dtool_MappingMethods_OSubStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OSubStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An ostream object that presents a subwindow into another ostream.  The\n"
    " * first character written to this stream will be the \"start\" character in the\n"
    " * dest istream; no characters may be written to character \"end\" or later\n"
    " * (unless end is zero).\n"
    " *\n"
    " * The dest stream must be one that we can randomly seek within.  The\n"
    " * resulting OSubStream will also support arbitrary seeks.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OSubStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OSubStream,
    PyType_GenericAlloc,
    Dtool_new_OSubStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OSubStream,
  Dtool_UpcastInterface_OSubStream,
  Dtool_DowncastInterface_OSubStream,
  (CoerceFunction)Dtool_ConstCoerce_OSubStream,
  (CoerceFunction)Dtool_Coerce_OSubStream,
};

static void Dtool_PyModuleClassInit_OSubStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_OSubStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_OSubStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OSubStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OSubStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OSubStream);
  }
}

/**
 * Python method tables for SubStream (SubStream)
 */
static PyMethodDef Dtool_Methods_SubStream[] = {
  {"open", (PyCFunction) &Dtool_SubStream_open_1288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SubStream_open_1288_comment},
  {"close", &Dtool_SubStream_close_1289, METH_NOARGS, (const char *)Dtool_SubStream_close_1289_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_SubStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SubStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_SubStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_SubStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_SubStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SubStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SubStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_SubStream,
    &Dtool_SequenceMethods_SubStream,
    &Dtool_MappingMethods_SubStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_SubStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Combined ISubStream and OSubStream for bidirectional I/O.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SubStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SubStream,
    PyType_GenericAlloc,
    Dtool_new_SubStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SubStream,
  Dtool_UpcastInterface_SubStream,
  Dtool_DowncastInterface_SubStream,
  (CoerceFunction)Dtool_ConstCoerce_SubStream,
  (CoerceFunction)Dtool_Coerce_SubStream,
};

static void Dtool_PyModuleClassInit_SubStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_iostream(NULL);
    Dtool_SubStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_iostream);
    PyObject *dict = PyDict_New();
    Dtool_SubStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SubStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SubStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SubStream);
  }
}

/**
 * Python method tables for OpenSSLWrapper (OpenSSLWrapper)
 */
static PyMethodDef Dtool_Methods_OpenSSLWrapper[] = {
  {"clear_certificates", &Dtool_OpenSSLWrapper_clear_certificates_1292, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_clear_certificates_1292_comment},
  {"clearCertificates", &Dtool_OpenSSLWrapper_clear_certificates_1292, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_clear_certificates_1292_comment},
  {"load_certificates", &Dtool_OpenSSLWrapper_load_certificates_1293, METH_O, (const char *)Dtool_OpenSSLWrapper_load_certificates_1293_comment},
  {"loadCertificates", &Dtool_OpenSSLWrapper_load_certificates_1293, METH_O, (const char *)Dtool_OpenSSLWrapper_load_certificates_1293_comment},
  {"load_certificates_from_pem_ram", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294_comment},
  {"loadCertificatesFromPemRam", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_1294_comment},
  {"load_certificates_from_der_ram", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295_comment},
  {"loadCertificatesFromDerRam", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_der_ram_1295_comment},
  {"notify_ssl_errors", &Dtool_OpenSSLWrapper_notify_ssl_errors_1297, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_ssl_errors_1297_comment},
  {"notifySslErrors", &Dtool_OpenSSLWrapper_notify_ssl_errors_1297, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_ssl_errors_1297_comment},
  {"notify_debug_ssl_errors", &Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298_comment},
  {"notifyDebugSslErrors", &Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_debug_ssl_errors_1298_comment},
  {"get_global_ptr", &Dtool_OpenSSLWrapper_get_global_ptr_1299, METH_NOARGS | METH_STATIC, (const char *)Dtool_OpenSSLWrapper_get_global_ptr_1299_comment},
  {"getGlobalPtr", &Dtool_OpenSSLWrapper_get_global_ptr_1299, METH_NOARGS | METH_STATIC, (const char *)Dtool_OpenSSLWrapper_get_global_ptr_1299_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OpenSSLWrapper = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_OpenSSLWrapper = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OpenSSLWrapper",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OpenSSLWrapper,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OpenSSLWrapper,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Provides an interface wrapper around the OpenSSL library, to ensure that\n"
    " * the library is properly initialized in the application, and to provide some\n"
    " * hooks into global OpenSSL context data.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OpenSSLWrapper,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OpenSSLWrapper,
    PyType_GenericAlloc,
    Dtool_new_OpenSSLWrapper,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OpenSSLWrapper,
  Dtool_UpcastInterface_OpenSSLWrapper,
  Dtool_DowncastInterface_OpenSSLWrapper,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_OpenSSLWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OpenSSLWrapper._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_OpenSSLWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OpenSSLWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OpenSSLWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OpenSSLWrapper);
  }
}

/**
 * Python method tables for Multifile (Multifile)
 */
static PyMethodDef Dtool_Methods_Multifile[] = {
  {"open_read", (PyCFunction) &Dtool_Multifile_open_read_1302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_1302_comment},
  {"openRead", (PyCFunction) &Dtool_Multifile_open_read_1302, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_1302_comment},
  {"open_write", (PyCFunction) &Dtool_Multifile_open_write_1303, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_write_1303_comment},
  {"openWrite", (PyCFunction) &Dtool_Multifile_open_write_1303, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_write_1303_comment},
  {"open_read_write", (PyCFunction) &Dtool_Multifile_open_read_write_1304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_write_1304_comment},
  {"openReadWrite", (PyCFunction) &Dtool_Multifile_open_read_write_1304, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_write_1304_comment},
  {"close", &Dtool_Multifile_close_1305, METH_NOARGS, (const char *)Dtool_Multifile_close_1305_comment},
  {"get_multifile_name", &Dtool_Multifile_get_multifile_name_1306, METH_NOARGS, (const char *)Dtool_Multifile_get_multifile_name_1306_comment},
  {"getMultifileName", &Dtool_Multifile_get_multifile_name_1306, METH_NOARGS, (const char *)Dtool_Multifile_get_multifile_name_1306_comment},
  {"set_multifile_name", &Dtool_Multifile_set_multifile_name_1307, METH_O, (const char *)Dtool_Multifile_set_multifile_name_1307_comment},
  {"setMultifileName", &Dtool_Multifile_set_multifile_name_1307, METH_O, (const char *)Dtool_Multifile_set_multifile_name_1307_comment},
  {"is_read_valid", &Dtool_Multifile_is_read_valid_1308, METH_NOARGS, (const char *)Dtool_Multifile_is_read_valid_1308_comment},
  {"isReadValid", &Dtool_Multifile_is_read_valid_1308, METH_NOARGS, (const char *)Dtool_Multifile_is_read_valid_1308_comment},
  {"is_write_valid", &Dtool_Multifile_is_write_valid_1309, METH_NOARGS, (const char *)Dtool_Multifile_is_write_valid_1309_comment},
  {"isWriteValid", &Dtool_Multifile_is_write_valid_1309, METH_NOARGS, (const char *)Dtool_Multifile_is_write_valid_1309_comment},
  {"needs_repack", &Dtool_Multifile_needs_repack_1310, METH_NOARGS, (const char *)Dtool_Multifile_needs_repack_1310_comment},
  {"needsRepack", &Dtool_Multifile_needs_repack_1310, METH_NOARGS, (const char *)Dtool_Multifile_needs_repack_1310_comment},
  {"get_timestamp", &Dtool_Multifile_get_timestamp_1311, METH_NOARGS, (const char *)Dtool_Multifile_get_timestamp_1311_comment},
  {"getTimestamp", &Dtool_Multifile_get_timestamp_1311, METH_NOARGS, (const char *)Dtool_Multifile_get_timestamp_1311_comment},
  {"set_record_timestamp", &Dtool_Multifile_set_record_timestamp_1312, METH_O, (const char *)Dtool_Multifile_set_record_timestamp_1312_comment},
  {"setRecordTimestamp", &Dtool_Multifile_set_record_timestamp_1312, METH_O, (const char *)Dtool_Multifile_set_record_timestamp_1312_comment},
  {"get_record_timestamp", &Dtool_Multifile_get_record_timestamp_1313, METH_NOARGS, (const char *)Dtool_Multifile_get_record_timestamp_1313_comment},
  {"getRecordTimestamp", &Dtool_Multifile_get_record_timestamp_1313, METH_NOARGS, (const char *)Dtool_Multifile_get_record_timestamp_1313_comment},
  {"set_scale_factor", &Dtool_Multifile_set_scale_factor_1314, METH_O, (const char *)Dtool_Multifile_set_scale_factor_1314_comment},
  {"setScaleFactor", &Dtool_Multifile_set_scale_factor_1314, METH_O, (const char *)Dtool_Multifile_set_scale_factor_1314_comment},
  {"get_scale_factor", &Dtool_Multifile_get_scale_factor_1315, METH_NOARGS, (const char *)Dtool_Multifile_get_scale_factor_1315_comment},
  {"getScaleFactor", &Dtool_Multifile_get_scale_factor_1315, METH_NOARGS, (const char *)Dtool_Multifile_get_scale_factor_1315_comment},
  {"set_encryption_flag", &Dtool_Multifile_set_encryption_flag_1316, METH_O, (const char *)Dtool_Multifile_set_encryption_flag_1316_comment},
  {"setEncryptionFlag", &Dtool_Multifile_set_encryption_flag_1316, METH_O, (const char *)Dtool_Multifile_set_encryption_flag_1316_comment},
  {"get_encryption_flag", &Dtool_Multifile_get_encryption_flag_1317, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_flag_1317_comment},
  {"getEncryptionFlag", &Dtool_Multifile_get_encryption_flag_1317, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_flag_1317_comment},
  {"set_encryption_password", &Dtool_Multifile_set_encryption_password_1318, METH_O, (const char *)Dtool_Multifile_set_encryption_password_1318_comment},
  {"setEncryptionPassword", &Dtool_Multifile_set_encryption_password_1318, METH_O, (const char *)Dtool_Multifile_set_encryption_password_1318_comment},
  {"get_encryption_password", &Dtool_Multifile_get_encryption_password_1319, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_password_1319_comment},
  {"getEncryptionPassword", &Dtool_Multifile_get_encryption_password_1319, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_password_1319_comment},
  {"set_encryption_algorithm", &Dtool_Multifile_set_encryption_algorithm_1320, METH_O, (const char *)Dtool_Multifile_set_encryption_algorithm_1320_comment},
  {"setEncryptionAlgorithm", &Dtool_Multifile_set_encryption_algorithm_1320, METH_O, (const char *)Dtool_Multifile_set_encryption_algorithm_1320_comment},
  {"get_encryption_algorithm", &Dtool_Multifile_get_encryption_algorithm_1321, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_algorithm_1321_comment},
  {"getEncryptionAlgorithm", &Dtool_Multifile_get_encryption_algorithm_1321, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_algorithm_1321_comment},
  {"set_encryption_key_length", &Dtool_Multifile_set_encryption_key_length_1322, METH_O, (const char *)Dtool_Multifile_set_encryption_key_length_1322_comment},
  {"setEncryptionKeyLength", &Dtool_Multifile_set_encryption_key_length_1322, METH_O, (const char *)Dtool_Multifile_set_encryption_key_length_1322_comment},
  {"get_encryption_key_length", &Dtool_Multifile_get_encryption_key_length_1323, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_key_length_1323_comment},
  {"getEncryptionKeyLength", &Dtool_Multifile_get_encryption_key_length_1323, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_key_length_1323_comment},
  {"set_encryption_iteration_count", &Dtool_Multifile_set_encryption_iteration_count_1324, METH_O, (const char *)Dtool_Multifile_set_encryption_iteration_count_1324_comment},
  {"setEncryptionIterationCount", &Dtool_Multifile_set_encryption_iteration_count_1324, METH_O, (const char *)Dtool_Multifile_set_encryption_iteration_count_1324_comment},
  {"get_encryption_iteration_count", &Dtool_Multifile_get_encryption_iteration_count_1325, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_iteration_count_1325_comment},
  {"getEncryptionIterationCount", &Dtool_Multifile_get_encryption_iteration_count_1325, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_iteration_count_1325_comment},
  {"add_subfile", (PyCFunction) &Dtool_Multifile_add_subfile_1326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_subfile_1326_comment},
  {"addSubfile", (PyCFunction) &Dtool_Multifile_add_subfile_1326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_subfile_1326_comment},
  {"update_subfile", (PyCFunction) &Dtool_Multifile_update_subfile_1327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_update_subfile_1327_comment},
  {"updateSubfile", (PyCFunction) &Dtool_Multifile_update_subfile_1327, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_update_subfile_1327_comment},
  {"add_signature", (PyCFunction) &Dtool_Multifile_add_signature_1328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_signature_1328_comment},
  {"addSignature", (PyCFunction) &Dtool_Multifile_add_signature_1328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_signature_1328_comment},
  {"get_num_signatures", &Dtool_Multifile_get_num_signatures_1329, METH_NOARGS, (const char *)Dtool_Multifile_get_num_signatures_1329_comment},
  {"getNumSignatures", &Dtool_Multifile_get_num_signatures_1329, METH_NOARGS, (const char *)Dtool_Multifile_get_num_signatures_1329_comment},
  {"get_signature_subject_name", &Dtool_Multifile_get_signature_subject_name_1330, METH_O, (const char *)Dtool_Multifile_get_signature_subject_name_1330_comment},
  {"getSignatureSubjectName", &Dtool_Multifile_get_signature_subject_name_1330, METH_O, (const char *)Dtool_Multifile_get_signature_subject_name_1330_comment},
  {"get_signature_friendly_name", &Dtool_Multifile_get_signature_friendly_name_1331, METH_O, (const char *)Dtool_Multifile_get_signature_friendly_name_1331_comment},
  {"getSignatureFriendlyName", &Dtool_Multifile_get_signature_friendly_name_1331, METH_O, (const char *)Dtool_Multifile_get_signature_friendly_name_1331_comment},
  {"get_signature_public_key", &Dtool_Multifile_get_signature_public_key_1332, METH_O, (const char *)Dtool_Multifile_get_signature_public_key_1332_comment},
  {"getSignaturePublicKey", &Dtool_Multifile_get_signature_public_key_1332, METH_O, (const char *)Dtool_Multifile_get_signature_public_key_1332_comment},
  {"print_signature_certificate", (PyCFunction) &Dtool_Multifile_print_signature_certificate_1333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_print_signature_certificate_1333_comment},
  {"printSignatureCertificate", (PyCFunction) &Dtool_Multifile_print_signature_certificate_1333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_print_signature_certificate_1333_comment},
  {"write_signature_certificate", (PyCFunction) &Dtool_Multifile_write_signature_certificate_1334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_write_signature_certificate_1334_comment},
  {"writeSignatureCertificate", (PyCFunction) &Dtool_Multifile_write_signature_certificate_1334, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_write_signature_certificate_1334_comment},
  {"validate_signature_certificate", &Dtool_Multifile_validate_signature_certificate_1335, METH_O, (const char *)Dtool_Multifile_validate_signature_certificate_1335_comment},
  {"validateSignatureCertificate", &Dtool_Multifile_validate_signature_certificate_1335, METH_O, (const char *)Dtool_Multifile_validate_signature_certificate_1335_comment},
  {"flush", &Dtool_Multifile_flush_1336, METH_NOARGS, (const char *)Dtool_Multifile_flush_1336_comment},
  {"repack", &Dtool_Multifile_repack_1337, METH_NOARGS, (const char *)Dtool_Multifile_repack_1337_comment},
  {"get_num_subfiles", &Dtool_Multifile_get_num_subfiles_1338, METH_NOARGS, (const char *)Dtool_Multifile_get_num_subfiles_1338_comment},
  {"getNumSubfiles", &Dtool_Multifile_get_num_subfiles_1338, METH_NOARGS, (const char *)Dtool_Multifile_get_num_subfiles_1338_comment},
  {"find_subfile", &Dtool_Multifile_find_subfile_1339, METH_O, (const char *)Dtool_Multifile_find_subfile_1339_comment},
  {"findSubfile", &Dtool_Multifile_find_subfile_1339, METH_O, (const char *)Dtool_Multifile_find_subfile_1339_comment},
  {"has_directory", &Dtool_Multifile_has_directory_1340, METH_O, (const char *)Dtool_Multifile_has_directory_1340_comment},
  {"hasDirectory", &Dtool_Multifile_has_directory_1340, METH_O, (const char *)Dtool_Multifile_has_directory_1340_comment},
  {"remove_subfile", &Dtool_Multifile_remove_subfile_1342, METH_O, (const char *)Dtool_Multifile_remove_subfile_1342_comment},
  {"removeSubfile", &Dtool_Multifile_remove_subfile_1342, METH_O, (const char *)Dtool_Multifile_remove_subfile_1342_comment},
  {"get_subfile_name", &Dtool_Multifile_get_subfile_name_1343, METH_O, (const char *)Dtool_Multifile_get_subfile_name_1343_comment},
  {"getSubfileName", &Dtool_Multifile_get_subfile_name_1343, METH_O, (const char *)Dtool_Multifile_get_subfile_name_1343_comment},
  {"get_subfile_length", &Dtool_Multifile_get_subfile_length_1345, METH_O, (const char *)Dtool_Multifile_get_subfile_length_1345_comment},
  {"getSubfileLength", &Dtool_Multifile_get_subfile_length_1345, METH_O, (const char *)Dtool_Multifile_get_subfile_length_1345_comment},
  {"get_subfile_timestamp", &Dtool_Multifile_get_subfile_timestamp_1346, METH_O, (const char *)Dtool_Multifile_get_subfile_timestamp_1346_comment},
  {"getSubfileTimestamp", &Dtool_Multifile_get_subfile_timestamp_1346, METH_O, (const char *)Dtool_Multifile_get_subfile_timestamp_1346_comment},
  {"is_subfile_compressed", &Dtool_Multifile_is_subfile_compressed_1347, METH_O, (const char *)Dtool_Multifile_is_subfile_compressed_1347_comment},
  {"isSubfileCompressed", &Dtool_Multifile_is_subfile_compressed_1347, METH_O, (const char *)Dtool_Multifile_is_subfile_compressed_1347_comment},
  {"is_subfile_encrypted", &Dtool_Multifile_is_subfile_encrypted_1348, METH_O, (const char *)Dtool_Multifile_is_subfile_encrypted_1348_comment},
  {"isSubfileEncrypted", &Dtool_Multifile_is_subfile_encrypted_1348, METH_O, (const char *)Dtool_Multifile_is_subfile_encrypted_1348_comment},
  {"is_subfile_text", &Dtool_Multifile_is_subfile_text_1349, METH_O, (const char *)Dtool_Multifile_is_subfile_text_1349_comment},
  {"isSubfileText", &Dtool_Multifile_is_subfile_text_1349, METH_O, (const char *)Dtool_Multifile_is_subfile_text_1349_comment},
  {"get_index_end", &Dtool_Multifile_get_index_end_1350, METH_NOARGS, (const char *)Dtool_Multifile_get_index_end_1350_comment},
  {"getIndexEnd", &Dtool_Multifile_get_index_end_1350, METH_NOARGS, (const char *)Dtool_Multifile_get_index_end_1350_comment},
  {"get_subfile_internal_start", &Dtool_Multifile_get_subfile_internal_start_1351, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_start_1351_comment},
  {"getSubfileInternalStart", &Dtool_Multifile_get_subfile_internal_start_1351, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_start_1351_comment},
  {"get_subfile_internal_length", &Dtool_Multifile_get_subfile_internal_length_1352, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_length_1352_comment},
  {"getSubfileInternalLength", &Dtool_Multifile_get_subfile_internal_length_1352, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_length_1352_comment},
  {"read_subfile", &Dtool_Multifile_read_subfile_1353, METH_O, (const char *)Dtool_Multifile_read_subfile_1353_comment},
  {"readSubfile", &Dtool_Multifile_read_subfile_1353, METH_O, (const char *)Dtool_Multifile_read_subfile_1353_comment},
  {"open_read_subfile", &Dtool_Multifile_open_read_subfile_1354, METH_O, (const char *)Dtool_Multifile_open_read_subfile_1354_comment},
  {"openReadSubfile", &Dtool_Multifile_open_read_subfile_1354, METH_O, (const char *)Dtool_Multifile_open_read_subfile_1354_comment},
  {"close_read_subfile", &Dtool_Multifile_close_read_subfile_1355, METH_O | METH_STATIC, (const char *)Dtool_Multifile_close_read_subfile_1355_comment},
  {"closeReadSubfile", &Dtool_Multifile_close_read_subfile_1355, METH_O | METH_STATIC, (const char *)Dtool_Multifile_close_read_subfile_1355_comment},
  {"extract_subfile", (PyCFunction) &Dtool_Multifile_extract_subfile_1356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_1356_comment},
  {"extractSubfile", (PyCFunction) &Dtool_Multifile_extract_subfile_1356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_1356_comment},
  {"extract_subfile_to", (PyCFunction) &Dtool_Multifile_extract_subfile_to_1357, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_to_1357_comment},
  {"extractSubfileTo", (PyCFunction) &Dtool_Multifile_extract_subfile_to_1357, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_to_1357_comment},
  {"compare_subfile", (PyCFunction) &Dtool_Multifile_compare_subfile_1358, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_compare_subfile_1358_comment},
  {"compareSubfile", (PyCFunction) &Dtool_Multifile_compare_subfile_1358, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_compare_subfile_1358_comment},
  {"output", &Dtool_Multifile_output_1359, METH_O, (const char *)Dtool_Multifile_output_1359_comment},
  {"ls", (PyCFunction) &Dtool_Multifile_ls_1360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_ls_1360_comment},
  {"get_magic_number", &Dtool_Multifile_get_magic_number_1361, METH_NOARGS | METH_STATIC, (const char *)Dtool_Multifile_get_magic_number_1361_comment},
  {"getMagicNumber", &Dtool_Multifile_get_magic_number_1361, METH_NOARGS | METH_STATIC, (const char *)Dtool_Multifile_get_magic_number_1361_comment},
  {"set_header_prefix", &Dtool_Multifile_set_header_prefix_1362, METH_O, (const char *)Dtool_Multifile_set_header_prefix_1362_comment},
  {"setHeaderPrefix", &Dtool_Multifile_set_header_prefix_1362, METH_O, (const char *)Dtool_Multifile_set_header_prefix_1362_comment},
  {"get_header_prefix", &Dtool_Multifile_get_header_prefix_1363, METH_NOARGS, (const char *)Dtool_Multifile_get_header_prefix_1363_comment},
  {"getHeaderPrefix", &Dtool_Multifile_get_header_prefix_1363, METH_NOARGS, (const char *)Dtool_Multifile_get_header_prefix_1363_comment},
  {"get_subfile_names", (PyCFunction) &MakeSeq_Multifile_get_subfile_names, METH_NOARGS, NULL},
  { "getSubfileNames", (PyCFunction) &MakeSeq_Multifile_get_subfile_names, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Multifile
//////////////////
static PyObject *Dtool_Repr_Multifile(PyObject *self) {
  Multifile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Multifile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Multifile = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Multifile = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Multifile = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Multifile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Multifile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Multifile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_Multifile,
    &Dtool_NumberMethods_Multifile,
    &Dtool_SequenceMethods_Multifile,
    &Dtool_MappingMethods_Multifile,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_Multifile,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Multifile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A file that contains a set of files.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Multifile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Multifile,
    PyType_GenericAlloc,
    Dtool_new_Multifile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Multifile,
  Dtool_UpcastInterface_Multifile,
  Dtool_DowncastInterface_Multifile,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Multifile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(NULL);
    Dtool_Multifile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_Multifile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Multifile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Multifile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Multifile);
  }
}

/**
 * Python method tables for Namable (Namable)
 */
static PyMethodDef Dtool_Methods_Namable[] = {
  {"assign", &Dtool_Namable_operator_1366, METH_O, (const char *)Dtool_Namable_operator_1366_comment},
  {"set_name", &Dtool_Namable_set_name_1367, METH_O, (const char *)Dtool_Namable_set_name_1367_comment},
  {"setName", &Dtool_Namable_set_name_1367, METH_O, (const char *)Dtool_Namable_set_name_1367_comment},
  {"clear_name", &Dtool_Namable_clear_name_1368, METH_NOARGS, (const char *)Dtool_Namable_clear_name_1368_comment},
  {"clearName", &Dtool_Namable_clear_name_1368, METH_NOARGS, (const char *)Dtool_Namable_clear_name_1368_comment},
  {"has_name", &Dtool_Namable_has_name_1369, METH_NOARGS, (const char *)Dtool_Namable_has_name_1369_comment},
  {"hasName", &Dtool_Namable_has_name_1369, METH_NOARGS, (const char *)Dtool_Namable_has_name_1369_comment},
  {"get_name", &Dtool_Namable_get_name_1370, METH_NOARGS, (const char *)Dtool_Namable_get_name_1370_comment},
  {"getName", &Dtool_Namable_get_name_1370, METH_NOARGS, (const char *)Dtool_Namable_get_name_1370_comment},
  {"output", &Dtool_Namable_output_1372, METH_O, (const char *)Dtool_Namable_output_1372_comment},
  {"get_class_type", &Dtool_Namable_get_class_type_1373, METH_NOARGS | METH_STATIC, (const char *)Dtool_Namable_get_class_type_1373_comment},
  {"getClassType", &Dtool_Namable_get_class_type_1373, METH_NOARGS | METH_STATIC, (const char *)Dtool_Namable_get_class_type_1373_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     Namable
//////////////////
static PyObject *Dtool_Repr_Namable(PyObject *self) {
  Namable *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Namable[] = {
  {(char *)"name", &Dtool_Namable_name_Getter, &Dtool_Namable_name_Setter, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Namable = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Namable = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_Namable = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_Namable = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_Namable = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Namable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Namable,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_Namable,
    &Dtool_NumberMethods_Namable,
    &Dtool_SequenceMethods_Namable,
    &Dtool_MappingMethods_Namable,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_Namable,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_Namable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for all things which can have a name.  The name is either\n"
    " * empty or nonempty, but it is never NULL.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Namable,
    0, // tp_members
    Dtool_Properties_Namable,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Namable,
    PyType_GenericAlloc,
    Dtool_new_Namable,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Namable,
  Dtool_UpcastInterface_Namable,
  Dtool_DowncastInterface_Namable,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_Namable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Namable._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Namable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Namable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Namable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Namable);
  }
}

/**
 * Python method tables for SubfileInfo (SubfileInfo)
 */
static PyMethodDef Dtool_Methods_SubfileInfo[] = {
  {"assign", &Dtool_SubfileInfo_operator_1377, METH_O, (const char *)Dtool_SubfileInfo_operator_1377_comment},
  {"is_empty", &Dtool_SubfileInfo_is_empty_1378, METH_NOARGS, (const char *)Dtool_SubfileInfo_is_empty_1378_comment},
  {"isEmpty", &Dtool_SubfileInfo_is_empty_1378, METH_NOARGS, (const char *)Dtool_SubfileInfo_is_empty_1378_comment},
  {"get_file", &Dtool_SubfileInfo_get_file_1379, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_file_1379_comment},
  {"getFile", &Dtool_SubfileInfo_get_file_1379, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_file_1379_comment},
  {"get_filename", &Dtool_SubfileInfo_get_filename_1380, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_filename_1380_comment},
  {"getFilename", &Dtool_SubfileInfo_get_filename_1380, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_filename_1380_comment},
  {"get_start", &Dtool_SubfileInfo_get_start_1381, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_start_1381_comment},
  {"getStart", &Dtool_SubfileInfo_get_start_1381, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_start_1381_comment},
  {"get_size", &Dtool_SubfileInfo_get_size_1382, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_size_1382_comment},
  {"getSize", &Dtool_SubfileInfo_get_size_1382, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_size_1382_comment},
  {"output", &Dtool_SubfileInfo_output_1383, METH_O, (const char *)Dtool_SubfileInfo_output_1383_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     SubfileInfo
//////////////////
static PyObject *Dtool_Repr_SubfileInfo(PyObject *self) {
  SubfileInfo *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SubfileInfo = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_SubfileInfo = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.SubfileInfo",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_SubfileInfo,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_SubfileInfo,
    &Dtool_NumberMethods_SubfileInfo,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_SubfileInfo,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class records a particular byte sub-range within an existing file on\n"
    " * disk.  Generally, the filename is understood as a physical file on disk,\n"
    " * and not to be looked up via the vfs.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_SubfileInfo,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_SubfileInfo,
    PyType_GenericAlloc,
    Dtool_new_SubfileInfo,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SubfileInfo,
  Dtool_UpcastInterface_SubfileInfo,
  Dtool_DowncastInterface_SubfileInfo,
  (CoerceFunction)Dtool_ConstCoerce_SubfileInfo,
  (CoerceFunction)Dtool_Coerce_SubfileInfo,
};

static void Dtool_PyModuleClassInit_SubfileInfo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SubfileInfo._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_SubfileInfo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SubfileInfo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SubfileInfo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SubfileInfo);
  }
}

/**
 * Python method tables for VirtualFile (VirtualFile)
 */
static PyMethodDef Dtool_Methods_VirtualFile[] = {
  {"get_file_system", &Dtool_VirtualFile_get_file_system_1386, METH_NOARGS, (const char *)Dtool_VirtualFile_get_file_system_1386_comment},
  {"getFileSystem", &Dtool_VirtualFile_get_file_system_1386, METH_NOARGS, (const char *)Dtool_VirtualFile_get_file_system_1386_comment},
  {"get_filename", &Dtool_VirtualFile_get_filename_1387, METH_NOARGS, (const char *)Dtool_VirtualFile_get_filename_1387_comment},
  {"getFilename", &Dtool_VirtualFile_get_filename_1387, METH_NOARGS, (const char *)Dtool_VirtualFile_get_filename_1387_comment},
  {"get_original_filename", &Dtool_VirtualFile_get_original_filename_1388, METH_NOARGS, (const char *)Dtool_VirtualFile_get_original_filename_1388_comment},
  {"getOriginalFilename", &Dtool_VirtualFile_get_original_filename_1388, METH_NOARGS, (const char *)Dtool_VirtualFile_get_original_filename_1388_comment},
  {"has_file", &Dtool_VirtualFile_has_file_1389, METH_NOARGS, (const char *)Dtool_VirtualFile_has_file_1389_comment},
  {"hasFile", &Dtool_VirtualFile_has_file_1389, METH_NOARGS, (const char *)Dtool_VirtualFile_has_file_1389_comment},
  {"is_directory", &Dtool_VirtualFile_is_directory_1390, METH_NOARGS, (const char *)Dtool_VirtualFile_is_directory_1390_comment},
  {"isDirectory", &Dtool_VirtualFile_is_directory_1390, METH_NOARGS, (const char *)Dtool_VirtualFile_is_directory_1390_comment},
  {"is_regular_file", &Dtool_VirtualFile_is_regular_file_1391, METH_NOARGS, (const char *)Dtool_VirtualFile_is_regular_file_1391_comment},
  {"isRegularFile", &Dtool_VirtualFile_is_regular_file_1391, METH_NOARGS, (const char *)Dtool_VirtualFile_is_regular_file_1391_comment},
  {"is_writable", &Dtool_VirtualFile_is_writable_1392, METH_NOARGS, (const char *)Dtool_VirtualFile_is_writable_1392_comment},
  {"isWritable", &Dtool_VirtualFile_is_writable_1392, METH_NOARGS, (const char *)Dtool_VirtualFile_is_writable_1392_comment},
  {"delete_file", &Dtool_VirtualFile_delete_file_1393, METH_NOARGS, (const char *)Dtool_VirtualFile_delete_file_1393_comment},
  {"deleteFile", &Dtool_VirtualFile_delete_file_1393, METH_NOARGS, (const char *)Dtool_VirtualFile_delete_file_1393_comment},
  {"rename_file", &Dtool_VirtualFile_rename_file_1394, METH_O, (const char *)Dtool_VirtualFile_rename_file_1394_comment},
  {"renameFile", &Dtool_VirtualFile_rename_file_1394, METH_O, (const char *)Dtool_VirtualFile_rename_file_1394_comment},
  {"copy_file", &Dtool_VirtualFile_copy_file_1395, METH_O, (const char *)Dtool_VirtualFile_copy_file_1395_comment},
  {"copyFile", &Dtool_VirtualFile_copy_file_1395, METH_O, (const char *)Dtool_VirtualFile_copy_file_1395_comment},
  {"scan_directory", &Dtool_VirtualFile_scan_directory_1396, METH_NOARGS, (const char *)Dtool_VirtualFile_scan_directory_1396_comment},
  {"scanDirectory", &Dtool_VirtualFile_scan_directory_1396, METH_NOARGS, (const char *)Dtool_VirtualFile_scan_directory_1396_comment},
  {"output", &Dtool_VirtualFile_output_1397, METH_O, (const char *)Dtool_VirtualFile_output_1397_comment},
  {"ls", (PyCFunction) &Dtool_VirtualFile_ls_1398, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_ls_1398_comment},
  {"ls_all", (PyCFunction) &Dtool_VirtualFile_ls_all_1399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_ls_all_1399_comment},
  {"lsAll", (PyCFunction) &Dtool_VirtualFile_ls_all_1399, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_ls_all_1399_comment},
  {"read_file", &Dtool_VirtualFile_read_file_1400, METH_O, (const char *)Dtool_VirtualFile_read_file_1400_comment},
  {"readFile", &Dtool_VirtualFile_read_file_1400, METH_O, (const char *)Dtool_VirtualFile_read_file_1400_comment},
  {"open_read_file", &Dtool_VirtualFile_open_read_file_1401, METH_O, (const char *)Dtool_VirtualFile_open_read_file_1401_comment},
  {"openReadFile", &Dtool_VirtualFile_open_read_file_1401, METH_O, (const char *)Dtool_VirtualFile_open_read_file_1401_comment},
  {"close_read_file", &Dtool_VirtualFile_close_read_file_1402, METH_O, (const char *)Dtool_VirtualFile_close_read_file_1402_comment},
  {"closeReadFile", &Dtool_VirtualFile_close_read_file_1402, METH_O, (const char *)Dtool_VirtualFile_close_read_file_1402_comment},
  {"was_read_successful", &Dtool_VirtualFile_was_read_successful_1403, METH_NOARGS, (const char *)Dtool_VirtualFile_was_read_successful_1403_comment},
  {"wasReadSuccessful", &Dtool_VirtualFile_was_read_successful_1403, METH_NOARGS, (const char *)Dtool_VirtualFile_was_read_successful_1403_comment},
  {"write_file", (PyCFunction) &Dtool_VirtualFile_write_file_1404, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_write_file_1404_comment},
  {"writeFile", (PyCFunction) &Dtool_VirtualFile_write_file_1404, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_write_file_1404_comment},
  {"open_write_file", (PyCFunction) &Dtool_VirtualFile_open_write_file_1405, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_open_write_file_1405_comment},
  {"openWriteFile", (PyCFunction) &Dtool_VirtualFile_open_write_file_1405, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_open_write_file_1405_comment},
  {"open_append_file", &Dtool_VirtualFile_open_append_file_1406, METH_NOARGS, (const char *)Dtool_VirtualFile_open_append_file_1406_comment},
  {"openAppendFile", &Dtool_VirtualFile_open_append_file_1406, METH_NOARGS, (const char *)Dtool_VirtualFile_open_append_file_1406_comment},
  {"close_write_file", &Dtool_VirtualFile_close_write_file_1407, METH_O, (const char *)Dtool_VirtualFile_close_write_file_1407_comment},
  {"closeWriteFile", &Dtool_VirtualFile_close_write_file_1407, METH_O, (const char *)Dtool_VirtualFile_close_write_file_1407_comment},
  {"open_read_write_file", &Dtool_VirtualFile_open_read_write_file_1408, METH_O, (const char *)Dtool_VirtualFile_open_read_write_file_1408_comment},
  {"openReadWriteFile", &Dtool_VirtualFile_open_read_write_file_1408, METH_O, (const char *)Dtool_VirtualFile_open_read_write_file_1408_comment},
  {"open_read_append_file", &Dtool_VirtualFile_open_read_append_file_1409, METH_NOARGS, (const char *)Dtool_VirtualFile_open_read_append_file_1409_comment},
  {"openReadAppendFile", &Dtool_VirtualFile_open_read_append_file_1409, METH_NOARGS, (const char *)Dtool_VirtualFile_open_read_append_file_1409_comment},
  {"close_read_write_file", &Dtool_VirtualFile_close_read_write_file_1410, METH_O, (const char *)Dtool_VirtualFile_close_read_write_file_1410_comment},
  {"closeReadWriteFile", &Dtool_VirtualFile_close_read_write_file_1410, METH_O, (const char *)Dtool_VirtualFile_close_read_write_file_1410_comment},
  {"get_file_size", &Dtool_VirtualFile_get_file_size_1411, METH_VARARGS, (const char *)Dtool_VirtualFile_get_file_size_1411_comment},
  {"getFileSize", &Dtool_VirtualFile_get_file_size_1411, METH_VARARGS, (const char *)Dtool_VirtualFile_get_file_size_1411_comment},
  {"get_timestamp", &Dtool_VirtualFile_get_timestamp_1412, METH_NOARGS, (const char *)Dtool_VirtualFile_get_timestamp_1412_comment},
  {"getTimestamp", &Dtool_VirtualFile_get_timestamp_1412, METH_NOARGS, (const char *)Dtool_VirtualFile_get_timestamp_1412_comment},
  {"get_system_info", &Dtool_VirtualFile_get_system_info_1413, METH_O, (const char *)Dtool_VirtualFile_get_system_info_1413_comment},
  {"getSystemInfo", &Dtool_VirtualFile_get_system_info_1413, METH_O, (const char *)Dtool_VirtualFile_get_system_info_1413_comment},
  {"get_class_type", &Dtool_VirtualFile_get_class_type_1414, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFile_get_class_type_1414_comment},
  {"getClassType", &Dtool_VirtualFile_get_class_type_1414, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFile_get_class_type_1414_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     VirtualFile
//////////////////
static PyObject *Dtool_Repr_VirtualFile(PyObject *self) {
  VirtualFile *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_VirtualFile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFile = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFile = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFile = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_VirtualFile,
    &Dtool_NumberMethods_VirtualFile,
    &Dtool_SequenceMethods_VirtualFile,
    &Dtool_MappingMethods_VirtualFile,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_VirtualFile,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for a file or directory within the\n"
    " * VirtualFileSystem.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFile,
    PyType_GenericAlloc,
    Dtool_new_VirtualFile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFile,
  Dtool_UpcastInterface_VirtualFile,
  Dtool_DowncastInterface_VirtualFile,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedReferenceCount(NULL);
    Dtool_VirtualFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFile);
  }
}

/**
 * Python method tables for VirtualFileComposite (VirtualFileComposite)
 */
static PyMethodDef Dtool_Methods_VirtualFileComposite[] = {
  {"get_class_type", &Dtool_VirtualFileComposite_get_class_type_1417, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileComposite_get_class_type_1417_comment},
  {"getClassType", &Dtool_VirtualFileComposite_get_class_type_1417, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileComposite_get_class_type_1417_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileComposite = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileComposite = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileComposite = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileComposite = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileComposite = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileComposite",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileComposite,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileComposite,
    &Dtool_SequenceMethods_VirtualFileComposite,
    &Dtool_MappingMethods_VirtualFileComposite,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileComposite,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A composite directory within the VirtualFileSystem: this maps to more than\n"
    " * one directory on different mount points.  The resulting directory appears\n"
    " * to be the union of all the individual simple directories.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileComposite,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileComposite,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileComposite,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileComposite,
  Dtool_UpcastInterface_VirtualFileComposite,
  Dtool_DowncastInterface_VirtualFileComposite,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileComposite(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFile(NULL);
    Dtool_VirtualFileComposite._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFile);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileComposite._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileComposite) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileComposite)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileComposite);
  }
}

/**
 * Python method tables for VirtualFileMount (VirtualFileMount)
 */
static PyMethodDef Dtool_Methods_VirtualFileMount[] = {
  {"get_file_system", &Dtool_VirtualFileMount_get_file_system_1420, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_file_system_1420_comment},
  {"getFileSystem", &Dtool_VirtualFileMount_get_file_system_1420, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_file_system_1420_comment},
  {"get_mount_point", &Dtool_VirtualFileMount_get_mount_point_1421, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_point_1421_comment},
  {"getMountPoint", &Dtool_VirtualFileMount_get_mount_point_1421, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_point_1421_comment},
  {"get_mount_flags", &Dtool_VirtualFileMount_get_mount_flags_1422, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_flags_1422_comment},
  {"getMountFlags", &Dtool_VirtualFileMount_get_mount_flags_1422, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_flags_1422_comment},
  {"output", &Dtool_VirtualFileMount_output_1423, METH_O, (const char *)Dtool_VirtualFileMount_output_1423_comment},
  {"write", &Dtool_VirtualFileMount_write_1424, METH_O, (const char *)Dtool_VirtualFileMount_write_1424_comment},
  {"get_class_type", &Dtool_VirtualFileMount_get_class_type_1425, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMount_get_class_type_1425_comment},
  {"getClassType", &Dtool_VirtualFileMount_get_class_type_1425, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMount_get_class_type_1425_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     VirtualFileMount
//////////////////
static PyObject *Dtool_Repr_VirtualFileMount(PyObject *self) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     VirtualFileMount
//////////////////
static PyObject *Dtool_Str_VirtualFileMount(PyObject *self) {
  VirtualFileMount *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_VirtualFileMount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileMount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileMount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_VirtualFileMount,
    &Dtool_NumberMethods_VirtualFileMount,
    &Dtool_SequenceMethods_VirtualFileMount,
    &Dtool_MappingMethods_VirtualFileMount,
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_VirtualFileMount,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileMount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for a mount definition used within a\n"
    " * VirtualFileSystem.  Normally users don't need to monkey with this class\n"
    " * directly.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileMount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMount,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMount,
  Dtool_UpcastInterface_VirtualFileMount,
  Dtool_DowncastInterface_VirtualFileMount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileMount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedReferenceCount(NULL);
    Dtool_VirtualFileMount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMount);
  }
}

/**
 * Python method tables for VirtualFileMountMultifile (VirtualFileMountMultifile)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountMultifile[] = {
  {"get_multifile", &Dtool_VirtualFileMountMultifile_get_multifile_1428, METH_NOARGS, (const char *)Dtool_VirtualFileMountMultifile_get_multifile_1428_comment},
  {"getMultifile", &Dtool_VirtualFileMountMultifile_get_multifile_1428, METH_NOARGS, (const char *)Dtool_VirtualFileMountMultifile_get_multifile_1428_comment},
  {"get_class_type", &Dtool_VirtualFileMountMultifile_get_class_type_1429, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountMultifile_get_class_type_1429_comment},
  {"getClassType", &Dtool_VirtualFileMountMultifile_get_class_type_1429, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountMultifile_get_class_type_1429_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountMultifile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountMultifile = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountMultifile = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountMultifile = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileMountMultifile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileMountMultifile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountMultifile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileMountMultifile,
    &Dtool_SequenceMethods_VirtualFileMountMultifile,
    &Dtool_MappingMethods_VirtualFileMountMultifile,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileMountMultifile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Maps a Multifile's contents into the VirtualFileSystem.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileMountMultifile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountMultifile,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountMultifile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountMultifile,
  Dtool_UpcastInterface_VirtualFileMountMultifile,
  Dtool_DowncastInterface_VirtualFileMountMultifile,
  (CoerceFunction)Dtool_ConstCoerce_VirtualFileMountMultifile,
  (CoerceFunction)Dtool_Coerce_VirtualFileMountMultifile,
};

static void Dtool_PyModuleClassInit_VirtualFileMountMultifile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFileMount(NULL);
    Dtool_VirtualFileMountMultifile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFileMount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountMultifile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountMultifile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountMultifile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountMultifile);
  }
}

/**
 * Python method tables for VirtualFileMountRamdisk (VirtualFileMountRamdisk)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountRamdisk[] = {
  {"get_class_type", &Dtool_VirtualFileMountRamdisk_get_class_type_1432, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountRamdisk_get_class_type_1432_comment},
  {"getClassType", &Dtool_VirtualFileMountRamdisk_get_class_type_1432, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountRamdisk_get_class_type_1432_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountRamdisk = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountRamdisk = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountRamdisk = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountRamdisk = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileMountRamdisk = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileMountRamdisk",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountRamdisk,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileMountRamdisk,
    &Dtool_SequenceMethods_VirtualFileMountRamdisk,
    &Dtool_MappingMethods_VirtualFileMountRamdisk,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileMountRamdisk,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Simulates an actual directory on disk with in-memory storage.  This is\n"
    " * useful mainly for performing high level functions that expect disk I/O\n"
    " * without actually writing files to disk.  Naturally, there are significant\n"
    " * limits to the size of the files that may be written with this system; and\n"
    " * \"files\" written here are not automatically persistent between sessions.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileMountRamdisk,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountRamdisk,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountRamdisk,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountRamdisk,
  Dtool_UpcastInterface_VirtualFileMountRamdisk,
  Dtool_DowncastInterface_VirtualFileMountRamdisk,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileMountRamdisk(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFileMount(NULL);
    Dtool_VirtualFileMountRamdisk._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFileMount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountRamdisk._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountRamdisk) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountRamdisk)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountRamdisk);
  }
}

/**
 * Python method tables for VirtualFileMountSystem (VirtualFileMountSystem)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountSystem[] = {
  {"get_physical_filename", &Dtool_VirtualFileMountSystem_get_physical_filename_1436, METH_NOARGS, (const char *)Dtool_VirtualFileMountSystem_get_physical_filename_1436_comment},
  {"getPhysicalFilename", &Dtool_VirtualFileMountSystem_get_physical_filename_1436, METH_NOARGS, (const char *)Dtool_VirtualFileMountSystem_get_physical_filename_1436_comment},
  {"get_class_type", &Dtool_VirtualFileMountSystem_get_class_type_1437, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountSystem_get_class_type_1437_comment},
  {"getClassType", &Dtool_VirtualFileMountSystem_get_class_type_1437, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountSystem_get_class_type_1437_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountSystem = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountSystem = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountSystem = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountSystem = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileMountSystem = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileMountSystem",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountSystem,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileMountSystem,
    &Dtool_SequenceMethods_VirtualFileMountSystem,
    &Dtool_MappingMethods_VirtualFileMountSystem,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileMountSystem,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Maps an actual OS directory into the VirtualFileSystem.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileMountSystem,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountSystem,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountSystem,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountSystem,
  Dtool_UpcastInterface_VirtualFileMountSystem,
  Dtool_DowncastInterface_VirtualFileMountSystem,
  (CoerceFunction)Dtool_ConstCoerce_VirtualFileMountSystem,
  (CoerceFunction)Dtool_Coerce_VirtualFileMountSystem,
};

static void Dtool_PyModuleClassInit_VirtualFileMountSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFileMount(NULL);
    Dtool_VirtualFileMountSystem._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFileMount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountSystem);
  }
}

/**
 * Python method tables for VirtualFileSimple (VirtualFileSimple)
 */
static PyMethodDef Dtool_Methods_VirtualFileSimple[] = {
  {"get_mount", &Dtool_VirtualFileSimple_get_mount_1440, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_get_mount_1440_comment},
  {"getMount", &Dtool_VirtualFileSimple_get_mount_1440, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_get_mount_1440_comment},
  {"is_implicit_pz_file", &Dtool_VirtualFileSimple_is_implicit_pz_file_1441, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_is_implicit_pz_file_1441_comment},
  {"isImplicitPzFile", &Dtool_VirtualFileSimple_is_implicit_pz_file_1441, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_is_implicit_pz_file_1441_comment},
  {"get_class_type", &Dtool_VirtualFileSimple_get_class_type_1442, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSimple_get_class_type_1442_comment},
  {"getClassType", &Dtool_VirtualFileSimple_get_class_type_1442, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSimple_get_class_type_1442_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileSimple = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileSimple = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileSimple = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileSimple = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileSimple = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileSimple",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileSimple,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileSimple,
    &Dtool_SequenceMethods_VirtualFileSimple,
    &Dtool_MappingMethods_VirtualFileSimple,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileSimple,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A simple file or directory within the VirtualFileSystem: this maps to\n"
    " * exactly one file on one mount point.  Most directories, and all regular\n"
    " * files, are of this kind.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileSimple,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileSimple,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileSimple,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileSimple,
  Dtool_UpcastInterface_VirtualFileSimple,
  Dtool_DowncastInterface_VirtualFileSimple,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileSimple(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFile(NULL);
    Dtool_VirtualFileSimple._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFile);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileSimple._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileSimple) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileSimple)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileSimple);
  }
}

/**
 * Python method tables for TemporaryFile (TemporaryFile)
 */
static PyMethodDef Dtool_Methods_TemporaryFile[] = {
  {"get_class_type", &Dtool_TemporaryFile_get_class_type_1446, METH_NOARGS | METH_STATIC, (const char *)Dtool_TemporaryFile_get_class_type_1446_comment},
  {"getClassType", &Dtool_TemporaryFile_get_class_type_1446, METH_NOARGS | METH_STATIC, (const char *)Dtool_TemporaryFile_get_class_type_1446_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_TemporaryFile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TemporaryFile = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_TemporaryFile = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_TemporaryFile = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_TemporaryFile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TemporaryFile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TemporaryFile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TemporaryFile,
    &Dtool_SequenceMethods_TemporaryFile,
    &Dtool_MappingMethods_TemporaryFile,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_TemporaryFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of FileReference class that automatically deletes\n"
    " * the file in question when it is deleted.  It is not responsible for\n"
    " * creating, opening, or closing the file, however.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TemporaryFile,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TemporaryFile,
    PyType_GenericAlloc,
    Dtool_new_TemporaryFile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TemporaryFile,
  Dtool_UpcastInterface_TemporaryFile,
  Dtool_DowncastInterface_TemporaryFile,
  (CoerceFunction)Dtool_ConstCoerce_TemporaryFile,
  (CoerceFunction)Dtool_Coerce_TemporaryFile,
};

static void Dtool_PyModuleClassInit_TemporaryFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FileReference(NULL);
    Dtool_TemporaryFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FileReference);
    PyObject *dict = PyDict_New();
    Dtool_TemporaryFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TemporaryFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TemporaryFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TemporaryFile);
  }
}

/**
 * Python method tables for IDecompressStream (IDecompressStream)
 */
static PyMethodDef Dtool_Methods_IDecompressStream[] = {
  {"open", (PyCFunction) &Dtool_IDecompressStream_open_1449, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IDecompressStream_open_1449_comment},
  {"close", &Dtool_IDecompressStream_close_1450, METH_NOARGS, (const char *)Dtool_IDecompressStream_close_1450_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_IDecompressStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IDecompressStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_IDecompressStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_IDecompressStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_IDecompressStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.IDecompressStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_IDecompressStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_IDecompressStream,
    &Dtool_SequenceMethods_IDecompressStream,
    &Dtool_MappingMethods_IDecompressStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_IDecompressStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses zlib to decompress (inflate) the input\n"
    " * from another source stream on-the-fly.\n"
    " *\n"
    " * Attach an IDecompressStream to an existing istream that provides compressed\n"
    " * data, and read the corresponding uncompressed data from the\n"
    " * IDecompressStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_IDecompressStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_IDecompressStream,
    PyType_GenericAlloc,
    Dtool_new_IDecompressStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IDecompressStream,
  Dtool_UpcastInterface_IDecompressStream,
  Dtool_DowncastInterface_IDecompressStream,
  (CoerceFunction)Dtool_ConstCoerce_IDecompressStream,
  (CoerceFunction)Dtool_Coerce_IDecompressStream,
};

static void Dtool_PyModuleClassInit_IDecompressStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_istream(NULL);
    Dtool_IDecompressStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_istream);
    PyObject *dict = PyDict_New();
    Dtool_IDecompressStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IDecompressStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IDecompressStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IDecompressStream);
  }
}

/**
 * Python method tables for OCompressStream (OCompressStream)
 */
static PyMethodDef Dtool_Methods_OCompressStream[] = {
  {"open", (PyCFunction) &Dtool_OCompressStream_open_1454, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OCompressStream_open_1454_comment},
  {"close", &Dtool_OCompressStream_close_1455, METH_NOARGS, (const char *)Dtool_OCompressStream_close_1455_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_OCompressStream = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OCompressStream = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_OCompressStream = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_OCompressStream = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_OCompressStream = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.OCompressStream",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_OCompressStream,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_OCompressStream,
    &Dtool_SequenceMethods_OCompressStream,
    &Dtool_MappingMethods_OCompressStream,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_OCompressStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses zlib to compress (deflate) data to another\n"
    " * destination stream on-the-fly.\n"
    " *\n"
    " * Attach an OCompressStream to an existing ostream that will accept\n"
    " * compressed data, and write your uncompressed source data to the\n"
    " * OCompressStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_OCompressStream,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_OCompressStream,
    PyType_GenericAlloc,
    Dtool_new_OCompressStream,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OCompressStream,
  Dtool_UpcastInterface_OCompressStream,
  Dtool_DowncastInterface_OCompressStream,
  (CoerceFunction)Dtool_ConstCoerce_OCompressStream,
  (CoerceFunction)Dtool_Coerce_OCompressStream,
};

static void Dtool_PyModuleClassInit_OCompressStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ostream(NULL);
    Dtool_OCompressStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ostream);
    PyObject *dict = PyDict_New();
    Dtool_OCompressStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OCompressStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OCompressStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OCompressStream);
  }
}

/**
 * Python method tables for VirtualFileList (VirtualFileList)
 */
static PyMethodDef Dtool_Methods_VirtualFileList[] = {
  {"get_num_files", &Dtool_VirtualFileList_get_num_files_1458, METH_NOARGS, (const char *)Dtool_VirtualFileList_get_num_files_1458_comment},
  {"getNumFiles", &Dtool_VirtualFileList_get_num_files_1458, METH_NOARGS, (const char *)Dtool_VirtualFileList_get_num_files_1458_comment},
  {"get_file", &Dtool_VirtualFileList_get_file_1459, METH_O, (const char *)Dtool_VirtualFileList_get_file_1459_comment},
  {"getFile", &Dtool_VirtualFileList_get_file_1459, METH_O, (const char *)Dtool_VirtualFileList_get_file_1459_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_files", (PyCFunction) &MakeSeq_VirtualFileList_get_files, METH_NOARGS, NULL},
  { "getFiles", (PyCFunction) &MakeSeq_VirtualFileList_get_files, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot nb_add -> operator +
//////////////////
static PyObject *Dtool_VirtualFileList_operator_1464_nb_add(PyObject *self, PyObject *arg) {
  VirtualFileList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_VirtualFileList, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline VirtualFileList VirtualFileList::operator +(VirtualFileList const &other) const
  VirtualFileList const *arg_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileList, 1, "VirtualFileList.__add__", true, true);
  if (arg_this != NULL) {
    VirtualFileList *return_value = new VirtualFileList((*(const VirtualFileList*)local_this).operator +(*arg_this));
    if (return_value == NULL) {
      return PyErr_NoMemory();
    }
    if (return_value != (VirtualFileList *)NULL) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (notify->has_assert_failed()) {
      if (return_value != (VirtualFileList *)NULL) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileList, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_VirtualFileList_operator_1463_nb_inplace_add(PyObject *self, PyObject *arg) {
  VirtualFileList *local_this = NULL;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_VirtualFileList, (void **)&local_this);
  if (local_this == NULL) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if (!((Dtool_PyInstDef *)self)->_is_const) {
    // 1-inline void VirtualFileList::operator +=(VirtualFileList const &other)
    VirtualFileList const *arg_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileList, 1, "VirtualFileList.__iadd__", true, true);
    if (arg_this != NULL) {
      (*local_this).operator +=(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (notify->has_assert_failed()) {
        return Dtool_Raise_AssertionError();
      }
#endif
      Py_INCREF(self);
      return self;
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call VirtualFileList.__iadd__() on a const object.");
#endif
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot sq_item -> operator []
//////////////////
static PyObject *Dtool_VirtualFileList_operator_1461_sq_item(PyObject *self, Py_ssize_t index) {
  VirtualFileList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return NULL;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "VirtualFileList index out of range");
    return NULL;
  }
  // 1-inline VirtualFile *VirtualFileList::operator [](std::size_t n) const
  VirtualFile *return_value = (*(const VirtualFileList*)local_this).operator [](index);
  if (return_value != (VirtualFile *)NULL) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (notify->has_assert_failed()) {
    if (return_value != (VirtualFile *)NULL) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == NULL) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFile, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(VirtualFileList self, index)\n");
  }
  return NULL;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_VirtualFileList_size_1462_sq_length(PyObject *self) {
  VirtualFileList *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_VirtualFileList = {
  &Dtool_VirtualFileList_operator_1464_nb_add,
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  &Dtool_VirtualFileList_operator_1463_nb_inplace_add,
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileList = {
  &Dtool_VirtualFileList_size_1462_sq_length,
  0, // sq_concat
  0, // sq_repeat
  &Dtool_VirtualFileList_operator_1461_sq_item,
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileList = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileList = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileList = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileList",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileList,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileList,
    &Dtool_SequenceMethods_VirtualFileList,
    &Dtool_MappingMethods_VirtualFileList,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_VirtualFileList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A list of VirtualFiles, as returned by VirtualFile::scan_directory().\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileList,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileList,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileList,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileList,
  Dtool_UpcastInterface_VirtualFileList,
  Dtool_DowncastInterface_VirtualFileList,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(NULL);
    Dtool_VirtualFileList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileList);
  }
}

/**
 * Python method tables for VirtualFileSystem (VirtualFileSystem)
 */
static PyMethodDef Dtool_Methods_VirtualFileSystem[] = {
  {"mount", (PyCFunction) &Dtool_VirtualFileSystem_mount_1470, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_mount_1470_comment},
  {"mount_loop", (PyCFunction) &Dtool_VirtualFileSystem_mount_loop_1471, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_mount_loop_1471_comment},
  {"mountLoop", (PyCFunction) &Dtool_VirtualFileSystem_mount_loop_1471, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_mount_loop_1471_comment},
  {"unmount", &Dtool_VirtualFileSystem_unmount_1472, METH_O, (const char *)Dtool_VirtualFileSystem_unmount_1472_comment},
  {"unmount_point", &Dtool_VirtualFileSystem_unmount_point_1473, METH_O, (const char *)Dtool_VirtualFileSystem_unmount_point_1473_comment},
  {"unmountPoint", &Dtool_VirtualFileSystem_unmount_point_1473, METH_O, (const char *)Dtool_VirtualFileSystem_unmount_point_1473_comment},
  {"unmount_all", &Dtool_VirtualFileSystem_unmount_all_1474, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_unmount_all_1474_comment},
  {"unmountAll", &Dtool_VirtualFileSystem_unmount_all_1474, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_unmount_all_1474_comment},
  {"get_num_mounts", &Dtool_VirtualFileSystem_get_num_mounts_1475, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_num_mounts_1475_comment},
  {"getNumMounts", &Dtool_VirtualFileSystem_get_num_mounts_1475, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_num_mounts_1475_comment},
  {"get_mount", &Dtool_VirtualFileSystem_get_mount_1476, METH_O, (const char *)Dtool_VirtualFileSystem_get_mount_1476_comment},
  {"getMount", &Dtool_VirtualFileSystem_get_mount_1476, METH_O, (const char *)Dtool_VirtualFileSystem_get_mount_1476_comment},
  {"chdir", &Dtool_VirtualFileSystem_chdir_1489, METH_O, (const char *)Dtool_VirtualFileSystem_chdir_1489_comment},
  {"get_cwd", &Dtool_VirtualFileSystem_get_cwd_1490, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_cwd_1490_comment},
  {"getCwd", &Dtool_VirtualFileSystem_get_cwd_1490, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_cwd_1490_comment},
  {"make_directory", &Dtool_VirtualFileSystem_make_directory_1491, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_1491_comment},
  {"makeDirectory", &Dtool_VirtualFileSystem_make_directory_1491, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_1491_comment},
  {"make_directory_full", &Dtool_VirtualFileSystem_make_directory_full_1492, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_full_1492_comment},
  {"makeDirectoryFull", &Dtool_VirtualFileSystem_make_directory_full_1492, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_full_1492_comment},
  {"get_file", (PyCFunction) &Dtool_VirtualFileSystem_get_file_1493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_get_file_1493_comment},
  {"getFile", (PyCFunction) &Dtool_VirtualFileSystem_get_file_1493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_get_file_1493_comment},
  {"create_file", &Dtool_VirtualFileSystem_create_file_1494, METH_O, (const char *)Dtool_VirtualFileSystem_create_file_1494_comment},
  {"createFile", &Dtool_VirtualFileSystem_create_file_1494, METH_O, (const char *)Dtool_VirtualFileSystem_create_file_1494_comment},
  {"find_file", (PyCFunction) &Dtool_VirtualFileSystem_find_file_1495, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_file_1495_comment},
  {"findFile", (PyCFunction) &Dtool_VirtualFileSystem_find_file_1495, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_file_1495_comment},
  {"delete_file", &Dtool_VirtualFileSystem_delete_file_1496, METH_O, (const char *)Dtool_VirtualFileSystem_delete_file_1496_comment},
  {"deleteFile", &Dtool_VirtualFileSystem_delete_file_1496, METH_O, (const char *)Dtool_VirtualFileSystem_delete_file_1496_comment},
  {"rename_file", (PyCFunction) &Dtool_VirtualFileSystem_rename_file_1497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_rename_file_1497_comment},
  {"renameFile", (PyCFunction) &Dtool_VirtualFileSystem_rename_file_1497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_rename_file_1497_comment},
  {"copy_file", (PyCFunction) &Dtool_VirtualFileSystem_copy_file_1498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_copy_file_1498_comment},
  {"copyFile", (PyCFunction) &Dtool_VirtualFileSystem_copy_file_1498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_copy_file_1498_comment},
  {"resolve_filename", (PyCFunction) &Dtool_VirtualFileSystem_resolve_filename_1499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_resolve_filename_1499_comment},
  {"resolveFilename", (PyCFunction) &Dtool_VirtualFileSystem_resolve_filename_1499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_resolve_filename_1499_comment},
  {"find_all_files", (PyCFunction) &Dtool_VirtualFileSystem_find_all_files_1500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_all_files_1500_comment},
  {"findAllFiles", (PyCFunction) &Dtool_VirtualFileSystem_find_all_files_1500, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_all_files_1500_comment},
  {"exists", &Dtool_VirtualFileSystem_exists_1501, METH_O, (const char *)Dtool_VirtualFileSystem_exists_1501_comment},
  {"is_directory", &Dtool_VirtualFileSystem_is_directory_1502, METH_O, (const char *)Dtool_VirtualFileSystem_is_directory_1502_comment},
  {"isDirectory", &Dtool_VirtualFileSystem_is_directory_1502, METH_O, (const char *)Dtool_VirtualFileSystem_is_directory_1502_comment},
  {"is_regular_file", &Dtool_VirtualFileSystem_is_regular_file_1503, METH_O, (const char *)Dtool_VirtualFileSystem_is_regular_file_1503_comment},
  {"isRegularFile", &Dtool_VirtualFileSystem_is_regular_file_1503, METH_O, (const char *)Dtool_VirtualFileSystem_is_regular_file_1503_comment},
  {"scan_directory", &Dtool_VirtualFileSystem_scan_directory_1504, METH_O, (const char *)Dtool_VirtualFileSystem_scan_directory_1504_comment},
  {"scanDirectory", &Dtool_VirtualFileSystem_scan_directory_1504, METH_O, (const char *)Dtool_VirtualFileSystem_scan_directory_1504_comment},
  {"ls", &Dtool_VirtualFileSystem_ls_1505, METH_O, (const char *)Dtool_VirtualFileSystem_ls_1505_comment},
  {"ls_all", &Dtool_VirtualFileSystem_ls_all_1506, METH_O, (const char *)Dtool_VirtualFileSystem_ls_all_1506_comment},
  {"lsAll", &Dtool_VirtualFileSystem_ls_all_1506, METH_O, (const char *)Dtool_VirtualFileSystem_ls_all_1506_comment},
  {"write", &Dtool_VirtualFileSystem_write_1507, METH_O, (const char *)Dtool_VirtualFileSystem_write_1507_comment},
  {"get_global_ptr", &Dtool_VirtualFileSystem_get_global_ptr_1508, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSystem_get_global_ptr_1508_comment},
  {"getGlobalPtr", &Dtool_VirtualFileSystem_get_global_ptr_1508, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSystem_get_global_ptr_1508_comment},
  {"read_file", (PyCFunction) &Dtool_VirtualFileSystem_read_file_1509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_read_file_1509_comment},
  {"readFile", (PyCFunction) &Dtool_VirtualFileSystem_read_file_1509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_read_file_1509_comment},
  {"open_read_file", (PyCFunction) &Dtool_VirtualFileSystem_open_read_file_1510, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_file_1510_comment},
  {"openReadFile", (PyCFunction) &Dtool_VirtualFileSystem_open_read_file_1510, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_file_1510_comment},
  {"close_read_file", &Dtool_VirtualFileSystem_close_read_file_1511, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_file_1511_comment},
  {"closeReadFile", &Dtool_VirtualFileSystem_close_read_file_1511, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_file_1511_comment},
  {"write_file", (PyCFunction) &Dtool_VirtualFileSystem_write_file_1512, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_write_file_1512_comment},
  {"writeFile", (PyCFunction) &Dtool_VirtualFileSystem_write_file_1512, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_write_file_1512_comment},
  {"open_write_file", (PyCFunction) &Dtool_VirtualFileSystem_open_write_file_1513, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_write_file_1513_comment},
  {"openWriteFile", (PyCFunction) &Dtool_VirtualFileSystem_open_write_file_1513, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_write_file_1513_comment},
  {"open_append_file", &Dtool_VirtualFileSystem_open_append_file_1514, METH_O, (const char *)Dtool_VirtualFileSystem_open_append_file_1514_comment},
  {"openAppendFile", &Dtool_VirtualFileSystem_open_append_file_1514, METH_O, (const char *)Dtool_VirtualFileSystem_open_append_file_1514_comment},
  {"close_write_file", &Dtool_VirtualFileSystem_close_write_file_1515, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_write_file_1515_comment},
  {"closeWriteFile", &Dtool_VirtualFileSystem_close_write_file_1515, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_write_file_1515_comment},
  {"open_read_write_file", (PyCFunction) &Dtool_VirtualFileSystem_open_read_write_file_1516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_write_file_1516_comment},
  {"openReadWriteFile", (PyCFunction) &Dtool_VirtualFileSystem_open_read_write_file_1516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_write_file_1516_comment},
  {"open_read_append_file", &Dtool_VirtualFileSystem_open_read_append_file_1517, METH_O, (const char *)Dtool_VirtualFileSystem_open_read_append_file_1517_comment},
  {"openReadAppendFile", &Dtool_VirtualFileSystem_open_read_append_file_1517, METH_O, (const char *)Dtool_VirtualFileSystem_open_read_append_file_1517_comment},
  {"close_read_write_file", &Dtool_VirtualFileSystem_close_read_write_file_1518, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_write_file_1518_comment},
  {"closeReadWriteFile", &Dtool_VirtualFileSystem_close_read_write_file_1518, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_write_file_1518_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {"get_mounts", (PyCFunction) &MakeSeq_VirtualFileSystem_get_mounts, METH_NOARGS, NULL},
  { "getMounts", (PyCFunction) &MakeSeq_VirtualFileSystem_get_mounts, METH_NOARGS, NULL},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __str__ function
//     VirtualFileSystem
//////////////////
static PyObject *Dtool_Str_VirtualFileSystem(PyObject *self) {
  VirtualFileSystem *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_VirtualFileSystem[] = {
  {(char *)"mounts", &Dtool_VirtualFileSystem_mounts_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileSystem = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileSystem = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.VirtualFileSystem",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileSystem,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_VirtualFileSystem,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    &Dtool_Str_VirtualFileSystem,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A hierarchy of directories and files that appears to be one continuous file\n"
    " * system, even though the files may originate from several different sources\n"
    " * that may not be related to the actual OS's file system.\n"
    " *\n"
    " * For instance, a VirtualFileSystem can transparently mount one or more\n"
    " * Multifiles as their own subdirectory hierarchies.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_VirtualFileSystem,
    0, // tp_members
    Dtool_Properties_VirtualFileSystem,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_VirtualFileSystem,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileSystem,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileSystem,
  Dtool_UpcastInterface_VirtualFileSystem,
  Dtool_DowncastInterface_VirtualFileSystem,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_VirtualFileSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_VirtualFileSystem._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum VirtualFileSystem::MountFlags;
    PyDict_SetItemString(dict, "MF_read_only", Dtool_WrapValue(VirtualFileSystem::MF_read_only));
    PyDict_SetItemString(dict, "MFReadOnly", Dtool_WrapValue(VirtualFileSystem::MF_read_only));
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileSystem);
  }
}

/**
 * Python method tables for PointerTo_VirtualFileMount (PointerTo_VirtualFileMount)
 */
static PyMethodDef Dtool_Methods_PointerTo_VirtualFileMount[] = {
  {"p", &Dtool_PointerTo_VirtualFileMount_p_1485, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_p_1485_comment},
  {"assign", &Dtool_PointerTo_VirtualFileMount_operator_1486, METH_O, (const char *)Dtool_PointerTo_VirtualFileMount_operator_1486_comment},
  {"is_null", &Dtool_PointerTo_VirtualFileMount_is_null_1487, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_is_null_1487_comment},
  {"isNull", &Dtool_PointerTo_VirtualFileMount_is_null_1487, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_is_null_1487_comment},
  {"clear", &Dtool_PointerTo_VirtualFileMount_clear_1488, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_clear_1488_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_PointerTo_VirtualFileMount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerTo_VirtualFileMount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerTo_VirtualFileMount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerTo_VirtualFileMount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerTo_VirtualFileMount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerTo_VirtualFileMount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerTo_VirtualFileMount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_PointerTo_VirtualFileMount,
    &Dtool_SequenceMethods_PointerTo_VirtualFileMount,
    &Dtool_MappingMethods_PointerTo_VirtualFileMount,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerTo_VirtualFileMount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerTo_VirtualFileMount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerTo_VirtualFileMount,
    PyType_GenericAlloc,
    Dtool_new_PointerTo_VirtualFileMount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerTo_VirtualFileMount,
  Dtool_UpcastInterface_PointerTo_VirtualFileMount,
  Dtool_DowncastInterface_PointerTo_VirtualFileMount,
  (CoerceFunction)Dtool_ConstCoerce_PointerTo_VirtualFileMount,
  (CoerceFunction)Dtool_Coerce_PointerTo_VirtualFileMount,
};

static void Dtool_PyModuleClassInit_PointerTo_VirtualFileMount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(NULL);
    Dtool_PointerTo_VirtualFileMount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_VirtualFileMount);
    PyObject *dict = PyDict_New();
    Dtool_PointerTo_VirtualFileMount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerTo_VirtualFileMount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerTo_VirtualFileMount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerTo_VirtualFileMount);
  }
}

/**
 * Python method tables for PointerToBase_VirtualFileMount (PointerToBase_VirtualFileMount)
 */
static PyMethodDef Dtool_Methods_PointerToBase_VirtualFileMount[] = {
  {"clear", &Dtool_PointerToBase_VirtualFileMount_clear_1481, METH_NOARGS, (const char *)Dtool_PointerToBase_VirtualFileMount_clear_1481_comment},
  {"output", &Dtool_PointerToBase_VirtualFileMount_output_1482, METH_O, (const char *)Dtool_PointerToBase_VirtualFileMount_output_1482_comment},
  {NULL, NULL, 0, NULL}
};

//////////////////
//  A __repr__ function
//     PointerToBase_VirtualFileMount
//////////////////
static PyObject *Dtool_Repr_PointerToBase_VirtualFileMount(PyObject *self) {
  PointerToBase< VirtualFileMount > *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_VirtualFileMount, (void **)&local_this)) {
    return NULL;
  }

  ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_VirtualFileMount = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_VirtualFileMount = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_VirtualFileMount = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_VirtualFileMount = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_PointerToBase_VirtualFileMount = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.PointerToBase_VirtualFileMount",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_VirtualFileMount,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_VirtualFileMount,
    &Dtool_NumberMethods_PointerToBase_VirtualFileMount,
    &Dtool_SequenceMethods_PointerToBase_VirtualFileMount,
    &Dtool_MappingMethods_PointerToBase_VirtualFileMount,
    0, // tp_hash
    0, // tp_call
    &Dtool_Repr_PointerToBase_VirtualFileMount,
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_PointerToBase_VirtualFileMount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    0, // tp_doc
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_PointerToBase_VirtualFileMount,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_VirtualFileMount,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_VirtualFileMount,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount,
  Dtool_UpcastInterface_PointerToBase_VirtualFileMount,
  Dtool_DowncastInterface_PointerToBase_VirtualFileMount,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(NULL);
    Dtool_PointerToBase_VirtualFileMount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_VirtualFileMount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_VirtualFileMount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_VirtualFileMount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_VirtualFileMount);
  }
}

/**
 * Python method tables for TrueClock (TrueClock)
 */
static PyMethodDef Dtool_Methods_TrueClock[] = {
  {"get_long_time", &Dtool_TrueClock_get_long_time_1520, METH_NOARGS, (const char *)Dtool_TrueClock_get_long_time_1520_comment},
  {"getLongTime", &Dtool_TrueClock_get_long_time_1520, METH_NOARGS, (const char *)Dtool_TrueClock_get_long_time_1520_comment},
  {"get_short_time", &Dtool_TrueClock_get_short_time_1522, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_time_1522_comment},
  {"getShortTime", &Dtool_TrueClock_get_short_time_1522, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_time_1522_comment},
  {"get_short_raw_time", &Dtool_TrueClock_get_short_raw_time_1524, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_raw_time_1524_comment},
  {"getShortRawTime", &Dtool_TrueClock_get_short_raw_time_1524, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_raw_time_1524_comment},
  {"get_error_count", &Dtool_TrueClock_get_error_count_1526, METH_NOARGS, (const char *)Dtool_TrueClock_get_error_count_1526_comment},
  {"getErrorCount", &Dtool_TrueClock_get_error_count_1526, METH_NOARGS, (const char *)Dtool_TrueClock_get_error_count_1526_comment},
  {"get_global_ptr", &Dtool_TrueClock_get_global_ptr_1528, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrueClock_get_global_ptr_1528_comment},
  {"getGlobalPtr", &Dtool_TrueClock_get_global_ptr_1528, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrueClock_get_global_ptr_1528_comment},
  {"set_cpu_affinity", &Dtool_TrueClock_set_cpu_affinity_1529, METH_O, (const char *)Dtool_TrueClock_set_cpu_affinity_1529_comment},
  {"setCpuAffinity", &Dtool_TrueClock_set_cpu_affinity_1529, METH_O, (const char *)Dtool_TrueClock_set_cpu_affinity_1529_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_TrueClock[] = {
  {(char *)"long_time", &Dtool_TrueClock_long_time_Getter, NULL, NULL, NULL},
  {(char *)"short_time", &Dtool_TrueClock_short_time_Getter, NULL, NULL, NULL},
  {(char *)"short_raw_time", &Dtool_TrueClock_short_raw_time_Getter, NULL, NULL, NULL},
  {(char *)"error_count", &Dtool_TrueClock_error_count_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_TrueClock = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_TrueClock = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.TrueClock",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_TrueClock,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_TrueClock,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interface to whatever real-time clock we might have available in the\n"
    " * current environment.  There is only one TrueClock in existence, and it\n"
    " * constructs itself.\n"
    " *\n"
    " * The TrueClock returns elapsed real time in seconds since some undefined\n"
    " * epoch.  Since it is not defined at what time precisely the clock indicates\n"
    " * zero, this value can only be meaningfully used to measure elapsed time, by\n"
    " * sampling it at two different times and subtracting.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_TrueClock,
    0, // tp_members
    Dtool_Properties_TrueClock,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_TrueClock,
    PyType_GenericAlloc,
    Dtool_new_TrueClock,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TrueClock,
  Dtool_UpcastInterface_TrueClock,
  Dtool_DowncastInterface_TrueClock,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_TrueClock(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TrueClock._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_TrueClock._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TrueClock) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TrueClock)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TrueClock);
  }
}

/**
 * Python method tables for Patchfile (Patchfile)
 */
static PyMethodDef Dtool_Methods_Patchfile[] = {
  {"build", (PyCFunction) &Dtool_Patchfile_build_1533, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patchfile_build_1533_comment},
  {"read_header", &Dtool_Patchfile_read_header_1534, METH_O, (const char *)Dtool_Patchfile_read_header_1534_comment},
  {"readHeader", &Dtool_Patchfile_read_header_1534, METH_O, (const char *)Dtool_Patchfile_read_header_1534_comment},
  {"initiate", (PyCFunction) &Dtool_Patchfile_initiate_1535, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patchfile_initiate_1535_comment},
  {"run", &Dtool_Patchfile_run_1536, METH_NOARGS, (const char *)Dtool_Patchfile_run_1536_comment},
  {"apply", (PyCFunction) &Dtool_Patchfile_apply_1537, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patchfile_apply_1537_comment},
  {"get_progress", &Dtool_Patchfile_get_progress_1538, METH_NOARGS, (const char *)Dtool_Patchfile_get_progress_1538_comment},
  {"getProgress", &Dtool_Patchfile_get_progress_1538, METH_NOARGS, (const char *)Dtool_Patchfile_get_progress_1538_comment},
  {"set_allow_multifile", &Dtool_Patchfile_set_allow_multifile_1542, METH_O, (const char *)Dtool_Patchfile_set_allow_multifile_1542_comment},
  {"setAllowMultifile", &Dtool_Patchfile_set_allow_multifile_1542, METH_O, (const char *)Dtool_Patchfile_set_allow_multifile_1542_comment},
  {"get_allow_multifile", &Dtool_Patchfile_get_allow_multifile_1543, METH_NOARGS, (const char *)Dtool_Patchfile_get_allow_multifile_1543_comment},
  {"getAllowMultifile", &Dtool_Patchfile_get_allow_multifile_1543, METH_NOARGS, (const char *)Dtool_Patchfile_get_allow_multifile_1543_comment},
  {"set_footprint_length", &Dtool_Patchfile_set_footprint_length_1545, METH_O, (const char *)Dtool_Patchfile_set_footprint_length_1545_comment},
  {"setFootprintLength", &Dtool_Patchfile_set_footprint_length_1545, METH_O, (const char *)Dtool_Patchfile_set_footprint_length_1545_comment},
  {"get_footprint_length", &Dtool_Patchfile_get_footprint_length_1546, METH_NOARGS, (const char *)Dtool_Patchfile_get_footprint_length_1546_comment},
  {"getFootprintLength", &Dtool_Patchfile_get_footprint_length_1546, METH_NOARGS, (const char *)Dtool_Patchfile_get_footprint_length_1546_comment},
  {"reset_footprint_length", &Dtool_Patchfile_reset_footprint_length_1547, METH_NOARGS, (const char *)Dtool_Patchfile_reset_footprint_length_1547_comment},
  {"resetFootprintLength", &Dtool_Patchfile_reset_footprint_length_1547, METH_NOARGS, (const char *)Dtool_Patchfile_reset_footprint_length_1547_comment},
  {"has_source_hash", &Dtool_Patchfile_has_source_hash_1549, METH_NOARGS, (const char *)Dtool_Patchfile_has_source_hash_1549_comment},
  {"hasSourceHash", &Dtool_Patchfile_has_source_hash_1549, METH_NOARGS, (const char *)Dtool_Patchfile_has_source_hash_1549_comment},
  {"get_source_hash", &Dtool_Patchfile_get_source_hash_1550, METH_NOARGS, (const char *)Dtool_Patchfile_get_source_hash_1550_comment},
  {"getSourceHash", &Dtool_Patchfile_get_source_hash_1550, METH_NOARGS, (const char *)Dtool_Patchfile_get_source_hash_1550_comment},
  {"get_result_hash", &Dtool_Patchfile_get_result_hash_1551, METH_NOARGS, (const char *)Dtool_Patchfile_get_result_hash_1551_comment},
  {"getResultHash", &Dtool_Patchfile_get_result_hash_1551, METH_NOARGS, (const char *)Dtool_Patchfile_get_result_hash_1551_comment},
  {NULL, NULL, 0, NULL}
};

static PyGetSetDef Dtool_Properties_Patchfile[] = {
  {(char *)"progress", &Dtool_Patchfile_progress_Getter, NULL, NULL, NULL},
  {(char *)"allow_multifile", &Dtool_Patchfile_allow_multifile_Getter, &Dtool_Patchfile_allow_multifile_Setter, NULL, NULL},
  {(char *)"footprint_length", &Dtool_Patchfile_footprint_length_Getter, &Dtool_Patchfile_footprint_length_Setter, NULL, NULL},
  {(char *)"source_hash", &Dtool_Patchfile_source_hash_Getter, NULL, NULL, NULL},
  {(char *)"result_hash", &Dtool_Patchfile_result_hash_Getter, NULL, NULL, NULL},
  {NULL},
};

static PyNumberMethods Dtool_NumberMethods_Patchfile = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_Patchfile = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.Patchfile",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_Patchfile,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_Patchfile,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_Patchfile,
    0, // tp_members
    Dtool_Properties_Patchfile,
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_Patchfile,
    PyType_GenericAlloc,
    Dtool_new_Patchfile,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Patchfile,
  Dtool_UpcastInterface_Patchfile,
  Dtool_DowncastInterface_Patchfile,
  (CoerceFunction)Dtool_ConstCoerce_Patchfile,
  (CoerceFunction)Dtool_Coerce_Patchfile,
};

static void Dtool_PyModuleClassInit_Patchfile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Patchfile._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_Patchfile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Patchfile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Patchfile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Patchfile);
  }
}

/**
 * Python method tables for ProfileTimer (ProfileTimer)
 */
static PyMethodDef Dtool_Methods_ProfileTimer[] = {
  {"init", (PyCFunction) &Dtool_ProfileTimer_init_1559, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProfileTimer_init_1559_comment},
  {"on", &Dtool_ProfileTimer_on_1560, METH_NOARGS, (const char *)Dtool_ProfileTimer_on_1560_comment},
  {"mark", &Dtool_ProfileTimer_mark_1561, METH_O, (const char *)Dtool_ProfileTimer_mark_1561_comment},
  {"off", &Dtool_ProfileTimer_off_1562, METH_VARARGS, (const char *)Dtool_ProfileTimer_off_1562_comment},
  {"getTotalTime", &Dtool_ProfileTimer_getTotalTime_1563, METH_NOARGS, (const char *)Dtool_ProfileTimer_getTotalTime_1563_comment},
  {"consolidateAllTo", (PyCFunction) &Dtool_ProfileTimer_consolidateAllTo_1564, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ProfileTimer_consolidateAllTo_1564_comment},
  {"consolidateTo", (PyCFunction) &Dtool_ProfileTimer_consolidateTo_1565, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProfileTimer_consolidateTo_1565_comment},
  {"printAllTo", (PyCFunction) &Dtool_ProfileTimer_printAllTo_1566, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_ProfileTimer_printAllTo_1566_comment},
  {"printTo", (PyCFunction) &Dtool_ProfileTimer_printTo_1567, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ProfileTimer_printTo_1567_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_ProfileTimer = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_ProfileTimer = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.ProfileTimer",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_ProfileTimer,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_ProfileTimer,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/*\n"
    "    ProfileTimer\n"
    "\n"
    "    HowTo:\n"
    "      Create a ProfileTimer and hold onto it.\n"
    "      Call init() whenever you like (the timer doesn't\n"
    "        start yet).\n"
    "      Call on() to start the timer.\n"
    "      While the timer is on, call mark() at each point of interest,\n"
    "        in the code you are timing.\n"
    "      You can turn the timer off() and on() to skip things you\n"
    "        don't want to time.\n"
    "      When your timing is finished, call printTo() to see the\n"
    "        results (e.g. myTimer.printTo(cerr)).\n"
    "\n"
    "    Notes:\n"
    "      You should be able to time things down to the millisecond\n"
    "      well enough, but if you call on() and off() within micro-\n"
    "      seconds of each other, I don't think you'll get very good\n"
    "      results.\n"
    "*/",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_ProfileTimer,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_ProfileTimer,
    PyType_GenericAlloc,
    Dtool_new_ProfileTimer,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ProfileTimer,
  Dtool_UpcastInterface_ProfileTimer,
  Dtool_DowncastInterface_ProfileTimer,
  (CoerceFunction)Dtool_ConstCoerce_ProfileTimer,
  (CoerceFunction)Dtool_Coerce_ProfileTimer,
};

static void Dtool_PyModuleClassInit_ProfileTimer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ProfileTimer._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_ProfileTimer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ProfileTimer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ProfileTimer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ProfileTimer);
  }
}

/**
 * Python method tables for WeakPointerToVoid (WeakPointerToVoid)
 */
static PyMethodDef Dtool_Methods_WeakPointerToVoid[] = {
  {"was_deleted", &Dtool_WeakPointerToVoid_was_deleted_1569, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_was_deleted_1569_comment},
  {"wasDeleted", &Dtool_WeakPointerToVoid_was_deleted_1569, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_was_deleted_1569_comment},
  {"is_valid_pointer", &Dtool_WeakPointerToVoid_is_valid_pointer_1570, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_is_valid_pointer_1570_comment},
  {"isValidPointer", &Dtool_WeakPointerToVoid_is_valid_pointer_1570, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_is_valid_pointer_1570_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_WeakPointerToVoid = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WeakPointerToVoid = {
  0, // sq_length
  0, // sq_concat
  0, // sq_repeat
  0, // sq_item
  0, // sq_slice
  0, // sq_ass_item
  0, // sq_ass_slice
  0, // sq_contains
  0, // sq_inplace_concat
  0, // sq_inplace_repeat
};

static PyMappingMethods Dtool_MappingMethods_WeakPointerToVoid = {
  0, // mp_length
  0, // mp_subscript
  0, // mp_ass_subscript
};

static PyBufferProcs Dtool_BufferProcs_WeakPointerToVoid = {
#if PY_MAJOR_VERSION < 3
  0, // bf_getreadbuffer
  0, // bf_getwritebuffer
  0, // bf_getsegcount
  0, // bf_getcharbuffer
#endif
#if PY_VERSION_HEX >= 0x02060000
  0, // bf_getbuffer
  0, // bf_releasebuffer
#endif
};

struct Dtool_PyTypedObject Dtool_WeakPointerToVoid = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.WeakPointerToVoid",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_WeakPointerToVoid,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_WeakPointerToVoid,
    &Dtool_SequenceMethods_WeakPointerToVoid,
    &Dtool_MappingMethods_WeakPointerToVoid,
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    &Dtool_BufferProcs_WeakPointerToVoid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the specialization of PointerToVoid for weak pointers.  It needs an\n"
    " * additional flag to indicate that the pointer has been deleted.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_WeakPointerToVoid,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_WeakPointerToVoid,
    PyType_GenericAlloc,
    Dtool_new_WeakPointerToVoid,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WeakPointerToVoid,
  Dtool_UpcastInterface_WeakPointerToVoid,
  Dtool_DowncastInterface_WeakPointerToVoid,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_WeakPointerToVoid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(NULL);
    Dtool_WeakPointerToVoid._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    PyObject *dict = PyDict_New();
    Dtool_WeakPointerToVoid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WeakPointerToVoid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WeakPointerToVoid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WeakPointerToVoid);
  }
}

/**
 * Python method tables for WindowsRegistry (WindowsRegistry)
 */
static PyMethodDef Dtool_Methods_WindowsRegistry[] = {
  {"set_string_value", (PyCFunction) &Dtool_WindowsRegistry_set_string_value_1573, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_set_string_value_1573_comment},
  {"setStringValue", (PyCFunction) &Dtool_WindowsRegistry_set_string_value_1573, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_set_string_value_1573_comment},
  {"set_int_value", (PyCFunction) &Dtool_WindowsRegistry_set_int_value_1574, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_set_int_value_1574_comment},
  {"setIntValue", (PyCFunction) &Dtool_WindowsRegistry_set_int_value_1574, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_set_int_value_1574_comment},
  {"get_key_type", (PyCFunction) &Dtool_WindowsRegistry_get_key_type_1576, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_get_key_type_1576_comment},
  {"getKeyType", (PyCFunction) &Dtool_WindowsRegistry_get_key_type_1576, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_get_key_type_1576_comment},
  {"get_string_value", (PyCFunction) &Dtool_WindowsRegistry_get_string_value_1577, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_get_string_value_1577_comment},
  {"getStringValue", (PyCFunction) &Dtool_WindowsRegistry_get_string_value_1577, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_get_string_value_1577_comment},
  {"get_int_value", (PyCFunction) &Dtool_WindowsRegistry_get_int_value_1578, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_get_int_value_1578_comment},
  {"getIntValue", (PyCFunction) &Dtool_WindowsRegistry_get_int_value_1578, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_WindowsRegistry_get_int_value_1578_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, NULL},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, NULL},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_WindowsRegistry = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_WindowsRegistry = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.core.WindowsRegistry",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_WindowsRegistry,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_WindowsRegistry,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides a hook to Python to read and write strings and integers\n"
    " * to the windows registry.  It automatically converts strings from utf-8\n"
    " * encoding and stores them in Unicode (and conversely reconverts them on\n"
    " * retrieval).\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_WindowsRegistry,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_WindowsRegistry,
    PyType_GenericAlloc,
    Dtool_new_WindowsRegistry,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WindowsRegistry,
  Dtool_UpcastInterface_WindowsRegistry,
  Dtool_DowncastInterface_WindowsRegistry,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_WindowsRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_WindowsRegistry._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_WindowsRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum WindowsRegistry::RegLevel;
    PyDict_SetItemString(dict, "rl_machine", Dtool_WrapValue(WindowsRegistry::rl_machine));
    PyDict_SetItemString(dict, "RlMachine", Dtool_WrapValue(WindowsRegistry::rl_machine));
    PyDict_SetItemString(dict, "rl_user", Dtool_WrapValue(WindowsRegistry::rl_user));
    PyDict_SetItemString(dict, "RlUser", Dtool_WrapValue(WindowsRegistry::rl_user));
    // enum WindowsRegistry::Type;
    PyDict_SetItemString(dict, "T_none", Dtool_WrapValue(WindowsRegistry::T_none));
    PyDict_SetItemString(dict, "TNone", Dtool_WrapValue(WindowsRegistry::T_none));
    PyDict_SetItemString(dict, "T_int", Dtool_WrapValue(WindowsRegistry::T_int));
    PyDict_SetItemString(dict, "TInt", Dtool_WrapValue(WindowsRegistry::T_int));
    PyDict_SetItemString(dict, "T_string", Dtool_WrapValue(WindowsRegistry::T_string));
    PyDict_SetItemString(dict, "TString", Dtool_WrapValue(WindowsRegistry::T_string));
    if (PyType_Ready((PyTypeObject *)&Dtool_WindowsRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WindowsRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WindowsRegistry);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3express_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< double >", Dtool_ConstPointerToArray_double);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< double >", Dtool_PointerToArrayBase_double);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< double > >", Dtool_PointerToBase_ReferenceCountedVector_double);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToVoid", Dtool_PointerToVoid);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< float >", Dtool_ConstPointerToArray_float);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< float >", Dtool_PointerToArrayBase_float);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< float > >", Dtool_PointerToBase_ReferenceCountedVector_float);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< int >", Dtool_ConstPointerToArray_int);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< int >", Dtool_PointerToArrayBase_int);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< int > >", Dtool_PointerToBase_ReferenceCountedVector_int);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConstPointerToArray< unsigned char >", Dtool_ConstPointerToArray_unsigned_char);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArrayBase< unsigned char >", Dtool_PointerToArrayBase_unsigned_char);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< ReferenceCountedVector< unsigned char > >", Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigDeclaration", Dtool_ConfigDeclaration);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigFlags", Dtool_ConfigFlags);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigPage", Dtool_ConfigPage);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableCore", Dtool_ConfigVariableCore);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigPageManager", Dtool_ConfigPageManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariable", Dtool_ConfigVariable);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableBase", Dtool_ConfigVariableBase);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableBool", Dtool_ConfigVariableBool);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableDouble", Dtool_ConfigVariableDouble);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableFilename", Dtool_ConfigVariableFilename);
#endif
  Dtool_Filename._type = Filename::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Filename);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableInt", Dtool_ConfigVariableInt);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableInt64", Dtool_ConfigVariableInt64);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableList", Dtool_ConfigVariableList);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableManager", Dtool_ConfigVariableManager);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableSearchPath", Dtool_ConfigVariableSearchPath);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DSearchPath", Dtool_DSearchPath);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DSearchPath::Results", Dtool_DSearchPath_Results);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ConfigVariableString", Dtool_ConfigVariableString);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DConfig", Dtool_DConfig);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ExecutionEnvironment", Dtool_ExecutionEnvironment);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("FileStream", Dtool_FileStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("iostream", Dtool_iostream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("istream", Dtool_istream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ios", Dtool_ios);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ios_base", Dtool_ios_base);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ostream", Dtool_ostream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("GlobPattern", Dtool_GlobPattern);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("IDecryptStream", Dtool_IDecryptStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("IFileStream", Dtool_IFileStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("IStreamWrapper", Dtool_IStreamWrapper);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StreamWrapperBase", Dtool_StreamWrapperBase);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("LineStream", Dtool_LineStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NeverFreeMemory", Dtool_NeverFreeMemory);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Notify", Dtool_Notify);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("NotifyCategory", Dtool_NotifyCategory);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OEncryptStream", Dtool_OEncryptStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OFileStream", Dtool_OFileStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OStreamWrapper", Dtool_OStreamWrapper);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< double >", Dtool_PointerToArray_double);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< float >", Dtool_PointerToArray_float);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< int >", Dtool_PointerToArray_int);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToArray< unsigned char >", Dtool_PointerToArray_unsigned_char);
#endif
  Dtool_PandaSystem._type = PandaSystem::get_class_type();
  RegisterRuntimeTypedClass(Dtool_PandaSystem);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StreamReader", Dtool_StreamReader);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StreamWrapper", Dtool_StreamWrapper);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("StreamWriter", Dtool_StreamWriter);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TextEncoder", Dtool_TextEncoder);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TypeHandle", Dtool_TypeHandle);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TypeRegistry", Dtool_TypeRegistry);
#endif
  Dtool_TypedObject._type = TypedObject::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TypedObject);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("fstream", Dtool_fstream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ifstream", Dtool_ifstream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ofstream", Dtool_ofstream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MemoryUsage", Dtool_MemoryUsage);
#endif
  Dtool_ReferenceCount._type = ReferenceCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_ReferenceCount);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Buffer", Dtool_Buffer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PStatCollectorForwardBase", Dtool_PStatCollectorForwardBase);
#endif
  Dtool_NodeReferenceCount._type = NodeReferenceCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_NodeReferenceCount);
  Dtool_Datagram._type = Datagram::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Datagram);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DatagramGenerator", Dtool_DatagramGenerator);
#endif
  Dtool_DatagramIterator._type = DatagramIterator::get_class_type();
  RegisterRuntimeTypedClass(Dtool_DatagramIterator);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("DatagramSink", Dtool_DatagramSink);
#endif
  Dtool_TypedReferenceCount._type = TypedReferenceCount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TypedReferenceCount);
  Dtool_FileReference._type = FileReference::get_class_type();
  RegisterRuntimeTypedClass(Dtool_FileReference);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Ramfile", Dtool_Ramfile);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("HashVal", Dtool_HashVal);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("MemoryUsagePointers", Dtool_MemoryUsagePointers);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ISubStream", Dtool_ISubStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OSubStream", Dtool_OSubStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SubStream", Dtool_SubStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OpenSSLWrapper", Dtool_OpenSSLWrapper);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Multifile", Dtool_Multifile);
#endif
  Dtool_Namable._type = Namable::get_class_type();
  RegisterRuntimeTypedClass(Dtool_Namable);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("SubfileInfo", Dtool_SubfileInfo);
#endif
  Dtool_VirtualFile._type = VirtualFile::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFile);
  Dtool_VirtualFileComposite._type = VirtualFileComposite::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileComposite);
  Dtool_VirtualFileMount._type = VirtualFileMount::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileMount);
  Dtool_VirtualFileMountMultifile._type = VirtualFileMountMultifile::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileMountMultifile);
  Dtool_VirtualFileMountRamdisk._type = VirtualFileMountRamdisk::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileMountRamdisk);
  Dtool_VirtualFileMountSystem._type = VirtualFileMountSystem::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileMountSystem);
  Dtool_VirtualFileSimple._type = VirtualFileSimple::get_class_type();
  RegisterRuntimeTypedClass(Dtool_VirtualFileSimple);
  Dtool_TemporaryFile._type = TemporaryFile::get_class_type();
  RegisterRuntimeTypedClass(Dtool_TemporaryFile);
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("IDecompressStream", Dtool_IDecompressStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("OCompressStream", Dtool_OCompressStream);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("VirtualFileList", Dtool_VirtualFileList);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("VirtualFileSystem", Dtool_VirtualFileSystem);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerTo< VirtualFileMount >", Dtool_PointerTo_VirtualFileMount);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("PointerToBase< VirtualFileMount >", Dtool_PointerToBase_VirtualFileMount);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("TrueClock", Dtool_TrueClock);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("Patchfile", Dtool_Patchfile);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("ProfileTimer", Dtool_ProfileTimer);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("WeakPointerToVoid", Dtool_WeakPointerToVoid);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("WindowsRegistry", Dtool_WindowsRegistry);
#endif
}

void Dtool_libp3express_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
#endif
}

void Dtool_libp3express_BuildInstants(PyObject *module) {
  (void) module;
  // enum NotifySeverity
  PyModule_AddObject(module, "NS_unspecified", Dtool_WrapValue(::NS_unspecified));
  PyModule_AddObject(module, "NSUnspecified", Dtool_WrapValue(::NS_unspecified));
  PyModule_AddObject(module, "NS_spam", Dtool_WrapValue(::NS_spam));
  PyModule_AddObject(module, "NSSpam", Dtool_WrapValue(::NS_spam));
  PyModule_AddObject(module, "NS_debug", Dtool_WrapValue(::NS_debug));
  PyModule_AddObject(module, "NSDebug", Dtool_WrapValue(::NS_debug));
  PyModule_AddObject(module, "NS_info", Dtool_WrapValue(::NS_info));
  PyModule_AddObject(module, "NSInfo", Dtool_WrapValue(::NS_info));
  PyModule_AddObject(module, "NS_warning", Dtool_WrapValue(::NS_warning));
  PyModule_AddObject(module, "NSWarning", Dtool_WrapValue(::NS_warning));
  PyModule_AddObject(module, "NS_error", Dtool_WrapValue(::NS_error));
  PyModule_AddObject(module, "NSError", Dtool_WrapValue(::NS_error));
  PyModule_AddObject(module, "NS_fatal", Dtool_WrapValue(::NS_fatal));
  PyModule_AddObject(module, "NSFatal", Dtool_WrapValue(::NS_fatal));
  // enum ErrorUtilCode
  PyModule_AddObject(module, "EU_http_redirect", Dtool_WrapValue(::EU_http_redirect));
  PyModule_AddObject(module, "EUHttpRedirect", Dtool_WrapValue(::EU_http_redirect));
  PyModule_AddObject(module, "EU_eof", Dtool_WrapValue(::EU_eof));
  PyModule_AddObject(module, "EUEof", Dtool_WrapValue(::EU_eof));
  PyModule_AddObject(module, "EU_network_no_data", Dtool_WrapValue(::EU_network_no_data));
  PyModule_AddObject(module, "EUNetworkNoData", Dtool_WrapValue(::EU_network_no_data));
  PyModule_AddObject(module, "EU_write_ram", Dtool_WrapValue(::EU_write_ram));
  PyModule_AddObject(module, "EUWriteRam", Dtool_WrapValue(::EU_write_ram));
  PyModule_AddObject(module, "EU_write", Dtool_WrapValue(::EU_write));
  PyModule_AddObject(module, "EUWrite", Dtool_WrapValue(::EU_write));
  PyModule_AddObject(module, "EU_ok", Dtool_WrapValue(::EU_ok));
  PyModule_AddObject(module, "EUOk", Dtool_WrapValue(::EU_ok));
  PyModule_AddObject(module, "EU_success", Dtool_WrapValue(::EU_success));
  PyModule_AddObject(module, "EUSuccess", Dtool_WrapValue(::EU_success));
  PyModule_AddObject(module, "EU_error_abort", Dtool_WrapValue(::EU_error_abort));
  PyModule_AddObject(module, "EUErrorAbort", Dtool_WrapValue(::EU_error_abort));
  PyModule_AddObject(module, "EU_error_file_empty", Dtool_WrapValue(::EU_error_file_empty));
  PyModule_AddObject(module, "EUErrorFileEmpty", Dtool_WrapValue(::EU_error_file_empty));
  PyModule_AddObject(module, "EU_error_file_invalid", Dtool_WrapValue(::EU_error_file_invalid));
  PyModule_AddObject(module, "EUErrorFileInvalid", Dtool_WrapValue(::EU_error_file_invalid));
  PyModule_AddObject(module, "EU_error_invalid_checksum", Dtool_WrapValue(::EU_error_invalid_checksum));
  PyModule_AddObject(module, "EUErrorInvalidChecksum", Dtool_WrapValue(::EU_error_invalid_checksum));
  PyModule_AddObject(module, "EU_error_network_dead", Dtool_WrapValue(::EU_error_network_dead));
  PyModule_AddObject(module, "EUErrorNetworkDead", Dtool_WrapValue(::EU_error_network_dead));
  PyModule_AddObject(module, "EU_error_network_unreachable", Dtool_WrapValue(::EU_error_network_unreachable));
  PyModule_AddObject(module, "EUErrorNetworkUnreachable", Dtool_WrapValue(::EU_error_network_unreachable));
  PyModule_AddObject(module, "EU_error_network_disconnected", Dtool_WrapValue(::EU_error_network_disconnected));
  PyModule_AddObject(module, "EUErrorNetworkDisconnected", Dtool_WrapValue(::EU_error_network_disconnected));
  PyModule_AddObject(module, "EU_error_network_timeout", Dtool_WrapValue(::EU_error_network_timeout));
  PyModule_AddObject(module, "EUErrorNetworkTimeout", Dtool_WrapValue(::EU_error_network_timeout));
  PyModule_AddObject(module, "EU_error_network_no_data", Dtool_WrapValue(::EU_error_network_no_data));
  PyModule_AddObject(module, "EUErrorNetworkNoData", Dtool_WrapValue(::EU_error_network_no_data));
  PyModule_AddObject(module, "EU_error_network_disconnected_locally", Dtool_WrapValue(::EU_error_network_disconnected_locally));
  PyModule_AddObject(module, "EUErrorNetworkDisconnectedLocally", Dtool_WrapValue(::EU_error_network_disconnected_locally));
  PyModule_AddObject(module, "EU_error_network_buffer_overflow", Dtool_WrapValue(::EU_error_network_buffer_overflow));
  PyModule_AddObject(module, "EUErrorNetworkBufferOverflow", Dtool_WrapValue(::EU_error_network_buffer_overflow));
  PyModule_AddObject(module, "EU_error_network_disk_quota_exceeded", Dtool_WrapValue(::EU_error_network_disk_quota_exceeded));
  PyModule_AddObject(module, "EUErrorNetworkDiskQuotaExceeded", Dtool_WrapValue(::EU_error_network_disk_quota_exceeded));
  PyModule_AddObject(module, "EU_error_network_remote_host_disconnected", Dtool_WrapValue(::EU_error_network_remote_host_disconnected));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostDisconnected", Dtool_WrapValue(::EU_error_network_remote_host_disconnected));
  PyModule_AddObject(module, "EU_error_network_remote_host_down", Dtool_WrapValue(::EU_error_network_remote_host_down));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostDown", Dtool_WrapValue(::EU_error_network_remote_host_down));
  PyModule_AddObject(module, "EU_error_network_remote_host_unreachable", Dtool_WrapValue(::EU_error_network_remote_host_unreachable));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostUnreachable", Dtool_WrapValue(::EU_error_network_remote_host_unreachable));
  PyModule_AddObject(module, "EU_error_network_remote_host_not_found", Dtool_WrapValue(::EU_error_network_remote_host_not_found));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostNotFound", Dtool_WrapValue(::EU_error_network_remote_host_not_found));
  PyModule_AddObject(module, "EU_error_network_remote_host_no_response", Dtool_WrapValue(::EU_error_network_remote_host_no_response));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostNoResponse", Dtool_WrapValue(::EU_error_network_remote_host_no_response));
  PyModule_AddObject(module, "EU_error_write_out_of_files", Dtool_WrapValue(::EU_error_write_out_of_files));
  PyModule_AddObject(module, "EUErrorWriteOutOfFiles", Dtool_WrapValue(::EU_error_write_out_of_files));
  PyModule_AddObject(module, "EU_error_write_out_of_memory", Dtool_WrapValue(::EU_error_write_out_of_memory));
  PyModule_AddObject(module, "EUErrorWriteOutOfMemory", Dtool_WrapValue(::EU_error_write_out_of_memory));
  PyModule_AddObject(module, "EU_error_write_sharing_violation", Dtool_WrapValue(::EU_error_write_sharing_violation));
  PyModule_AddObject(module, "EUErrorWriteSharingViolation", Dtool_WrapValue(::EU_error_write_sharing_violation));
  PyModule_AddObject(module, "EU_error_write_disk_full", Dtool_WrapValue(::EU_error_write_disk_full));
  PyModule_AddObject(module, "EUErrorWriteDiskFull", Dtool_WrapValue(::EU_error_write_disk_full));
  PyModule_AddObject(module, "EU_error_write_disk_not_found", Dtool_WrapValue(::EU_error_write_disk_not_found));
  PyModule_AddObject(module, "EUErrorWriteDiskNotFound", Dtool_WrapValue(::EU_error_write_disk_not_found));
  PyModule_AddObject(module, "EU_error_write_disk_sector_not_found", Dtool_WrapValue(::EU_error_write_disk_sector_not_found));
  PyModule_AddObject(module, "EUErrorWriteDiskSectorNotFound", Dtool_WrapValue(::EU_error_write_disk_sector_not_found));
  PyModule_AddObject(module, "EU_error_write_disk_fault", Dtool_WrapValue(::EU_error_write_disk_fault));
  PyModule_AddObject(module, "EUErrorWriteDiskFault", Dtool_WrapValue(::EU_error_write_disk_fault));
  PyModule_AddObject(module, "EU_error_write_file_rename", Dtool_WrapValue(::EU_error_write_file_rename));
  PyModule_AddObject(module, "EUErrorWriteFileRename", Dtool_WrapValue(::EU_error_write_file_rename));
  PyModule_AddObject(module, "EU_error_http_server_timeout", Dtool_WrapValue(::EU_error_http_server_timeout));
  PyModule_AddObject(module, "EUErrorHttpServerTimeout", Dtool_WrapValue(::EU_error_http_server_timeout));
  PyModule_AddObject(module, "EU_error_http_gateway_timeout", Dtool_WrapValue(::EU_error_http_gateway_timeout));
  PyModule_AddObject(module, "EUErrorHttpGatewayTimeout", Dtool_WrapValue(::EU_error_http_gateway_timeout));
  PyModule_AddObject(module, "EU_error_http_service_unavailable", Dtool_WrapValue(::EU_error_http_service_unavailable));
  PyModule_AddObject(module, "EUErrorHttpServiceUnavailable", Dtool_WrapValue(::EU_error_http_service_unavailable));
  PyModule_AddObject(module, "EU_error_http_proxy_authentication", Dtool_WrapValue(::EU_error_http_proxy_authentication));
  PyModule_AddObject(module, "EUErrorHttpProxyAuthentication", Dtool_WrapValue(::EU_error_http_proxy_authentication));
  PyModule_AddObject(module, "EU_error_zlib", Dtool_WrapValue(::EU_error_zlib));
  PyModule_AddObject(module, "EUErrorZlib", Dtool_WrapValue(::EU_error_zlib));
  // typedef ConstPointerToArray< double > CPTA_double
  Dtool_PyModuleClassInit_ConstPointerToArray_double(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_double);
  PyModule_AddObject(module, "CPTA_double", (PyObject *)&Dtool_ConstPointerToArray_double);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_double);
  PyModule_AddObject(module, "CPTADouble", (PyObject *)&Dtool_ConstPointerToArray_double);
  // ConstPointerToArray< double >
  Dtool_PyModuleClassInit_ConstPointerToArray_double(module);
  PyModule_AddObject(module, "ConstPointerToArray_double", (PyObject *)&Dtool_ConstPointerToArray_double);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_double);
  PyModule_AddObject(module, "ConstPointerToArrayDouble", (PyObject *)&Dtool_ConstPointerToArray_double);
  // PointerToArrayBase< double >
  Dtool_PyModuleClassInit_PointerToArrayBase_double(module);
  PyModule_AddObject(module, "PointerToArrayBase_double", (PyObject *)&Dtool_PointerToArrayBase_double);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_double);
  PyModule_AddObject(module, "PointerToArrayBaseDouble", (PyObject *)&Dtool_PointerToArrayBase_double);
  // PointerToBase< ReferenceCountedVector< double > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_double", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_double);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorDouble", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
  // PointerToVoid
  Dtool_PyModuleClassInit_PointerToVoid(module);
  PyModule_AddObject(module, "PointerToVoid", (PyObject *)&Dtool_PointerToVoid);
  // typedef ConstPointerToArray< float > CPTA_float
  Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTA_float", (PyObject *)&Dtool_ConstPointerToArray_float);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTAFloat", (PyObject *)&Dtool_ConstPointerToArray_float);
  // ConstPointerToArray< float >
  Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
  PyModule_AddObject(module, "ConstPointerToArray_float", (PyObject *)&Dtool_ConstPointerToArray_float);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_float);
  PyModule_AddObject(module, "ConstPointerToArrayFloat", (PyObject *)&Dtool_ConstPointerToArray_float);
  // PointerToArrayBase< float >
  Dtool_PyModuleClassInit_PointerToArrayBase_float(module);
  PyModule_AddObject(module, "PointerToArrayBase_float", (PyObject *)&Dtool_PointerToArrayBase_float);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_float);
  PyModule_AddObject(module, "PointerToArrayBaseFloat", (PyObject *)&Dtool_PointerToArrayBase_float);
  // PointerToBase< ReferenceCountedVector< float > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_float", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_float);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorFloat", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
  // typedef ConstPointerToArray< int > CPTA_int
  Dtool_PyModuleClassInit_ConstPointerToArray_int(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_int);
  PyModule_AddObject(module, "CPTA_int", (PyObject *)&Dtool_ConstPointerToArray_int);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_int);
  PyModule_AddObject(module, "CPTAInt", (PyObject *)&Dtool_ConstPointerToArray_int);
  // ConstPointerToArray< int >
  Dtool_PyModuleClassInit_ConstPointerToArray_int(module);
  PyModule_AddObject(module, "ConstPointerToArray_int", (PyObject *)&Dtool_ConstPointerToArray_int);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_int);
  PyModule_AddObject(module, "ConstPointerToArrayInt", (PyObject *)&Dtool_ConstPointerToArray_int);
  // PointerToArrayBase< int >
  Dtool_PyModuleClassInit_PointerToArrayBase_int(module);
  PyModule_AddObject(module, "PointerToArrayBase_int", (PyObject *)&Dtool_PointerToArrayBase_int);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_int);
  PyModule_AddObject(module, "PointerToArrayBaseInt", (PyObject *)&Dtool_PointerToArrayBase_int);
  // PointerToBase< ReferenceCountedVector< int > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_int", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_int);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorInt", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
  // typedef ConstPointerToArray< unsigned char > CPTA_uchar
  Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  PyModule_AddObject(module, "CPTA_uchar", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_unsigned_char);
  PyModule_AddObject(module, "CPTAUchar", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  // ConstPointerToArray< unsigned char >
  Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(module);
  PyModule_AddObject(module, "ConstPointerToArray_unsigned_char", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_unsigned_char);
  PyModule_AddObject(module, "ConstPointerToArrayUnsignedChar", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  // PointerToArrayBase< unsigned char >
  Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(module);
  PyModule_AddObject(module, "PointerToArrayBase_unsigned_char", (PyObject *)&Dtool_PointerToArrayBase_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_unsigned_char);
  PyModule_AddObject(module, "PointerToArrayBaseUnsignedChar", (PyObject *)&Dtool_PointerToArrayBase_unsigned_char);
  // PointerToBase< ReferenceCountedVector< unsigned char > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_unsigned_char", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnsignedChar", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
  // ConfigDeclaration
  Dtool_PyModuleClassInit_ConfigDeclaration(module);
  PyModule_AddObject(module, "ConfigDeclaration", (PyObject *)&Dtool_ConfigDeclaration);
  // ConfigFlags
  Dtool_PyModuleClassInit_ConfigFlags(module);
  PyModule_AddObject(module, "ConfigFlags", (PyObject *)&Dtool_ConfigFlags);
  // ConfigPage
  Dtool_PyModuleClassInit_ConfigPage(module);
  PyModule_AddObject(module, "ConfigPage", (PyObject *)&Dtool_ConfigPage);
  // ConfigVariableCore
  Dtool_PyModuleClassInit_ConfigVariableCore(module);
  PyModule_AddObject(module, "ConfigVariableCore", (PyObject *)&Dtool_ConfigVariableCore);
  // ConfigPageManager
  Dtool_PyModuleClassInit_ConfigPageManager(module);
  PyModule_AddObject(module, "ConfigPageManager", (PyObject *)&Dtool_ConfigPageManager);
  // ConfigVariable
  Dtool_PyModuleClassInit_ConfigVariable(module);
  PyModule_AddObject(module, "ConfigVariable", (PyObject *)&Dtool_ConfigVariable);
  // ConfigVariableBase
  Dtool_PyModuleClassInit_ConfigVariableBase(module);
  PyModule_AddObject(module, "ConfigVariableBase", (PyObject *)&Dtool_ConfigVariableBase);
  // ConfigVariableBool
  Dtool_PyModuleClassInit_ConfigVariableBool(module);
  PyModule_AddObject(module, "ConfigVariableBool", (PyObject *)&Dtool_ConfigVariableBool);
  // ConfigVariableDouble
  Dtool_PyModuleClassInit_ConfigVariableDouble(module);
  PyModule_AddObject(module, "ConfigVariableDouble", (PyObject *)&Dtool_ConfigVariableDouble);
  // ConfigVariableFilename
  Dtool_PyModuleClassInit_ConfigVariableFilename(module);
  PyModule_AddObject(module, "ConfigVariableFilename", (PyObject *)&Dtool_ConfigVariableFilename);
  // Filename
  Dtool_PyModuleClassInit_Filename(module);
  PyModule_AddObject(module, "Filename", (PyObject *)&Dtool_Filename);
  // ConfigVariableInt
  Dtool_PyModuleClassInit_ConfigVariableInt(module);
  PyModule_AddObject(module, "ConfigVariableInt", (PyObject *)&Dtool_ConfigVariableInt);
  // ConfigVariableInt64
  Dtool_PyModuleClassInit_ConfigVariableInt64(module);
  PyModule_AddObject(module, "ConfigVariableInt64", (PyObject *)&Dtool_ConfigVariableInt64);
  // ConfigVariableList
  Dtool_PyModuleClassInit_ConfigVariableList(module);
  PyModule_AddObject(module, "ConfigVariableList", (PyObject *)&Dtool_ConfigVariableList);
  // ConfigVariableManager
  Dtool_PyModuleClassInit_ConfigVariableManager(module);
  PyModule_AddObject(module, "ConfigVariableManager", (PyObject *)&Dtool_ConfigVariableManager);
  // ConfigVariableSearchPath
  Dtool_PyModuleClassInit_ConfigVariableSearchPath(module);
  PyModule_AddObject(module, "ConfigVariableSearchPath", (PyObject *)&Dtool_ConfigVariableSearchPath);
  // DSearchPath
  Dtool_PyModuleClassInit_DSearchPath(module);
  PyModule_AddObject(module, "DSearchPath", (PyObject *)&Dtool_DSearchPath);
  // ConfigVariableString
  Dtool_PyModuleClassInit_ConfigVariableString(module);
  PyModule_AddObject(module, "ConfigVariableString", (PyObject *)&Dtool_ConfigVariableString);
  // DConfig
  Dtool_PyModuleClassInit_DConfig(module);
  PyModule_AddObject(module, "DConfig", (PyObject *)&Dtool_DConfig);
  // ExecutionEnvironment
  Dtool_PyModuleClassInit_ExecutionEnvironment(module);
  PyModule_AddObject(module, "ExecutionEnvironment", (PyObject *)&Dtool_ExecutionEnvironment);
  // FileStream
  Dtool_PyModuleClassInit_FileStream(module);
  PyModule_AddObject(module, "FileStream", (PyObject *)&Dtool_FileStream);
  // iostream
  Dtool_PyModuleClassInit_iostream(module);
  PyModule_AddObject(module, "iostream", (PyObject *)&Dtool_iostream);
  Py_INCREF(Dtool_Ptr_iostream);
  PyModule_AddObject(module, "Iostream", (PyObject *)&Dtool_iostream);
  // istream
  Dtool_PyModuleClassInit_istream(module);
  PyModule_AddObject(module, "istream", (PyObject *)&Dtool_istream);
  Py_INCREF(Dtool_Ptr_istream);
  PyModule_AddObject(module, "Istream", (PyObject *)&Dtool_istream);
  // ios
  Dtool_PyModuleClassInit_ios(module);
  PyModule_AddObject(module, "ios", (PyObject *)&Dtool_ios);
  Py_INCREF(Dtool_Ptr_ios);
  PyModule_AddObject(module, "Ios", (PyObject *)&Dtool_ios);
  // ios_base
  Dtool_PyModuleClassInit_ios_base(module);
  PyModule_AddObject(module, "ios_base", (PyObject *)&Dtool_ios_base);
  Py_INCREF(Dtool_Ptr_ios_base);
  PyModule_AddObject(module, "IosBase", (PyObject *)&Dtool_ios_base);
  // ostream
  Dtool_PyModuleClassInit_ostream(module);
  PyModule_AddObject(module, "ostream", (PyObject *)&Dtool_ostream);
  Py_INCREF(Dtool_Ptr_ostream);
  PyModule_AddObject(module, "Ostream", (PyObject *)&Dtool_ostream);
  // GlobPattern
  Dtool_PyModuleClassInit_GlobPattern(module);
  PyModule_AddObject(module, "GlobPattern", (PyObject *)&Dtool_GlobPattern);
  // IDecryptStream
  Dtool_PyModuleClassInit_IDecryptStream(module);
  PyModule_AddObject(module, "IDecryptStream", (PyObject *)&Dtool_IDecryptStream);
  // IFileStream
  Dtool_PyModuleClassInit_IFileStream(module);
  PyModule_AddObject(module, "IFileStream", (PyObject *)&Dtool_IFileStream);
  // IStreamWrapper
  Dtool_PyModuleClassInit_IStreamWrapper(module);
  PyModule_AddObject(module, "IStreamWrapper", (PyObject *)&Dtool_IStreamWrapper);
  // StreamWrapperBase
  Dtool_PyModuleClassInit_StreamWrapperBase(module);
  PyModule_AddObject(module, "StreamWrapperBase", (PyObject *)&Dtool_StreamWrapperBase);
  // LineStream
  Dtool_PyModuleClassInit_LineStream(module);
  PyModule_AddObject(module, "LineStream", (PyObject *)&Dtool_LineStream);
  // NeverFreeMemory
  Dtool_PyModuleClassInit_NeverFreeMemory(module);
  PyModule_AddObject(module, "NeverFreeMemory", (PyObject *)&Dtool_NeverFreeMemory);
  // Notify
  Dtool_PyModuleClassInit_Notify(module);
  PyModule_AddObject(module, "Notify", (PyObject *)&Dtool_Notify);
  // NotifyCategory
  Dtool_PyModuleClassInit_NotifyCategory(module);
  PyModule_AddObject(module, "NotifyCategory", (PyObject *)&Dtool_NotifyCategory);
  // OEncryptStream
  Dtool_PyModuleClassInit_OEncryptStream(module);
  PyModule_AddObject(module, "OEncryptStream", (PyObject *)&Dtool_OEncryptStream);
  // OFileStream
  Dtool_PyModuleClassInit_OFileStream(module);
  PyModule_AddObject(module, "OFileStream", (PyObject *)&Dtool_OFileStream);
  // OStreamWrapper
  Dtool_PyModuleClassInit_OStreamWrapper(module);
  PyModule_AddObject(module, "OStreamWrapper", (PyObject *)&Dtool_OStreamWrapper);
  // typedef PointerToArray< double > PTA_double
  Dtool_PyModuleClassInit_PointerToArray_double(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_double);
  PyModule_AddObject(module, "PTA_double", (PyObject *)&Dtool_PointerToArray_double);
  Py_INCREF(Dtool_Ptr_PointerToArray_double);
  PyModule_AddObject(module, "PTADouble", (PyObject *)&Dtool_PointerToArray_double);
  // PointerToArray< double >
  Dtool_PyModuleClassInit_PointerToArray_double(module);
  PyModule_AddObject(module, "PointerToArray_double", (PyObject *)&Dtool_PointerToArray_double);
  Py_INCREF(Dtool_Ptr_PointerToArray_double);
  PyModule_AddObject(module, "PointerToArrayDouble", (PyObject *)&Dtool_PointerToArray_double);
  // typedef PointerToArray< float > PTA_float
  Dtool_PyModuleClassInit_PointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_float);
  PyModule_AddObject(module, "PTA_float", (PyObject *)&Dtool_PointerToArray_float);
  Py_INCREF(Dtool_Ptr_PointerToArray_float);
  PyModule_AddObject(module, "PTAFloat", (PyObject *)&Dtool_PointerToArray_float);
  // PointerToArray< float >
  Dtool_PyModuleClassInit_PointerToArray_float(module);
  PyModule_AddObject(module, "PointerToArray_float", (PyObject *)&Dtool_PointerToArray_float);
  Py_INCREF(Dtool_Ptr_PointerToArray_float);
  PyModule_AddObject(module, "PointerToArrayFloat", (PyObject *)&Dtool_PointerToArray_float);
  // typedef PointerToArray< int > PTA_int
  Dtool_PyModuleClassInit_PointerToArray_int(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_int);
  PyModule_AddObject(module, "PTA_int", (PyObject *)&Dtool_PointerToArray_int);
  Py_INCREF(Dtool_Ptr_PointerToArray_int);
  PyModule_AddObject(module, "PTAInt", (PyObject *)&Dtool_PointerToArray_int);
  // PointerToArray< int >
  Dtool_PyModuleClassInit_PointerToArray_int(module);
  PyModule_AddObject(module, "PointerToArray_int", (PyObject *)&Dtool_PointerToArray_int);
  Py_INCREF(Dtool_Ptr_PointerToArray_int);
  PyModule_AddObject(module, "PointerToArrayInt", (PyObject *)&Dtool_PointerToArray_int);
  // typedef PointerToArray< unsigned char > PTA_uchar
  Dtool_PyModuleClassInit_PointerToArray_unsigned_char(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_unsigned_char);
  PyModule_AddObject(module, "PTA_uchar", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToArray_unsigned_char);
  PyModule_AddObject(module, "PTAUchar", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  // PointerToArray< unsigned char >
  Dtool_PyModuleClassInit_PointerToArray_unsigned_char(module);
  PyModule_AddObject(module, "PointerToArray_unsigned_char", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToArray_unsigned_char);
  PyModule_AddObject(module, "PointerToArrayUnsignedChar", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  // PandaSystem
  Dtool_PyModuleClassInit_PandaSystem(module);
  PyModule_AddObject(module, "PandaSystem", (PyObject *)&Dtool_PandaSystem);
  // StreamReader
  Dtool_PyModuleClassInit_StreamReader(module);
  PyModule_AddObject(module, "StreamReader", (PyObject *)&Dtool_StreamReader);
  // StreamWrapper
  Dtool_PyModuleClassInit_StreamWrapper(module);
  PyModule_AddObject(module, "StreamWrapper", (PyObject *)&Dtool_StreamWrapper);
  // StreamWriter
  Dtool_PyModuleClassInit_StreamWriter(module);
  PyModule_AddObject(module, "StreamWriter", (PyObject *)&Dtool_StreamWriter);
  // TextEncoder
  Dtool_PyModuleClassInit_TextEncoder(module);
  PyModule_AddObject(module, "TextEncoder", (PyObject *)&Dtool_TextEncoder);
  // TypeHandle
  Dtool_PyModuleClassInit_TypeHandle(module);
  PyModule_AddObject(module, "TypeHandle", (PyObject *)&Dtool_TypeHandle);
  // TypeRegistry
  Dtool_PyModuleClassInit_TypeRegistry(module);
  PyModule_AddObject(module, "TypeRegistry", (PyObject *)&Dtool_TypeRegistry);
  // TypedObject
  Dtool_PyModuleClassInit_TypedObject(module);
  PyModule_AddObject(module, "TypedObject", (PyObject *)&Dtool_TypedObject);
  // fstream
  Dtool_PyModuleClassInit_fstream(module);
  PyModule_AddObject(module, "fstream", (PyObject *)&Dtool_fstream);
  Py_INCREF(Dtool_Ptr_fstream);
  PyModule_AddObject(module, "Fstream", (PyObject *)&Dtool_fstream);
  // ifstream
  Dtool_PyModuleClassInit_ifstream(module);
  PyModule_AddObject(module, "ifstream", (PyObject *)&Dtool_ifstream);
  Py_INCREF(Dtool_Ptr_ifstream);
  PyModule_AddObject(module, "Ifstream", (PyObject *)&Dtool_ifstream);
  // ofstream
  Dtool_PyModuleClassInit_ofstream(module);
  PyModule_AddObject(module, "ofstream", (PyObject *)&Dtool_ofstream);
  Py_INCREF(Dtool_Ptr_ofstream);
  PyModule_AddObject(module, "Ofstream", (PyObject *)&Dtool_ofstream);
  // MemoryUsage
  Dtool_PyModuleClassInit_MemoryUsage(module);
  PyModule_AddObject(module, "MemoryUsage", (PyObject *)&Dtool_MemoryUsage);
  // ReferenceCount
  Dtool_PyModuleClassInit_ReferenceCount(module);
  PyModule_AddObject(module, "ReferenceCount", (PyObject *)&Dtool_ReferenceCount);
  // Buffer
  Dtool_PyModuleClassInit_Buffer(module);
  PyModule_AddObject(module, "Buffer", (PyObject *)&Dtool_Buffer);
  // PStatCollectorForwardBase
  Dtool_PyModuleClassInit_PStatCollectorForwardBase(module);
  PyModule_AddObject(module, "PStatCollectorForwardBase", (PyObject *)&Dtool_PStatCollectorForwardBase);
  // NodeReferenceCount
  Dtool_PyModuleClassInit_NodeReferenceCount(module);
  PyModule_AddObject(module, "NodeReferenceCount", (PyObject *)&Dtool_NodeReferenceCount);
  // Datagram
  Dtool_PyModuleClassInit_Datagram(module);
  PyModule_AddObject(module, "Datagram", (PyObject *)&Dtool_Datagram);
  // DatagramGenerator
  Dtool_PyModuleClassInit_DatagramGenerator(module);
  PyModule_AddObject(module, "DatagramGenerator", (PyObject *)&Dtool_DatagramGenerator);
  // DatagramIterator
  Dtool_PyModuleClassInit_DatagramIterator(module);
  PyModule_AddObject(module, "DatagramIterator", (PyObject *)&Dtool_DatagramIterator);
  // DatagramSink
  Dtool_PyModuleClassInit_DatagramSink(module);
  PyModule_AddObject(module, "DatagramSink", (PyObject *)&Dtool_DatagramSink);
  // TypedReferenceCount
  Dtool_PyModuleClassInit_TypedReferenceCount(module);
  PyModule_AddObject(module, "TypedReferenceCount", (PyObject *)&Dtool_TypedReferenceCount);
  // FileReference
  Dtool_PyModuleClassInit_FileReference(module);
  PyModule_AddObject(module, "FileReference", (PyObject *)&Dtool_FileReference);
  // Ramfile
  Dtool_PyModuleClassInit_Ramfile(module);
  PyModule_AddObject(module, "Ramfile", (PyObject *)&Dtool_Ramfile);
  // HashVal
  Dtool_PyModuleClassInit_HashVal(module);
  PyModule_AddObject(module, "HashVal", (PyObject *)&Dtool_HashVal);
  // MemoryUsagePointers
  Dtool_PyModuleClassInit_MemoryUsagePointers(module);
  PyModule_AddObject(module, "MemoryUsagePointers", (PyObject *)&Dtool_MemoryUsagePointers);
  // ISubStream
  Dtool_PyModuleClassInit_ISubStream(module);
  PyModule_AddObject(module, "ISubStream", (PyObject *)&Dtool_ISubStream);
  // OSubStream
  Dtool_PyModuleClassInit_OSubStream(module);
  PyModule_AddObject(module, "OSubStream", (PyObject *)&Dtool_OSubStream);
  // SubStream
  Dtool_PyModuleClassInit_SubStream(module);
  PyModule_AddObject(module, "SubStream", (PyObject *)&Dtool_SubStream);
  // OpenSSLWrapper
  Dtool_PyModuleClassInit_OpenSSLWrapper(module);
  PyModule_AddObject(module, "OpenSSLWrapper", (PyObject *)&Dtool_OpenSSLWrapper);
  // Multifile
  Dtool_PyModuleClassInit_Multifile(module);
  PyModule_AddObject(module, "Multifile", (PyObject *)&Dtool_Multifile);
  // Namable
  Dtool_PyModuleClassInit_Namable(module);
  PyModule_AddObject(module, "Namable", (PyObject *)&Dtool_Namable);
  // SubfileInfo
  Dtool_PyModuleClassInit_SubfileInfo(module);
  PyModule_AddObject(module, "SubfileInfo", (PyObject *)&Dtool_SubfileInfo);
  // VirtualFile
  Dtool_PyModuleClassInit_VirtualFile(module);
  PyModule_AddObject(module, "VirtualFile", (PyObject *)&Dtool_VirtualFile);
  // VirtualFileComposite
  Dtool_PyModuleClassInit_VirtualFileComposite(module);
  PyModule_AddObject(module, "VirtualFileComposite", (PyObject *)&Dtool_VirtualFileComposite);
  // VirtualFileMount
  Dtool_PyModuleClassInit_VirtualFileMount(module);
  PyModule_AddObject(module, "VirtualFileMount", (PyObject *)&Dtool_VirtualFileMount);
  // VirtualFileMountMultifile
  Dtool_PyModuleClassInit_VirtualFileMountMultifile(module);
  PyModule_AddObject(module, "VirtualFileMountMultifile", (PyObject *)&Dtool_VirtualFileMountMultifile);
  // VirtualFileMountRamdisk
  Dtool_PyModuleClassInit_VirtualFileMountRamdisk(module);
  PyModule_AddObject(module, "VirtualFileMountRamdisk", (PyObject *)&Dtool_VirtualFileMountRamdisk);
  // VirtualFileMountSystem
  Dtool_PyModuleClassInit_VirtualFileMountSystem(module);
  PyModule_AddObject(module, "VirtualFileMountSystem", (PyObject *)&Dtool_VirtualFileMountSystem);
  // VirtualFileSimple
  Dtool_PyModuleClassInit_VirtualFileSimple(module);
  PyModule_AddObject(module, "VirtualFileSimple", (PyObject *)&Dtool_VirtualFileSimple);
  // TemporaryFile
  Dtool_PyModuleClassInit_TemporaryFile(module);
  PyModule_AddObject(module, "TemporaryFile", (PyObject *)&Dtool_TemporaryFile);
  // IDecompressStream
  Dtool_PyModuleClassInit_IDecompressStream(module);
  PyModule_AddObject(module, "IDecompressStream", (PyObject *)&Dtool_IDecompressStream);
  // OCompressStream
  Dtool_PyModuleClassInit_OCompressStream(module);
  PyModule_AddObject(module, "OCompressStream", (PyObject *)&Dtool_OCompressStream);
  // VirtualFileList
  Dtool_PyModuleClassInit_VirtualFileList(module);
  PyModule_AddObject(module, "VirtualFileList", (PyObject *)&Dtool_VirtualFileList);
  // VirtualFileSystem
  Dtool_PyModuleClassInit_VirtualFileSystem(module);
  PyModule_AddObject(module, "VirtualFileSystem", (PyObject *)&Dtool_VirtualFileSystem);
  // PointerTo< VirtualFileMount >
  Dtool_PyModuleClassInit_PointerTo_VirtualFileMount(module);
  PyModule_AddObject(module, "PointerTo_VirtualFileMount", (PyObject *)&Dtool_PointerTo_VirtualFileMount);
  Py_INCREF(Dtool_Ptr_PointerTo_VirtualFileMount);
  PyModule_AddObject(module, "PointerToVirtualFileMount", (PyObject *)&Dtool_PointerTo_VirtualFileMount);
  // PointerToBase< VirtualFileMount >
  Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(module);
  PyModule_AddObject(module, "PointerToBase_VirtualFileMount", (PyObject *)&Dtool_PointerToBase_VirtualFileMount);
  Py_INCREF(Dtool_Ptr_PointerToBase_VirtualFileMount);
  PyModule_AddObject(module, "PointerToBaseVirtualFileMount", (PyObject *)&Dtool_PointerToBase_VirtualFileMount);
  // TrueClock
  Dtool_PyModuleClassInit_TrueClock(module);
  PyModule_AddObject(module, "TrueClock", (PyObject *)&Dtool_TrueClock);
  // Patchfile
  Dtool_PyModuleClassInit_Patchfile(module);
  PyModule_AddObject(module, "Patchfile", (PyObject *)&Dtool_Patchfile);
  // ProfileTimer
  Dtool_PyModuleClassInit_ProfileTimer(module);
  PyModule_AddObject(module, "ProfileTimer", (PyObject *)&Dtool_ProfileTimer);
  // WeakPointerToVoid
  Dtool_PyModuleClassInit_WeakPointerToVoid(module);
  PyModule_AddObject(module, "WeakPointerToVoid", (PyObject *)&Dtool_WeakPointerToVoid);
  // WindowsRegistry
  Dtool_PyModuleClassInit_WindowsRegistry(module);
  PyModule_AddObject(module, "WindowsRegistry", (PyObject *)&Dtool_WindowsRegistry);
  // typedef PointerToArray< float > PTA_stdfloat
  Dtool_PyModuleClassInit_PointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_float);
  PyModule_AddObject(module, "PTA_stdfloat", (PyObject *)&Dtool_PointerToArray_float);
  Py_INCREF(Dtool_Ptr_PointerToArray_float);
  PyModule_AddObject(module, "PTAStdfloat", (PyObject *)&Dtool_PointerToArray_float);
  // typedef ConstPointerToArray< float > CPTA_stdfloat
  Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTA_stdfloat", (PyObject *)&Dtool_ConstPointerToArray_float);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTAStdfloat", (PyObject *)&Dtool_ConstPointerToArray_float);
}

static PyMethodDef python_simple_funcs[] = {
  {"get_config_express", &Dtool_get_config_express_1060, METH_NOARGS, (const char *)Dtool_get_config_express_1060_comment},
  {"getConfigExpress", &Dtool_get_config_express_1060, METH_NOARGS, (const char *)Dtool_get_config_express_1060_comment},
  {"compress_string", (PyCFunction) &Dtool_compress_string_1075, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_string_1075_comment},
  {"compressString", (PyCFunction) &Dtool_compress_string_1075, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_string_1075_comment},
  {"decompress_string", &Dtool_decompress_string_1076, METH_O, (const char *)Dtool_decompress_string_1076_comment},
  {"decompressString", &Dtool_decompress_string_1076, METH_O, (const char *)Dtool_decompress_string_1076_comment},
  {"compress_file", (PyCFunction) &Dtool_compress_file_1077, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_file_1077_comment},
  {"compressFile", (PyCFunction) &Dtool_compress_file_1077, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_file_1077_comment},
  {"decompress_file", (PyCFunction) &Dtool_decompress_file_1078, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_file_1078_comment},
  {"decompressFile", (PyCFunction) &Dtool_decompress_file_1078, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_file_1078_comment},
  {"compress_stream", (PyCFunction) &Dtool_compress_stream_1079, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_stream_1079_comment},
  {"compressStream", (PyCFunction) &Dtool_compress_stream_1079, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_stream_1079_comment},
  {"decompress_stream", (PyCFunction) &Dtool_decompress_stream_1080, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_stream_1080_comment},
  {"decompressStream", (PyCFunction) &Dtool_decompress_stream_1080, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_stream_1080_comment},
  {"copy_stream", (PyCFunction) &Dtool_copy_stream_1081, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_copy_stream_1081_comment},
  {"copyStream", (PyCFunction) &Dtool_copy_stream_1081, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_copy_stream_1081_comment},
  {"encrypt_string", (PyCFunction) &Dtool_encrypt_string_1196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_string_1196_comment},
  {"encryptString", (PyCFunction) &Dtool_encrypt_string_1196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_string_1196_comment},
  {"decrypt_string", (PyCFunction) &Dtool_decrypt_string_1197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_string_1197_comment},
  {"decryptString", (PyCFunction) &Dtool_decrypt_string_1197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_string_1197_comment},
  {"encrypt_file", (PyCFunction) &Dtool_encrypt_file_1198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_file_1198_comment},
  {"encryptFile", (PyCFunction) &Dtool_encrypt_file_1198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_file_1198_comment},
  {"decrypt_file", (PyCFunction) &Dtool_decrypt_file_1199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_file_1199_comment},
  {"decryptFile", (PyCFunction) &Dtool_decrypt_file_1199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_file_1199_comment},
  {"encrypt_stream", (PyCFunction) &Dtool_encrypt_stream_1200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_stream_1200_comment},
  {"encryptStream", (PyCFunction) &Dtool_encrypt_stream_1200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_stream_1200_comment},
  {"decrypt_stream", (PyCFunction) &Dtool_decrypt_stream_1201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_stream_1201_comment},
  {"decryptStream", (PyCFunction) &Dtool_decrypt_stream_1201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_stream_1201_comment},
  {"error_to_text", &Dtool_error_to_text_1203, METH_O, (const char *)Dtool_error_to_text_1203_comment},
  {"errorToText", &Dtool_error_to_text_1203, METH_O, (const char *)Dtool_error_to_text_1203_comment},
  {"get_write_error", &Dtool_get_write_error_1204, METH_NOARGS, (const char *)Dtool_get_write_error_1204_comment},
  {"getWriteError", &Dtool_get_write_error_1204, METH_NOARGS, (const char *)Dtool_get_write_error_1204_comment},
  {"handle_socket_error", &Dtool_handle_socket_error_1205, METH_NOARGS, (const char *)Dtool_handle_socket_error_1205_comment},
  {"handleSocketError", &Dtool_handle_socket_error_1205, METH_NOARGS, (const char *)Dtool_handle_socket_error_1205_comment},
  {"get_network_error", &Dtool_get_network_error_1206, METH_NOARGS, (const char *)Dtool_get_network_error_1206_comment},
  {"getNetworkError", &Dtool_get_network_error_1206, METH_NOARGS, (const char *)Dtool_get_network_error_1206_comment},
  {"password_hash", (PyCFunction) &Dtool_password_hash_1555, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_password_hash_1555_comment},
  {"passwordHash", (PyCFunction) &Dtool_password_hash_1555, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_password_hash_1555_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3express_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478209493,  /* file_identifier */
  "libp3express",  /* library_name */
  "vDgf",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3express.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  3257  /* next_index */
};

Configure(_in_configure_libp3express);
ConfigureFn(_in_configure_libp3express) {
  interrogate_request_module(&_in_module_def);
}

