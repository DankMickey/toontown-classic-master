/*
 * This file was generated by:
 * built\bin\interrogate -v -srcdir direct/src/distributed -Idirect/src/distributed -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -DWIN32_VC -DWIN32 -D_WIN32 -D_M_IX86 -D_MSC_VER=1600 -D__declspec(param)= -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall -oc built/tmp/libp3distributed_igate.cxx -od built/pandac/input/libp3distributed.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/distributed -Sbuilt/tmp -Sbuilt/include -Sthirdparty/win-python/include -Sthirdparty/win-libs-vc10/openssl/include -Sthirdparty/win-libs-vc10/extras/include -DWITHIN_PANDA=1 -module panda3d.direct -library libp3distributed cConnectionRepository.cxx cConnectionRepository.h cDistributedSmoothNodeBase.cxx cDistributedSmoothNodeBase.h config_distributed.cxx config_distributed.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libp3distributed
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "cConnectionRepository.h"
#include "cDistributedSmoothNodeBase.h"
#include "config_distributed.h"
#include "config_downloader.h"
#include "datagramIterator.h"
#include "dcClass.h"
#include "dcField.h"
#include "dcPacker.h"
#include "dcmsgtypes.h"
#include "dconfig.h"
#include "httpChannel.h"
#include "pStatTimer.h"
#include "py_panda.h"
#include "throw_event.h"
#include "urlSpec.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CConnectionRepository
 */
typedef CConnectionRepository CConnectionRepository_localtype;
Define_Module_Class(panda3d.direct, CConnectionRepository, CConnectionRepository_localtype, CConnectionRepository);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConnectionRepository = &Dtool_CConnectionRepository;
static void Dtool_PyModuleClassInit_CConnectionRepository(PyObject *module);
bool Dtool_ConstCoerce_CConnectionRepository(PyObject *args, CConnectionRepository const *&coerced, bool &manage);
bool Dtool_Coerce_CConnectionRepository(PyObject *args, CConnectionRepository *&coerced, bool &manage);

/**
 * Forward declarations for top-level class CDistributedSmoothNodeBase
 */
typedef CDistributedSmoothNodeBase CDistributedSmoothNodeBase_localtype;
Define_Module_Class(panda3d.direct, CDistributedSmoothNodeBase, CDistributedSmoothNodeBase_localtype, CDistributedSmoothNodeBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CDistributedSmoothNodeBase = &Dtool_CDistributedSmoothNodeBase;
static void Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(PyObject *module);

/**
 * Extern declarations for imported classes
 */
// DCFile
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DCFile;
#else
extern struct Dtool_PyTypedObject Dtool_DCFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCFile = &Dtool_DCFile;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_Datagram;
inline static bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram const *&, bool&))Dtool_Ptr_Datagram->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_Datagram != NULL, false);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, Datagram *&, bool&))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern bool Dtool_ConstCoerce_Datagram(PyObject *args, Datagram const *&coerced, bool &manage);
extern bool Dtool_Coerce_Datagram(PyObject *args, Datagram *&coerced, bool &manage);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DatagramIterator;
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != NULL, NULL);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != NULL, NULL);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// QueuedConnectionManager
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_QueuedConnectionManager;
#else
extern struct Dtool_PyTypedObject Dtool_QueuedConnectionManager;
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionManager = &Dtool_QueuedConnectionManager;
#endif
// ConnectionWriter
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_ConnectionWriter;
inline static bool Dtool_ConstCoerce_ConnectionWriter(PyObject *args, ConnectionWriter const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_ConnectionWriter != NULL, false);
  nassertr(Dtool_Ptr_ConnectionWriter->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, ConnectionWriter const *&, bool&))Dtool_Ptr_ConnectionWriter->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_ConnectionWriter(PyObject *args, ConnectionWriter *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_ConnectionWriter != NULL, false);
  nassertr(Dtool_Ptr_ConnectionWriter->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, ConnectionWriter *&, bool&))Dtool_Ptr_ConnectionWriter->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConnectionWriter;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionWriter = &Dtool_ConnectionWriter;
extern bool Dtool_ConstCoerce_ConnectionWriter(PyObject *args, ConnectionWriter const *&coerced, bool &manage);
extern bool Dtool_Coerce_ConnectionWriter(PyObject *args, ConnectionWriter *&coerced, bool &manage);
#endif
// DCClass
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_DCClass;
#else
extern struct Dtool_PyTypedObject Dtool_DCClass;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCClass = &Dtool_DCClass;
#endif
// QueuedConnectionReader
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_QueuedConnectionReader;
inline static bool Dtool_ConstCoerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_QueuedConnectionReader != NULL, false);
  nassertr(Dtool_Ptr_QueuedConnectionReader->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, QueuedConnectionReader const *&, bool&))Dtool_Ptr_QueuedConnectionReader->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_QueuedConnectionReader != NULL, false);
  nassertr(Dtool_Ptr_QueuedConnectionReader->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, QueuedConnectionReader *&, bool&))Dtool_Ptr_QueuedConnectionReader->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_QueuedConnectionReader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionReader = &Dtool_QueuedConnectionReader;
extern bool Dtool_ConstCoerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader const *&coerced, bool &manage);
extern bool Dtool_Coerce_QueuedConnectionReader(PyObject *args, QueuedConnectionReader *&coerced, bool &manage);
#endif
// URLSpec
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_URLSpec;
inline static bool Dtool_ConstCoerce_URLSpec(PyObject *args, URLSpec const *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_URLSpec != NULL, false);
  nassertr(Dtool_Ptr_URLSpec->_Dtool_ConstCoerce != NULL, false);
  return ((bool (*)(PyObject *, URLSpec const *&, bool&))Dtool_Ptr_URLSpec->_Dtool_ConstCoerce)(args, coerced, manage);
}
inline static bool Dtool_Coerce_URLSpec(PyObject *args, URLSpec *&coerced, bool &manage) {
  nassertr(Dtool_Ptr_URLSpec != NULL, false);
  nassertr(Dtool_Ptr_URLSpec->_Dtool_Coerce != NULL, false);
  return ((bool (*)(PyObject *, URLSpec *&, bool&))Dtool_Ptr_URLSpec->_Dtool_Coerce)(args, coerced, manage);
}
#else
extern struct Dtool_PyTypedObject Dtool_URLSpec;
static struct Dtool_PyTypedObject *const Dtool_Ptr_URLSpec = &Dtool_URLSpec;
extern bool Dtool_ConstCoerce_URLSpec(PyObject *args, URLSpec const *&coerced, bool &manage);
extern bool Dtool_Coerce_URLSpec(PyObject *args, URLSpec *&coerced, bool &manage);
#endif
// SocketStream
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_SocketStream;
#else
extern struct Dtool_PyTypedObject Dtool_SocketStream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SocketStream = &Dtool_SocketStream;
#endif
// HTTPChannel
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_HTTPChannel;
#else
extern struct Dtool_PyTypedObject Dtool_HTTPChannel;
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPChannel = &Dtool_HTTPChannel;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
static struct Dtool_PyTypedObject *Dtool_Ptr_NodePath;
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CConnectionRepository
 */
/**
 * Python function wrapper for:
 * inline DCFile &CConnectionRepository::get_dc_file(void)
 */
static PyObject *Dtool_CConnectionRepository_get_dc_file_4(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_dc_file")) {
    return NULL;
  }
  // 1-inline DCFile &CConnectionRepository::get_dc_file(void)
  DCFile *return_value = &((*local_this).get_dc_file());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCFile, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_dc_file_4_comment =
  "C++ Interface:\n"
  "get_dc_file(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the DCFile object associated with this repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_dc_file_4_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::has_owner_view(void) const
 */
static PyObject *Dtool_CConnectionRepository_has_owner_view_5(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::has_owner_view(void) const
  bool return_value = (*(const CConnectionRepository*)local_this).has_owner_view();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_has_owner_view_5_comment =
  "C++ Interface:\n"
  "has_owner_view(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if this repository can have 'owner' views of distributed\n"
  " * objects.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_has_owner_view_5_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates)
 */
static PyObject *Dtool_CConnectionRepository_set_handle_c_updates_6(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_handle_c_updates")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates)
  (*local_this).set_handle_c_updates((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_handle_c_updates(const CConnectionRepository self, bool handle_c_updates)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_handle_c_updates_6_comment =
  "C++ Interface:\n"
  "set_handle_c_updates(const CConnectionRepository self, bool handle_c_updates)\n"
  "\n"
  "/**\n"
  " * Set true to specify this repository should process distributed updates\n"
  " * internally in C++ code, or false if it should return them to Python.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_handle_c_updates_6_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_handle_c_updates(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_handle_c_updates_7(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_handle_c_updates(void) const
  bool return_value = (*(const CConnectionRepository*)local_this).get_handle_c_updates();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_handle_c_updates_7_comment =
  "C++ Interface:\n"
  "get_handle_c_updates(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if this repository will process distributed updates internally\n"
  " * in C++ code, or false if it will return them to Python.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_handle_c_updates_7_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_client_datagram(bool client_datagram)
 */
static PyObject *Dtool_CConnectionRepository_set_client_datagram_8(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_client_datagram")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_client_datagram(bool client_datagram)
  (*local_this).set_client_datagram((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_datagram(const CConnectionRepository self, bool client_datagram)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_client_datagram_8_comment =
  "C++ Interface:\n"
  "set_client_datagram(const CConnectionRepository self, bool client_datagram)\n"
  "\n"
  "/**\n"
  " * Sets the client_datagram flag.  If this is true, incoming datagrams are not\n"
  " * expected to be prefixed with the server routing information like message\n"
  " * sender, channel number, etc.; otherwise, these server fields are parsed and\n"
  " * removed from each incoming datagram.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_client_datagram_8_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_client_datagram(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_client_datagram_9(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_client_datagram(void) const
  bool return_value = (*(const CConnectionRepository*)local_this).get_client_datagram();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_client_datagram_9_comment =
  "C++ Interface:\n"
  "get_client_datagram(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the client_datagram flag.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_client_datagram_9_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally)
 */
static PyObject *Dtool_CConnectionRepository_set_handle_datagrams_internally_10(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_handle_datagrams_internally")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally)
  (*local_this).set_handle_datagrams_internally((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_handle_datagrams_internally(const CConnectionRepository self, bool handle_datagrams_internally)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment =
  "C++ Interface:\n"
  "set_handle_datagrams_internally(const CConnectionRepository self, bool handle_datagrams_internally)\n"
  "\n"
  "/**\n"
  " * Sets the handle_datagrams_internally flag.  When true, certain message\n"
  " * types can be handled by the C++ code in in this module.  When false, all\n"
  " * datagrams, regardless of message type, are passed up to Python for\n"
  " * processing.\n"
  " *\n"
  " * The CMU distributed-object implementation requires this to be set false.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_handle_datagrams_internally(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_handle_datagrams_internally_11(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_handle_datagrams_internally(void) const
  bool return_value = (*(const CConnectionRepository*)local_this).get_handle_datagrams_internally();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment =
  "C++ Interface:\n"
  "get_handle_datagrams_internally(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the handle_datagrams_internally flag.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_CConnectionRepository_set_tcp_header_size_12(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_tcp_header_size")) {
    return NULL;
  }
  // 1-void CConnectionRepository::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (*local_this).set_tcp_header_size((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const CConnectionRepository self, int tcp_header_size)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_tcp_header_size_12_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const CConnectionRepository self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size of TCP packets.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_tcp_header_size_12_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CConnectionRepository::get_tcp_header_size(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_tcp_header_size_13(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CConnectionRepository::get_tcp_header_size(void) const
  int return_value = (*(const CConnectionRepository*)local_this).get_tcp_header_size();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_tcp_header_size_13_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of TCP header size.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_tcp_header_size_13_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_python_repository(PyObject *python_repository)
 */
static PyObject *Dtool_CConnectionRepository_set_python_repository_14(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_python_repository")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_python_repository(PyObject *python_repository)
  (*local_this).set_python_repository(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_repository(const CConnectionRepository self, object python_repository)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_python_repository_14_comment =
  "C++ Interface:\n"
  "set_python_repository(const CConnectionRepository self, object python_repository)\n"
  "\n"
  "/**\n"
  " * Records the pointer to the Python class that derives from\n"
  " * CConnectionRepository.  This allows the C++ implementation to directly\n"
  " * manipulation some python structures on the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_python_repository_14_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::set_connection_http(HTTPChannel *channel)
 */
static PyObject *Dtool_CConnectionRepository_set_connection_http_15(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_connection_http")) {
    return NULL;
  }
  // 1-void CConnectionRepository::set_connection_http(HTTPChannel *channel)
  HTTPChannel *arg_this = (HTTPChannel *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPChannel, 1, "CConnectionRepository.set_connection_http", false, true);
  if (arg_this != NULL) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).set_connection_http(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_connection_http(const CConnectionRepository self, HTTPChannel channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_connection_http_15_comment =
  "C++ Interface:\n"
  "set_connection_http(const CConnectionRepository self, HTTPChannel channel)\n"
  "\n"
  "/**\n"
  " * Once a connection has been established via the HTTP interface, gets the\n"
  " * connection and uses it.  The supplied HTTPChannel object must have a\n"
  " * connection available via get_connection().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_connection_http_15_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * SocketStream *CConnectionRepository::get_stream(void)
 */
static PyObject *Dtool_CConnectionRepository_get_stream_16(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_stream")) {
    return NULL;
  }
  // 1-SocketStream *CConnectionRepository::get_stream(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  SocketStream *return_value = (*local_this).get_stream();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_stream_16_comment =
  "C++ Interface:\n"
  "get_stream(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the SocketStream that internally represents the already-established\n"
  " * HTTP connection.  Returns NULL if there is no current HTTP connection.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_stream_16_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::try_connect_net(URLSpec const &url)
 */
static PyObject *Dtool_CConnectionRepository_try_connect_net_17(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.try_connect_net")) {
    return NULL;
  }
  // 1-bool CConnectionRepository::try_connect_net(URLSpec const &url)
  URLSpec const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_URLSpec(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.try_connect_net", "URLSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).try_connect_net(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "try_connect_net(const CConnectionRepository self, const URLSpec url)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_try_connect_net_17_comment =
  "C++ Interface:\n"
  "try_connect_net(const CConnectionRepository self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Uses Panda's \"net\" library to try to connect to the server and port named\n"
  " * in the indicated URL.  Returns true if successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_try_connect_net_17_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline QueuedConnectionManager &CConnectionRepository::get_qcm(void)
 */
static PyObject *Dtool_CConnectionRepository_get_qcm_18(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_qcm")) {
    return NULL;
  }
  // 1-inline QueuedConnectionManager &CConnectionRepository::get_qcm(void)
  QueuedConnectionManager *return_value = &((*local_this).get_qcm());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_qcm_18_comment =
  "C++ Interface:\n"
  "get_qcm(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the QueuedConnectionManager object associated with the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_qcm_18_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline ConnectionWriter &CConnectionRepository::get_cw(void)
 */
static PyObject *Dtool_CConnectionRepository_get_cw_19(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_cw")) {
    return NULL;
  }
  // 1-inline ConnectionWriter &CConnectionRepository::get_cw(void)
  ConnectionWriter *return_value = &((*local_this).get_cw());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_cw_19_comment =
  "C++ Interface:\n"
  "get_cw(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the ConnectionWriter object associated with the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_cw_19_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline QueuedConnectionReader &CConnectionRepository::get_qcr(void)
 */
static PyObject *Dtool_CConnectionRepository_get_qcr_20(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_qcr")) {
    return NULL;
  }
  // 1-inline QueuedConnectionReader &CConnectionRepository::get_qcr(void)
  QueuedConnectionReader *return_value = &((*local_this).get_qcr());
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_qcr_20_comment =
  "C++ Interface:\n"
  "get_qcr(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the QueuedConnectionReader object associated with the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_qcr_20_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::check_datagram(void)
 */
static PyObject *Dtool_CConnectionRepository_check_datagram_21(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.check_datagram")) {
    return NULL;
  }
  // 1-bool CConnectionRepository::check_datagram(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).check_datagram();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_check_datagram_21_comment =
  "C++ Interface:\n"
  "check_datagram(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if a new datagram is available, false otherwise.  If the\n"
  " * return value is true, the new datagram may be retrieved via get_datagram(),\n"
  " * or preferably, with get_datagram_iterator() and get_msg_type().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_check_datagram_21_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::get_datagram(Datagram &dg)
 */
static PyObject *Dtool_CConnectionRepository_get_datagram_22(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_datagram")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::get_datagram(Datagram &dg)
  Datagram *arg_this;
  bool arg_manage = false;
  if (!Dtool_Coerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.get_datagram", "Datagram");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).get_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram(const CConnectionRepository self, Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_datagram_22_comment =
  "C++ Interface:\n"
  "get_datagram(const CConnectionRepository self, Datagram dg)\n"
  "\n"
  "/**\n"
  " * Fills the datagram object with the datagram most recently retrieved by\n"
  " * check_datagram().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_datagram_22_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &di)
 */
static PyObject *Dtool_CConnectionRepository_get_datagram_iterator_23(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_datagram_iterator")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &di)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != NULL)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.get_datagram_iterator", "DatagramIterator");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).get_datagram_iterator(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram_iterator(const CConnectionRepository self, DatagramIterator di)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_datagram_iterator_23_comment =
  "C++ Interface:\n"
  "get_datagram_iterator(const CConnectionRepository self, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Fills the DatagramIterator object with the iterator for the datagram most\n"
  " * recently retrieved by check_datagram().  This iterator has already read\n"
  " * past the datagram header and the message type, and is positioned at the\n"
  " * beginning of data.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_datagram_iterator_23_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CHANNEL_TYPE CConnectionRepository::get_msg_channel(int offset = 0) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_channel_24(PyObject *self, PyObject *args, PyObject *kwds) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CHANNEL_TYPE CConnectionRepository::get_msg_channel(int offset = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"offset", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_msg_channel", (char **)keyword_list, &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    CHANNEL_TYPE return_value = (*(const CConnectionRepository*)local_this).get_msg_channel((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return NULL;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_msg_channel(CConnectionRepository self, int offset)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_channel_24_comment =
  "C++ Interface:\n"
  "get_msg_channel(CConnectionRepository self, int offset)\n"
  "\n"
  "/**\n"
  " * Returns the channel(s) to which the current message was sent, according to\n"
  " * the datagram headers.  This information is not available to the client.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_msg_channel_24_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline int CConnectionRepository::get_msg_channel_count(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_channel_count_25(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline int CConnectionRepository::get_msg_channel_count(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int return_value = (*(const CConnectionRepository*)local_this).get_msg_channel_count();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_channel_count_25_comment =
  "C++ Interface:\n"
  "get_msg_channel_count(CConnectionRepository self)\n";
#else
static const char *Dtool_CConnectionRepository_get_msg_channel_count_25_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline CHANNEL_TYPE CConnectionRepository::get_msg_sender(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_sender_26(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline CHANNEL_TYPE CConnectionRepository::get_msg_sender(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  CHANNEL_TYPE return_value = (*(const CConnectionRepository*)local_this).get_msg_sender();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_sender_26_comment =
  "C++ Interface:\n"
  "get_msg_sender(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the sender ID of the current message, according to the datagram\n"
  " * headers.  This information is not available to the client.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_msg_sender_26_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int CConnectionRepository::get_msg_type(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_type_27(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline unsigned int CConnectionRepository::get_msg_type(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  unsigned int return_value = (*(const CConnectionRepository*)local_this).get_msg_type();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_type_27_comment =
  "C++ Interface:\n"
  "get_msg_type(CConnectionRepository self)\n"
  "\n"
  "// INLINE unsigned char get_sec_code() const;\n"
  "\n"
  "/**\n"
  " * Returns the type ID of the current message, according to the datagram\n"
  " * headers.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_msg_type_27_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * static inline std::string const &CConnectionRepository::get_overflow_event_name(void)
 */
static PyObject *Dtool_CConnectionRepository_get_overflow_event_name_28(PyObject *, PyObject *) {
  // 1-static inline std::string const &CConnectionRepository::get_overflow_event_name(void)
  std::string const &return_value = CConnectionRepository::get_overflow_event_name();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_overflow_event_name_28_comment =
  "C++ Interface:\n"
  "get_overflow_event_name()\n"
  "\n"
  "/**\n"
  " * Returns event string that will be thrown if the datagram reader queue\n"
  " * overflows.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_overflow_event_name_28_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::is_connected(void)
 */
static PyObject *Dtool_CConnectionRepository_is_connected_29(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.is_connected")) {
    return NULL;
  }
  // 1-bool CConnectionRepository::is_connected(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).is_connected();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_is_connected_29_comment =
  "C++ Interface:\n"
  "is_connected(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if the connection to the gameserver is established and still\n"
  " * good, false if we are not connected.  A false value means either (a) we\n"
  " * never successfully connected, (b) we explicitly called disconnect(), or (c)\n"
  " * we were connected, but the connection was spontaneously lost.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_is_connected_29_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::send_datagram(Datagram const &dg)
 */
static PyObject *Dtool_CConnectionRepository_send_datagram_30(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.send_datagram")) {
    return NULL;
  }
  // 1-bool CConnectionRepository::send_datagram(Datagram const &dg)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.send_datagram", "Datagram");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).send_datagram(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_datagram(const CConnectionRepository self, const Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_send_datagram_30_comment =
  "C++ Interface:\n"
  "send_datagram(const CConnectionRepository self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " * Queues the indicated datagram for sending to the server.  It may not get\n"
  " * sent immediately if collect_tcp is in effect; call flush() to guarantee it\n"
  " * is sent now.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_send_datagram_30_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_want_message_bundling(bool flag)
 */
static PyObject *Dtool_CConnectionRepository_set_want_message_bundling_31(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_want_message_bundling")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_want_message_bundling(bool flag)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).set_want_message_bundling((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_message_bundling(const CConnectionRepository self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_want_message_bundling_31_comment =
  "C++ Interface:\n"
  "set_want_message_bundling(const CConnectionRepository self, bool flag)\n"
  "\n"
  "/**\n"
  " * Enable/disable outbound message bundling\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_want_message_bundling_31_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_want_message_bundling(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_want_message_bundling_32(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_want_message_bundling(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const CConnectionRepository*)local_this).get_want_message_bundling();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_want_message_bundling_32_comment =
  "C++ Interface:\n"
  "get_want_message_bundling(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if message bundling enabled\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_want_message_bundling_32_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_in_quiet_zone(bool flag)
 */
static PyObject *Dtool_CConnectionRepository_set_in_quiet_zone_33(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_in_quiet_zone")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_in_quiet_zone(bool flag)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).set_in_quiet_zone((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_in_quiet_zone(const CConnectionRepository self, bool flag)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_in_quiet_zone_33_comment =
  "C++ Interface:\n"
  "set_in_quiet_zone(const CConnectionRepository self, bool flag)\n"
  "\n"
  "/**\n"
  " * Enables/disables quiet zone mode\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_in_quiet_zone_33_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_in_quiet_zone(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_in_quiet_zone_34(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_in_quiet_zone(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const CConnectionRepository*)local_this).get_in_quiet_zone();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_in_quiet_zone_34_comment =
  "C++ Interface:\n"
  "get_in_quiet_zone(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if repository is in quiet zone mode\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_in_quiet_zone_34_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::start_message_bundle(void)
 */
static PyObject *Dtool_CConnectionRepository_start_message_bundle_35(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.start_message_bundle")) {
    return NULL;
  }
  // 1-void CConnectionRepository::start_message_bundle(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).start_message_bundle();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_start_message_bundle_35_comment =
  "C++ Interface:\n"
  "start_message_bundle(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Send a set of messages to the state server that will be processed\n"
  " * atomically.  For instance, you can do a combined setLocation/setPos and\n"
  " * prevent race conditions where clients briefly get the setLocation but not\n"
  " * the setPos, because the state server hasn't processed the setPos yet\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_start_message_bundle_35_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::is_bundling_messages(void) const
 */
static PyObject *Dtool_CConnectionRepository_is_bundling_messages_36(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::is_bundling_messages(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*(const CConnectionRepository*)local_this).is_bundling_messages();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_is_bundling_messages_36_comment =
  "C++ Interface:\n"
  "is_bundling_messages(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if repository is queueing outgoing messages into a message\n"
  " * bundle\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_is_bundling_messages_36_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel)
 */
static PyObject *Dtool_CConnectionRepository_send_message_bundle_37(PyObject *self, PyObject *args, PyObject *kwds) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.send_message_bundle")) {
    return NULL;
  }
  // 1-void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel)
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"channel", "sender_channel", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:send_message_bundle", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (*local_this).send_message_bundle((unsigned int)param1, (unsigned int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_message_bundle(const CConnectionRepository self, int channel, int sender_channel)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_send_message_bundle_37_comment =
  "C++ Interface:\n"
  "send_message_bundle(const CConnectionRepository self, int channel, int sender_channel)\n"
  "\n"
  "/**\n"
  " * Send network messages queued up since startMessageBundle was called.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_send_message_bundle_37_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::abandon_message_bundles(void)
 */
static PyObject *Dtool_CConnectionRepository_abandon_message_bundles_38(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.abandon_message_bundles")) {
    return NULL;
  }
  // 1-void CConnectionRepository::abandon_message_bundles(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).abandon_message_bundles();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_abandon_message_bundles_38_comment =
  "C++ Interface:\n"
  "abandon_message_bundles(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * throw out any msgs that have been queued up for message bundles\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_abandon_message_bundles_38_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::bundle_msg(Datagram const &dg)
 */
static PyObject *Dtool_CConnectionRepository_bundle_msg_39(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.bundle_msg")) {
    return NULL;
  }
  // 1-void CConnectionRepository::bundle_msg(Datagram const &dg)
  Datagram const *arg_this;
  bool arg_manage = false;
  if (!Dtool_ConstCoerce_Datagram(arg, arg_this, arg_manage)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.bundle_msg", "Datagram");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).bundle_msg(*arg_this);
  if (arg_manage) {
    delete arg_this;
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bundle_msg(const CConnectionRepository self, const Datagram dg)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_bundle_msg_39_comment =
  "C++ Interface:\n"
  "bundle_msg(const CConnectionRepository self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_bundle_msg_39_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::consider_flush(void)
 */
static PyObject *Dtool_CConnectionRepository_consider_flush_40(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.consider_flush")) {
    return NULL;
  }
  // 1-bool CConnectionRepository::consider_flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).consider_flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_consider_flush_40_comment =
  "C++ Interface:\n"
  "consider_flush(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data if enough time has elapsed.  This only\n"
  " * has meaning if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_consider_flush_40_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::flush(void)
 */
static PyObject *Dtool_CConnectionRepository_flush_41(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.flush")) {
    return NULL;
  }
  // 1-bool CConnectionRepository::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = (*local_this).flush();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_flush_41_comment =
  "C++ Interface:\n"
  "flush(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data now.  This only has meaning if\n"
  " * set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_flush_41_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::disconnect(void)
 */
static PyObject *Dtool_CConnectionRepository_disconnect_42(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.disconnect")) {
    return NULL;
  }
  // 1-void CConnectionRepository::disconnect(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).disconnect();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_disconnect_42_comment =
  "C++ Interface:\n"
  "disconnect(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Closes the connection to the server.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_disconnect_42_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::shutdown(void)
 */
static PyObject *Dtool_CConnectionRepository_shutdown_43(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.shutdown")) {
    return NULL;
  }
  // 1-void CConnectionRepository::shutdown(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  (*local_this).shutdown();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_shutdown_43_comment =
  "C++ Interface:\n"
  "shutdown(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * May be called at application shutdown to ensure all threads are cleaned up.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_shutdown_43_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect)
 */
static PyObject *Dtool_CConnectionRepository_set_simulated_disconnect_44(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_simulated_disconnect")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect)
  (*local_this).set_simulated_disconnect((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_simulated_disconnect(const CConnectionRepository self, bool simulated_disconnect)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_simulated_disconnect_44_comment =
  "C++ Interface:\n"
  "set_simulated_disconnect(const CConnectionRepository self, bool simulated_disconnect)\n"
  "\n"
  "/**\n"
  " * Sets the simulated disconnect flag.  While this is true, no datagrams will\n"
  " * be retrieved from or sent to the server.  The idea is to simulate a\n"
  " * temporary network outage.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_simulated_disconnect_44_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_simulated_disconnect(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_simulated_disconnect_45(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_simulated_disconnect(void) const
  bool return_value = (*(const CConnectionRepository*)local_this).get_simulated_disconnect();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_simulated_disconnect_45_comment =
  "C++ Interface:\n"
  "get_simulated_disconnect(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the simulated disconnect flag.  While this is true, no datagrams\n"
  " * will be retrieved from or sent to the server.  The idea is to simulate a\n"
  " * temporary network outage.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_simulated_disconnect_45_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::toggle_verbose(void)
 */
static PyObject *Dtool_CConnectionRepository_toggle_verbose_46(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.toggle_verbose")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::toggle_verbose(void)
  (*local_this).toggle_verbose();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_toggle_verbose_46_comment =
  "C++ Interface:\n"
  "toggle_verbose(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Toggles the current setting of the verbose flag.  When true, this describes\n"
  " * every message going back and forth on the wire.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_toggle_verbose_46_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_verbose(bool verbose)
 */
static PyObject *Dtool_CConnectionRepository_set_verbose_47(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_verbose")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_verbose(bool verbose)
  (*local_this).set_verbose((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_verbose(const CConnectionRepository self, bool verbose)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_verbose_47_comment =
  "C++ Interface:\n"
  "set_verbose(const CConnectionRepository self, bool verbose)\n"
  "\n"
  "/**\n"
  " * Directly sets the verbose flag.  When true, this describes every message\n"
  " * going back and forth on the wire.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_verbose_47_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_verbose(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_verbose_48(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline bool CConnectionRepository::get_verbose(void) const
  bool return_value = (*(const CConnectionRepository*)local_this).get_verbose();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_verbose_48_comment =
  "C++ Interface:\n"
  "get_verbose(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the verbose flag.  When true, this describes\n"
  " * every message going back and forth on the wire.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_verbose_48_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_time_warning(float time_warning)
 */
static PyObject *Dtool_CConnectionRepository_set_time_warning_49(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_time_warning")) {
    return NULL;
  }
  // 1-inline void CConnectionRepository::set_time_warning(float time_warning)
  if (PyNumber_Check(arg)) {
    (*local_this).set_time_warning((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time_warning(const CConnectionRepository self, float time_warning)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_time_warning_49_comment =
  "C++ Interface:\n"
  "set_time_warning(const CConnectionRepository self, float time_warning)\n"
  "\n"
  "/**\n"
  " * Directly sets the time_warning field.  When non zero, this describes every\n"
  " * message going back and forth on the wire when the msg handling time is over\n"
  " * it\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_time_warning_49_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline float CConnectionRepository::get_time_warning(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_time_warning_50(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConnectionRepository, (void **)&local_this)) {
    return NULL;
  }
  // 1-inline float CConnectionRepository::get_time_warning(void) const
  float return_value = (*(const CConnectionRepository*)local_this).get_time_warning();
  if (Dtool_CheckErrorOccurred()) {
    return NULL;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_time_warning_50_comment =
  "C++ Interface:\n"
  "get_time_warning(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the time_warning field.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_time_warning_50_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CConnectionRepository::CConnectionRepository(bool has_owner_view = false, bool threaded_net = false)
 */
static int Dtool_Init_CConnectionRepository(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view = false, bool threaded_net = false)
  PyObject *param0 = Py_False;
  PyObject *param1 = Py_False;
  static const char *keyword_list[] = {"has_owner_view", "threaded_net", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|OO:CConnectionRepository", (char **)keyword_list, &param0, &param1)) {
    CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(param0) != 0), (PyObject_IsTrue(param1) != 0));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConnectionRepository, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConnectionRepository(bool has_owner_view, bool threaded_net)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CConnectionRepository(PyObject *args, CConnectionRepository const *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConnectionRepository, (void**)&coerced);
  if (coerced != NULL) {
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net)
    CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(arg) != 0));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    if (_PyErr_OCCURRED()) {
      delete return_value;
      return false;
    } else {
      coerced = return_value;
      manage = true;
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "CConnectionRepository", 2, 2, &param0, &param1)) {
        CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(param0) != 0), (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_CConnectionRepository(PyObject *args, CConnectionRepository *&coerced, bool &manage) {
  DTOOL_Call_ExtractThisPointerForType(args, &Dtool_CConnectionRepository, (void**)&coerced);
  if (coerced != NULL) {
    if (!((Dtool_PyInstDef *)args)->_is_const) {
      // A non-const instance is required, which this is.
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net)
    CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(arg) != 0));
    if (return_value == NULL) {
      PyErr_NoMemory();
      return false;
    }
    if (_PyErr_OCCURRED()) {
      delete return_value;
      return false;
    } else {
      coerced = return_value;
      manage = true;
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-CConnectionRepository::CConnectionRepository(bool has_owner_view, bool threaded_net)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "CConnectionRepository", 2, 2, &param0, &param1)) {
        CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(param0) != 0), (PyObject_IsTrue(param1) != 0));
        if (return_value == NULL) {
          PyErr_NoMemory();
          return false;
        }
        if (_PyErr_OCCURRED()) {
          delete return_value;
          return false;
        } else {
          coerced = return_value;
          manage = true;
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_CConnectionRepository(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CConnectionRepository) {
    printf("CConnectionRepository ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CConnectionRepository *local_this = (CConnectionRepository *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CConnectionRepository) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CConnectionRepository(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CConnectionRepository) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python wrappers for functions of class CDistributedSmoothNodeBase
 */
/**
 * Python function wrapper for:
 * inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, CHANNEL_TYPE ai_id)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_set_repository_54(PyObject *self, PyObject *args, PyObject *kwds) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.set_repository")) {
    return NULL;
  }
  // 1-inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, CHANNEL_TYPE ai_id)
  PyObject *param1;
  PyObject *param2;
  unsigned PY_LONG_LONG param3;
  static const char *keyword_list[] = {"repository", "is_ai", "ai_id", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOK:set_repository", (char **)keyword_list, &param1, &param2, &param3)) {
    CConnectionRepository *param1_this;
    bool param1_manage = false;
    if (!Dtool_Coerce_CConnectionRepository(param1, param1_this, param1_manage)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "CDistributedSmoothNodeBase.set_repository", "CConnectionRepository");
    }
    (*local_this).set_repository(param1_this, (PyObject_IsTrue(param2) != 0), (CHANNEL_TYPE)param3);
    if (param1_manage) {
      delete param1_this;
    }
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_repository(const CDistributedSmoothNodeBase self, CConnectionRepository repository, bool is_ai, long ai_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_set_repository_54_comment =
  "C++ Interface:\n"
  "set_repository(const CDistributedSmoothNodeBase self, CConnectionRepository repository, bool is_ai, long ai_id)\n"
  "\n"
  "/**\n"
  " * Tells the C++ instance definition about the AI or Client repository, used\n"
  " * for sending datagrams.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_set_repository_54_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_set_clock_delta_55(PyObject *self, PyObject *arg) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.set_clock_delta")) {
    return NULL;
  }
  // 1-inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta)
  (*local_this).set_clock_delta(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clock_delta(const CDistributedSmoothNodeBase self, object clock_delta)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_set_clock_delta_55_comment =
  "C++ Interface:\n"
  "set_clock_delta(const CDistributedSmoothNodeBase self, object clock_delta)\n"
  "\n"
  "/**\n"
  " * Tells the C++ instance definition about the global ClockDelta object.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_set_clock_delta_55_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::initialize(NodePath const &node_path, DCClass *dclass, CHANNEL_TYPE do_id)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_initialize_56(PyObject *self, PyObject *args, PyObject *kwds) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.initialize")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::initialize(NodePath const &node_path, DCClass *dclass, CHANNEL_TYPE do_id)
  PyObject *param1;
  PyObject *param2;
  unsigned PY_LONG_LONG param3;
  static const char *keyword_list[] = {"node_path", "dclass", "do_id", NULL};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOK:initialize", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CDistributedSmoothNodeBase.initialize", true, true);
    DCClass *param2_this = (DCClass *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DCClass, 2, "CDistributedSmoothNodeBase.initialize", false, true);
    if (param1_this != NULL && param2_this != NULL) {
      (*local_this).initialize(*param1_this, param2_this, (CHANNEL_TYPE)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initialize(const CDistributedSmoothNodeBase self, const NodePath node_path, DCClass dclass, long do_id)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_initialize_56_comment =
  "C++ Interface:\n"
  "initialize(const CDistributedSmoothNodeBase self, const NodePath node_path, DCClass dclass, long do_id)\n"
  "\n"
  "/**\n"
  " * Initializes the internal structures from some constructs that are normally\n"
  " * stored only in Python.  Also reads the current node's pos & hpr values in\n"
  " * preparation for transmitting them via one of the broadcast_pos_hpr_*()\n"
  " * methods.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_initialize_56_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::send_everything(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_send_everything_57(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.send_everything")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::send_everything(void)
  (*local_this).send_everything();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_send_everything_57_comment =
  "C++ Interface:\n"
  "send_everything(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Broadcasts the current pos/hpr in its complete form.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_send_everything_57_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.broadcast_pos_hpr_full")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void)
  (*local_this).broadcast_pos_hpr_full();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58_comment =
  "C++ Interface:\n"
  "broadcast_pos_hpr_full(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Examines the complete pos/hpr information to see which of the six elements\n"
  " * have changed, and broadcasts the appropriate messages.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.broadcast_pos_hpr_xyh")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void)
  (*local_this).broadcast_pos_hpr_xyh();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59_comment =
  "C++ Interface:\n"
  "broadcast_pos_hpr_xyh(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Examines only X, Y, and H of the pos/hpr information, and broadcasts the\n"
  " * appropriate messages.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.broadcast_pos_hpr_xy")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void)
  (*local_this).broadcast_pos_hpr_xy();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60_comment =
  "C++ Interface:\n"
  "broadcast_pos_hpr_xy(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Examines only X and Y of the pos/hpr information, and broadcasts the\n"
  " * appropriate messages.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::set_curr_l(uint64_t l)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_set_curr_l_61(PyObject *self, PyObject *arg) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.set_curr_l")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::set_curr_l(uint64_t l)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:set_curr_l", &param1)) {
    (*local_this).set_curr_l((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curr_l(const CDistributedSmoothNodeBase self, long l)\n");
  }
  return NULL;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_set_curr_l_61_comment =
  "C++ Interface:\n"
  "set_curr_l(const CDistributedSmoothNodeBase self, long l)\n"
  "\n"
  "/**\n"
  " * Appends the timestamp and sends the update.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_set_curr_l_61_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::print_curr_l(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_print_curr_l_62(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = NULL;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.print_curr_l")) {
    return NULL;
  }
  // 1-void CDistributedSmoothNodeBase::print_curr_l(void)
  (*local_this).print_curr_l();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_print_curr_l_62_comment =
  "C++ Interface:\n"
  "print_curr_l(const CDistributedSmoothNodeBase self)\n";
#else
static const char *Dtool_CDistributedSmoothNodeBase_print_curr_l_62_comment = NULL;
#endif

/**
 * Python function wrapper for:
 * CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void)
 */
static int Dtool_Init_CDistributedSmoothNodeBase(PyObject *self, PyObject *args, PyObject *kwds) {
  if (PyTuple_Size(args) > 0 || (kwds != NULL && PyDict_Size(kwds) > 0)) {
    int parameter_count = (int)PyTuple_Size(args);
    if (kwds != NULL) {
      parameter_count += (int)PyDict_Size(kwds);
    }
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CDistributedSmoothNodeBase() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void)
  CDistributedSmoothNodeBase *return_value = new CDistributedSmoothNodeBase();
  if (return_value == NULL) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CDistributedSmoothNodeBase, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CDistributedSmoothNodeBase()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CDistributedSmoothNodeBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
  if (SelfType != Dtool_Ptr_CDistributedSmoothNodeBase) {
    printf("CDistributedSmoothNodeBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(NULL);
    return NULL;
  }

  CDistributedSmoothNodeBase *local_this = (CDistributedSmoothNodeBase *)((Dtool_PyInstDef *)self)->_ptr_to_object;
  if (requested_type == Dtool_Ptr_CDistributedSmoothNodeBase) {
    return local_this;
  }
  return NULL;
}

static void *Dtool_DowncastInterface_CDistributedSmoothNodeBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == NULL || from_type == NULL) {
    return NULL;
  }
  if (from_type == Dtool_Ptr_CDistributedSmoothNodeBase) {
    return from_this;
  }
  return (void *) NULL;
}

/**
 * Python method tables for CConnectionRepository (CConnectionRepository)
 */
static PyMethodDef Dtool_Methods_CConnectionRepository[] = {
  {"get_dc_file", &Dtool_CConnectionRepository_get_dc_file_4, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_dc_file_4_comment},
  {"getDcFile", &Dtool_CConnectionRepository_get_dc_file_4, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_dc_file_4_comment},
  {"has_owner_view", &Dtool_CConnectionRepository_has_owner_view_5, METH_NOARGS, (const char *)Dtool_CConnectionRepository_has_owner_view_5_comment},
  {"hasOwnerView", &Dtool_CConnectionRepository_has_owner_view_5, METH_NOARGS, (const char *)Dtool_CConnectionRepository_has_owner_view_5_comment},
  {"set_handle_c_updates", &Dtool_CConnectionRepository_set_handle_c_updates_6, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_c_updates_6_comment},
  {"setHandleCUpdates", &Dtool_CConnectionRepository_set_handle_c_updates_6, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_c_updates_6_comment},
  {"get_handle_c_updates", &Dtool_CConnectionRepository_get_handle_c_updates_7, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_c_updates_7_comment},
  {"getHandleCUpdates", &Dtool_CConnectionRepository_get_handle_c_updates_7, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_c_updates_7_comment},
  {"set_client_datagram", &Dtool_CConnectionRepository_set_client_datagram_8, METH_O, (const char *)Dtool_CConnectionRepository_set_client_datagram_8_comment},
  {"setClientDatagram", &Dtool_CConnectionRepository_set_client_datagram_8, METH_O, (const char *)Dtool_CConnectionRepository_set_client_datagram_8_comment},
  {"get_client_datagram", &Dtool_CConnectionRepository_get_client_datagram_9, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_client_datagram_9_comment},
  {"getClientDatagram", &Dtool_CConnectionRepository_get_client_datagram_9, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_client_datagram_9_comment},
  {"set_handle_datagrams_internally", &Dtool_CConnectionRepository_set_handle_datagrams_internally_10, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment},
  {"setHandleDatagramsInternally", &Dtool_CConnectionRepository_set_handle_datagrams_internally_10, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment},
  {"get_handle_datagrams_internally", &Dtool_CConnectionRepository_get_handle_datagrams_internally_11, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment},
  {"getHandleDatagramsInternally", &Dtool_CConnectionRepository_get_handle_datagrams_internally_11, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment},
  {"set_tcp_header_size", &Dtool_CConnectionRepository_set_tcp_header_size_12, METH_O, (const char *)Dtool_CConnectionRepository_set_tcp_header_size_12_comment},
  {"setTcpHeaderSize", &Dtool_CConnectionRepository_set_tcp_header_size_12, METH_O, (const char *)Dtool_CConnectionRepository_set_tcp_header_size_12_comment},
  {"get_tcp_header_size", &Dtool_CConnectionRepository_get_tcp_header_size_13, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_tcp_header_size_13_comment},
  {"getTcpHeaderSize", &Dtool_CConnectionRepository_get_tcp_header_size_13, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_tcp_header_size_13_comment},
  {"set_python_repository", &Dtool_CConnectionRepository_set_python_repository_14, METH_O, (const char *)Dtool_CConnectionRepository_set_python_repository_14_comment},
  {"setPythonRepository", &Dtool_CConnectionRepository_set_python_repository_14, METH_O, (const char *)Dtool_CConnectionRepository_set_python_repository_14_comment},
  {"set_connection_http", &Dtool_CConnectionRepository_set_connection_http_15, METH_O, (const char *)Dtool_CConnectionRepository_set_connection_http_15_comment},
  {"setConnectionHttp", &Dtool_CConnectionRepository_set_connection_http_15, METH_O, (const char *)Dtool_CConnectionRepository_set_connection_http_15_comment},
  {"get_stream", &Dtool_CConnectionRepository_get_stream_16, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_stream_16_comment},
  {"getStream", &Dtool_CConnectionRepository_get_stream_16, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_stream_16_comment},
  {"try_connect_net", &Dtool_CConnectionRepository_try_connect_net_17, METH_O, (const char *)Dtool_CConnectionRepository_try_connect_net_17_comment},
  {"tryConnectNet", &Dtool_CConnectionRepository_try_connect_net_17, METH_O, (const char *)Dtool_CConnectionRepository_try_connect_net_17_comment},
  {"get_qcm", &Dtool_CConnectionRepository_get_qcm_18, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcm_18_comment},
  {"getQcm", &Dtool_CConnectionRepository_get_qcm_18, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcm_18_comment},
  {"get_cw", &Dtool_CConnectionRepository_get_cw_19, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_cw_19_comment},
  {"getCw", &Dtool_CConnectionRepository_get_cw_19, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_cw_19_comment},
  {"get_qcr", &Dtool_CConnectionRepository_get_qcr_20, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcr_20_comment},
  {"getQcr", &Dtool_CConnectionRepository_get_qcr_20, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcr_20_comment},
  {"check_datagram", &Dtool_CConnectionRepository_check_datagram_21, METH_NOARGS, (const char *)Dtool_CConnectionRepository_check_datagram_21_comment},
  {"checkDatagram", &Dtool_CConnectionRepository_check_datagram_21, METH_NOARGS, (const char *)Dtool_CConnectionRepository_check_datagram_21_comment},
  {"get_datagram", &Dtool_CConnectionRepository_get_datagram_22, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_22_comment},
  {"getDatagram", &Dtool_CConnectionRepository_get_datagram_22, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_22_comment},
  {"get_datagram_iterator", &Dtool_CConnectionRepository_get_datagram_iterator_23, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_iterator_23_comment},
  {"getDatagramIterator", &Dtool_CConnectionRepository_get_datagram_iterator_23, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_iterator_23_comment},
  {"get_msg_channel", (PyCFunction) &Dtool_CConnectionRepository_get_msg_channel_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_get_msg_channel_24_comment},
  {"getMsgChannel", (PyCFunction) &Dtool_CConnectionRepository_get_msg_channel_24, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_get_msg_channel_24_comment},
  {"get_msg_channel_count", &Dtool_CConnectionRepository_get_msg_channel_count_25, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_channel_count_25_comment},
  {"getMsgChannelCount", &Dtool_CConnectionRepository_get_msg_channel_count_25, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_channel_count_25_comment},
  {"get_msg_sender", &Dtool_CConnectionRepository_get_msg_sender_26, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_sender_26_comment},
  {"getMsgSender", &Dtool_CConnectionRepository_get_msg_sender_26, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_sender_26_comment},
  {"get_msg_type", &Dtool_CConnectionRepository_get_msg_type_27, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_type_27_comment},
  {"getMsgType", &Dtool_CConnectionRepository_get_msg_type_27, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_type_27_comment},
  {"get_overflow_event_name", &Dtool_CConnectionRepository_get_overflow_event_name_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConnectionRepository_get_overflow_event_name_28_comment},
  {"getOverflowEventName", &Dtool_CConnectionRepository_get_overflow_event_name_28, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConnectionRepository_get_overflow_event_name_28_comment},
  {"is_connected", &Dtool_CConnectionRepository_is_connected_29, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_connected_29_comment},
  {"isConnected", &Dtool_CConnectionRepository_is_connected_29, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_connected_29_comment},
  {"send_datagram", &Dtool_CConnectionRepository_send_datagram_30, METH_O, (const char *)Dtool_CConnectionRepository_send_datagram_30_comment},
  {"sendDatagram", &Dtool_CConnectionRepository_send_datagram_30, METH_O, (const char *)Dtool_CConnectionRepository_send_datagram_30_comment},
  {"set_want_message_bundling", &Dtool_CConnectionRepository_set_want_message_bundling_31, METH_O, (const char *)Dtool_CConnectionRepository_set_want_message_bundling_31_comment},
  {"setWantMessageBundling", &Dtool_CConnectionRepository_set_want_message_bundling_31, METH_O, (const char *)Dtool_CConnectionRepository_set_want_message_bundling_31_comment},
  {"get_want_message_bundling", &Dtool_CConnectionRepository_get_want_message_bundling_32, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_want_message_bundling_32_comment},
  {"getWantMessageBundling", &Dtool_CConnectionRepository_get_want_message_bundling_32, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_want_message_bundling_32_comment},
  {"set_in_quiet_zone", &Dtool_CConnectionRepository_set_in_quiet_zone_33, METH_O, (const char *)Dtool_CConnectionRepository_set_in_quiet_zone_33_comment},
  {"setInQuietZone", &Dtool_CConnectionRepository_set_in_quiet_zone_33, METH_O, (const char *)Dtool_CConnectionRepository_set_in_quiet_zone_33_comment},
  {"get_in_quiet_zone", &Dtool_CConnectionRepository_get_in_quiet_zone_34, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_in_quiet_zone_34_comment},
  {"getInQuietZone", &Dtool_CConnectionRepository_get_in_quiet_zone_34, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_in_quiet_zone_34_comment},
  {"start_message_bundle", &Dtool_CConnectionRepository_start_message_bundle_35, METH_NOARGS, (const char *)Dtool_CConnectionRepository_start_message_bundle_35_comment},
  {"startMessageBundle", &Dtool_CConnectionRepository_start_message_bundle_35, METH_NOARGS, (const char *)Dtool_CConnectionRepository_start_message_bundle_35_comment},
  {"is_bundling_messages", &Dtool_CConnectionRepository_is_bundling_messages_36, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_bundling_messages_36_comment},
  {"isBundlingMessages", &Dtool_CConnectionRepository_is_bundling_messages_36, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_bundling_messages_36_comment},
  {"send_message_bundle", (PyCFunction) &Dtool_CConnectionRepository_send_message_bundle_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_send_message_bundle_37_comment},
  {"sendMessageBundle", (PyCFunction) &Dtool_CConnectionRepository_send_message_bundle_37, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_send_message_bundle_37_comment},
  {"abandon_message_bundles", &Dtool_CConnectionRepository_abandon_message_bundles_38, METH_NOARGS, (const char *)Dtool_CConnectionRepository_abandon_message_bundles_38_comment},
  {"abandonMessageBundles", &Dtool_CConnectionRepository_abandon_message_bundles_38, METH_NOARGS, (const char *)Dtool_CConnectionRepository_abandon_message_bundles_38_comment},
  {"bundle_msg", &Dtool_CConnectionRepository_bundle_msg_39, METH_O, (const char *)Dtool_CConnectionRepository_bundle_msg_39_comment},
  {"bundleMsg", &Dtool_CConnectionRepository_bundle_msg_39, METH_O, (const char *)Dtool_CConnectionRepository_bundle_msg_39_comment},
  {"consider_flush", &Dtool_CConnectionRepository_consider_flush_40, METH_NOARGS, (const char *)Dtool_CConnectionRepository_consider_flush_40_comment},
  {"considerFlush", &Dtool_CConnectionRepository_consider_flush_40, METH_NOARGS, (const char *)Dtool_CConnectionRepository_consider_flush_40_comment},
  {"flush", &Dtool_CConnectionRepository_flush_41, METH_NOARGS, (const char *)Dtool_CConnectionRepository_flush_41_comment},
  {"disconnect", &Dtool_CConnectionRepository_disconnect_42, METH_NOARGS, (const char *)Dtool_CConnectionRepository_disconnect_42_comment},
  {"shutdown", &Dtool_CConnectionRepository_shutdown_43, METH_NOARGS, (const char *)Dtool_CConnectionRepository_shutdown_43_comment},
  {"set_simulated_disconnect", &Dtool_CConnectionRepository_set_simulated_disconnect_44, METH_O, (const char *)Dtool_CConnectionRepository_set_simulated_disconnect_44_comment},
  {"setSimulatedDisconnect", &Dtool_CConnectionRepository_set_simulated_disconnect_44, METH_O, (const char *)Dtool_CConnectionRepository_set_simulated_disconnect_44_comment},
  {"get_simulated_disconnect", &Dtool_CConnectionRepository_get_simulated_disconnect_45, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_simulated_disconnect_45_comment},
  {"getSimulatedDisconnect", &Dtool_CConnectionRepository_get_simulated_disconnect_45, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_simulated_disconnect_45_comment},
  {"toggle_verbose", &Dtool_CConnectionRepository_toggle_verbose_46, METH_NOARGS, (const char *)Dtool_CConnectionRepository_toggle_verbose_46_comment},
  {"toggleVerbose", &Dtool_CConnectionRepository_toggle_verbose_46, METH_NOARGS, (const char *)Dtool_CConnectionRepository_toggle_verbose_46_comment},
  {"set_verbose", &Dtool_CConnectionRepository_set_verbose_47, METH_O, (const char *)Dtool_CConnectionRepository_set_verbose_47_comment},
  {"setVerbose", &Dtool_CConnectionRepository_set_verbose_47, METH_O, (const char *)Dtool_CConnectionRepository_set_verbose_47_comment},
  {"get_verbose", &Dtool_CConnectionRepository_get_verbose_48, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_verbose_48_comment},
  {"getVerbose", &Dtool_CConnectionRepository_get_verbose_48, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_verbose_48_comment},
  {"set_time_warning", &Dtool_CConnectionRepository_set_time_warning_49, METH_O, (const char *)Dtool_CConnectionRepository_set_time_warning_49_comment},
  {"setTimeWarning", &Dtool_CConnectionRepository_set_time_warning_49, METH_O, (const char *)Dtool_CConnectionRepository_set_time_warning_49_comment},
  {"get_time_warning", &Dtool_CConnectionRepository_get_time_warning_50, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_time_warning_50_comment},
  {"getTimeWarning", &Dtool_CConnectionRepository_get_time_warning_50, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_time_warning_50_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CConnectionRepository = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_CConnectionRepository = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CConnectionRepository",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CConnectionRepository,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CConnectionRepository,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements the C++ side of the ConnectionRepository object.  In\n"
    " * particular, it manages the connection to the server once it has been opened\n"
    " * (but does not open it directly).  It manages reading and writing datagrams\n"
    " * on the connection and monitoring for unexpected disconnects as well as\n"
    " * handling intentional disconnects.\n"
    " *\n"
    " * Certain server messages, like field updates, are handled entirely within\n"
    " * the C++ layer, while server messages that are not understood by the C++\n"
    " * layer are returned up to the Python layer for processing.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CConnectionRepository,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CConnectionRepository,
    PyType_GenericAlloc,
    Dtool_new_CConnectionRepository,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConnectionRepository,
  Dtool_UpcastInterface_CConnectionRepository,
  Dtool_DowncastInterface_CConnectionRepository,
  (CoerceFunction)Dtool_ConstCoerce_CConnectionRepository,
  (CoerceFunction)Dtool_Coerce_CConnectionRepository,
};

static void Dtool_PyModuleClassInit_CConnectionRepository(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CConnectionRepository._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_CConnectionRepository._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConnectionRepository) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConnectionRepository)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConnectionRepository);
  }
}

/**
 * Python method tables for CDistributedSmoothNodeBase (CDistributedSmoothNodeBase)
 */
static PyMethodDef Dtool_Methods_CDistributedSmoothNodeBase[] = {
  {"set_repository", (PyCFunction) &Dtool_CDistributedSmoothNodeBase_set_repository_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CDistributedSmoothNodeBase_set_repository_54_comment},
  {"setRepository", (PyCFunction) &Dtool_CDistributedSmoothNodeBase_set_repository_54, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CDistributedSmoothNodeBase_set_repository_54_comment},
  {"set_clock_delta", &Dtool_CDistributedSmoothNodeBase_set_clock_delta_55, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_clock_delta_55_comment},
  {"setClockDelta", &Dtool_CDistributedSmoothNodeBase_set_clock_delta_55, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_clock_delta_55_comment},
  {"initialize", (PyCFunction) &Dtool_CDistributedSmoothNodeBase_initialize_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CDistributedSmoothNodeBase_initialize_56_comment},
  {"send_everything", &Dtool_CDistributedSmoothNodeBase_send_everything_57, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_send_everything_57_comment},
  {"sendEverything", &Dtool_CDistributedSmoothNodeBase_send_everything_57, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_send_everything_57_comment},
  {"broadcast_pos_hpr_full", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58_comment},
  {"broadcastPosHprFull", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_58_comment},
  {"broadcast_pos_hpr_xyh", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59_comment},
  {"broadcastPosHprXyh", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_59_comment},
  {"broadcast_pos_hpr_xy", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60_comment},
  {"broadcastPosHprXy", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_60_comment},
  {"set_curr_l", &Dtool_CDistributedSmoothNodeBase_set_curr_l_61, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_curr_l_61_comment},
  {"setCurrL", &Dtool_CDistributedSmoothNodeBase_set_curr_l_61, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_curr_l_61_comment},
  {"print_curr_l", &Dtool_CDistributedSmoothNodeBase_print_curr_l_62, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_print_curr_l_62_comment},
  {"printCurrL", &Dtool_CDistributedSmoothNodeBase_print_curr_l_62, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_print_curr_l_62_comment},
  {NULL, NULL, 0, NULL}
};

static PyNumberMethods Dtool_NumberMethods_CDistributedSmoothNodeBase = {
  0, // nb_add
  0, // nb_subtract
  0, // nb_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_divide
#endif
  0, // nb_remainder
  0, // nb_divmod
  0, // nb_power
  0, // nb_negative
  0, // nb_positive
  0, // nb_absolute
  0, // nb_bool
  0, // nb_invert
  0, // nb_lshift
  0, // nb_rshift
  0, // nb_and
  0, // nb_xor
  0, // nb_or
#if PY_MAJOR_VERSION < 3
  0, // nb_coerce
#endif
  0, // nb_int
  0, // nb_long
  0, // nb_float
#if PY_MAJOR_VERSION < 3
  0, // nb_oct
  0, // nb_hex
#endif
  0, // nb_inplace_add
  0, // nb_inplace_subtract
  0, // nb_inplace_multiply
#if PY_MAJOR_VERSION < 3
  0, // nb_inplace_divide
#endif
  0, // nb_inplace_remainder
  0, // nb_inplace_power
  0, // nb_inplace_lshift
  0, // nb_inplace_rshift
  0, // nb_inplace_and
  0, // nb_inplace_xor
  0, // nb_inplace_or
  0, // nb_floor_divide
  0, // nb_true_divide
  0, // nb_inplace_floor_divide
  0, // nb_inplace_true_divide
#if PY_VERSION_HEX >= 0x02050000
  0, // nb_index
#endif
#if PY_VERSION_HEX >= 0x03050000
  0, // nb_matrix_multiply
  0, // nb_inplace_matrix_multiply
#endif
};

struct Dtool_PyTypedObject Dtool_CDistributedSmoothNodeBase = {
  {
    PyVarObject_HEAD_INIT(NULL, 0)
    "panda3d.direct.CDistributedSmoothNodeBase",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_CDistributedSmoothNodeBase,
    0, // tp_print
    0, // tp_getattr
    0, // tp_setattr
#if PY_MAJOR_VERSION >= 3
    0, // tp_reserved
#else
    0, // tp_compare
#endif
    0, // tp_repr
    &Dtool_NumberMethods_CDistributedSmoothNodeBase,
    0, // tp_as_sequence
    0, // tp_as_mapping
    0, // tp_hash
    0, // tp_call
    0, // tp_str
    PyObject_GenericGetAttr,
    PyObject_GenericSetAttr,
    0, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines some basic methods of DistributedSmoothNodeBase which\n"
    " * have been moved into C++ as a performance optimization.\n"
    " */",
#endif
    0, // tp_traverse
    0, // tp_clear
    0, // tp_richcompare
    0, // tp_weaklistoffset
    0, // tp_iter
    0, // tp_iternext
    Dtool_Methods_CDistributedSmoothNodeBase,
    0, // tp_members
    0, // tp_getset
    0, // tp_base
    0, // tp_dict
    0, // tp_descr_get
    0, // tp_descr_set
    0, // tp_dictoffset
    Dtool_Init_CDistributedSmoothNodeBase,
    PyType_GenericAlloc,
    Dtool_new_CDistributedSmoothNodeBase,
    PyObject_Del,
    0, // tp_is_gc
    0, // tp_bases
    0, // tp_mro
    0, // tp_cache
    0, // tp_subclasses
    0, // tp_weaklist
    0, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    0, // tp_finalize
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CDistributedSmoothNodeBase,
  Dtool_UpcastInterface_CDistributedSmoothNodeBase,
  Dtool_DowncastInterface_CDistributedSmoothNodeBase,
  (CoerceFunction)0,
  (CoerceFunction)0,
};

static void Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CDistributedSmoothNodeBase._PyType.tp_base = (PyTypeObject *)Dtool_Ptr_DTOOL_SUPER_BASE;
    PyObject *dict = PyDict_New();
    Dtool_CDistributedSmoothNodeBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CDistributedSmoothNodeBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CDistributedSmoothNodeBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CDistributedSmoothNodeBase);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3distributed_RegisterTypes() {
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("CConnectionRepository", Dtool_CConnectionRepository);
#endif
#ifndef LINK_ALL_STATIC
  RegisterNamedClass("CDistributedSmoothNodeBase", Dtool_CDistributedSmoothNodeBase);
#endif
}

void Dtool_libp3distributed_ResolveExternals() {
#ifndef LINK_ALL_STATIC
  // Resolve externally imported types.
  Dtool_Ptr_DCFile = LookupNamedClass("DCFile");
  Dtool_Ptr_Datagram = LookupRuntimeTypedClass(Datagram::get_class_type());
  Dtool_Ptr_DatagramIterator = LookupRuntimeTypedClass(DatagramIterator::get_class_type());
  Dtool_Ptr_QueuedConnectionManager = LookupNamedClass("QueuedConnectionManager");
  Dtool_Ptr_ConnectionWriter = LookupNamedClass("ConnectionWriter");
  Dtool_Ptr_DCClass = LookupNamedClass("DCClass");
  Dtool_Ptr_QueuedConnectionReader = LookupNamedClass("QueuedConnectionReader");
  Dtool_Ptr_URLSpec = LookupNamedClass("URLSpec");
  Dtool_Ptr_SocketStream = LookupNamedClass("SocketStream");
  Dtool_Ptr_HTTPChannel = LookupRuntimeTypedClass(HTTPChannel::get_class_type());
  Dtool_Ptr_NodePath = LookupRuntimeTypedClass(NodePath::get_class_type());
#endif
}

void Dtool_libp3distributed_BuildInstants(PyObject *module) {
  (void) module;
  // CConnectionRepository
  Dtool_PyModuleClassInit_CConnectionRepository(module);
  PyModule_AddObject(module, "CConnectionRepository", (PyObject *)&Dtool_CConnectionRepository);
  // CDistributedSmoothNodeBase
  Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(module);
  PyModule_AddObject(module, "CDistributedSmoothNodeBase", (PyObject *)&Dtool_CDistributedSmoothNodeBase);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary, METH_VARARGS, "Used to add items into a tp_dict"},
  {NULL, NULL, 0, NULL}
};

struct LibraryDef libp3distributed_moddef = {python_simple_funcs};
static InterrogateModuleDef _in_module_def = {
  1478214694,  /* file_identifier */
  "libp3distributed",  /* library_name */
  "nqI8",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3distributed.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  163  /* next_index */
};

Configure(_in_configure_libp3distributed);
ConfigureFn(_in_configure_libp3distributed) {
  interrogate_request_module(&_in_module_def);
}

